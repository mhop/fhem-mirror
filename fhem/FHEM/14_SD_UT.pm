#########################################################################################
# $Id$
#
# The file is part of the SIGNALduino project.
# The purpose of this module is universal support for devices.
# 2016 - 1.fhemtester | 2018/2019 - HomeAuto_User & elektron-bbs
#
# - unitec Modul alte Variante bis 20180901 (Typ unitec-Sound) --> keine MU MSG!
# - unitec Funkfernschalterset (Typ uniTEC_48110) ??? EIM-826 Funksteckdosen --> keine MU MSG!
###############################################################################################################################################################################
# - unitec remote door reed switch 47031 (Typ Unitec_47031) [Protocol 30] and [additionally Protocol 83] (sync -30)  (1 = on | 0 = off)
#{    FORUM: https://forum.fhem.de/index.php/topic,43346.msg353144.html#msg353144
#     8 DIP-switches for deviceCode (1-8) | 3 DIP-switches for zone (9-11) | 1 DIP-switch unknown (12) | baugleich FRIEDLAND SU4F zwecks gleichem Platinenlayout + Jumper
#     Kopplung an Unitec 47121 (Zone 1-6) | Unitec 47125 (Zone 1-2) | Friedland (Zone 1)
#     Adresse: 95 - öffnen?               |  get sduino_dummy raw MU;;P0=309;;P1=636;;P2=-690;;P3=-363;;P4=-10027;;D=012031203120402031312031203120312031204020313120312031203120312040203131203120312031203120402031312031203120312031204020313120312031203120312040203131203120312031203120402031312031203120312031204020313120312031203120312040203131203120312030;;CP=0;;O;;
#}    Adresse: 00 - Gehäuse geöffnet?     |  get sduino_dummy raw MU;;P0=684;;P1=-304;;P2=-644;;P3=369;;P4=-9931;;D=010101010101010232323104310101010101010102323231043101010101010101023232310431010101010101010232323104310101010101010102323231043101010101010101023232310431010101010101010232323104310101010101010102323231043101010101010101023232310431010100;;CP=0;;O;;
###############################################################################################################################################################################
# - Westinghouse Deckenventilator (Typ HT12E | remote with 5 buttons without SET | Buttons_five ??? 7787100 ???) [Protocol 29] and [additionally Protocol 30] (sync -35) (1 = off | 0 = on)
#{    FORUM: https://forum.fhem.de/index.php/topic,58397.960.html | https://forum.fhem.de/index.php/topic,53282.30.html
#     Adresse e | 1110 (off|off|off|on): fan_off         |  get sduino_dummy raw MU;;P0=250;;P1=-492;;P2=166;;P3=-255;;P4=491;;P5=-8588;;D=052121212121234121212121234521212121212341212121212345212121212123412121212123452121212121234121212121234;;CP=0;;
#}    Adresse e | 1110 (off|off|off|on): fan low speed   |  get sduino_dummy raw MU;;P0=-32001;;P1=224;;P2=-255;;P3=478;;P4=-508;;P6=152;;P7=-8598;;D=01234141414641414141414123712341414141414141414141237123414141414141414141412371234141414141414141414123712341414141414141414141237123414141414141414141412371234141414141414141414123712341414141414141414141237123414141414141414141412371234141414141414141;;CP=1;;R=108;;O;;
####################################################################################################################################
# - Westinghouse Deckenventilator (Typ [M1EN compatible HT12E] example Delancey | remote RH787T with 9 buttons + SET) [Protocol 83] and [additionally Protocol 30] (sync -36) (1 = off | 0 = on)
#{    Adresse 0 | 0000 (on|on|on|on): I - fan minimum speed  |  get sduino_dummy raw MU;;P0=388;;P1=-112;;P2=267;;P3=-378;;P5=585;;P6=-693;;P7=-11234;;D=0123035353535356262623562626272353535353562626235626262723535353535626262356262627235353535356262623562626272353535353562626235626262723535353535626262356262627235353535356262623562626272353535353562626235626262723535353535626262356262627235353535356262;;CP=2;;R=43;;O;;
#     Adresse 8 | 1000 (off|on|on|on): I - fan minimum speed |  get sduino_dummy raw MU;;P0=-11250;;P1=-200;;P2=263;;P3=-116;;P4=-374;;P5=578;;P6=-697;;D=1232456245454562626245626262024562454545626262456262620245624545456262624562626202456245454562626245626262024562454545626262456262620245624545456262624562626202456245454562626245626262024562454545626262456262620245624545456262624562626202456245454562626;;CP=2;;R=49;;O;;
#     Adresse c | 1100 (off|off|on|on): fan_off              |  get sduino_dummy raw MU;;P0=-720;;P1=235;;P2=-386;;P3=561;;P4=-11254;;D=01230141230101232301010101012301412301012323010101010123014123010123230101010101010141230101232301010101010101412301012323010101010101014123010123230101010101010;;CP=1;;R=242;;
#}    Adresse c | 1100 (off|off|on|on): fan_off              |  get sduino_dummy raw MU;;P0=-11230;;P1=258;;P2=-390;;P3=571;;P4=-699;;D=0123414123234141414141234101234141232341414141412341012341412323414141414123410123414123234141414141234101234141232341414141412341012341412323414141414123410123414123234141414141234101234141232341414141412341012341412323414141414123410123414123234141414;;CP=1;;R=246;;O;;
###############################################################################################################################################################################
# - Remote control SA-434-1 mini 923301 [Protocol 81] and [additionally Protocol 83 + Protocol 86]
#{    one Button, 434 MHz
#     protocol like HT12E
#     10 DIP-switches for address:
#     switch                                hex     bin
#     ------------------------------------------------------------
#     1-10 on                               004     0000 0000 0100
#     1 off, 9-10 on                        804     1000 0000 0100
#     4/8 off, 9-3 5-7 9-10 on              114     0001 0001 0100
#     4/8 off, 9-3 5-7 on, 9 off, 10 on     115     0001 0001 0101
#     4/8 off, 9-3 5-7 on, 9 on, 10 off     11C     0001 0001 1100
#     4/8 off, 9-3 5-7 on, 9-10 off         11D     0001 0001 1101
#     ------------------------------------------------------------
#     pilot 12 bitlength, from that 1/3 bitlength high: -175000, 500   -35, 1
#     one:                                                -1000, 500    -2, 1
#     zero:                                                -500, 1000   -1, 2
#
#     get sduino_dummy raw MU;;P0=-1756;;P1=112;;P2=-11752;;P3=496;;P4=-495;;P5=998;;P6=-988;;P7=-17183;;D=0123454545634545456345634563734545456345454563456345637345454563454545634563456373454545634545456345634563734545456345454563456345637345454563454545634563456373454545634545456345634563734545456345454563456345637345454563454545634563456373454545634545456;;CP=3;;R=0;;
#}    get sduino_dummy raw MU;;P0=-485;;P1=188;;P2=-6784;;P3=508;;P5=1010;;P6=-974;;P7=-17172;;D=0123050505630505056305630563730505056305050563056305637305050563050505630563056373050505630505056305630563730505056305050563056305637305050563050505630563056373050505630505056305630563730505056305050563056305637305050563050505630563056373050505630505056;;CP=3;;R=0;;
###############################################################################################################################################################################
# - QUIGG GT-7000 Funk-Steckdosendimmer | transmitter QUIGG_DMV - receiver DMV-7009AS  [Protocol 34]
#{    https://github.com/RFD-FHEM/RFFHEM/issues/195
#     nibble 0-2 -> Ident | nibble 3-4 -> Tastencode
#     get sduino_dummy raw MU;;P0=-5476;;P1=592;;P2=-665;;P3=1226;;P4=-1309;;D=01232323232323232323232323412323412323414;;CP=3;;R=1;;
#}    Send Adresse FFF funktioniert nicht 100%ig!
###############################################################################################################################################################################
# - TR-502MSV (LIBRA GmbH) [LIDL] Funk-Steckdosendimmer + Schalter | transmitter TR-502MSV - receiver RC-710DX|RC-710 [Protocol 34]
#{    nibble 0-1 -> Hauscode | nibble 3 ??? | nibble 3-4 -> Tastencode | repeats 3
#			get sduino_dummy raw MU;;P0=-12064;;P1=717;;P2=-669;;P3=1351;;P4=-1319;;D=012323414141234123232323232323232323232323;;
#}    get sduino_dummy raw MU;;P0=697;;P1=-1352;;P2=-679;;P3=1343;;D=01010101010231023232323232323232323232323;CP=0;R=27;;
###############################################################################################################################################################################
# - Remote Control Novy_840029 for Novy Pureline 6830 kitchen hood [Protocol 86] (Länge je nach Taste 12 oder 18 Bit)
#{    0100				"novy_button"			- nicht geprüft
#     0101				"+_button"				- i.O.
#     0110				"-_button"				- i.O.
#     0111010001	"light_on_off"		- nur 10 Bit, SIGNALduino.pm hängt 2 Nullen an
#     0111010011	"power_button"		- nur 10 Bit, SIGNALduino.pm hängt 2 Nullen an
#    https://github.com/RFD-FHEM/RFFHEM/issues/331
#			nibble 0-1 -> Ident | nibble 2-4 -> Tastencode
#     light on/off button   -	get sduino_dummy raw MU;;P0=710;;P1=353;;P2=-403;;P4=-761;;P6=-16071;;D=20204161204120412041204120414141204120202041612041204120412041204141412041202020416120412041204120412041414120412020204161204120412041204120414141204120202041;;CP=1;;R=40;;
#     + button              -	get sduino_dummy raw MU;;P0=22808;;P1=-24232;;P2=701;;P3=-765;;P4=357;;P5=-15970;;P7=-406;;D=012345472347234723472347234723454723472347234723472347234547234723472347234723472345472347234723472347234723454723472347234723472347234;;CP=4;;R=39;;
#     - button              -	get sduino_dummy raw MU;;P0=-8032;;P1=364;;P2=-398;;P3=700;;P4=-760;;P5=-15980;;D=0123412341234123412341412351234123412341234123414123512341234123412341234141235123412341234123412341412351234123412341234123414123;;CP=1;;R=40;;
#     power button          -	get sduino_dummy raw MU;;P0=-756;;P1=718;;P2=354;;P3=-395;;P4=-16056;;D=01020202310231310202423102310231023102310202023102313102024231023102310231023102020231023131020242310231023102310231020202310231310202;;CP=2;;R=41;;
#}    novy button           - get sduino_dummy raw MU;;P0=706;;P1=-763;;P2=370;;P3=-405;;P4=-15980;;D=0123012301230304230123012301230123012303042;;CP=2;;R=42;;
###############################################################################################################################################################################
# - CAME Drehtor Antrieb - remote CAME_TOP_432EV [Protocol 86] and [additionally Protocol 81]
#{    https://github.com/RFD-FHEM/RFFHEM/issues/151
#     nibble 0-1 -> Ident | nibble 2 -> Tastencode
#}    get sduino_dummy raw MU;;P0=-322;;P1=136;;P2=-15241;;P3=288;;P4=-735;;P6=723;;D=0123434343064343430643434306234343430643434306434343062343434306434343064343430623434343064343430643434306234343430643434306434343062343434306434343064343430623434343064343430643434306234343430643434306434343062343434306434343064343430;;CP=3;;R=27;;
###############################################################################################################################################################################
# - Hoermann HS1-868-BS [Protocol 69]
#{    https://github.com/RFD-FHEM/RFFHEM/issues/344 | https://github.com/RFD-FHEM/RFFHEM/issues/149
#                iiii iiii iiii iiii iiii iiii iiii bbbb
#			0000 0000 1111 0110 0010 1010 1001 1100 0000 0001 1100 (HS1-868-BS)
#}    get sduino_dummy raw MU;;P0=-578;;P1=1033;;P2=506;;P3=-1110;;P4=13632;;D=0101010232323101040101010101010101023232323102323101010231023102310231010232323101010101010101010232323101040101010101010101023232323102323101010231023102310231010232323101010101010101010232323101040101010101010101023232323102323101010231023102310231010;;CP=2;;R=77;;
###############################################################################################################################################################################
# - Hoermann HSM4 [Protocol 69]
#{    https://forum.fhem.de/index.php/topic,71877.msg642879.html (HSM4, Taste 1-4)
#               iiii iiii iiii iiii iiii iiii iiii bbbb
#     0000 0000 1110 0110 1011 1110 1001 0001 0000 0111 1100 (HSM4 Taste A)
#     0000 0000 1110 0110 1011 1110 1001 0001 0000 1011 1100 (HSM4 Taste B)
#     0000 0000 1110 0110 1011 1110 1001 0001 0000 1110 1100 (HSM4 Taste C)
#     0000 0000 1110 0110 1011 1110 1001 0001 0000 1101 1100 (HSM4 Taste D)
#}    get sduino_dummy raw MU;;P0=-3656;;P1=12248;;P2=-519;;P3=1008;;P4=506;;P5=-1033;;D=01232323232323232324545453232454532453245454545453245323245323232453232323245453245454532321232323232323232324545453232454532453245454545453245323245323232453232323245453245454532321232323232323232324545453232454532453245454545453245323245323232453232323;;CP=4;;R=48;;O;;
###############################################################################################################################################################################
# - Transmitter SF01 01319004 433,92 MHz (SF01_01319004) (NEFF / Refsta Topdraft kitchen hood) [Protocol 86]
#{    https://github.com/RFD-FHEM/RFFHEM/issues/376 | https://forum.fhem.de/index.php?topic=93545.0 | https://forum.fhem.de/index.php/topic,93545.msg908150.html#msg908150
#     Sends 18 bits, converting to hex in SIGNALduino.pm adds 2 bits of 0
#                   iiii iiii iiii ii bbbb aa   hex
#     ------------------------------------------------
#     Plus:         1010 0001 0101 00 1100 00   A15 30
#     Minus:        1010 0001 0101 00 1010 00   A15 28
#     Licht:        1010 0001 0101 00 1110 00   A15 38
#     Nachlüften:   1010 0001 0101 00 1001 00   A15 24
#     Intervall:    1010 0001 0101 00 1101 00   A15 34
#     ------------------------------------------------
#     i - ident, b - button, a - appended
#     get sduino_dummy raw MU;;P0=-707;;P1=332;;P2=-376;;P3=670;;P5=-15243;;D=01012301232323230123012301232301010123510123012323232301230123012323010101235101230123232323012301230123230101012351012301232323230123012301232301010123510123012323232301230123012323010101235101230123232323012301230123230101012351012301232323230123012301;;CP=1;;R=3;;O;;
#     get sduino_dummy raw MU;;P0=-32001;;P1=348;;P2=-704;;P3=-374;;P4=664;;P5=-15255;;D=01213421343434342134213421343421213434512134213434343421342134213434212134345121342134343434213421342134342121343451213421343434342134213421343421213434512134213434343421342134213434212134345121342134343434213421342134342121343451213421343434342134213421;;CP=1;;R=15;;O;;
#     get sduino_dummy raw MU;;P0=-32001;;P1=326;;P2=-721;;P3=-385;;P4=656;;P5=-15267;;D=01213421343434342134213421343421342134512134213434343421342134213434213421345121342134343434213421342134342134213451213421343434342134213421343421342134512134213434343421342134213434213421345121342134343434213421342134342134213451213421343434342134213421;;CP=1;;R=10;;O;;
#     get sduino_dummy raw MU;;P0=-372;;P1=330;;P2=684;;P3=-699;;P4=-14178;;D=010231020202023102310231020231310231413102310202020231023102310202313102314;;CP=1;;R=253;;
#}    get sduino_dummy raw MU;;P0=-710;;P1=329;;P2=-388;;P3=661;;P4=-14766;;D=01232301410123012323232301230123012323012323014;;CP=1;;R=1;;
###
# - Transmitter SF01 01319004 (SF01_01319004_Typ2) 433,92 MHz (BOSCH kitchen) [Protocol 86]
#{                  iiii iiii iiii ii bbbb aa   hex
#     ------------------------------------------------
#     Plus:         0010 0110 0011 10 0100 00		263 90
#     Minus:        0010 0110 0011 10 0010 00		263 88
#     Licht:        0010 0110 0011 10 0110 00		263 98
#     Nachlüften:   0010 0110 0011 10 0001 00		263 84
#     Intervall:    0010 0110 0011 10 0101 00		263 94
#     ------------------------------------------------
#     i - ident, b - button, a - appended
#     get sduino_dummy raw MU;;P0=706;;P1=-160;;P2=140;;P3=-335;;P4=-664;;P5=385;;P6=-15226;;P7=248;;D=01210103045303045453030304545453030454530653030453030454530303045454530304747306530304530304545303030454545303045453065303045303045453030304545453030454530653030453030454530303045454530304545306530304530304545303030454545303045453065303045303045453030304;;CP=5;;O;;
#     get sduino_dummy raw MU;;P0=-15222;;P1=379;;P2=-329;;P3=712;;P6=-661;;D=30123236123236161232323616161232361232301232361232361612323236161612323612323012323612323616123232361616123236123230123236123236161232323616161232361232301232361232361612323236161612323612323012323612323616123232361616123236123230123236123236161232323616;;CP=1;;O;;
#     get sduino_dummy raw MU;;P0=705;;P1=-140;;P2=-336;;P3=-667;;P4=377;;P5=-15230;;P6=248;;D=01020342020343420202034343420202020345420203420203434202020343434202020203654202034202034342020203434342020202034542020342020343420202034343420202020345420203420203434202020343434202020203454202034202034342020203434342020202034542020342020343420202034343;;CP=4;;O;;
#     get sduino_dummy raw MU;;P0=704;;P1=-338;;P2=-670;;P3=378;;P4=-15227;;P5=244;;D=01023231010102323231010102310431010231010232310101023232310101025104310102310102323101010232323101010231043101023101023231010102323231010102310431010231010232310101023232310101023104310102310102323101010232323101010231043101023101023231010102323231010102;;CP=3;;O;;
#}    get sduino_dummy raw MU;;P0=-334;;P1=709;;P2=-152;;P3=-663;;P4=379;;P5=-15226;;P6=250;;D=01210134010134340101013434340101340134540101340101343401010134343401013601365401013401013434010101343434010134013454010134010134340101013434340101340134540101340101343401010134343401013401345401013401013434010101343434010134013454010134010134340101013434;;CP=4;;O;;
###############################################################################################################################################################################
# - Berner Garagentorantrieb GA401 | remote TEDSEN SKX1MD 433.92 MHz - 1 button | settings via 9 switch on battery compartment [Protocol 46]
#{    compatible with doors: BERNER SKX1MD, ELKA SKX1MD, TEDSEN SKX1LC, TEDSEN SKX1
#     https://github.com/RFD-FHEM/RFFHEM/issues/91
#     get sduino_dummy raw MU;;P0=-15829;;P1=-3580;;P2=1962;;P3=-330;;P4=245;;P5=-2051;;D=1234523232345234523232323234523234540023452323234523452323232323452323454023452323234523452323232323452323454023452323234523452323232323452323454023452323234523452323232323452323454023452323234523452323;;CP=2;;
#     GEIGER GF0001, 2 Button, DIP-Schalter: + 0 + - + + - 0 0
#     https://forum.fhem.de/index.php/topic,39153.0.html
#     rauf:   MU;P0=-32001;P1=2072;P2=-260;P3=326;P4=-2015;P5=-15769;D=01212123412123434121212123434123412351212123412123434121212123434123412351212123412123434121212123434123412351212123412123434121212123434123412351212123412123434121212123434123412351212123412123434121212123434123412351212123412123434121212123434123412351;CP=3;R=37;O;
#     runter: MU;P0=-15694;P1=2009;P2=-261;P3=324;P4=-2016;D=01212123412123434121212123434123434301212123412123434121212123434123434301212123412123434121212123434123434301212123412123434121212123434123434301212123412123434121212123434123434301;CP=3;R=30;
#     ???
#     MU;P0=313;P1=1212;P2=-309;P4=-2024;P5=-16091;P6=2014;D=01204040562620404626204040404040462046204040562620404626204040404040462046204040562620404626204040404040462046204040562620404626204040404040462046204040;CP=0;R=236;
#     MU;P0=-15770;P1=2075;P2=-264;P3=326;P4=-2016;P5=948;D=012121234121234341212121234341234343012125;CP=3;R=208;
#}
###############################################################################################################################################################################
# - Chilitec Großhandel 22640 - LED Christbaumkerzen mit Fernbedienung [Protocol 14]
#{ 		Taste -: 		AA802			0010		brightness_minus
# 		Taste Aus: 	AA804			0100		power_off
# 		Taste FL: 	AA806			0110		flickering_fast
# 		Taste Ein: 	AA808			1000		power_on
# 		Taste SL: 	AA80A			1010		flickering_slowly
# 		Taste +: 		AA80C			1100		brightness_plus
#
#}    get sduino_dummy raw MS;;P0=988;;P1=-384;;P2=346;;P3=-1026;;P4=-4923;;D=240123012301230123012323232323232301232323;;CP=2;;SP=4;;R=0;;O;;m=1;;
###############################################################################################################################################################################
# - XM21-0 - LED Christbaumkerzen mit Fernbedienung [Protocol 76]
#{ 		button - ON
# 		MU;P0=-205;P1=113;P3=406;D=010101010101010101010101010101010101010101010101010101010101030303030101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010103030303010101010101010101010100;CP=1;R=69;
# 		MU;P0=-198;P1=115;P4=424;D=0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010404040401010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101040404040;CP=1;R=60;O;
# 		MU;P0=114;P1=-197;P2=419;D=01212121210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010121212121010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
# 		button - OFF
# 		MU;P0=-189;P1=115;P4=422;D=0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101040404040101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010104040404010101010;CP=1;R=73;O;
# 		MU;P0=-203;P1=412;P2=114;D=01010101020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020101010102020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020200;CP=2;R=74;
# 		MU;P0=-210;P1=106;P3=413;D=0101010101010101010303030301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101030303030100;CP=1;R=80;
#
# 		    iiiiiiiiiiiiii bb
# 		---------------------
# 		P76#FFFFFFFFFFFFFF FF		- on
#} 		P76#FFFFFFFFFFFFFF C		- off
###############################################################################################################################################################################
# - Krinner LUMIX - LED X-MAS model 572152 [Protocol 92]
#{ 		button - ON
# 		MU;P0=-592;P1=112;P2=-968;P3=413;P4=995;P5=-394;P6=-10161;D=01232323245453245453232323232323232454645324532323232323245453245453232323245453245453232323232323232454645324532323232323245453245453232323245453245453232323232323232454645324532323232323245453245453232323245453245453232323232323232454;CP=3;R=25;
#			MU;P0=24188;P1=-16308;P2=993;P3=-402;P4=416;P5=-967;P6=-10162;D=0123234545454523234523234545454545454545232623452345454545454523234523234545454523234523234545454545454545232623452345454545454523234523234545454523234523234545454545454545232623452345454545454523234523234545454523234523234545454545454545232;CP=4;R=25;
# 		button - OFF
# 		MU;P0=417;P1=-558;P2=975;P3=272;P4=-974;P5=140;P6=-419;P7=-10150;D=01213454040426260426260404040404040404042726042604040404040426260426260404040426260426260404040404040404042726042604040404040426260426260404040426260426260404040404040404042726042604040404040426260426260404040426260426260404040404040404042;CP=0;R=37;
#			MU;P0=11076;P1=-20524;P2=281;P3=-980;P4=982;P5=-411;P6=408;P7=-10156;D=0123232345456345456363636363636363634745634563636363636345456345456363636345456345456363636363636363634745634563636363636345456345456363636345456345456363636363636363634745634563636363636345456345456363636345456345456363636363636363634;CP=6;R=38;
#
# 		    iiiiiii b
# 		----------- -
# 		P92#A06C360 1
#} 		P92#A06C360 0
###############################################################################################################################################################################
# - Atlantic Security / Focus Security China Devices | door/windows switch MD-210R | Vibration Schock Sensor MD-2018R | GasSensor MD-2003R [Protocol 91] & [Protocol 91.1]
#		https://forum.fhem.de/index.php/topic,95346.0.html | https://forum.fhem.de/index.php?topic=95346.msg881810#msg881810 | https://github.com/RFD-FHEM/RFFHEM/issues/477
#		36bit = 24bit DeviceID + 8bit Commando (4 Bit -> Sabo,Contact,Contact extern,keepalive or batterie | 4 bit -> typ) + 4bit Check | all nibbles are XOR = 0
#		i ident | s sabo | c contact intern | e contact extern | k keepalive (battery?) | t typ | C ckecksumme
#
#{	door/windows switch MD_210R
#
#		iiiiiiiiiiiiiiiiiiiiiiiiscekttttCCCC
#		------------------------------------
#		Kontakt auf | Gehäuse auf		get sduino_dummy raw MS;;P1=-410;;P2=807;;P3=-803;;P4=394;;P5=-3994;;D=45412123434123412123434341234123434121234123412121234341234343434123412343;;CP=4;;SP=5;;R=30;;O;;m2;;
#		Kontakt zu | Gehäuse auf		get sduino_dummy raw MS;;P0=-397;;P1=816;;P2=-804;;P3=407;;P4=-4007;;D=34301012323012301012323230123012323010123012301010123010123232323012323232;;CP=3;;SP=4;;R=71;;O;;m2;;
#		Kontakt auf | Gehäuse zu		get sduino_dummy raw MS;;P1=-404;;P2=813;;P3=-794;;P4=409;;P5=-4002;;D=45412123434123412123434341234123434121234123412121212341234343434121212343;;CP=4;;SP=5;;R=65;;m0;;
#		Kontakt zu | Gehäuse zu			get sduino_dummy raw MS;;P0=-800;;P1=402;;P2=-401;;P3=806;;P4=-3983;;D=14123230101230123230101012301230101232301230123232323232301010101232301010;;CP=1;;SP=4;;R=57;;O;;m2;;
#}
#{	Vibration Schock Sensor MD-2018R | water sensor MD_230R
#
#		iiiiiiiiiiiiiiiiiiiiiiiisc?kttttCCCC
#		------------------------------------
#		get sduino_dummy raw MS;;P0=-404;;P1=383;;P2=-797;;P3=778;;P4=-3934;;D=14103030321032121032103030303030321210321032103210303030321032103032103212;;CP=1;;SP=4;;R=0;;
#		get sduino_dummy raw MU;;P0=776;;P1=-409;;P2=-802;;P3=379;;P4=-3946;;D=010102310102323231043101010231023231023101010101010232310231023102310102310101023101023232310431010102310232310231010101010102323102310231023101023101010231010232323100;;CP=3;;R=0;;
#}
#{	GasSensor MD-2003R
#
#		iiiiiiiiiiiiiiiiiiiiiiiisc?kttttCCCC
#		------------------------------------
#		get sduino_dummy raw MU;;P0=-164;;P1=378;;P2=-813;;P3=-429;;P4=764;;P5=-3929;;D=0121212134342121343434343421342121212121213434343421212134342134213451212121212121343421213434343434213421212121212134343434212121343421342134512121212121213434212134343434342134212121212121343434342121213434213421345121212121212134342121343434343421342;;CP=1;;R=0;;O;;
#		get sduino_dummy raw MU;;P1=-419;;P2=380;;P3=-810;;P5=767;;P6=-3912;;P7=-32001;;D=262323232323232151532321515151515321532323232323215321515153232151515153232;;CP=2;;R=0;;
#}
###############################################################################################################################################################################
# - Manax | MX-RCS270 , Typ: RCS-10 | MX-RCS250 / mumbi | m-FS300 [Protocol 90] and [additionally Protocol 93]
#{  Manax https://forum.fhem.de/index.php/topic,94327.0.html remote MANAX MX-RCS250
#
#		i ident | b button | ? unknown
#		iiii iiii iiii iiii ???? bbbb ???? ???? ?????
#		---------------------------------------------
#		Taste A Ein: MS;P1=274;P2=-865;P3=787;P4=-349;P5=-10168;D=15123412121212343434341212341234341212121234343434341234121212123412;CP=1;SP=5;R=46;O;m2;
#		Taste A Aus: MS;P1=285;P2=-858;P3=794;P4=-341;P6=-10162;D=16123412121212343434341212341234341212121234343412341234121212121212;CP=1;SP=6;R=61;O;m2;
#		Taste B Ein: MS;P1=269;P2=-872;P3=795;P4=-338;P6=-10174;D=16123412121212343434341212341234341212121234341234341234121212341212;CP=1;SP=6;R=73;O;m2;
#		Taste B Aus: MS;P1=264;P2=-863;P3=795;P4=-348;P7=-10167;D=17123412121212343434341212341234341212121234341212341234121212343412;CP=1;SP=7;R=73;O;m2;
#		Taste C Ein: MS;P0=-851;P1=283;P2=805;P3=-343;P4=-10146;D=14102310101010232323231010231023231010101023102323231023101023231010;CP=1;SP=4;R=65;O;m2;
#		Taste C Aus: MS;P0=-337;P1=766;P3=273;P4=-862;P5=-10178;D=35341034343434101010103434103410103434343410341034103410343410101034;CP=3;SP=5;R=55;m2;
#		Taste D Ein: MS;P1=261;P2=-872;P3=794;P4=-349;P6=-10168;D=16123412121212343434341212341234341212121212343434341234123434341212;CP=1;SP=6;R=58;O;m2;
#		Taste D Aus: MS;P1=281;P2=-862;P3=790;P4=-342;P6=-10160;D=16123412121212343434341212341234341212121212343412341234123434343412;CP=1;SP=6;R=61;O;m2;
#		Taste Alles Ein: MS;P2=-841;P3=294;P4=812;P6=-325;P7=-10140;D=37324632323232464646463232463246463232323232463232463246324646324632;CP=3;SP=7;R=68;O;m2;
#		Taste Alles Aus: MS;P1=282;P2=-844;P3=816;P4=-330;P6=-10153;D=16123412121212343434341212341234341212121234121212341234121234123412;CP=1;SP=6;R=65;O;m2;
#
#		mumbi m-FS300 https://github.com/RFD-FHEM/RFFHEM/issues/60
#		...
#
#		SET mumbi AFS300-s  https://forum.fhem.de/index.php/topic,94327.msg953226.html#msg953226 | https://forum.fhem.de/index.php/topic,94327.msg953235.html#msg953235
#		remote control typ RC-10 | random code wireless switch typ RCS-22GS
#		Taste A on    :	MS;P1=781;P3=-372;P4=251;P5=-903;P6=-10342;D=46451313131345454545131345134545134545454513131313454513454513451345;CP=4;SP=6;O;m1;E;
#		Taste A off   :	MS;P1=790;P2=-363;P3=257;P4=-896;P5=-10283;D=35341212121234343434121234123434123434343412121234343412343412343434;CP=3;SP=5;O;m2;C;C;
#		Taste B on    :	MS;P0=-367;P2=-892;P3=265;P4=-10335;P5=787;D=34325050505032323232505032503232503232323250503250323250323250503232;CP=3;SP=4;O;m2;2;P;
#		Taste B off   :	MS;P0=264;P1=-367;P2=791;P4=-887;P6=-10335;D=06042121212104040404212104210404210404040421210404040421040421212104;CP=0;SP=6;O;m2;
#		Taste C on    : MS;P0=-887;P1=790;P2=-361;P3=265;P5=-10342;D=35301212121230303030121230123030123030303012301212303012303030301230;CP=3;SP=5;O;m2;0;0;
#		Taste C off   : MS;P0=794;P1=-364;P2=265;P3=-885;P4=-10325;D=24230101010123232323010123012323012323232301230123232301232323232323;CP=2;SP=4;O;m1;
#		Taste D on    : MS;P0=-884;P1=790;P2=-365;P3=272;P4=-10323;D=34301212121230303030121230123030123030303030121212303012301230301230;CP=3;SP=4;O;m1;0;
#		Taste D off   : MS;P1=-364;P2=264;P3=-892;P4=787;P5=-10331;D=25234141414123232323414123412323412323232323414123232341234123232323;CP=2;SP=5;O;m2;A;
#		Taste All on  : MS;P1=-361;P2=267;P3=-884;P4=792;P5=-10342;D=25234141414123232323414123412323412323232323412323232341234123414123;CP=2;SP=5;O;m2;A;
#		Taste All off : MS;P1=-363;P2=789;P3=267;P4=-887;P5=-10332;D=35342121212134343434212134213434213434343421343434343421343434212134;CP=3;SP=5;O;m2;4;
#}
###############################################################################################################################################################################
# - ESTO Lighting GmbH | remote control KL-RF01 with 9 buttons (CP 375-395) [Protocol 93] and [additionally Protocol 90]
#{  https://github.com/RFD-FHEM/RFFHEM/issues/449
#}
###############################################################################################################################################################################
#		Techmar / Garden Lights Fernbedienung, 6148011 Remote control + 12V Outdoor receiver [Protocol 95]
#{  https://github.com/RFD-FHEM/RFFHEM/issues/558 @BlackcatSandy
#		Fernbedienung mit 10 Tasten, 9 Gruppentasten und 1 Master
#		gesamt 50 Bit, Bit 0-31 Ident, Bit 32-39 Button, Bit 40-47 = Bit 32-39 invertiert, Bit 48-49 wechselt 00|01|02
#		Die letzten beiden Bits wechseln bei der Fernbedienung zwischen 00, 01 oder 02. Der Empfänger reagiert aber auch, wenn nur 00 gesendet wird.
#		sendet bei jedem Tastendruck ca. 50 Wiederholungen, Dauer etwa 6 Sekunden
#
#		Group_1_on:  MU;P0=-972;P1=526;P2=-335;P3=-666;D=01213131312131313121212121312121313131313121312131313121313131312121212121312121313131313121313121212101213131312131313121212121312121313131313121312131313121313131312121212121312121313131313121313121212101213131312131313121212121312121313131313121312131;CP=1;R=44;O;
#		Group_5_on:  MU;P0=-651;P1=530;P2=-345;P3=-969;D=01212121312101010121010101212121210121210101010101210121010101210101010121212121012121210101010121010101212101312101010121010101212121210121210101010101210121010101210101010121212121012121210101010121010101212121312101010121010101212121210121210101010101;CP=1;R=24;O;
#		Group_8_off: MU;P0=538;P1=-329;P2=-653;P3=-964;D=01020301020202010202020101010102010102020202020102010202020102020202010101010101010201020202020202010202010301020202010202020101010102010102020202020102010202020102020202010101010101010201020202020202010201010301020202010202020101010102010102020202020102;CP=0;R=19;O;
#}
###############################################################################################################################################################################
# - Medion OR28V RF Vista Remote Control (Made in china by X10) [Protocol 68]
#{  !! sendet zwei verschiedene Codes pro Taste (ausser power) !!
#		Taste ok    MS;P1=-1746;P2=513;P3=-571;P4=-4612;P5=2801;D=24512321212123232121212323212121212323232323;CP=2;SP=4;R=58;#;#;
#		Taste ok    MS;P1=-1712;P2=518;P3=-544;P4=-4586;P5=2807;D=24512121212123232121232323212121212323232323;CP=2;SP=4;R=58;m2;#;#;
#		Taste Vol+  MS;P1=-1620;P2=580;P3=-549;P4=-4561;P5=2812;D=24512121212323232323232323232123212123232323;CP=2;SP=4;R=69;O;m2;#;#;
#		Taste Vol+  MS;P1=-1645;P2=574;P3=-535;P4=-4556;P5=2811;D=24512321212323232323212323232123212123232323;CP=2;SP=4;R=57;m2;#;#;
#}
###############################################################################################################################################################################
# !!! ToDo´s !!!
#     - LED lights, counter battery-h reading --> commandref hour_counter module
#     -
###############################################################################################################################################################################

package main;

use strict;
use warnings;
no warnings 'portable';  # Support for 64-bit ints required
#use SetExtensions;

#$| = 1;		#Puffern abschalten, Hilfreich für PEARL WARNINGS Search

sub SD_UT_bin2tristate($);
sub SD_UT_tristate2bin($);

### HASH for all modul models ###
my %models = (
	# keys(model) => values
	"Buttons_five" =>	{ "011111"	=> "1_fan_low_speed",
											"111111" 	=> "2_fan_medium_speed",
											"111101" 	=> "3_fan_high_speed",
											"101111" 	=> "light_on_off",
											"111110"	=> "fan_off",
											hex_lengh	=> "3",
											Protocol 	=> "P29",
											Typ				=> "remote"
										},
	"CAME_TOP_432EV" =>	{	"1110"		=> "left_button",
												"1101"		=> "right_button",
												hex_lengh	=> "3",
												Protocol	=> "P86",
												Typ				=> "remote"
											},
	"Chilitec_22640" =>	{ "0010"    => "brightness_minus",
												"0100"    => "power_off",
												"0110"    => "flickering_fast",
												"1000"    => "power_on",
												"1010"    => "flickering_slowly",
												"1100"    => "brightness_plus",
												hex_lengh	=> "5",
												Protocol  => "P14",
												Typ       => "remote"
											},
	"HS1_868_BS" =>	{ "0"				=> "send",
										hex_lengh	=> "11",
										Protocol	=> "P69",
										Typ				=> "remote"
									},
	"HSM4" =>	{ "0111"		=> "button_1",
							"1011"		=> "button_2",
							"1110"		=> "button_3",
							"1101"		=> "button_4",
							hex_lengh	=> "11",
							Protocol 	=> "P69",
							Typ				=> "remote"
						},
	"Krinner_LUMIX" =>	{	"0000"			=> "off",
												"0001"			=> "on",
												Protocol		=> "P92",
												hex_lengh		=> "8",
												Typ					=> "remote"
											},
	"OR28V" =>	{	"000000"  => "volume_mute",
								"000010"  => "power",
								"000100"  => "tv_guide",
								"001000"  => "volume_minus",
								"001001"  => "volume_plus",
								"001011"  => "channel_plus",
								"001100"  => "channel_minus",
								"001101"  => "1",
								"001110"  => "2",
								"001111"  => "3",
								"010000"  => "4",
								"010001"  => "5",
								"010010"  => "6",
								"010011"  => "7",
								"010100"  => "8",
								"010101"  => "9",
								"010110"  => "T",
								"010111"  => "0",
								"011000"  => "tv_record",
								"011010"  => "arrow_up",
								"011011"  => "menu",
								"011100"  => "tv_play",
								"011101"  => "arrow_left",
								"011110"  => "ok",
								"011111"  => "arrow_right",
								"100000"  => "back",
								"100001"  => "video_back",
								"100010"  => "arrow_down",
								"100011"  => "video_forward",
								"100100"  => "video_rewind",
								"100101"  => "video_play",
								"100110"  => "video_fastforward",
								"100111"  => "video_record",
								"101000"  => "video_stop",
								"101001"  => "video_pause",
								"101111"  => "info",
								"110000"  => "clear",
								"110001"  => "tv_list",
								"110010"  => "color_red",
								"110011"  => "color_green",
								"110100"  => "color_yellow",
								"110101"  => "color_blue",
								"110110"  => "enter",
								"110111"  => "*",
								"111000"  => "#",
								Protocol	=> "P68",
								hex_lengh	=> "5",
								Typ				=> "remote"
							},
	"Novy_840029" => 	{	"0100"        => "novy",
											"0101"        => "speed_plus",
											"0110"        => "speed_minus",
											"0111010001"  => "light_on_off",	# 0111010000
											"0111010011"  => "power_on_off",	# 0111010010
											hex_lengh			=> "3,5",
											Protocol			=> "P86",
											Typ						=> "remote"
										},
	"QUIGG_DMV" =>	{	"11101110"	=> "Ch1_on",
										"11111111"	=> "Ch1_off",
										"01101100" 	=> "Ch2_on",
										"01111101" 	=> "Ch2_off",
										"10101111" 	=> "Ch3_on",
										"10111110" 	=> "Ch3_off",
										"00101101" 	=> "Ch4_on",
										"00111100" 	=> "Ch4_off",
										"00001111" 	=> "Master_on",
										"00011110" 	=> "Master_off",
										"00010100" 	=> "Unknown_up",
										"00000101" 	=> "Unknown_down",
										hex_lengh		=> "5",
										Protocol		=> "P34",
										Typ					=> "remote"
									},
	"TR_502MSV" =>	{	"11101110"	=> "Ch1_on",
										"11111111"	=> "Ch1_off",
										"01101100" 	=> "Ch2_on",
										"01111101" 	=> "Ch2_off",
										"10101111" 	=> "Ch3_on",
										"10111110" 	=> "Ch3_off",
										"00101101" 	=> "Ch4_on",
										"00111100" 	=> "Ch4_off",
										"00001111" 	=> "Master_on",
										"00011110" 	=> "Master_off",
										"00010100" 	=> "dim_up",				# after Master on/off
										"00000101" 	=> "dim_down",			# after Master on/off
										"11110101"	=> "Ch1_dim_up",		# after CH1 on/off
										"11100100"	=> "Ch1_dim_down",	# after CH1 on/off
										"01110111"	=> "Ch2_dim_up",		# after CH2 on/off
										"01100110"	=> "Ch2_dim_down",	# after CH2 on/off
										"10110100"	=> "Ch3_dim_up",		# after CH3 on/off
										"10100101"	=> "Ch3_dim_down",	# after CH3 on/off
										"00110110"	=> "Ch4_dim_up",		# after CH4 on/off
										"00100111"	=> "Ch4_dim_down",	# after CH4 on/off
										hex_lengh		=> "5",
										Protocol		=> "P34",
										Typ					=> "remote"
									},
	"RH787T" =>	{	"110111"	=> "1_fan_minimum_speed",
								"110101" 	=> "2_fan_low_speed",
								"101111"	=> "3_fan_medium_low_speed",
								"100111"	=> "4_fan_medium_speed",
								"011101"	=> "5_fan_medium_high_speed",
								"011111"	=> "6_fan_high_speed",
								"111011"	=> "fan_direction",
								"111101"	=> "fan_off",
								"111110"	=> "light_on_off",
								"101101"	=> "set",
								hex_lengh	=> "3",
								Protocol	=> "P83",
								Typ				=> "remote"
							},
	"SA_434_1_mini" =>	{	"0"				=> "send",
												hex_lengh	=> "3",
												Protocol	=> "P81",
												Typ				=> "remote"
											},
	"Techmar"	=>	{	"00001001"	=> "Group_1_on",		# 0x09
									"00001010"	=> "Group_1_off",		# 0x0A
									"00001111"	=> "Group_2_on",		# 0x0F
									"00010000"	=> "Group_2_off",		# 0x10
									"00000101"	=> "Group_3_on",		# 0x05
									"00000110"	=> "Group_3_off",		# 0x06
									"00001011"	=> "Group_4_on",		# 0x0B
									"00001100"	=> "Group_4_off",		# 0x0C
									"00010001"	=> "Group_5_on",		# 0x11
									"00010010"	=> "Group_5_off",		# 0x12
									"00001101"	=> "Group_6_on",		# 0x0D
									"00001110"	=> "Group_6_off",		# 0x0E
									"00000111"	=> "Group_7_on",		# 0x07
									"00001000"	=> "Group_7_off",		# 0x08
									"00000001"	=> "Group_8_on",		# 0x01
									"00000010"	=> "Group_8_off",		# 0x02
									"00000011"	=> "Group_9_on",		# 0x03
									"00000100"	=> "Group_9_off",		# 0x04
									"00010011"	=> "All_on",				# 0x13
									"00010100"	=> "All_off",				# 0x14
									hex_lengh		=> "13",
									Protocol	=> "P95",
									Typ				=> "remote"
								},
	"Tedsen_SKX1xx" =>	{	"1100"		=> "Button_1",	# tristate 10
												hex_lengh	=> "5",
												Protocol	=> "P46",
												Typ				=> "remote"
											},
	"Tedsen_SKX2xx" =>	{	"1000"		=> "Button_1",	#	tristate F0 = GEIGER Ab:  0-
												"1010"		=> "Button_2",	# tristate FF = GEIGER Auf: 00
												hex_lengh	=> "5",
												Protocol	=> "P46",
												Typ				=> "remote"
											},
	"Tedsen_SKX4xx" =>	{	"1000"		=> "Button_1",	#	tristate F0 = GEIGER Ab:  0-
												"1010"		=> "Button_2",	# tristate FF = GEIGER Auf: 00
												"0000"		=> "Button_3",	# tristate 00 = GEIGER Ab:  --
												"0010"		=> "Button_4",	# tristate 0F = GEIGER Auf: -0
												hex_lengh	=> "5",
												Protocol	=> "P46",
												Typ				=> "remote"
											},
	"Tedsen_SKX6xx" =>	{	"1000"		=> "Button_1",	#	tristate F0 = GEIGER Ab:  0-
												"1010"		=> "Button_2",	# tristate FF = GEIGER Auf: 00
												"0000"		=> "Button_3",	# tristate 00 = GEIGER Ab:  --
												"0010"		=> "Button_4",	# tristate 0F = GEIGER Auf: -0
												"1110"		=> "Button_5",	# tristate 1F = GEIGER Ab:  +0
												"1011"		=> "Button_6",	# tristate F1 = GEIGER Auf: 0+
												hex_lengh	=> "5",
												Protocol	=> "P46",
												Typ				=> "remote"
											},
	"Unitec_47031" =>	{ Protocol	=> "P30",
											hex_lengh	=> "3",
											Typ				=> "switch"
										},
	"LED_XM21_0" =>	{	"1100"			=> "off",
										"11111111"	=> "on",
										Protocol		=> "P76",
										hex_lengh		=> "15,16",
										Typ					=> "remote"
									},
	"SF01_01319004" =>	{ "1100"		=> "plus",
												"1010"		=> "minus",
												"1101"		=> "interval",
												"1110"		=> "light_on_off",
												"1001"		=> "delay",
												hex_lengh	=> "5",
												Protocol 	=> "P86",
												Typ				=> "remote"
											},
	"SF01_01319004_Typ2" =>	{	"0100"		=> "plus",
														"0010"		=> "minus",
														"0101"		=> "interval",
														"0110"		=> "light_on_off",
														"0001"		=> "delay",
														hex_lengh	=> "5",
														Protocol 	=> "P86",
														Typ				=> "remote"
													},
	"KL_RF01" =>	{	"0001" => "light_color_cold_white",
									"0010" => "night_mode",
									"0100" => "on",
									"0110" => "alternating_full_luminosity",
									"1000" => "full_brightness",
									"1001" => "off",
									"1010" => "light_color_warm_white",
									"1100" => "dimdown",
									"1110" => "dimup",
									Protocol	=> "P93",
									hex_lengh	=> "9",
									Typ				=> "remote"
								},
	"MD_2003R" =>	{	Protocol	=> "P91", 	#P91.1
									hex_lengh	=> "9",
									Typ				=> "gas"
								},
	"MD_210R" =>	{	Protocol	=> "P91", 	#P91.1
									hex_lengh	=> "9",
									Typ				=> "switch"
								},
	"MD_2018R" =>	{	Protocol	=> "P91", 	#P91.1
									hex_lengh	=> "9",
									Typ				=> "vibration"
								},
	"RC_10" =>	{	"1" => "on",
								"0" => "off",
								"buttons" => {
									"111" => "A",
									"110" => "B",
									"101" => "C",
									"011" => "D",
									"010" => "all",
									"100" => "all",
								},
								Protocol	=> "P90",
								hex_lengh	=> "9",
								Typ				=> "remote"
							},
	"unknown" =>	{	Protocol	=> "any",
									hex_lengh	=> "",
									Typ				=> "not_exist"
								}
);

#############################
sub SD_UT_Initialize($) {
	my ($hash) = @_;
	$hash->{Match}			= "^P(?:14|29|30|34|46|68|69|76|81|83|86|90|91|91.1|92|93|95)#.*";
	$hash->{DefFn}			= "SD_UT_Define";
	$hash->{UndefFn}		= "SD_UT_Undef";
	$hash->{ParseFn}		= "SD_UT_Parse";
	$hash->{SetFn}			= "SD_UT_Set";
	$hash->{AttrFn}			= "SD_UT_Attr";
	$hash->{AttrList}		= "repeats:1,2,3,4,5,6,7,8,9 IODev do_not_notify:1,0 ignore:0,1 showtime:1,0 model:".join(",", sort keys %models)." $readingFnAttributes ";
	$hash->{AutoCreate} =
	{
		"MD_2003R.*"	 => {ATTR => "model:MD_2003R", FILTER => "%NAME", autocreateThreshold => "3:180", GPLOT => ""},
		"MD_210R.*"	 => {ATTR => "model:MD_210R", FILTER => "%NAME", autocreateThreshold => "3:180", GPLOT => ""},
		"MD_2018R.*"	 => {ATTR => "model:MD_2018R", FILTER => "%NAME", autocreateThreshold => "3:180", GPLOT => ""},
		"OR28V.*"	 => {ATTR => "model:OR28V", FILTER => "%NAME", autocreateThreshold => "3:180", GPLOT => ""},
		"Techmar.*"	 => {ATTR => "model:Techmar", FILTER => "%NAME", autocreateThreshold => "3:180", GPLOT => ""},
		"unknown_please_select_model"	=> {ATTR => "model:unknown", FILTER => "%NAME", autocreateThreshold => "5:180", GPLOT => ""},
	};
}

#############################
sub SD_UT_Define($$) {
	my ($hash, $def) = @_;
	my @a = split("[ \t][ \t]*", $def);

	# Argument					   0	 1		2		3				4
	return "wrong syntax: define <name> SD_UT <model> <HEX-Value> <optional IODEV>" if(int(@a) < 3 || int(@a) > 5);
	return "wrong <model> $a[2]\n\n(allowed modelvalues: " . join(" | ", sort keys %models).")" if $a[2] && ( !grep { $_ eq $a[2] } %models );
	### checks unknown ###
	return "wrong define: <model> $a[2] need no HEX-Value to define!" if($a[2] eq "unknown" && $a[3] && length($a[3]) >= 1);

	### checks Westinghouse_Delancey RH787T & WestinghouseButtons_five ###
	if ($a[2] eq "RH787T" || $a[2] eq "Buttons_five") {
		if (length($a[3]) > 1) {
			return "wrong HEX-Value! $a[2] have one HEX-Value";
		}
		if (not $a[3] =~ /^[0-9a-fA-F]{1}/s) {
			return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value are not (0-9 | a-f | A-F)";
		}
	}

	### checks Medion OR28V ###
	if ($a[2] eq "OR28V") {
		if (length($a[3]) > 2) {
			return "wrong Value! $a[2] must be an number between 1 - 16";
		}
		if ($a[3] < 1 || $a[3] > 16) {
			return "wrong address! ($a[3]) $a[2] must be an number between 1 - 16";
		}
	}

	### [2] checks CAME_TOP_432EV & Novy_840029 & Unitec_47031 & TR_502MSV ###
	if (($a[2] eq "CAME_TOP_432EV" || $a[2] eq "Novy_840029" || $a[2] eq "Unitec_47031" || $a[2] eq "TR_502MSV") && not $a[3] =~ /^[0-9a-fA-F]{2}/s) {
		return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){2}";
	}
	### [3] checks SA_434_1_mini & QUIGG_DMV ###
	if (($a[2] eq "SA_434_1_mini" || $a[2] eq "QUIGG_DMV") && not $a[3] =~ /^[0-9a-fA-F]{3}/s) {
		return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){3}";
	}
	### [4] checks Neff SF01_01319004 & BOSCH SF01_01319004_Typ2 & Chilitec_22640 & ESTO KL_RF01###
	if (($a[2] eq "SF01_01319004" || $a[2] eq "SF01_01319004_Typ2" || $a[2] eq "Chilitec_22640" || $a[2] eq "KL_RF01") && not $a[3] =~ /^[0-9a-fA-F]{4}/s) {
		return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){4}";
	}
	### [6] checks Manax | mumbi ###
	if ($a[2] eq "RC_10" && not $a[3] =~ /^[0-9a-fA-F]{4}_([ABCD]|all)$/s) {
		return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){4}_[ABCD]|[all]";
	}

	### [6] checks MD_2003R | MD_210R | MD_2018R ###
	return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){6}" if (($a[2] eq "MD_2003R" || $a[2] eq "MD_210R" || $a[2] eq "MD_2018R") && not $a[3] =~ /^[0-9a-fA-F]{6}/s);
	### [7] checks Hoermann HSM4 | Krinner_LUMIX ###
	return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){7}" if (($a[2] eq "HSM4" || $a[2] eq "Krinner_LUMIX") && not $a[3] =~ /^[0-9a-fA-F]{7}/s);
	### [7] checks Tedsen_SKX1xx, Tedsen_SKX2xx, Tedsen_SKX4xx, Tedsen_SKX6xx (tristate code)###
	return "Wrong tristate code! ($a[3]) $a[2] code to short or long (must be 7 chars) or values not 0, 1 or F" if (($a[2] eq "Tedsen_SKX1xx" || $a[2] eq "Tedsen_SKX2xx" || $a[2] eq "Tedsen_SKX4xx" || $a[2] eq "Tedsen_SKX6xx") && not $a[3] =~ /^[01fF]{7}$/s);
	### [8 nibble] checks Techmar remote control ###
	return "Wrong HEX-Value! ($a[3]) $a[2] Hex-value to short or long (must be 8 chars) or not hex (0-9 | a-f | A-F)" if ($a[2] eq "Techmar" && not $a[3] =~ /^[0-9a-fA-F]{8}$/s);
	### [9] checks Hoermann HS1-868-BS ###
	return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){9}" if ($a[2] eq "HS1_868_BS" && not $a[3] =~ /^[0-9a-fA-F]{9}/s);
	### [14] checks LED_XM21_0 ###
	return "wrong HEX-Value! ($a[3]) $a[2] HEX-Value to short | long or not HEX (0-9 | a-f | A-F){14}" if ($a[2] eq "LED_XM21_0" && not $a[3] =~ /^[0-9a-fA-F]{14}/s);

	$hash->{lastMSG} =  "no data";
	$hash->{bitMSG} =  "no data";
	$hash->{STATE} =  "Defined";
	my $iodevice = $a[4] if($a[4]);
	my $name = $hash->{NAME};

	$modules{SD_UT}{defptr}{$hash->{DEF}} = $hash;
	my $ioname = $modules{SD_UT}{defptr}{ioname} if (exists $modules{SD_UT}{defptr}{ioname} && not $iodevice);
	$iodevice = $ioname if not $iodevice;

	### Attributes | model set after codesyntax ###
	my $devicetyp = $a[2];
	if ($devicetyp eq "unknown") {
		$attr{$name}{model}	= "unknown"	if( not defined( $attr{$name}{model} ) );
	} else {
		$attr{$name}{model}	= $devicetyp	if( not defined( $attr{$name}{model} ) );
	}
	$attr{$name}{room}	= "SD_UT"	if( not defined( $attr{$name}{room} ) );

	AssignIoPort($hash, $iodevice);
}

###################################
sub SD_UT_Set($$$@) {
	my ( $hash, $name, @a ) = @_;
	my $cmd = $a[0];
	my $ioname = $hash->{IODev}{NAME};
	my $model = AttrVal($name, "model", "unknown");
	my $ret = undef;
	my $msg = undef;
	my $msgEnd = undef;
	my $value = "";		# value from models cmd
	my $save = "";		# bits from models cmd
	my $repeats = AttrVal($name,'repeats', '5');

	Log3 $name, 4, "$ioname: SD_UT_Set attr_model=$model name=$name (before check)" if($cmd ne "?");
	return $ret if ($defs{$name}->{DEF} eq "unknown");		# no setlist

	############ Westinghouse_Delancey RH787T ############
	if ($model eq "RH787T" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%04b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 4 digits
		$msg = $models{$model}{Protocol} . "#0" . $adr ."1";
		$msgEnd = "#R" . $repeats;
	############ Westinghouse Buttons_five ############
	} elsif ($model eq "Buttons_five" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%04b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 4 digits
		$msg = $models{$model}{Protocol} . "#";
		$msgEnd .= "11".$adr."#R" . $repeats;
	############ SA_434_1_mini ############
	} elsif ($model eq "SA_434_1_mini" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																		# split adress from def
		my $bitData = sprintf( "%012b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 12 digits
		$msg = $models{$model}{Protocol} . "#" . $bitData . "#R" . $repeats;
	############ Tedsen_SKX1xx, Tedsen_SKX2xx, Tedsen_SKX4xx, Tedsen_SKX6xx ############
	} elsif (($model eq "Tedsen_SKX1xx" || $model eq "Tedsen_SKX2xx" || $model eq "Tedsen_SKX4xx" || $model eq "Tedsen_SKX6xx") && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = SD_UT_tristate2bin($definition[1]);															# argument 1 - adress tristate to bin with 18 bits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd = "#R" . $repeats;
	############ QUIGG_DMV ############
	} elsif ($model eq "QUIGG_DMV" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%012b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 12 digits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd = "P#R" . $repeats;
	############ TR_502MSV ############
	} elsif ($model eq "TR_502MSV" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%08b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 8 digits
		$msg = $models{$model}{Protocol} . "#" . $adr . "1111";
		$msgEnd = "P#R" . $repeats;		
	############ Novy_840029 ############
	} elsif ($model eq "Novy_840029" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%08b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 8 digits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd = "#R" . $repeats;
	############ CAME_TOP_432EV ############
	} elsif ($model eq "CAME_TOP_432EV" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%08b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 8 digits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd = "#R" . $repeats;
	############ NEFF SF01_01319004 || BOSCH SF01_01319004_Typ2 ############
	} elsif (($model eq "SF01_01319004" || $model eq "SF01_01319004_Typ2") && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%016b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 16 digits
		$msg = $models{$model}{Protocol} . "#" . substr($adr,0,14);
		$msgEnd = "#R" . $repeats;
	############ Hoermann HS1-868-BS ############
	} elsif ($model eq "HS1_868_BS" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																	# split adress from def
		my $bitData = "00000000";
		$bitData .= sprintf( "%036b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 36 digits
		$msg = $models{$model}{Protocol} . "#" . $bitData . "#R" . $repeats;
	############ Hoermann HSM4 ############
	} elsif ($model eq "HSM4" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%028b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 28 digits
		$msg = $models{$model}{Protocol} . "#00000000" . $adr;
		$msgEnd .= "1100#R" . $repeats;
	############ Chilitec 22640 ############
	} elsif ($model eq "Chilitec_22640" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%016b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 16 digits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd .= "#R" . $repeats;
	############ LED_XM21_0 22640 ############
	} elsif ($model eq "LED_XM21_0" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%014b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 14 digits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd .= "#R" . $repeats;
	############ Krinner_LUMIX ############
	} elsif ($model eq "Krinner_LUMIX" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%028b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 28 digits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd .= "#R" . $repeats;
	############ Manax | mumbi ############
	} elsif ($model eq "RC_10" && $cmd ne "?") {
		return "ERROR: to send, please push button on and off again on remote" if ( (ReadingsVal($name, "x_n5-8_on", "0") eq "0") || (ReadingsVal($name, "x_n5-8_off", "0") eq "0") || (ReadingsVal($name, "x_n4", "0") eq "0") );

		my @definition = split(" ", $hash->{DEF});																# split adress from def
		$definition[1] = substr($definition[1],0,4);
		my $adr = sprintf( "%016b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 16 digits
		my $unknown1 = ReadingsVal($name, "x_n4", "0");
		my $unknown2_btn = "x_n5-8_".$cmd;
		my $unknown2 = ReadingsVal($name, $unknown2_btn, "0");
		$msg = $models{$model}{Protocol} . "#" . $adr . $unknown1 . $unknown2;
		$msgEnd .= "#R" . $repeats;

		### if device _all, set A | B | C | D ### -> RC_10_7869_all (model_device_button)
		my $device = $model."_".substr($name,6,4);
		if ($name =~ /^$device.all$/) {
			foreach my $d (sort keys %defs) {
				if (defined($defs{$d}) && defined($defs{$d}{NAME}) && $defs{$d}{NAME} =~ /^$device.[ABCD]$/) {
					readingsSingleUpdate($defs{$d}, "state" , $cmd , 1);
					Log3 $name, 4, "$ioname: SD_UT_Set attr_model=$model device $name set ".$defs{$d}{NAME}." to $cmd";
				}
			}
		}
	############ ESTO KL_RF01############
	} elsif ($model eq "KL_RF01" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%016b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 16 digits
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd .= "11110";	# nibble7 every?
		$msgEnd .= "#R" . $repeats;
	############ Techmar Garden Lights ############
	} elsif ($model eq "Techmar" && $cmd ne "?") {
		my @definition = split(" ", $hash->{DEF});																# split adress from def
		my $adr = sprintf( "%032b", hex($definition[1])) if ($name ne "unknown");	# argument 1 - adress to binary with 32 bits
		
		$msg = $models{$model}{Protocol} . "#" . $adr;
		$msgEnd = "00#R" . $repeats;	#	Last two bits alternately by transmitter 00, 01 or 02. Receiver also reacts to only 00.
	############ Medion OR28V ############
	} elsif ($model eq "OR28V" && $cmd ne "?") {
		$msg = $models{$model}{Protocol} . "#";
		$msgEnd .= "#R" . $repeats;	# R1 wird vom SIGNALduino nicht als MS erkannt!
	}

	Log3 $name, 4, "$ioname: SD_UT_Set attr_model=$model msg=$msg msgEnd=$msgEnd" if(defined $msgEnd);

	if ($cmd eq "?") {
		### create setlist ###
		foreach my $keys (sort keys %{ $models{$model}}) {
			if ( $keys =~ /^[0-1]{1,}/s ) {
				$ret.= $models{$model}{$keys}.":noArg ";
			}
		}
	} else {
		if (defined $msgEnd) {
			### if cmd, set bits ###
			foreach my $keys (sort keys %{ $models{$model}}) {
				if ( $keys =~ /^[0-1]{1,}/s ) {
					$save = $keys;
					$value = $models{$model}{$keys};
					last if ($value eq $cmd);
				}
			}

			############ KL_RF01 ############
			if ($model eq "KL_RF01") {
				my $save2 = $save;
				$save2 =~ tr/01/10/;									# invert message (nibble6 invert = nibble4)
				$msg .= $save."0000".$save2.$msgEnd;	# 0000 = nibble5 every?
			} elsif ($model eq "Techmar") {
				my $invert = $save;
				$invert =~ tr/01/10/;									# invert byte 4 (byte5 = inverted byte 4)
				$msg .= $save.$invert.$msgEnd;
			############ Medion OR28V ############
			} elsif ($model eq "OR28V") {
				my @definition = split(" ", $hash->{DEF});						# split adress from def
				my $adr = $definition[1] - 1;													# argument 1 - adress
				my $checksum = ($adr * 16 + oct("0b$save") + 85) & 0x7f;
				my $laststate = ReadingsVal($name, "state", "fehlt");
				my $lastbit0 = ReadingsVal($name, "bit0", "fehlt");
				Log3 $name, 5, "$ioname: SD_UT_Set $name ReadingsVal lastbit0=$lastbit0";
				my $bit0 = "0";													# bit 0 first press a new button
				if ($cmd eq $laststate && $cmd ne "power") {
					$bit0 = $lastbit0 eq "0" ? "1" : "0";	# toggle bit 0 when press the same button again
				}
				$bit0 = "1" if ($cmd eq "power");				# bit 0 always 1 by button power
				Log3 $name, 5, "$ioname: SD_UT_Set $name ReadingsVal laststate=$laststate cmd=$cmd bit0=$bit0";
				$msg .= $bit0;													# bit 0
				$msg .= sprintf ("%07b",$checksum);			# bit 1-7
				if (oct("0b$save") > 42) {	# button
					$msg .= $bit0;												# bit 8 = bit 0
				} else {
					$msg .= $bit0 eq "0" ? "1" : "0";			# bit 8 = bit 0 inverted
				}
				$msg .= "0";														# bit 9 always zero
				$msg .= $save;													# bit 10-15
				$msg .= sprintf ("%04b",$adr);					# bit 16-19
				$msg .= $msgEnd;
				Log3 $name, 5, "$ioname: SD_UT_Set $name msg=$msg checksum=$checksum";
				readingsSingleUpdate($hash, "bit0" , $bit0, 0);
			} else {
				$msg .= $save.$msgEnd;
			}
			Log3 $name, 5, "$ioname: SD_UT_Set attr_model=$model msg=$msg cmd=$cmd value=$value (cmd loop)";
		}

		readingsSingleUpdate($hash, "LastAction", "send", 0) if ($models{$model}{Typ} eq "remote");
		readingsSingleUpdate($hash, "state" , $cmd, 1);

		IOWrite($hash, 'sendMsg', $msg);
		Log3 $name, 3, "$ioname: $name set $cmd";

		## for hex output ##

		my @split = split("#", $msg);
		my $hexvalue = $split[1];
		$hexvalue =~ s/P+//g;															# if P parameter, replace P with nothing
		$hexvalue = sprintf("%X", oct( "0b$hexvalue" ) );
		###################
		Log3 $name, 4, "$ioname: $name SD_UT_Set sendMsg $msg, rawData $hexvalue";
	}
	return $ret;
}

#####################################
sub SD_UT_Undef($$) {
	my ($hash, $name) = @_;
	delete($modules{SD_UT}{defptr}{$hash->{DEF}})
		if(defined($hash->{DEF}) && defined($modules{SD_UT}{defptr}{$hash->{DEF}}));
	return undef;
}


###################################
sub SD_UT_Parse($$) {
	my ($iohash, $msg) = @_;
	my $ioname = $iohash->{NAME};
	my ($protocol,$rawData) = split("#",$msg);
	$protocol=~ s/^[u|U|P](\d+)/$1/; # extract protocol
	my $hlen = length($rawData);
	my $blen = $hlen * 4;
	my $bitData = unpack("B$blen", pack("H$hlen", $rawData));
	my $model = "unknown";
	my $name = "unknown_please_select_model";
	my $SensorTyp;
	Log3 $iohash, 4, "$ioname: SD_UT protocol $protocol, bitData $bitData, hlen $hlen";

	my $def;
	my $deviceCode = "";
	my $devicedef;
	my $zone;							# Unitec_47031 - bits for zone
	my $zoneRead;					# Unitec_47031 - text for user of zone
	my $usersystem;				# Unitec_47031 - text for user of system
	my $deviceTyp;				# hash -> typ
	my $contact;					# MD_210R
	my $keepalive;				# MD_210R
	my $sabotage;					# MD_210R
	my $batteryState;
	my $state = "unknown";
	my $tristateCode;
	my $unknown_bits;			# unknown bits to a reading

	my $deletecache = $modules{SD_UT}{defptr}{deletecache};
	Log3 $iohash, 5, "$ioname: SD_UT device in delete cache = $deletecache" if($deletecache && $deletecache ne "-");

	if ($deletecache && $deletecache ne "-") {
		CommandDelete( undef, "$deletecache" );						# delete device
		CommandDelete( undef, "FileLog_$deletecache" );		# delete filelog_device
		Log3 $iohash, 3, "SD_UT_Parse device $deletecache deleted" if($deletecache);
		$modules{SD_UT}{defptr}{deletecache} = "-";
		return "";
	}

	if ($hlen == 3) {
		### Westinghouse Buttons_five [P29] ###
		if (!$def && ($protocol == 29 || $protocol == 30)) {
			$deviceCode = substr($rawData,2,1);
			$devicedef = "Buttons_five " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
		### Unitec_47031 [P30] ###
		if (!$def && ($protocol == 30 || $protocol == 83)) {
			$deviceCode = substr($rawData,0,2);
			$devicedef = "Unitec_47031 " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
		### Remote control SA_434_1_mini 923301 [P81] ###
		if (!$def && ($protocol == 81 || $protocol == 83 || $protocol == 86)) {
			$deviceCode = $rawData;
			$devicedef = "SA_434_1_mini " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
		### Westinghouse_Delancey RH787T [P83] ### no define
		if (!$def && ($protocol == 83 || $protocol == 30)) {
			$deviceCode = substr($bitData,1,4);
			$deviceCode = sprintf("%X", oct( "0b$deviceCode" ) );
			$devicedef = "RH787T " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
		### CAME_TOP_432EV [P86] ###  no define
		if (!$def && ($protocol == 86 || $protocol == 81)) {
			$deviceCode = substr($rawData,0,2);
			$devicedef = "CAME_TOP_432EV " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
	}

	if($hlen == 3 || $hlen == 5) {
		### Novy_840029 [P86] ###
		if (!$def && ($protocol == 86 || $protocol == 81)) {
			$deviceCode = substr($rawData,0,2);
			$devicedef = "Novy_840029 " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
	}

	if ($hlen == 5) {
		### Chilitec_22640 [P14] ###
		if (!$def && $protocol == 14) {
			$deviceCode = substr($rawData,0,4);
			$devicedef = "Chilitec_22640 " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
		### QUIGG_DMV [P34] ###
		if (!$def && $protocol == 34) {
			$deviceCode = substr($rawData,0,3);
			$devicedef = "QUIGG_DMV " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
		### TR_502MSV [P34] ###
		if (!$def && $protocol == 34) {
			$deviceCode = substr($rawData,0,2);
			$devicedef = "TR_502MSV " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
		### Remote control Tedsen_SKX2xx [P46] ###
		if (!$def && $protocol == 46) {
			$deviceCode = SD_UT_bin2tristate(substr($bitData,0,14));		# only 14 bit from bitdata to tristate
			$devicedef = "Tedsen_SKX1xx " . $deviceCode if (!$def);
			$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
			$devicedef = "Tedsen_SKX2xx " . $deviceCode if (!$def);
			$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
			$devicedef = "Tedsen_SKX4xx " . $deviceCode if (!$def);
			$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
			$devicedef = "Tedsen_SKX6xx " . $deviceCode if (!$def);
			$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
		}
		### OR28V [P68] ###
		if ($protocol == 68) {
			my $check = (oct( "0b".substr($bitData,9,7) ) + oct( "0b".substr($bitData,16,4)."0000" ) + 85) & 0x7f;
			if ($check != oct( "0b".substr($bitData,1,7))) {
				Log3 $iohash, 3, "$ioname: SD_UT_Parse device OR28V - checksum - ERROR (rawData:$rawData)";
				return "";
			} else {
				Log3 $iohash, 4, "$ioname: SD_UT_Parse device OR28V check length & Protocol OK";
				$deviceCode = oct(substr($rawData,4,1)) + 1;
				$devicedef = "OR28V " . $deviceCode;
				$def = $modules{SD_UT}{defptr}{$devicedef};
				$model = "OR28V";
				$name = $model."_" . $deviceCode;
			}
		}
		### NEFF SF01_01319004 || BOSCH SF01_01319004_Typ2 [P86] ###
		if (!$def && $protocol == 86) {
			$deviceCode = substr($bitData,0,14) . "00";
			$deviceCode = sprintf("%X", oct( "0b$deviceCode" ) );
			$devicedef = "SF01_01319004 " . $deviceCode if (!$def);
			$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
			$devicedef = "SF01_01319004_Typ2 " . $deviceCode if (!$def);
			$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
		}
	}

	if ($hlen == 8 && !$def && $protocol == 92) {
		### Remote control Krinner_LUMIX [P92] ###
		$deviceCode = substr($rawData,0,7);
		$devicedef = "Krinner_LUMIX " . $deviceCode;
		$def = $modules{SD_UT}{defptr}{$devicedef};
	}

	if ($hlen == 9) {
		if ($protocol == 91 || $protocol == 91.1) {
			### Atlantic Security with all models [P91] or [P91.1 ] with CHECK ###
			Log3 $iohash, 4, "$ioname: SD_UT device MD_210R check length & Protocol OK";
			my @array_rawData = split("",$rawData);
			my $xor_check = hex($array_rawData[0]);
			foreach my $nibble (1...8) {
				$xor_check = $xor_check ^ hex($array_rawData[$nibble]);
			}
			if ($xor_check != 0) {
				Log3 $iohash, 4, "$ioname: SD_UT device from Atlantic Security - check XOR ($xor_check) FAILED! rawData=$rawData";
				return "";
			} else {
				Log3 $iohash, 4, "$ioname: SD_UT device from Atlantic Security - check XOR OK";
			}

			$model = substr($rawData,7,1);
			if ($model eq "E") {
				$model = "MD_210R";
			} elsif ($model eq "4") {
				$model = "MD_2018R";
			} elsif ($model eq "C") {
				$model = "MD_2003R";
			} else {
				Log3 $iohash, 1, "SD_UT Please report maintainer. Your model from Atlantic Security are unknown! rawData=$rawData";
				return "";
			}

			$deviceTyp = $models{$model}{Typ};
			$model = "$model";
			$deviceCode = substr($rawData,0,6);
			$devicedef = "$model " . $deviceCode if (!$def);
			$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
			$name = $model."_" . $deviceCode;

			Log3 $iohash, 4, "$ioname: SD_UT device $model from category $deviceTyp with code $deviceCode are ready to decode";
		}

		### Manax MX-RCS250 | mumbi [P90] ###
		if (!$def && $protocol == 90) {
			$deviceCode = substr($rawData,0,4);
            my $button = $models{RC_10}{buttons}{substr($bitData,20,3)};
            $devicedef = "RC_10 ".$deviceCode."_".$button;			
			$def       = $modules{SD_UT}{defptr}{$devicedef};
			
			if ($button ne "all")
			{
				$state = substr($bitData,23,1) eq "1" ? "on" : "off" 
			} else {
				$state = substr($bitData,20,4);
				if ($state eq "0100") {
					$state = "on";
				} elsif ($state eq "1000") {
					$state = "off";
				} else {
					$state = "unknown";
					$def = undef;
				}

				### if received data from device _all, set cannels A | B | C | D to state and trigger event ###
				for ( "A" .. "D" ) {
					my $defPtr = $modules{SD_UT}{defptr}{"RC_10 ".$deviceCode."_$_"};
					if (defined $defPtr) {
						readingsSingleUpdate($defPtr, "state" , $state , 1);
						DoTrigger($defPtr->{NAME}, undef, 0);
						Log3 $iohash, 5, "$ioname: SD_UT device - RC_10 devicedef: $defPtr->{NAME}";
						Log3 $iohash, 5, "$ioname: SD_UT device - RC_10 button: $_ | state: $state";
					}
				}
			}
			Log3 $iohash, 4, "$ioname: SD_UT device - RC_10 devicedef: $devicedef";
			Log3 $iohash, 4, "$ioname: SD_UT device - RC_10 button: $button | state: $state";
		}

		### ESTO KL_RF01 [P93] ###
		if (!$def && ($protocol == 93 || $protocol == 90)) {
			$deviceCode = substr($rawData,0,4);
			$devicedef = "KL_RF01 " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
		}
	}

	if ($hlen == 11 && $protocol == 69) {
		### Remote control Hoermann HS1-868-BS [P69] ###
		$deviceCode = substr($rawData,2,9);
		$devicedef = "HS1_868_BS " . $deviceCode if (!$def);
		$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
		### Remote control Hoermann HSM4 [P69] ###
		$deviceCode = substr($rawData,2,7);
		$devicedef = "HSM4 " . $deviceCode if (!$def);
		$def = $modules{SD_UT}{defptr}{$devicedef} if (!$def);
	}

	if ($hlen == 13 && $protocol == 95) {
		### Remote control Techmar Garden Lights [P95] ###
		Log3 $iohash, 4, "$ioname: SD_UT_Parse device Techmar - check length and protocol number - OK";

		my $check = hex(substr($rawData,8,2)) ^ hex(substr($rawData,10,2));	# byte 5 is inverted to byte 4
		if ($check != 255) {
			Log3 $iohash, 3, "$ioname: SD_UT_Parse device Techmar - check byte 4 and byte 5 - ERROR";
			return "";
		} else {
			Log3 $iohash, 4, "$ioname: SD_UT_Parse device Techmar - check byte 4 and byte 5 - OK";
			$deviceCode = substr($rawData,0,8);
			$devicedef = "Techmar " . $deviceCode;
			$def = $modules{SD_UT}{defptr}{$devicedef};
			$model = "Techmar";
			$name = "Techmar_" . $deviceCode;
		}
	}

	if (($hlen == 15 || $hlen == 16) &&  !$def && $protocol == 76) {
		### Remote LED_XM21_0 [P76] ###
		$deviceCode = substr($rawData,0,14);
		$devicedef = "LED_XM21_0 " . $deviceCode;
		$def = $modules{SD_UT}{defptr}{$devicedef};
	}

	### unknown ###
	$devicedef = "unknown" if(!$def);
	$def = $modules{SD_UT}{defptr}{$devicedef} if(!$def);
	$modules{SD_UT}{defptr}{ioname} = $ioname;

	Log3 $iohash, 4, "$ioname: SD_UT device $devicedef found (delete cache = $deletecache)" if($def && $deletecache && $deletecache ne "-");

	if(!$def) {
		Log3 $iohash, 1, "$ioname: SD_UT_Parse UNDEFINED sensor $model detected, protocol $protocol, data $rawData, code $deviceCode";
		return "UNDEFINED $name SD_UT $model" if ($model eq "unknown");																		# model set user manual
		return "UNDEFINED $name SD_UT $model $deviceCode" if ($model ne "unknown_please_select_model");		# model set automatically
	}

	my $hash = $def;
	$name = $hash->{NAME};
	$hash->{lastMSG} = $rawData;
	$hash->{bitMSG} = $bitData;
	$deviceCode = undef;				# reset

	$model = AttrVal($name, "model", "unknown");
	Log3 $name, 5, "$ioname: SD_UT_Parse devicedef=$devicedef attr_model=$model protocol=$protocol state=$state (before check)";

	readingsBeginUpdate($hash);

	############ Westinghouse_Delancey RH787T ############ Protocol 83 or 30 ############
  	if ($model eq "RH787T" && ($protocol == 83 || $protocol == 30)) {
		$state = substr($bitData,6,6);
		$deviceCode = substr($bitData,1,4);

		## Check fixed bits
		my $unknown1 = substr($bitData,0,1);	# every 0
		my $unknown2 = substr($bitData,5,1);	# every 1
		if ($unknown1 ne "0" | $unknown2 ne "1") {
			Log3 $name, 3, "$ioname: $model fixed bits wrong! always bit0=0 ($unknown1) and bit5=1 ($unknown2)";
			return "";
		}

		## deviceCode conversion for User in ON or OFF ##
		my $deviceCodeUser = $deviceCode;
		$deviceCodeUser =~ s/1/off|/g;
		$deviceCodeUser =~ s/0/on|/g;
		$deviceCodeUser = substr($deviceCodeUser, 0 , length($deviceCodeUser)-1);
		$deviceCode = $deviceCode." ($deviceCodeUser)";

	############ Westinghouse Buttons_five ############ Protocol 29 or 30 ############
	} elsif ($model eq "Buttons_five" && ($protocol == 29 || $protocol == 30)) {
		$state = substr($bitData,0,6);
		$deviceCode = substr($bitData,8,4);

		## Check fixed bits
		my $unknown1 = substr($bitData,6,1);	# every 1
		my $unknown2 = substr($bitData,7,1);	# every 1
		if ($unknown1 ne "1" | $unknown2 ne "1") {
			Log3 $name, 3, "$ioname: $model fixed bits wrong! always bit6=1 ($unknown1) and bit7=1 ($unknown2)";
			return "";
		}

		## deviceCode conversion for User in ON or OFF ##
		my $deviceCodeUser = $deviceCode;
		$deviceCodeUser =~ s/1/off|/g;
		$deviceCodeUser =~ s/0/on|/g;
		$deviceCodeUser = substr($deviceCodeUser, 0 , length($deviceCodeUser)-1);
		$deviceCode = $deviceCode." ($deviceCodeUser)";
	############ Unitec_47031 ############ Protocol 30 or 83 ############
	} elsif ($model eq "Unitec_47031" && ($protocol == 30 || $protocol == 83)) {
		$state = substr($bitData,11,1);		# muss noch 100% verifiziert werden !!!

		## deviceCode conversion for User in ON or OFF ##
		$deviceCode = substr($bitData,0,8);
		my $deviceCodeUser = $deviceCode;
		$deviceCodeUser =~ s/1/on|/g;
		$deviceCodeUser =~ s/0/off|/g;
		$deviceCodeUser = substr($deviceCodeUser, 0 , length($deviceCodeUser)-1);
		$deviceCode = $deviceCode." ($deviceCodeUser)";

		## zone conversion for User in ON or OFF ##
		$zone = substr($bitData,8,3);
		my $zoneUser = $zone;
		$zoneUser =~ s/1/on|/g;
		$zoneUser =~ s/0/off|/g;
		$zoneUser = substr($zoneUser, 0 , length($zoneUser)-1);
		$zoneRead = $zone." ($zoneUser) - Zone ";

		# Anmeldung an Profi-Alarmanzentrale 47121
		if (oct("0b".$zone) < 6 ) {
			$zoneRead.= (oct("0b".$zone)+1);
			$usersystem = "Unitec 47121";
		# other variants
		} else {
			$zoneRead.= (oct("0b".$zone)-5);
			# Anmeldung an Basis-Alarmanzentrale 47125 | Sirenen-System (z.B. ein System ohne separate Funk-Zentrale)
			$usersystem = "Unitec 47125 or Friedland" if (oct("0b".$zone) == 6);
			# Anmeldung an Basis-Alarmanzentrale 47125
			$usersystem = "Unitec 47125" if (oct("0b".$zone) == 7);
		}
		Log3 $name, 5, "$ioname: SD_UT_Parse devicedef=$devicedef attr_model=$model protocol=$protocol deviceCode=$deviceCode state=$state Zone=$zone";
	############ Tedsen_SKX1xx, Tedsen_SKX2xx, Tedsen_SKX4xx, Tedsen_SKX6xx ############ Protocol 46 ############
	} elsif (($model eq "Tedsen_SKX1xx" || $model eq "Tedsen_SKX2xx" || $model eq "Tedsen_SKX4xx" || $model eq "Tedsen_SKX6xx") && $protocol == 46) {
		$state = substr($bitData,14,4);
		$tristateCode = SD_UT_bin2tristate(substr($bitData,0,-2));		# only 18 bit from bitdata
		Log3 $iohash, 4, "$ioname: SD_UT_Parse $model - converted to tristate $tristateCode";
	############ SA_434_1_mini ############ Protocol 81 ############
	} elsif ($model eq "SA_434_1_mini" && ($protocol == 81 || $protocol == 83 || $protocol == 86)) {
		$state = "receive";
	############ QUIGG_DMV ############ Protocol 34 ############
	} elsif ($model eq "QUIGG_DMV" && $protocol == 34) {
		$state = substr($bitData,12,8);
		$deviceCode = substr($bitData,0,12);
	############ TR_502MSV ############ Protocol 34 ############
	} elsif ($model eq "TR_502MSV" && $protocol == 34) {
		$state = substr($bitData,12,8);
		$deviceCode = substr($bitData,0,8);
		$unknown_bits = substr($bitData,8,4);
	############ Novy_840029 ############ Protocol 86 ############
	} elsif ($model eq "Novy_840029" && ($protocol == 86 || $protocol == 81)) {
		if ($hlen == 3) {		# 12 Bit [3]
			$state = substr($bitData,8);			# 4 Bit
		} else {						# 20 Bit [5]
			$state = substr($bitData,8,10);		# 10 Bit (letzte 2 Bit entfernen)
		}
		$deviceCode = substr($bitData,0,8);
	############ CAME_TOP_432EV ############ Protocol 86 ############
	} elsif ($model eq "CAME_TOP_432EV" && ($protocol == 86 || $protocol == 81)) {
		$state = substr($bitData,8);
		$deviceCode = substr($bitData,0,8);
	############ NEFF SF01_01319004 || BOSCH SF01_01319004_Typ2 ############ Protocol 86 ############
	} elsif (($model eq "SF01_01319004" || $model eq "SF01_01319004_Typ2") && $protocol == 86) {
		$state = substr($bitData,14,4);
		$deviceCode = substr($bitData,0,14) . "00" if ($blen >= 14);
		$deviceCode = sprintf("%X", oct( "0b$deviceCode" ) );
	############ Medion OR28V ############ Protocol 68 ############
	} elsif ($model eq "OR28V" && $protocol == 68) {
		$state = substr($bitData,10,6);
		$deviceCode = substr($rawData,4,1);
	############ Hoermann HS1-868-BS ############ Protocol 69 ############
	} elsif ($model eq "HS1_868_BS" && $protocol == 69) {
		$state = "receive";
		$deviceCode = substr($bitData,8,28);
	############ Hoermann HSM4 ############ Protocol 69 ############
	} elsif ($model eq "HSM4" && $protocol == 69) {
		$state = substr($bitData,36,4);
		$deviceCode = substr($bitData,8,28);
	############ Chilitec_22640 ############ Protocol 14 ############
	} elsif ($model eq "Chilitec_22640" && $protocol == 14) {
		$state = substr($bitData,16,4);
		$deviceCode = substr($bitData,0,16);
	############ LED_XM21_0 ############ Protocol 76 ############
	} elsif ($model eq "LED_XM21_0" && $protocol == 76) {
		$deviceCode = substr($bitData,0,56);
		$state = substr($bitData,56,8);
	############ Krinner_LUMIX ############ Protocol 92 ############
	} elsif ($model eq "Krinner_LUMIX" && $protocol == 92) {
		$deviceCode = substr($bitData,0,28);
		$state = substr($bitData,28,4);
	############ Atlantic Security ############ Protocol 91 or 91.1 ############
	} elsif ($protocol == 91 || $protocol == 91.1) {
		############ MD_210R ############ switch ############
		$sabotage = substr($bitData,24,1);
		$contact = substr($bitData,25,1);
		$batteryState = substr($bitData,26,1);		# muss noch 100% verifiziert werden  bei all typs !!!
		$keepalive = substr($bitData,27,1);				# muss noch 100% verifiziert werden  bei all typs !!!

		($batteryState) = @_ = ('ok', 'warning')[$batteryState];
		($keepalive) = @_ = ('event', 'periodically')[$keepalive];
		($sabotage) = @_ = ('closed', 'open')[$sabotage];

		if ($model eq "MD_210R") {
			($contact) = @_ = ('closed', 'open')[$contact];
			if ($sabotage eq "closed" && $contact eq "closed") {
				$state = "normal";
			} else {
				$state = "warning";
			}
		############ MD_2018R ############ vibration ############ | ############ MD_2003R ############ gas ############
		} elsif ($model eq "MD_2018R" || $model eq "MD_2003R") {
			($contact) = @_ = ('no Alarm', 'Alarm')[$contact];
			$sabotage = undef;

			if ($contact eq "no Alarm") {
				$state = "normal";
			} else {
				$state = "warning";
			}
		}
	} elsif ($model eq "RC_10" && $protocol == 90) {
	############ Manax | mumbi ############ Protocol 90 ############
		## Check fixed bits	## Workaround to send ##
		my $nibble4 = substr($bitData,16,4);			# evey 0000 ?
		my $nibble5 = substr($bitData,20,4);			# Button and State
		my $nibble6to8 = substr($bitData,24,9);		# unknown crc ? | SIGNALduino added to full nibble

		readingsBulkUpdate($hash, "x_n4" , $nibble4, 0);
		readingsBulkUpdate($hash, "x_n5-8_on" , $nibble5.$nibble6to8, 0) if ($state eq "on");
		readingsBulkUpdate($hash, "x_n5-8_off" , $nibble5.$nibble6to8, 0) if ($state eq "off");

		$deviceCode = substr($bitData,0,16);
	} elsif ($model eq "KL_RF01" && $protocol == 93) {
	############ ESTO KL_RF01 ############ Protocol 90 ############
		## Check fixed bits
		my $unknown1 = substr($bitData,20,4);		# ?
		my $unknown2 = substr($bitData,28,4);		# ?

		$state = substr($bitData,16,4);
		my $state_invers = substr($bitData,24,4);
		$deviceCode = substr($bitData,0,16);
		$state_invers =~ tr/01/10/;							# invert message
		if ($state eq $state_invers) {
			Log3 $name, 4, "$ioname: SD_UT_Parse - check $model OK, nibble4 ($state) = nibble6 ($state_invers)";
		} else {
			Log3 $name, 3, "$ioname: SD_UT_Parse - check $model FAILED, $state!=$state_invers, ERROR, nibble4 ($state) NOT nibble6 ($state_invers)!";
			return "";
		}
	### Remote control Techmar Garden Lights [P95] ###
	} elsif ($model eq "Techmar" && $protocol == 95) {
		$state = substr($bitData,32,8);
		$deviceCode = substr($rawData,0,8);
	############ unknown ############
	} else {
		readingsBulkUpdate($hash, "state", "???");
		readingsBulkUpdate($hash, "unknownMSG", $bitData."  (protocol: ".$protocol.")") if (AttrVal($name, "model", "unknown") eq "unknown");
		Log3 $name, 3, "$ioname: SD_UT Please define your model of Device $name in Attributes!" if (AttrVal($name, "model", "unknown") eq "unknown");
		Log3 $name, 5, "$ioname: SD_UT_Parse devicedef=$devicedef attr_model=$model protocol=$protocol rawData=$rawData, bitData=$bitData";
	}

	Log3 $name, 5, "$ioname: SD_UT_Parse devicedef=$devicedef attr_model=$model protocol=$protocol devicecode=$deviceCode state=$state" if($model ne "unknown" && defined($deviceCode));
	Log3 $name, 5, "$ioname: SD_UT_Parse devicedef=$devicedef attr_model=$model typ=".$models{$model}{Typ}." (after check)";

	if ($models{$model}{Typ} eq "remote" && ($model ne "SA_434_1_mini" || $model ne "HS1_868_BS")) {
		### identify state bits to value from hash ###
		foreach my $keys (sort keys %{ $models{$model}}) {
			if ($keys eq $state) {
				$state = $models{$model}{$keys};
				Log3 $name, 5, "$ioname: SD_UT_Parse devicedef=$devicedef attr_model=$model typ=".$models{$model}{Typ}." key=".$models{$model}{$keys}." (state loop)";
				last;
			}
		}
	}

	readingsBulkUpdate($hash, "deviceCode", $deviceCode, 0) if (defined($deviceCode) && $models{$model}{Typ} eq "remote");
	readingsBulkUpdate($hash, "unknown_bits", $unknown_bits, 0) if (defined($unknown_bits) && $models{$model}{Typ} eq "remote");
	readingsBulkUpdate($hash, "contact", $contact) if (defined($contact) && ($model eq "MD_210R" || $model eq "MD_2018R" || $model eq "MD_2003R"));
	readingsBulkUpdate($hash, "batteryState", $batteryState) if (defined($batteryState));
	readingsBulkUpdate($hash, "deviceTyp", $deviceTyp,0) if (defined($deviceTyp) && ($model eq "MD_210R" || $model eq "MD_2018R" || $model eq "MD_2003R"));
	readingsBulkUpdate($hash, "keepalive", $keepalive) if (defined($keepalive) && ($model eq "MD_210R" || $model eq "MD_2018R" || $model eq "MD_2003R"));
	readingsBulkUpdate($hash, "sabotage", $sabotage) if (defined($sabotage) && ($model eq "MD_210R" || $model eq "MD_2018R" || $model eq "MD_2003R"));
	readingsBulkUpdate($hash, "System-Housecode", $deviceCode, 0) if (defined($deviceCode) && $model eq "Unitec_47031");
	readingsBulkUpdate($hash, "Zone", $zoneRead, 0) if (defined($zoneRead) && $model eq "Unitec_47031");
	readingsBulkUpdate($hash, "Usersystem", $usersystem, 0) if (defined($zoneRead) && $model eq "Unitec_47031");
	readingsBulkUpdate($hash, "LastAction", "receive", 0) if (defined($state) && $models{$model}{Typ} eq "remote" && ($model ne "SA_434_1_mini" || $model ne "HS1_868_BS"));
	readingsBulkUpdate($hash, "state", $state)  if (defined($state) && $state ne "unknown");
	readingsBulkUpdate($hash, "tristateCode", $tristateCode) if (defined($tristateCode));
	readingsEndUpdate($hash, 1); 		# Notify is done by Dispatch

	return $name;
}

###################################
sub SD_UT_Attr(@) {
	my ($cmd, $name, $attrName, $attrValue) = @_;
	my $hash = $defs{$name};
	my $typ = $hash->{TYPE};
	my $devicemodel;
	my $deviceCode;
	my $devicename;
	my $ioDev = InternalVal($name, "LASTInputDev", undef);
	my $state;
	my $oldmodel = AttrVal($name, "model", "unknown");
	my $bitData;
	my $hex_lengh = length(InternalVal($name, "lastMSG", "0"));

	############ chance device models ############
	if ($cmd eq "set" && $attrName eq "model" && $attrValue ne $oldmodel) {

		if (InternalVal($name, "bitMSG", "no data") ne "no data") {
			my $devicemodel;

			### ERROR for Users
			my $allowed_models;
			foreach my $keys (sort keys %models) {	# read allowed_models with the same hex_lengh
				$allowed_models.= $keys.", " if ($models{$keys}{hex_lengh} eq $hex_lengh);
			}

			Log3 $name, 4, "SD_UT_Attr Check for the change, $oldmodel hex_lengh=$hex_lengh, attrValue=$attrValue needed hex_lengh=".$models{$attrValue}{hex_lengh};
			return "ERROR! You want to choose the $oldmodel model to $attrValue.\nPlease check your selection.\nThe length of RAWMSG must be the same!\n\nAllowed models are: $allowed_models" if ($models{$attrValue}{hex_lengh} ne $hex_lengh && $oldmodel ne "unknown");	# variants one
			return "ERROR! You want to choose the unknown model to $attrValue.\nPlease check your selection.\nRAWMSG length is wrong!\n\nAllowed models are: $allowed_models" if (not ($models{$attrValue}{hex_lengh} =~ /($hex_lengh)/ ) && $oldmodel eq "unknown");				# variants two/three
			### #### #### ###

			if ($attrName eq "model" && $attrValue eq "unknown") {
				readingsSingleUpdate($hash, "state", " Please define your model with attributes! ", 0);
			}

			foreach my $keys (sort keys %models) {
				if($keys eq $attrValue) {
					$attr{$name}{model}	= $attrValue;				# set new model
					$bitData = InternalVal($name, "bitMSG", "-");
					$devicemodel = $keys;
					$state = "Defined";
					last;
				}
			}

			############ Westinghouse_Delancey RH787T ############
			if ($attrName eq "model" && $attrValue eq "RH787T") {
				$deviceCode = substr($bitData,1,4);
				$deviceCode = sprintf("%X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Westinghouse Buttons_five ############
			} elsif ($attrName eq "model" && $attrValue eq "Buttons_five") {
				$deviceCode = substr($bitData,8,4);
				$deviceCode = sprintf("%X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ SA_434_1_mini	############
			} elsif ($attrName eq "model" && $attrValue eq "SA_434_1_mini") {
				$deviceCode = sprintf("%03X", oct( "0b$bitData" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Tedsen_SKX1xx, Tedsen_SKX2xx, Tedsen_SKX4xx, Tedsen_SKX6xx	############
			} elsif ($attrName eq "model" && ($attrValue eq "Tedsen_SKX1xx" || $attrValue eq "Tedsen_SKX2xx" || $attrValue eq "Tedsen_SKX4xx" || $attrValue eq "Tedsen_SKX6xx")) {
				$deviceCode = SD_UT_bin2tristate(substr($bitData,0,14));					# only 14 bit from bitdata to tristate
				$devicename = $devicemodel."_".$deviceCode;
			############ Unitec_47031	############
			} elsif ($attrName eq "model" && $attrValue eq "Unitec_47031") {
				$deviceCode = substr($bitData,0,8);																# unklar derzeit! 10Dil auf Bild
				$deviceCode = sprintf("%02X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ QUIGG_DMV ############
			} elsif ($attrName eq "model" && $attrValue eq "QUIGG_DMV") {
				$deviceCode = substr($bitData,0,12);
				$deviceCode = sprintf("%03X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ TR_502MSV ############
			} elsif ($attrName eq "model" && $attrValue eq "TR_502MSV") {
				$deviceCode = substr($bitData,0,8);
				$deviceCode = sprintf("%02X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Novy_840029 ############
			} elsif ($attrName eq "model" && $attrValue eq "Novy_840029") {
				$deviceCode = substr($bitData,0,8);
				$deviceCode = sprintf("%02X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ CAME_TOP_432EV ############
			} elsif ($attrName eq "model" && $attrValue eq "CAME_TOP_432EV") {
				$deviceCode = substr($bitData,0,8);
				$deviceCode = sprintf("%X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ NEFF SF01_01319004 || BOSCH SF01_01319004_Typ2 || Refsta Topdraft (Tecnowind) ############
			} elsif ($attrName eq "model" && ($attrValue eq "SF01_01319004" || $attrValue eq "SF01_01319004_Typ2")) {
				$deviceCode = substr($bitData,0,14) . "00";
				$deviceCode = sprintf("%04X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Hoermann HS1-868-BS	############
			} elsif ($attrName eq "model" && $attrValue eq "HS1_868_BS") {
				$deviceCode = sprintf("%09X", oct( "0b$bitData" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Hoermann HSM4	############
			} elsif ($attrName eq "model" && $attrValue eq "HSM4") {
				$deviceCode = substr($bitData,8,28);
				$deviceCode = sprintf("%07X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Chilitec_22640	############
			} elsif ($attrName eq "model" && $attrValue eq "Chilitec_22640") {
				$deviceCode = substr($bitData,0,16);
				$deviceCode = sprintf("%04X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ LED_XM21_0	############
			} elsif ($attrName eq "model" && $attrValue eq "LED_XM21_0") {
				$deviceCode = substr($bitData,0,56);
				$deviceCode = sprintf("%14X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Krinner_LUMIX	############
			} elsif ($attrName eq "model" && $attrValue eq "Krinner_LUMIX") {
				$deviceCode = substr($bitData,0,28);
				$deviceCode = sprintf("%07X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Manax | mumbi ############
			} elsif ($attrName eq "model" && $attrValue eq "RC_10") {
				$deviceCode = substr($bitData,0,16);
				$deviceCode = sprintf("%04X", oct( "0b$deviceCode" ) );
				
				my $button = substr($bitData,20,3);
				foreach my $keys (sort keys %{$models{RC_10}{buttons}}) {
					if ($keys eq $button) {
						$deviceCode = $deviceCode."_".$models{RC_10}{buttons}{$keys};
						last;
					}
				}
				
				$devicename = $devicemodel."_".$deviceCode;
			############ ESTO KL_RF01 ############
			} elsif ($attrName eq "model" && $attrValue eq "KL_RF01") {
				$deviceCode = substr($bitData,0,16);
				$deviceCode = sprintf("%04X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ Techmar Garden Lights ############
			} elsif ($attrName eq "model" && $attrValue eq "Techmar") {
				$deviceCode = substr($bitData,0,32);
				$deviceCode = sprintf("%08X", oct( "0b$deviceCode" ) );
				$devicename = $devicemodel."_".$deviceCode;
			############ unknown ############
			} else {
				$devicename = "unknown_please_select_model";
				Log3 $name, 3, "SD_UT_Attr UNDEFINED sensor $attrValue (model=unknown)";
			}

			Log3 $name, 3, "SD_UT_Attr UNDEFINED sensor $attrValue detected, code $deviceCode (DoTrigger)" if ($devicemodel ne "unknown");

			$modules{SD_UT}{defptr}{deletecache} = $name if ($hash->{DEF} eq "unknown");
			Log3 $name, 5, "SD_UT: Attr cmd=$cmd devicename=$name attrName=$attrName attrValue=$attrValue oldmodel=$oldmodel";

			readingsSingleUpdate($hash, "state", $state, 0);

			DoTrigger ("global","UNDEFINED unknown_please_select_model SD_UT unknown") if ($devicename eq "unknown_please_select_model");		# if user push attr return to unknown
			DoTrigger ("global","UNDEFINED $devicename SD_UT $devicemodel $deviceCode") if ($devicename ne "unknown_please_select_model");		# create new device

			#CommandAttr( undef, "$devicename model $attrValue" ) if ($devicename ne "unknown_please_select_model");	# set model | Function not reliable !!!
			$attr{$devicename}{model}	= "$attrValue" if ($devicename ne "unknown_please_select_model");				# set model

		} else {
			readingsSingleUpdate($hash, "state", "Please press button again!", 0);
			return "Please press button again or receive more messages!\nOnly with another message can the model be defined.\nWe need bitMSG from message.";
		}
	}

	if ($cmd eq "del" && $attrName eq "model") {			### delete readings
		for my $readingname (qw/Button deviceCode LastAction state unknownMSG/) {
			readingsDelete($hash,$readingname);
		}
	}

	## return if fhem init
	if ($init_done) {
		Log3 $name, 3, "SD_UT_Attr set $attrName to $attrValue" if ($cmd eq "set");
		return "Note: Your unknown_please_select_model device are deleted with the next receive.\nPlease use your new defined model device and do not forget to push -Save config-" if ($defs{$name}->{DEF} eq "unknown" && $oldmodel eq "unknown" && $attrValue ne "$oldmodel");
	}
	return undef;
}

###################################
sub SD_UT_bin2tristate($) {
	my $bitData = shift;
	my %bintotristate=(
	 	 "00" => "0",
	 	 "10" => "F",
	 	 "11" => "1"
	);
	my $tscode;
	for (my $n=0; $n < length($bitData); $n = $n + 2) {
		$tscode = $tscode . $bintotristate{substr($bitData,$n,2)};
	}
	return $tscode;
}

###################################
sub SD_UT_tristate2bin($) {
	my $tsData = shift;
	my %tristatetobin=(
	 	 "0" => "00",
	 	 "F" => "10",
	 	 "1" => "11"
	);
	my $bitData;
	for (my $n=0; $n < length($tsData); $n++) {
		$bitData = $bitData . $tristatetobin{substr($tsData,$n,1)};
	}
	return $bitData;
}

###################################

1;

=pod
=item summary    ...
=item summary_DE ...
=begin html

<a name="SD_UT"></a>
<h3>SD_UT</h3>
<ul>The module SD_UT is a universal module of SIGNALduino for devices or sensors.<br>
	After the first creation of the device <code><b>unknown_please_select_model</b></code>, the user must define the device himself via the <code>model</code> attribute.<br>
	If the device is not supported yet, bit data can be collected with the unknown_please_select_model device.<br><br>
	<i><u><b>Note:</b></u></i> As soon as the attribute model of a defined device is changed or deleted, the module re-creates a device of the selected type, and when a new message is run, the current device is deleted.
	Devices of <u>the same or different type with the same deviceCode will result in errors</u>. PLEASE use different <code>deviceCode</code>.<br><br>
	 <u>The following devices are supported:</u><br>
	 <ul> - Atlantic Security sensors&nbsp;&nbsp;&nbsp;<small>(module model: MD-2003R, MD-2018R,MD-210R | Protokoll 91|91.1)</small><br>
	 <code>&nbsp;&nbsp;&nbsp;note: the model MD_230R (water) is recognized as MD-2018R due to the same hardware ID!</code></ul>
	 <ul> - BOSCH ceiling fan&nbsp;&nbsp;&nbsp;<small>(module model: SF01_01319004_Typ2 | protocol 86)</small></ul>
	 <ul> - CAME swing gate drive&nbsp;&nbsp;&nbsp;<small>(module model: CAME_TOP_432EV | protocol 86)</small></ul>
	 <ul> - ChiliTec LED X-Mas light&nbsp;&nbsp;&nbsp;<small>(module model: Chilitec_22640 | protocol 14)</small></ul>
	 <ul> - ESTO ceiling lamp&nbsp;&nbsp;&nbsp;<small>(model: KL_RF01 | protocol 93)</small></ul>
	 <ul> - Hoermann HS1-868-BS&nbsp;&nbsp;&nbsp;<small>(module model: HS1_868_BS | protocol 69)</small></ul>
	 <ul> - Hoermann HSM4&nbsp;&nbsp;&nbsp;<small>(module model: HSM4 | protocol 69)</small></ul>
	 <ul> - Krinner LUMIX X-Mas light string&nbsp;&nbsp;&nbsp;<small>(module model: Krinner_LUMIX | protocol 92)</small></ul>
	 <ul> - LED_XM21_0 X-Mas light string&nbsp;&nbsp;&nbsp;<small>(module model: LED_XM21_0 | protocol 76)</small></ul>
	 <ul> - LIBRA TR-502MSV (LIDL)&nbsp;&nbsp;&nbsp;<small>(module model: TR_502MSV | protocol 34)</small></ul>
	 <ul> - Manax RCS250&nbsp;&nbsp;&nbsp;<small>(module model: RC_10 | protocol 90)</small></ul>
	 <ul> - Medion OR28V&nbsp;&nbsp;&nbsp;<small>(module model: OR28V | protocol 68)</small></ul>
	 <ul> - mumbi AFS300-s (remote control RC-10 | random code wireless switch RCS-22GS)&nbsp;&nbsp;&nbsp;<small>(module model: RC_10 | protocol 90)</small></ul>
	 <ul> - NEFF or Refsta Topdraft (Tecnowind) kitchen hood&nbsp;&nbsp;&nbsp;<small>(module model: SF01_01319004 | protocol 86)</small></ul>
	 <ul> - Novy Pureline 6830 kitchen hood&nbsp;&nbsp;&nbsp;<small>(module model: Novy_840029 | protocol 86)</small></ul>
	 <ul> - QUIGG DMV-7000&nbsp;&nbsp;&nbsp;<small>(module model: QUIGG_DMV | protocol 34)</small></ul>
	 <ul> - Remote control SA-434-1 mini 923301&nbsp;&nbsp;&nbsp;<small>(module model: SA_434_1_mini | protocol 81)</small></ul>
	 <ul> - Remote control for Techmar Garden Lights &nbsp;&nbsp;&nbsp;<small>(Modulmodel: Techmar | Protokoll 95)</small></ul>
	 <ul> - Tedsen Teletaster <small>(protocol 46)</small>:
			<small>
			<ul>SKX1xx, 1 button - module model: Tedsen_SKX1xx</ul>
			<ul>SKX2xx, 2 button (GEIGER_GF0x01) - module model: Tedsen_SKX2xx</ul>
			<ul>SKX4xx, 4 button (GEIGER_GF0x02) - module model: Tedsen_SKX4xx</ul>
			<ul>SKX6xx, 6 button (GEIGER_GF0x03) - module model: Tedsen_SKX6xx</ul>
			</small>
	 </ul>
	 <ul> - unitec remote door reed switch 47031 (Unitec 47121 | Unitec 47125 | Friedland)&nbsp;&nbsp;&nbsp;<small>(module model: Unitec_47031 | protocol 30)</small></ul>
	 <ul> - Westinghouse Delancey ceiling fan (remote, 5 buttons without SET)&nbsp;&nbsp;&nbsp;<small>(module model: Buttons_five | protocol 29)</small></ul>
	 <ul> - Westinghouse Delancey ceiling fan (remote, 9 buttons with SET)&nbsp;&nbsp;&nbsp;<small>(module model: RH787T | protocol 83)</small></ul>
	 <br><br>
	<b>Define</b><br>
	<ul><code>define &lt;NAME&gt; SD_UT &lt;model&gt; &lt;Hex-address&gt;</code><br><br>
	<u>examples:</u>
		<ul>
		define &lt;NAME&gt; SD_UT RH787T A<br>
		define &lt;NAME&gt; SD_UT SA_434_1_mini ffd<br>
		define &lt;NAME&gt; SD_UT unknown<br>
		</ul>	</ul><br><br>
	<b>Set</b><br>
	<ul>Different transmission commands are available.</ul><br>
		<ul><u>BOSCH (SF01_01319004_Typ2) | NEFF / Refsta Topdraft (SF01_01319004)</u></ul>
	<ul><a name="delay"></a>
		<li>delay<br>
		button one on the remote</li>
	</ul>
	<ul><a name="interval"></a>
		<li>interval<br>
		button two on the remote</li>
	</ul>
	<ul><a name="light_on_off"></a>
		<li>light_on_off<br>
		button three on the remote</li>
	</ul>
	<ul><a name="minus"></a>
		<li>minus<br>
		button four on the remote</li>
	</ul>
	<ul><a name="plus"></a>
		<li>plus<br>
		button five on the remote</li>
	</ul><br>

	<ul><u>ChiliTec LED X-Mas light</u></ul>
	<ul><a name="power_on"></a>
		<li>power_on<br>
		button ON on the remote</li>
	</ul>
	<ul><a name="power_off"></a>
		<li>power_off<br>
		button OFF on the remote</li>
	</ul>
	<ul><a name="flickering_slowly"></a>
		<li>flickering_slowly<br>
		button SL on the remote</li>
	</ul>
	<ul><a name="flickering_fast"></a>
		<li>flickering_fast<br>
		button SF on the remote</li>
	</ul>
	<ul><a name="brightness_minus"></a>
		<li>brightness_minus<br>
		button - on the remote</li>
	</ul>
	<ul><a name="brightness_plus"></a>
		<li>brightness_plus<br>
		button + on the remote</li>
	</ul><br>

		<ul><u>ESTO KL_RF01</u></ul>
	<ul><a name="on"></a>
		<li>on<br>
		button ON on the remote</li>
	</ul>
	<ul><a name="off"></a>
		<li>off<br>
		button OFF on the remote</li>
	</ul>
	<ul><a name="alternating_full_luminosity"></a>
		<li>alternating_full_luminosity<br>
		button alternating_full_luminosity on the remote</li>
	</ul>
	<ul><a name="full_brightness"></a>
		<li>full_brightness<br>
		button full_brightness on the remote</li>
	</ul>
	<ul><a name="light_color_warm_white"></a>
		<li>light_color_warm_white<br>
		button light_color_warm_white on the remote</li>
	</ul>
	<ul><a name="light_color_cold_white"></a>
		<li>light_color_cold_white<br>
		button light_color_cold_white on the remote</li>
	</ul>
	<ul><a name="dimup"></a>
		<li>dimup<br>
		button DIMUP on the remote</li>
	</ul>
		<ul><a name="dimdown"></a>
		<li>dimdown<br>
		button DIMDOWN on the remote</li>
	</ul>
	<ul><a name="night_mode"></a>
		<li>night_mode<br>
		button moon on the remote</li>
	</ul><br>

	<ul><u>LED_XM21_0 light string</u></ul>
	<ul><a name="on"></a>
		<li>on<br>
		button I on the remote</li>
	</ul>
	<ul><a name="off"></a>
		<li>off<br>
		button O on the remote</li>
	</ul><br>

	<ul><u>Remote control SA-434-1 mini 923301&nbsp;&nbsp;|&nbsp;&nbsp;Hoermann HS1-868-BS&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX1/2/4/6xx</u></ul>
	<ul>
		<li>send<br>
		button <small>(Always send the same, even if the user sends another set command via console.)</small></li>
	</ul><br>

	<ul><u>Hoermann HSM4 (remote with 4 buttons)</u></ul>
	<ul><a name="button_1"></a>
		<li>button_1<br>
		Button one on the remote</li>
	</ul>
	<ul><a name="button_2"></a>
		<li>button_2<br>
		Button two on the remote</li>
	</ul>
	<ul><a name="button_3"></a>
		<li>button_3<br>
		Button three on the remote</li>
	</ul>
	<ul><a name="button_4"></a>
		<li>button_4<br>
		Button four on the remote</li>
	</ul><br>

	<ul><u>Techmar Garden Lights (remote control with 10 buttons)</u></ul>
	<ul><li>Group_1 ... Group_9<br>
		Group 1 to 9, on / off</li>
	</ul>
	<ul><li>All_on / All_off<br>
		All Groups on / off</li>
	</ul><br>
	
	<ul><u>Westinghouse ceiling fan (remote with 5 buttons and without SET)</u></ul>
	<ul><a name="1_fan_low_speed"></a>
		<li>1_fan_low_speed<br>
		Button LOW on the remote</li>
	</ul>
	<ul><a name="2_fan_medium_speed"></a>
		<li>2_fan_medium_speed<br>
		Button MED on the remote</li>
	</ul>
	<ul><a name="3_fan_high_speed"></a>
		<li>3_fan_high_speed<br>
		Button HI on the remote</li>
	</ul>
	<ul><a name="light_on_off"></a>
		<li>light_on_off<br>
		switch light on or off</li>
	</ul>
	<ul><a name="fan_off"></a>
		<li>fan_off<br>
		turns off the fan</li>
	</ul><br><a name=" "></a>

	<ul><u>Westinghouse Delancey ceiling fan (remote RH787T with 9 buttons and SET)</u></ul>
	<ul><a name="1_fan_minimum_speed"></a>
		<li>1_fan_minimum_speed<br>
		Button I on the remote</li>
	</ul>
	<ul><a name="2_fan_low_speed"></a>
		<li>2_fan_low_speed<br>
		Button II on the remote</li>
	</ul>
	<ul><a name="3_fan_medium_low_speed"></a>
		<li>3_fan_medium_low_speed<br>
		Button III on the remote</li>
	</ul>
	<ul><a name="4_fan_medium_speed"></a>
		<li>4_fan_medium_speed<br>
		Button IV on the remote</li>
	</ul>
	<ul><a name="5_fan_medium_high_speed"></a>
		<li>5_fan_medium_high_speed<br>
		Button V on the remote</li>
	</ul>
	<ul><a name="6_fan_high_speed"></a>
		<li>6_fan_high_speed<br>
		Button VI on the remote</li>
	</ul>
	<ul><a name="fan_off"></a>
		<li>fan_off<br>
		turns off the fan</li>
	</ul>
	<ul><a name="fan_direction"></a>
		<li>fan_direction<br>
		Defining the direction of rotation</li>
	</ul>
	<ul><a name="light_on_off"></a>
		<li>light_on_off<br>
		switch light on or off</li>
	</ul>
	<ul><a name="set"></a>
		<li>set<br>
		Button SET in the remote</li><a name=" "></a>
	</ul>
	<br><br>

	<b>Get</b><br>
	<ul>N/A</ul><br><br>

	<b>Attribute</b><br>
	<ul><li><a href="#do_not_notify">do_not_notify</a></li></ul><br>
	<ul><li><a href="#ignore">ignore</a></li></ul><br>
	<ul><li><a href="#IODev">IODev</a></li></ul><br>
	<ul><a name="model"></a>
		<li>model<br>
		The attribute indicates the model type of your device.<br>
		(unknown, Buttons_five, CAME_TOP_432EV, Chilitec_22640, KL_RF01, HS1-868-BS, HSM4, QUIGG_DMV, LED_XM21_0, Novy_840029, OR28V, RC_10, RH787T, SA_434_1_mini, SF01_01319004, Tedsen_SKX1xx, Tedsen_SKX2xx, Tedsen_SKX4xx, Tedsen_SKX6xx, TR_502MSV, Unitec_47031)</li>
	</ul><br>
	<ul><li><a name="repeats">repeats</a><br>
	This attribute can be used to adjust how many repetitions are sent. Default is 5.</li></ul><br>

	<b><i>Generated readings of the models</i></b><br>
	<ul><u>Buttons_five | CAME_TOP_432EV | Chilitec_22640 | HSM4 | KL_RF01 | LED_XM21_0 | Novy_840029 | OR28V | QUIGG_DMV | RC_10 | RH787T | SF01_01319004 | SF01_01319004_Typ2 | TR_502MSV</u><br>
	<li>deviceCode<br>
	Device code of the system</li>
	<li>LastAction<br>
	Last executed action of the device. <code>receive</code> for command received | <code>send</code> for command send</li>
	<li>state<br>
	Last executed keystroke of the remote control</li></ul><br>

	<ul><u>MD_2003R (gas)&nbsp;&nbsp;|&nbsp;&nbsp;MD_2018R (vibration)&nbsp;&nbsp;|&nbsp;&nbsp;MD_210R (door/windows switch)&nbsp;&nbsp;|&nbsp;&nbsp;MD_230R (water)</u><br>
	<li>contact<br>
	Status of the internal alarm contact</li>
	<li>deviceTyp<br>
	Model type of your sensor</li>
	<li>sabotage<br>
	State of sabotage contact</li>
	<li>state<br>
	State of the device</li></ul><br>

	<ul><u>HS1-868-BS&nbsp;&nbsp;|&nbsp;&nbsp;SA_434_1_mini&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX1xx&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX2xx&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX4xx&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX6xx</u><br>
	<li>LastAction<br>
	Last executed action of FHEM. <code>send</code> for command send.</li>
	<li>state<br>
	Last executed action of the device. <code>receive</code> for command received | <code>send</code> for command send</li></ul><br>

	<ul><u>Unitec_47031</u><br>
	<li>System-Housecode<br>
	System or house code of the device</li>
	<li>state<br>
	Condition of contact (prepared, unconfirmed)</li>
	<li>Zone<br>
	Zone of the device</li>
	<li>Usersystem<br>
	Group of the system</li>
	</ul><br>

</ul>
=end html
=begin html_DE

<a name="SD_UT"></a>
<h3>SD_UT</h3>
<ul>Das Modul SD_UT ist ein Universalmodul vom SIGNALduino f&uuml;r Ger&auml;te oder Sensoren.<br>
	Nach dem ersten anlegen des Ger&auml;tes <code><b>unknown_please_select_model</b></code> muss der User das Ger&auml;t selber definieren via dem Attribut <code>model</code>.<br>
	Bei noch nicht unterst&uuml;tzen Ger&auml;ten k&ouml;nnen mit dem <code><b>unknown_please_select_model</b></code> Ger&auml;t Bitdaten gesammelt werden.<br><br>
	<i><u><b>Hinweis:</b></u></i> Sobald das Attribut model eines definieren Ger&auml;tes verstellt oder gel&ouml;scht wird, so legt das Modul ein Ger&auml;t des gew&auml;hlten Typs neu an und mit Durchlauf einer neuen Nachricht wird das aktuelle Ger&auml;t gel&ouml;scht.
	Das betreiben von Ger&auml;ten des <u>gleichen oder unterschiedliches Typs mit gleichem <code>deviceCode</code> f&uuml;hrt zu Fehlern</u>. BITTE achte stets auf einen unterschiedlichen <code>deviceCode</code>.<br><br>
	 <u>Es werden bisher folgende Ger&auml;te unterst&uuml;tzt:</u><br>
	 <ul> - Atlantic Security Sensoren&nbsp;&nbsp;&nbsp;<small>(Modulmodel: MD-2003R, MD-2018R,MD-210R | Protokoll 91|91.1)</small><br>
	 <code>&nbsp;&nbsp;&nbsp;Hinweis: Das Model MD_230R (water) wird aufgrund von gleicher Hardwarekennung als MD-2018R erkannt!</code></ul>
	 <ul> - BOSCH Deckenl&uuml;fter&nbsp;&nbsp;&nbsp;<small>(Modulmodel: SF01_01319004_Typ2 | Protokoll 86)</small></ul>
	 <ul> - CAME Drehtor Antrieb&nbsp;&nbsp;&nbsp;<small>(Modulmodel: CAME_TOP_432EV | Protokoll 86)</small></ul>
	 <ul> - ChiliTec LED Christbaumkerzen&nbsp;&nbsp;&nbsp;<small>(Modulmodel: Chilitec_22640 | Protokoll 14)</small></ul>
	 <ul> - ESTO Deckenlampe&nbsp;&nbsp;&nbsp;<small>(Modulmodel: KL_RF01 | Protokoll 93)</small></ul>
	 <ul> - Hoermann HS1-868-BS&nbsp;&nbsp;&nbsp;<small>(Modulmodel: HS1_868_BS | Protokoll 69)</small></ul>
	 <ul> - Hoermann HSM4&nbsp;&nbsp;&nbsp;<small>(Modulmodel: HSM4 | Protokoll 69)</small></ul>
	 <ul> - Krinner LUMIX Christbaumkerzen&nbsp;&nbsp;&nbsp;<small>(Modulmodel: Krinner_LUMIX | Protokol 92)</small></ul>
	 <ul> - LED_XM21_0 Christbaumkerzen&nbsp;&nbsp;&nbsp;<small>(Modulmodel: LED_XM21_0 | Protokol 76)</small></ul>
	 <ul> - LIBRA TR-502MSV (LIDL)&nbsp;&nbsp;&nbsp;<small>(Modulmodel: TR_502MSV | Protokol 34)</small></ul>
	 <ul> - Manax RCS250&nbsp;&nbsp;&nbsp;<small>(Modulmodel: RC_10 | Protokoll 90)</small></ul>
	 <ul> - Medion OR28V&nbsp;&nbsp;&nbsp;<small>(Modulmodel: OR28V | Protokoll 68)</small></ul>
	 <ul> - mumbi AFS300-s (remote control RC-10 | random code wireless switch RCS-22GS)&nbsp;&nbsp;&nbsp;<small>(Modulmodel: RC_10 | Protokoll 90)</small></ul>
	 <ul> - NEFF oder Refsta Topdraft (Tecnowind) Dunstabzugshaube&nbsp;&nbsp;&nbsp;<small>(Modulmodel: SF01_01319004 | Protokoll 86)</small></ul>
	 <ul> - Novy Pureline 6830 Dunstabzugshaube&nbsp;&nbsp;&nbsp;<small>(Modulmodel: Novy_840029 | Protokoll 86)</small></ul>
	 <ul> - QUIGG DMV-7000&nbsp;&nbsp;&nbsp;<small>(Modulmodel: QUIGG_DMV | Protokoll 34)</small></ul>
	 <ul> - Remote control SA-434-1 mini 923301&nbsp;&nbsp;&nbsp;<small>(Modulmodel: SA_434_1_mini | Protokoll 81)</small></ul>
	 <ul> - Techmar Garden Lights &nbsp;&nbsp;&nbsp;<small>(Modulmodel: Techmar | Protokoll 95)</small></ul>
	 <ul> - Tedsen Teletaster <small>(Protokoll 46)</small>:
			<small>
			<ul>SKX1xx, 1 Taste - Modulmodel: Tedsen_SKX1xx</ul>
			<ul>SKX2xx, 2 Tasten (GEIGER_GF0x01) - Modulmodel: Tedsen_SKX2xx</ul>
			<ul>SKX4xx, 4 Tasten (GEIGER_GF0x02) - Modulmodel: Tedsen_SKX4xx</ul>
			<ul>SKX6xx, 6 Tasten (GEIGER_GF0x03) - Modulmodel: Tedsen_SKX6xx</ul>
			</small>
	 </ul>
	 <ul> - unitec remote door reed switch 47031 (Unitec 47121 | Unitec 47125 | Friedland)&nbsp;&nbsp;&nbsp;<small>(Modulmodel: Unitec_47031 | Protokoll 30)</small></ul>
	 <ul> - Westinghouse Deckenventilator (Fernbedienung, 5 Tasten ohne SET)&nbsp;&nbsp;&nbsp;<small>(Modulmodel: Buttons_five | Protokoll 29)</small></ul>
	 <ul> - Westinghouse Delancey Deckenventilator (Fernbedienung, 9 Tasten mit SET)&nbsp;&nbsp;&nbsp;<small>(Modulmodel: RH787T | Protokoll 83)</small></ul>
	 <br><br>

	<b>Define</b><br>
	<ul><code>define &lt;NAME&gt; SD_UT &lt;model&gt; &lt;Hex-Adresse&gt;</code><br><br>
	<u>Beispiele:</u>
		<ul>
		define &lt;NAME&gt; SD_UT RH787T A<br>
		define &lt;NAME&gt; SD_UT SA_434_1_mini ffd<br>
		define &lt;NAME&gt; SD_UT unknown<br>
		</ul></ul><br><br>

	<b>Set</b><br>
	<ul>Je nach Ger&auml;t sind unterschiedliche Sendebefehle verf&uuml;gbar.</ul><br>
	<ul><u>BOSCH (SF01_01319004_Typ2) | NEFF / Refsta Topdraft (SF01_01319004)</u></ul>
	<ul><a name="delay"></a>
		<li>delay<br>
		Taste 1 auf der Fernbedienung</li>
	</ul>
	<ul><a name="interval"></a>
		<li>interval<br>
		Taste 2 auf der Fernbedienung</li>
	</ul>
	<ul><a name="light_on_off"></a>
		<li>light_on_off<br>
		Taste 3 auf der Fernbedienung</li>
	</ul>
	<ul><a name="minus"></a>
		<li>minus<br>
		Taste 4 auf der Fernbedienung</li>
	</ul>
	<ul><a name="plus"></a>
		<li>plus<br>
		Taste 5 auf der Fernbedienung</li>
	</ul><br>

	<ul><u>ChiliTec LED Christbaumkerzen</u></ul>
	<ul><a name="power_on"></a>
		<li>power_on<br>
		Taste ON auf der Fernbedienung</li>
	</ul>
	<ul><a name="power_off"></a>
		<li>power_off<br>
		Taste OFF auf der Fernbedienung</li>
	</ul>
	<ul><a name="flickering_slowly"></a>
		<li>flickering_slowly<br>
		Taste SL auf der Fernbedienung</li>
	</ul>
	<ul><a name="flickering_fast"></a>
		<li>flickering_fast<br>
		Taste SF auf der Fernbedienung</li>
	</ul>
	<ul><a name="brightness_minus"></a>
		<li>brightness_minus<br>
		Taste - auf der Fernbedienung</li>
	</ul>
	<ul><a name="brightness_plus"></a>
		<li>brightness_plus<br>
		Taste + auf der Fernbedienung</li>
	</ul><br>

	<ul><u>ESTO KL_RF01</u></ul>
	<ul><a name="on"></a>
		<li>on<br>
		Taste ON auf der Fernbedienung</li>
	</ul>
	<ul><a name="off"></a>
		<li>off<br>
		Taste OFF auf der Fernbedienung</li>
	</ul>
	<ul><a name="alternating_full_luminosity"></a>
		<li>alternating_full_luminosity<br>
		Taste ABWECHSELNDE_LEUCHTKRAFT auf der Fernbedienung</li>
	</ul>
	<ul><a name="full_brightness"></a>
		<li>full_brightness<br>
		Taste VOLLE_HELLIGKEIT auf der Fernbedienung</li>
	</ul>
	<ul><a name="light_color_warm_white"></a>
		<li>light_color_warm_white<br>
		Taste LICHTFARBE_WARMWEIß auf der Fernbedienung</li>
	</ul>
	<ul><a name="light_color_cold_white"></a>
		<li>light_color_cold_white<br>
		Taste LICHTFARBE_KALTWEIß auf der Fernbedienung</li>
	</ul>
	<ul><a name="dimup"></a>
		<li>dimup<br>
		Taste DIMUP auf der Fernbedienung</li>
	</ul>
		<ul><a name="dimdown"></a>
		<li>dimdown<br>
		Taste DIMDOWN auf der Fernbedienung</li>
	</ul>
	<ul><a name="night_mode"></a>
		<li>night_mode<br>
		Taste MOND auf der Fernbedienung</li>
	</ul><br>

	<ul><u>LED_XM21_0 Christbaumkerzen</u></ul>
	<ul><a name="on"></a>
		<li>on<br>
		Taste I auf der Fernbedienung</li>
	</ul>
	<ul><a name="off"></a>
		<li>off<br>
		Taste O auf der Fernbedienung</li>
	</ul><br>

	<ul><u>Remote control SA-434-1 mini 923301&nbsp;&nbsp;|&nbsp;&nbsp;Hoermann HS1-868-BS&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX1xx</u></ul>
	<ul>
		<li>send<br>
		Knopfdruck <small>(Sendet immer das selbe, auch wenn der Benutzer einen anderen Set-Befehl via Konsole sendet.)</small></li>
	</ul><br>

	<ul><u>Hoermann HSM4 (Fernbedienung mit 4 Tasten)</u></ul>
	<ul><a name="button_1"></a>
		<li>button_1<br>
		Taste 1 auf der Fernbedienung</li>
	</ul>
	<ul><a name="button_2"></a>
		<li>button_2<br>
		Taste 2 auf der Fernbedienung</li>
	</ul>
	<ul><a name="button_3"></a>
		<li>button_3<br>
		Taste 3 auf der Fernbedienung</li>
	</ul>
	<ul><a name="button_4"></a>
		<li>button_4<br>
		Taste 4 auf der Fernbedienung</li>
	</ul><br>

	<ul><u>Techmar Garden Lights (Fernbedienung mit 10 Tasten)</u></ul>
	<ul><li>Group_1 ... Group_9<br>
		Gruppe 1 bis 9, jeweils ein und aus</li>
	</ul>
	<ul><li>All_on / All_off<br>
		Alle Gruppen ein / aus</li>
	</ul><br>

	<ul><u>Westinghouse Deckenventilator (Fernbedienung mit 5 Tasten)</u></ul>
	<ul><a name="1_fan_low_speed"></a>
		<li>1_fan_low_speed<br>
		Taste LOW auf der Fernbedienung</li>
	</ul>
	<ul><a name="2_fan_medium_speed"></a>
		<li>2_fan_medium_speed<br>
		Taste MED auf der Fernbedienung</li>
	</ul>
	<ul><a name="3_fan_high_speed"></a>
		<li>3_fan_high_speed<br>
		Taste HI auf der Fernbedienung</li>
	</ul>
	<ul><a name="light_on_off"></a>
		<li>light_on_off<br>
		Licht ein-/ausschalten</li>
	</ul>
	<ul><a name="fan_off"></a>
		<li>fan_off<br>
		Ventilator ausschalten</li>
	</ul><br>

	<ul><a name=" "></a><u>Westinghouse Delancey Deckenventilator (Fernbedienung RH787T mit 9 Tasten + SET)</u></ul>
	<ul><a name="1_fan_minimum_speed"></a>
		<li>1_fan_minimum_speed<br>
		Taste I auf der Fernbedienung</li>
	</ul>
	<ul><a name="2_fan_low_speed"></a>
		<li>2_fan_low_speed<br>
		Taste II auf der Fernbedienung</li>
	</ul>

	<ul><a name="3_fan_medium_low_speed"></a>
		<li>3_fan_medium_low_speed<br>
		Taste III auf der Fernbedienung</li>
	</ul>
	<ul><a name="4_fan_medium_speed"></a>
		<li>4_fan_medium_speed<br>
		Taste IV auf der Fernbedienung</li>
	</ul>
	<ul><a name="5_fan_medium_high_speed"></a>
		<li>5_fan_medium_high_speed<br>
		Taste V auf der Fernbedienung</li>
	</ul>
	<ul><a name="6_fan_high_speed"></a>
		<li>6_fan_high_speed<br>
		Taste VI auf der Fernbedienung</li>
	</ul>
	<ul><a name="fan_off"></a>
		<li>fan_off<br>
		Ventilator ausschalten</li></ul>
	<ul><a name="fan_direction"></a>
		<li>fan_direction<br>
		Drehrichtung festlegen</li>
	</ul>
	<ul><a name="light_on_off"></a>
		<li>light_on_off<br>
		Licht ein-/ausschalten</li>
	</ul>
	<ul><a name="set"></a>
		<li>set<br>
		Taste SET in der Fernbedienung</li><a name=" "></a>
	</ul>
	<br><br>

	<b>Get</b><br>
	<ul>N/A</ul><br><br>

	<b>Attribute</b><br>
	<ul><li><a href="#do_not_notify">do_not_notify</a></li></ul><br>
	<ul><li><a href="#ignore">ignore</a></li></ul><br>
	<ul><li><a href="#IODev">IODev</a></li></ul><br>
	<ul><li><a name="model">model</a><br>
		Das Attribut bezeichnet den Modelltyp Ihres Ger&auml;tes.<br>
		(unknown, Buttons_five, CAME_TOP_432EV, Chilitec_22640, KL_RF01, HS1-868-BS, HSM4, QUIGG_DMV, LED_XM21_0, Novy_840029, OR28V, RC_10, RH787T, SA_434_1_mini, SF01_01319004, Tedsen_SKX1xx, Tedsen_SKX2xx, Tedsen_SKX4xx, Tedsen_SKX6xx, TR_502MSV, Unitec_47031)</li><a name=" "></a>
	</ul><br>
	<ul><li><a name="repeats">repeats</a><br>
	Mit diesem Attribut kann angepasst werden, wie viele Wiederholungen sendet werden. Standard ist 5.</li></ul><br>

	<b><i>Generierte Readings der Modelle</i></b><br>
	<ul><u>Buttons_five | CAME_TOP_432EV | Chilitec_22640 | HSM4 | KL_RF01 | LED_XM21_0 | Novy_840029 | OR28V | QUIGG_DMV | RC_10 | RH787T | SF01_01319004 | SF01_01319004_Typ2 | TR_502MSV</u><br>
	<li>deviceCode<br>
	Ger&auml;teCode des Systemes</li>
	<li>LastAction<br>
	Zuletzt ausgef&uuml;hrte Aktion des Ger&auml;tes. <code>receive</code> f&uuml;r Kommando empfangen | <code>send</code> f&uuml;r Kommando gesendet</li>
	<li>state<br>
	Zuletzt ausgef&uuml;hrter Tastendruck der Fernbedienung</li></ul><br>

	<ul><u>MD_2003R (gas)&nbsp;&nbsp;|&nbsp;&nbsp;MD_2018R (vibration)&nbsp;&nbsp;|&nbsp;&nbsp;MD_210R (door/windows switch)&nbsp;&nbsp;|&nbsp;&nbsp;MD_230R (water)</u><br>
	<li>contact<br>
	Zustand des internen Alarmkontaktes.</li>
	<li>deviceTyp<br>
	Modeltyp Ihres Sensors.</li>
	<li>sabotage<br>
	Zustand des Sabotagekontaktes.</li>
	<li>state<br>
	Zustand des Ger&auml;tes.</li></ul><br>

	<ul><u>HS1-868-BS&nbsp;&nbsp;|&nbsp;&nbsp;SA_434_1_mini&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX1xx&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX2xx&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX4xx&nbsp;&nbsp;|&nbsp;&nbsp;Tedsen_SKX6xx</u><br>
	<li>LastAction<br>
	Zuletzt ausgef&uuml;hrte Aktion aus FHEM. <code>send</code> f&uuml;r Kommando gesendet.</li>
	<li>state<br>
	Zuletzt ausgef&uuml;hrte Aktion des Ger&auml;tes. <code>receive</code> f&uuml;r Kommando empfangen.</li></ul><br>

	<ul><u>Unitec_47031</u><br>
	<li>System-Housecode<br>
	Eingestellter System bzw. Hauscode des Ger&auml;tes</li>
	<li>state<br>
	Zustand des Kontaktes (vorbereitet, unbest&auml;tigt)</li>
	<li>Zone<br>
	Eingestellte Zone des Ger&auml;tes</li>
	<li>Usersystem<br>
	Bezeichnung Systemes</li>
	</ul><br>

</ul>
=end html_DE
=cut
