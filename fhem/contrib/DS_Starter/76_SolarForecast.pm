########################################################################################################################
# $Id$
#########################################################################################################################
#       76_SolarForecast.pm
#
#       (c) 2020-2025 by Heiko Maaz  e-mail: Heiko dot Maaz at t-online dot de
#       with credits to: kask, Prof. Dr. Peter Henning, Wzut, ch.eick (and much more FHEM users)
#
#       This script is part of fhem.
#
#       Fhem is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 2 of the License, or
#       (at your option) any later version.
#
#       Fhem is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with fhem.  If not, see <http://www.gnu.org/licenses/>.
#
#       This copyright notice MUST APPEAR in all copies of the script! 
#
#########################################################################################################################
#
#  Leerzeichen entfernen: sed -i 's/[[:space:]]*$//' 76_SolarForecast.pm
#
#########################################################################################################################
main::LoadModule ('Astro');                                                          # Astro Modul für Sonnenkennzahlen laden

package FHEM::SolarForecast;                                                         ## no critic 'package'

use strict;
use warnings;
use POSIX;
use GPUtils qw(GP_Import GP_Export);                                                 # wird für den Import der FHEM Funktionen aus der fhem.pl benötigt
use Time::HiRes qw(gettimeofday tv_interval);
use Math::Trig;
use List::Util qw(sum min max shuffle);
use Scalar::Util qw(blessed weaken);

eval "use FHEM::Meta;1"                   or my $modMetaAbsent = 1;                  ## no critic 'eval'
eval "use FHEM::Utility::CTZ qw(:all);1;" or my $ctzAbsent     = 1;                  ## no critic 'eval'
#use Test::Memory::Usage;                                                            # https://metacpan.org/pod/Test::Memory::Usage

use Encode;
use Color;
use utf8;
use HttpUtils;
eval "use JSON;1;"                        or my $jsonabs = 'JSON';                   ## no critic 'eval' # cpan install JSON
eval "use AI::DecisionTree;1;"            or my $aidtabs = 'AI::DecisionTree';       ## no critic 'eval' # cpan install AI::DecisionTree

use FHEM::SynoModules::ErrCodes qw(:all);                                            # Error Code Modul
use FHEM::SynoModules::SMUtils qw (checkModVer
                                   delClHash
                                   evaljson
                                   getClHash
                                   moduleVersion
                                   trim
                                  );                                                 # Hilfsroutinen Modul

use Data::Dumper;
use Blocking;
use Storable qw(dclone freeze thaw nstore retrieve);
use MIME::Base64;

# Run before module compilation
BEGIN {
  # Import from main::
  GP_Import(
      qw (attr
          asyncOutput
          AnalyzePerlCommand
          AnalyzeCommandChain
          AttrVal
          AttrNum
          BlockingCall
          BlockingKill
          CommandAttr
          CommandGet
          CommandSet
          CommandSetReading
          data
          defs
          delFromDevAttrList
          delFromAttrList
          devspec2array
          deviceEvents
          DoTrigger
          Debug
          fhemTimeLocal
          fhemTimeGm
          fhem
          FileWrite
          FileRead
          FileDelete
          FmtTime
          FmtDateTime
          FW_makeImage
          getKeyValue
          getAllAttr
          getAllGets
          getAllSets
          HttpUtils_NonblockingGet
          HttpUtils_BlockingGet
          GetFileFromURL
          GetHttpFile
          init_done
          InternalTimer
          InternalVal
          IsDisabled
          Log
          Log3
          modules
          parseParams
          perlSyntaxCheck
          readingsSingleUpdate
          readingsBulkUpdate
          readingsBulkUpdateIfChanged
          readingsBeginUpdate
          readingsDelete
          readingsEndUpdate
          ReadingsNum
          ReadingsTimestamp
          ReadingsVal
          RemoveInternalTimer
          ReplaceEventMap
          readingFnAttributes
          setKeyValue
          sunrise_abs_dat
          sunset_abs_dat
          FW_cmd
          FW_directNotify
          FW_pH
          FW_room
          FW_detail
          FW_widgetOverride
          FW_wname
          readyfnlist
         )
  );

  # Export to main context with different name
  #     my $pkg  = caller(0);
  #     my $main = $pkg;
  #     $main =~ s/^(?:.+::)?([^:]+)$/main::$1\_/g;
  #     foreach (@_) {
  #         *{ $main . $_ } = *{ $pkg . '::' . $_ };
  #     }
  GP_Export(
      qw(
          Initialize
          pageAsHtml
          NexthoursVal
        )
  );
}

# Versions History intern
my %vNotesIntern = (
  "1.59.6" => "20.10.2025  ___ownSpecGetFWwidget: handling of line breaks in attributes & can hamdle a key=value pair separateley ".
                           "Width of a text field in graphicHeaderOwnspec fixed to 10 ".
                           "__batChargeOptTargetPower: use an average for the charging power if optPower set and charging target are not achievable ",
  "1.59.5" => "15.10.2025  new sub ___batAdjustPowerByMargin: implement optPower Safety margin decreasing proportionally to the linear surplus ".
                           "new Reading Battery_TargetAchievable_XX, _batSocTarget: minor code change ",
  "1.59.4" => "14.10.2025  new subs, ctrlBatSocManagementXX: new key loadTarget, replace __batCapShareFactor by __batDeficitShareFactor ".
                           "__batChargeOptTargetPower: use pinmax if achievable==0, new ctrlBatSocManagementXX->stepSoC key ".
						   "loadStrategy: possible value smartPower ", 
  "1.59.3" => "10.10.2025  ___batChargeSaveResults: fix writing 'rcdchargebatXX' ",
  "1.59.2" => "09.10.2025  one more fix of color filling of svg icon ",
  "1.59.1" => "08.10.2025  fixed transfer at day change, optimal SoC consideration in SoC forecast for optPower strategy ".
                           "__normIconInnerScale: add path color filling, Calculation of time-weighted consumption or PV generation ".
                           "in the current hour ",
  "1.59.0" => "06.10.2025  new sub __normIconInnerScale to fix problem with chromium engine > 140.x, Forum: https://forum.fhem.de/index.php?msg=1349058 ",
  "1.58.8" => "06.10.2025  __batChargeOptTargetPower: minor Code change ",
  "1.58.7" => "05.10.2025  fix negative SoC forecast when using optPower Forum: https://forum.fhem.de/index.php?msg=1348954 ",
  "1.58.6" => "03.10.2025  __batChargeMgmt code changed, new sub ___batChargeSaveResults, remove reading Battery_ChargeRecommended_XX ".
                           "_calcReadingsTomorrowPVFc: bugfix generating readings of tomorrow ".
                           "__batChargeOptTargetPower: complete rework, Attr ctrlBatSocManagementXX new keys 'loadStrategy', 'weightOwnUse' ".
                           "new battery key setupBatteryDevXX->efficiency ",
  "1.58.5" => "24.09.2025  __batChargeOptTargetPower: fix if battery load control is deactivated ",
  "1.58.4" => "23.09.2025  __batChargeOptTargetPower: user a better surplus value, excess based on average removed & some other code optimization ",
  "1.58.3" => "17.09.2025  __batChargeOptTargetPower: minor code change, consider bpinmax & lcintime ",
  "1.58.2" => "11.09.2025  __batChargeOptTargetPower: a lot of Code improvements, Attr flowGraphicControl->shiftx: unrestrict possible values ",
  "1.58.1" => "08.09.2025  edit comref, ctrlBatSocManagementXX->safetyMargin: Separate specification of surcharges for calculation of load ".
                           "clearance and performance optimization ",
  "1.58.0" => "06.09.2025  _batChargeMgmt: Code change and new loading feature with Reading Battery_ChargeOptTargetPower_XX ".
                           "ctrlBatSocManagementXX: new parameter safetyMargin ".
                           "edit Comref, delete obsolete Attr graphicBeamHeightLevelX, new parameter setupBatteryDevXX->pinreduced ",
  "1.57.3" => "26.08.2025  set default Performance Ratio PRDEF to 0.9, prevent crash when Victron API does not return an Array ".
                           "check global attribute dnsServer in all SF Models, expand plantControl->genPVdeviation for perspective change ".
                           "Household consumption calculation uniformly converted to vector calculation ".
                           "new ctrlSpecialReadings->dummyConsumption, _createSummaries: fix calc of surplus ".
                           "__createOwnSpec: change inputs for ___ghoValForm to prevent failures like https://forum.fhem.de/index.php?msg=1346936 ",
  "1.57.2" => "15.08.2025  _attrconsumer: The validity of the components of the key etotal is checked ".
                           "_transferMeterValues: modul accept meter reset > 0 at day start ",
  "1.57.1" => "10.08.2025  fix warning, Forum: https://forum.fhem.de/index.php?msg=1346055 ",
  "1.57.0" => "08.08.2025  new option attr graphicControl->scaleMode=X:staple ",
  "1.56.0" => "07.08.2025  set MAXINVERTER to 5 ",
  "1.55.0" => "06.08.2025  DWD-Weather and DWD-Radiation device new minimum value of attr 'forecastDays' is 2 ".
                           "checkPlantConfig: check forecastDays of new minimum value ".
                           "___createOpenMeteoURL: set forecast_hours=72, bugfix of V 1.54.7 ".
                           "Nexthours: max 72 hours available but not more than 3 days ",                           
  "1.54.7" => "01.08.2025  _transferAPIRadiationValues: Extension of Nexthours content up to 48 hours into the future ".
                           "attr graphicBeamHeightLevelX is obsolete -> use graphicControl instead ".
                           "attr graphicControl new key beamHeightlevel ",
  "1.54.6" => "29.07.2025  _graphicConsumerLegend: show surplus method and result in consumer legend hoover ",
  "1.54.5" => "24.07.2025  isAddSwitchOnCond/isAddSwitchOffCond: change debug info ",
  "1.54.4" => "22.07.2025  replace length by new sub strlength, Consumer attr new key 'aliasshort', change code of medianArray ".
                           "medianArray: can optional use newest 3..20 elements, avgArray: use the newest elements if num is set ".
                           "Debug consumerSwitching: print out info message of compare operation, remove attr graphicShowDiff ".
                           "store surpmeth calc result in key surpmethResult in Consumer master record, __readFileMessages: refactored code ".
                           "surpmeth: use average[_2..20] instead of numeric values 2.20 only ",
  "1.54.3" => "19.07.2025  ctrlDebug: add collectData_long ",
  "1.54.2" => "18.07.2025  _createSummaries: add debug infos ",
  "1.54.1" => "08.07.2025  userExit: new coding, __createReduceIcon: fix Wide character in syswrite - https://forum.fhem.de/index.php?msg=1344368 ".
                           "_setattrKeyVal: optimize function between execute from FHEMWEB and Commandline ".
                           "_beamGraphicFirstHour, _beamGraphicRemainingHours: decimal places according to the setting of the energy unit ".
                           "___switchConsumerOn: Switch on consumers even if they are not interruptible after state interrupted|interrupting|continuing ".
                           "increase MAXCONSUMER up to 20 ",
  "1.54.0" => "05.07.2025  edit commandref, ___areaFactorTrack: important bugfix in calc of direct area factor for DWD use ",
  "1.53.3" => "04.07.2025  Change of the correction factor calculation to the ratio of real production and the API raw forecast ",
  "1.53.2" => "03.07.2025  graphicControl->showDiff can be set separately for each level ".
                           "setupInverterDevXX: Check that there are no commas with spaces before and after (strings) ",
  "1.53.1" => "30.06.2025  add utf8 smileys, fix Perl warning uninitialized value \$color ",
  "1.53.0" => "28.06.2025  new battery style (batcontainer), new key setupBatteryDevXX->label, new reading Battery_ChargeUnrestricted_XX ".
                           "attribute graphicShowDiff replaced by graphicControl->showDiff ".
                           "check local coordinates are set in global device and fill message system if failure ".
                           "consumer Attr key noshow new possible value '9', _beamGraphic: scaleMode log double reduce Discount of z3 ".
                           "new key plantControl->reductionState, _calcDataEveryFullHour and subs: changeover aln to pvrlvd ".
                           "_getaiDecTree: reduce character size of aiRawData, set ... reset: pvCorrection deletes hidden readings too ",
  "1.52.18"=> "23.06.2025  ctrlSpecialReadings: new option conForecastComingNight, fix last hour of remainingSurplsHrsMinPwrBat_ ".
                           "some more minor fixes ",
  "1.52.17"=> "22.06.2025  remainingSurplsHrsMinPwrBat_: calculate with two decimal places ",
  "1.52.16"=> "21.06.2025  _genSpecialReadings: new option remainingSurplsHrsMinPwrBat_XX ",
  "1.52.15"=> "20.06.2025  ctrlBatSocManagementXX->loadAbort expanded by unlock condition ",
  "1.52.14"=> "18.06.2025  _beamGraphic: rework linear and logarithmic normalization of beam height ",
  "1.52.13"=> "17.06.2025  _genSpecialReadings: new option remainingHrsWoChargeRcmdBat_XX, edit comref ",
  "1.52.12"=> "15.06.2025  readCacheFile: option aitrained -> Code optimized for saving memory ".
                           "fillupMessageSystem: prevent Icon failore if SV contain spaces ".
                           "setupBatteryDevXX: 'dyn' -> Battery color can be dynamically set depending from SoC value ",
  "1.52.11"=> "03.06.2025  _genSpecialReadings: new option todayNotOwnerConsumption ",
  "1.52.10"=> "03.06.2025  attr plantControl->genPVforecastsToEvent new possible value 'adapt4fSteps' ",
  "1.52.9" => "02.06.2025  __getDWDSolarData: new sub azSolar2Astro, ctrlBatSocManagementXX: new key loadAbort ",
  "1.52.8" => "01.06.2025  _calcConsForecast_circular: use avgArray if number included days <= number of days in pvHistory ",
  "1.52.7" => "30.05.2025  _calcConsForecast_circular: excludes/includes only if number included days <= number of days in pvHistory ",
  "1.52.6" => "27.05.2025  verbose 3 for consumer switch log ",
  "1.52.5" => "25.05.2025  edit commandref, _batChargeMgmt: add load management time slot, ctrlBatSocManagementXX: new key lcSlot ".
                           "check attribute values for prohibited occurrence [...] Forum: https://forum.fhem.de/index.php?msg=1342147 ".
                           "_flowGraphic: bugfix chain style in case of logical on/off Forum: https://forum.fhem.de/index.php?msg=1342122 ".
                           "_attrBatteryDev: more checks (cap) ",
  "1.52.4" => "20.05.2025  commandref edited, setupInverterDevXX: change pv to pvOut, new key pvIn ".
                           "fix devision by zero -Forum: https://forum.fhem.de/index.php?msg=1341884, __calcFcQuality: minor code change ".
                           "ctrlSpecialReadings: new Topic BatWeightedTotalSOC ",
  "1.52.3" => "17.05.2025  _transferInverterValues: new property itype, graphicControl: new keys beamPaddingBottom, beamPaddingTop ".
                           " setter attrKeyVal has dorp down list of all composite attributes ",
  "1.52.2" => "14.05.2025  _flowGraphic: Discharge the battery directly into the household grid if no battery inverter is defined ".
                           "correction of inverter x-start, ".
                           "isConsumerLogOn: bugfix Threshold value detection if threshold value specification above 1% of power ",
  "1.52.1" => "13.05.2025  _flowGraphic: hide inverter node if only one PV inverter and no battery is used ",
  "1.52.0" => "11.05.2025  An inverter string must not be named 'none', setupInverterDevXX: 'strings=none' is added ".
                           "valInverter: add isource, new keys: ac2dc, dc2ac, _flowGraphic: add battery inverter type ".
                           "and extensive adjustments, new sub removeMinMaxArray, ___ownSpecGetFWwidget: bugfix with state-Reading ".
                           "flowGraphicControl: new key showGenerators, code cleaning ",
  "1.51.8" => "02.05.2025  _specialActivities: delete overhanging days at the change of month ".
                           "Bugfix: https://forum.fhem.de/index.php?msg=1340666 ",
  "1.51.7" => "01.05.2025  __createAdditionalEvents: optimized for SVG 'steps', new key plantControl->genPVforecastsToEvent ".
                           "aiAddRawData: add gcons, _listDataPoolCircular: add gcons_a ",
  "1.51.6" => "30.04.2025  graphicBeamXContent: change batsocforecast_XX to batsocCombi_XX, new options batsocForecast_XX, batsocReal_XX ".
                           "new Paramaeter socprogwhsum, socwhsum in pvHisory & NextHours ",
  "1.51.5" => "28.04.2025  attr transformed: graphicBeamWidth, graphicHourCount, graphicEnergyUnit, graphicSpaceSize ".
                           "graphicHeaderDetail, graphicHourStyle, graphicLayoutType ".
                           "graphicControl->beamWidth, graphicControl->hourCount, graphicControl->energyUnit, graphicControl->spaceSize ".
                           "graphicControl->headerDetail, graphicControl->hourStyle, graphicControl->layoutType ",
  "1.51.4" => "27.04.2025  avoid warnings uninitialized value \$FW_ME, \$FW_subdir in line 14434 ".
                           "bugfix in attr .*Control, fix 'ERROR deleting file' if no consumers are registered ".
                           "save batprogsocXX to pvHistory, prepared for new Attr graphicControl ",
  "1.51.3" => "22.04.2025  change battery text to 'load if above feed-in limit' ".
                           "transform set setupStringAzimuth, setupStringDeclination to attr setupStringAzimuth, setupStringDeclination ",
  "1.51.2" => "21.04.2025  Attributes obsolet: graphicHeaderShow replaced by graphicSelect, Value 'none' of consumerControl->showLegend deleted ",
  "1.51.1" => "20.04.2025  consumer: interruptable, swoncond, swoffcond, spignorecond can be perl code enclosed by {..} ".
                           "check key is valid in plantControl, aiControl, flowGraphicControl, consumerControl, setupMeterDev ".
                           "setupOtherProducer, setupInverterDev, setupBatteryDev, consumer ".
                           "writeCacheToFile: bugfix - cache File on OS is deleted if cache is empty ".
                           "new Setter attrKeyVal, graphicEnergyUnit: fix display of 'diff' ",
  "1.51.0" => "16.04.2025  obsolete Attr deleted: affectBatteryPreferredCharge, affectConsForecastInPlanning, ctrlShowLink, ctrlBackupFilesKeep ".
                           "affectConsForecastIdentWeekdays, affectConsForecastLastDays, ctrlInterval, ctrlGenPVdeviation ".
                           "affectSolCastPercentile, ctrlSolCastAPIoptimizeReq, consumerAdviceIcon, consumerLink, consumerLegend ",
  "1.50.4" => "16.04.2025  Consumer Strokes: fix val2pahColor, new key flowGraphicControl->strokeCmrRedColLimit ".
                           "__getopenMeteoData: fix get calclated call interval, new Setter cycleInterval ".
                           "normBeamWidth: decouple content batsocCombi_, energycosts, feedincome from the conversion Wh -> kWh ".
                           "___ownSpecGetFWwidget: textField-long -> textFieldNL-long ",
  "1.50.3" => "12.04.2025  __calcPVestimates: Fix missing limitation for strings if more than one string is assigned to an inverter ".
                           "code change in _attrInverterStrings, _attrStringPeak, checkPlantConfig: improved string check ",
  "1.50.2" => "11.04.2025  take inverter cap into account if no strings key is set, ctrlSpecialReadings: new option tomorrowConsumptionForecast ".
                           "plant check: print out module version in header, decouple graphicBeamHeightLevelX from each other ",
  "1.50.1" => "07.04.2025  new pvCorrectionFactor_Auto option 'on_complex_api_ai' to use average of AI + API forecast if AI Hit ".
                           "some code changes ",
  "1.50.0" => "05.04.2025  changes V 1.49.1 - 1.49.6 as new major release ",
  "1.49.6" => "05.04.2025  some code changes, _flowGraphic: position of home text element, new attr consumerControl->dummyIcon, _batChargeMgmt: change loading release ".
                           "attr consumerAdviceIcon replaced by consumerControl->adviceIcon ".
                           "attr consumerLegend replaced by consumerControl->showLegend ".
                           "attr consumerLink replaced by consumerControl->detailLink ",
  "1.49.5" => "29.03.2025  some code changes, Attr affectSolCastPercentile, ctrlSolCastAPIoptimizeReq are obsolete -> SolCast optimze requests is default now ".
                           "attr affectConsForecastIdentWeekdays replaced by plantControl->consForecastIdentWeekdays ".
                           "attr affectConsForecastLastDays replaced by plantControl->consForecastLastDays ".
                           "attr ctrlInterval replaced by plantControl->cycleInterval ".
                           "attr ctrlGenPVdeviation replaced by plantControl->genPVdeviation ".
                           "setupBatteryDevXX: new keys pinmax, poutmax ",
  "1.49.4" => "28.03.2025  _batChargeMgmt: revert Loading release changes of V 1.49.0, _transferAPIRadiationValues: fix sunalt for next day ".
                           "Home Node: Mouse over show Autarky Rate, flowGraphicControl: new key strokeconsumerdyncol ",
  "1.49.3" => "27.03.2025  flowGraphicControl: new key homenodedyncol ",
  "1.49.2" => "26.03.2025  ___enableSwitchByBatPrioCharge: fix usage of rusulting SOC of all batteries ",
  "1.49.1" => "25.03.2025  fix batteryPreferredCharge: https://forum.fhem.de/index.php?msg=1337802, Attr ctrlBackupFilesKeep is ".
                           "obsolete and replaced by plantControl->backupFilesKeep ",
  "1.49.0" => "23.03.2025  _listDataPoolApiData: fix warning item1, new option OpenMeteoDWD_D2-API with preparation for satellite support ".
                           "add Attr graphicBeamHeightLevel3, Compatibility of Rad1h data between DWD and OpenMeteo established ".
                           "set reset aiData deletes raw data also, _transferAPIRadiationValues: AI PV estimate limited to inverter capacity summary ".
                           "__calcPVestimates: pv power summary of all strings connected to inverter limited to inverter capacity summary ".
                           "_batChargeMgmt: fix calc if more than one batteries are installed, set aiDecTree: new option rawDataGHIreplace ".
                           "new Attr plantControl with keys feedinPowerLimit, batteryPreferredCharge, consForecastInPlanning ".
                           "Attr affectBatteryPreferredCharge, affectConsForecastInPlanning, ctrlShowLink are obsolete ",
  "1.48.0" => "14.03.2025  edit commandref, add graphicBeam layer 5 and 6, attr ctrlAIdataStorageDuration, ctrlAIshiftTrainStart removed ",
  "1.47.3" => "11.03.2025  adjust weather_ids and management of significant weather, _calcDataEveryFullHour: change attrInvChangedTs Management ".
                           "split __batteryOnBeam into _beamFillupBatValues and itself, expand bat key 'show' by top, bottom ".
                           "__getDWDSolarData: use always diffuse radiation as part of global radiation ",
  "1.47.2" => "09.03.2025  __getDWDSolarData: change calc when af == 0, aiAddInstance: add weatherid property ".
                           "overwrite wcc = 0 if wid = 0 -> give wid priority over wcc ",
  "1.47.1" => "07.03.2025  __substituteIcon: consider Tooltip content if ctrlBatSocManagementXX is set ",
  "1.47.0" => "05.03.2025  aiInit: change AI init sequence, use Random Forest with Ensemble algorithm, use Scalar::Util ".
                           "_beamGraphic.*: change decimal places für battery SoC, set aiDecTree: change addInstances to addInstAndTrain ".
                           "addInstAndTrain is generally executed non-blocking, _batChargeMgmt: use effective surplus for soc forecast, ".
                           "consider !ctrlBatSocManagement for permanent Bat loading release, _transferBatteryValues: change verbose 2 -> 3 ".
                           "new attr aiControl, attr ctrlAIdataStorageDuration, ctrlAIshiftTrainStart are obsolete ",
  "1.46.5" => "28.02.2025  new ctrlSpecialReadings  key todayConsumptionForecastDay ",
  "1.46.4" => "25.02.2025  _flowGraphic: fix clculation of node2home (Forum: https://forum.fhem.de/index.php?msg=1334798) ".
                           "_transferBatteryValues: change Debug Logging ",
  "1.46.3" => "22.02.2025  new sub getConsumerMintime, consumer key 'mintime' can handle a device/reading combination that deliver minutes ".
                           "reports violation of the continuity specification for battery in/out energy ",
  "1.46.2" => "19.02.2025  aiAddRawData: save original data and sort to bin in sub aiAddInstance instead, _calcConsForecast_circular: include epiecAVG ".
                           "fix NOTIFYDEV for consumers, change MAXINVERTER to 4 ",
  "1.46.1" => "18.02.2025  improve temp2bin, correct Log output to consumptionHistory, set setupStringDeclination can be free integer between 0..90 ",
  "1.46.0" => "17.02.2025  Notification System: print out last/next file pull if no messages are present, improvements and activation of ".
                           "_calcConsForecast_circular, checkPlantConfig: add Data Memory check pvHistory 'con' ".
                           "sunalt2bin/cloud2bin: classification of values improved, affectConsForecastLastDays: max to 180 ".
                           "set reset consumption to reset consumptionHistory, improve Debug Info ".
                           "fix error: https://forum.fhem.de/index.php?msg=1334123 ",
  "1.45.6" => "12.02.2025  Notification System: print out next planned file pull, timestringsFromOffset: allow +- offsets ".
                           "new sub _calcConsForecast_circular to prepare the evaluation of consumption days in pvCircular ",
  "1.45.5" => "09.02.2025  change constant GMFILEREPEAT, GMFILERANDOM, Pull Message File from GitHub Repo ",
  "1.45.4" => "08.02.2025  change constant GMFILEREPEAT + new constant GMFILERANDOM ",
  "1.45.3" => "06.02.2025  __readDataWeather: if no values of hour 01 (00:00+) use val of hour 24 of day before ".
                           "new special reading todayConsumption ",
  "1.45.2" => "05.02.2025  aiAddRawData: temp, con, wcc, rr1c, rad1h = undef if no value in pvhistory, fix isWeatherDevValid ".
                           "__readDataWeather(API): fix no values of hour 01 (00:00+), weather_ids: more weather entries ".
                           "change weather display management (don), some minor bugfixes ",
  "1.45.1" => "02.02.2025  _specialActivities: Task 1 __deleteEveryHourControls changed, all Tasks adapted ".
                           "_retrieveMessageFile: fix path in __updWriteFile, fix https://forum.fhem.de/index.php?msg=1332721 ",
  "1.45.0" => "01.02.2025  new function timestringsFromOffset, _batChargeMgmt: change condition for load release ".
                           "_addHourAiRawdata: add hour 24 (of day before), remove x-migrate -> auto migrate pv data ".
                           "Pool output width limited to 140 characters, checkPlantConfig: add installen Perl Modules check ",
  "1.44.5" => "30.01.2025  temp2bin: expand to more negative bins, bugfix: https://forum.fhem.de/index.php?msg=1332421 ".
                           "expand data collection dayname, con for AI support, Task 1: delete readings Error, Errorcode ",
  "1.44.4" => "26.01.2025  _getlistPVCircular: change width of output, new sub _listDataPoolPvHist, fix bug in hrepl Hash ".
                           "remove Attr graphicBeam1MaxVal,ctrlAreaFactorUsage ",
  "1.44.3" => "25.01.2025  Notification System: minor changes, special Readings todayBatInSum todayBatOutSum ",
  "1.44.2" => "23.01.2025  _batChargeMgmt: user storeffdef, show historical battery SoC when displaying the battery in the bar graph ",
  "1.44.1" => "20.01.2025  Notification system: minor fixes, integration of controls_solarforecast_messages_test/prod ".
                           "Define: random start of Timer subs, consumerXX: consumer device may have specified an own alias ",
  "1.44.0" => "19.01.2025  _listDataPoolCircular: may select a dedicated hour, add temporary Migrate funktion x_migrate ".
                           "fix interruptable key check in consumer attr Forum:https://forum.fhem.de/index.php?msg=1331073 ".
                           "set prdef to 1.0, Implementation of a Messaging System ",
  "1.43.6" => "17.01.2025  _calcCaQcomplex: additional write pvrl, pvfc to separate circular hash Array elements, listDataPool: show these Arrays ",
  "1.43.5" => "15.01.2025  _flowGraphic: calculate the resulting SoC as a cluster of batteries ",
  "1.43.4" => "14.01.2025  batsocslidereg: calculate the SoC as summary over all capacities in Wh, bugfix https://forum.fhem.de/index.php?msg=1330559 ",
  "1.43.3" => "13.01.2025  add Wiki icon in graphic header, _calcConsumptionForecast: switch calc from average to median, edit comref ",
  "1.43.2" => "12.01.2025  _batChargeMgmt: bugfix calc socwh, Attr graphicBeam1MaxVal, (experimental) ctrlAreaFactorUsage are obsolete ".
                           "trackFlex now default in DWD Model, replace title Charging recommendation by Charging release ".
                           "_saveEnergyConsumption: add dowrite flag, edit comref ",
  "1.43.1" => "11.01.2025  _batChargeMgmt: bugfix PV daily surplus update, _collectAllRegConsumers: fix interruptable hysteresis ".
                           "__batteryOnBeam: show soc forecast for hour 00 and fix english translation ".
                           "_batChargeMgmt: consider battery capacity as part of total capacity ",
  "1.43.0" => "10.01.2025  graphicShowNight: add possible Time Sync of chart bar level 1 and the other ".
                           "_addDynAttr: minor fix for graphicBeamXContent, new attr ctrlNextHoursSoCForecastReadings ",
  "1.42.0" => "07.01.2025  change socslidereg to batsocslidereg, _batChargeMgmt: add value to nexthours ".
                           "entryGraphic: enrich hfcg hash, __normDecPlaces: use it from/to battery, ".
                           "setupBatteryDevXX : new icon & show key, colour of icon can be changed separately, maxbatteries set to 3 ".
                           "medianArray: switch to simpel array sort, Task 1: delete Weather-API status data at night ".
                           "add SoC forecast to NextHours store, Battery bar chart: display of the device in the bar chart level 1 or 2 ".
                           "add batsocXX to pvHistory, add batsocCombi_XX to Attr graphicBeamXContent ".
                           " _addDynAttr: add graphicBeamXContent at runtime, attr ctrlBackupFilesKeep can set to 0 ",
  "1.41.4" => "02.01.2025  minor change of Logtext, new special Readings BatPowerIn_Sum, BatPowerOut_Sum ".
                           "rename ctrlStatisticReadings to ctrlSpecialReadings ",
  "1.41.3" => "01.01.2025  write/read battery values 0 .. maxbatteries to/from pvhistrory ".
                           "change ctrlBatSocManagement to ctrlBatSocManagement01 ",
  "0.1.0"  => "09.12.2020  initial Version "
);

## Standardvariablen
######################
my @da;                                                                             # zentraler temporärer Readings-Store
my @chours         = (5..21);                                                       # Stunden des Tages mit möglichen Korrekturwerten
my @widgetreadings = ();                                                            # Array der Hilfsreadings als Attributspeicher

my $root           = $attr{global}{modpath};                                        # Pfad zu dem Verzeichnis der FHEM Module
my $cachedir       = $root."/FHEM/FhemUtils";                                       # Directory für Cachefiles
my $pvhcache       = $root."/FHEM/FhemUtils/PVH_SolarForecast_";                    # Filename-Fragment für PV History (wird mit Devicename ergänzt)
my $pvccache       = $root."/FHEM/FhemUtils/PVC_SolarForecast_";                    # Filename-Fragment für PV Circular (wird mit Devicename ergänzt)
my $plantcfg       = $root."/FHEM/FhemUtils/PVCfg_SolarForecast_";                  # Filename-Fragment für PV Anlagenkonfiguration (wird mit Devicename ergänzt)
my $csmcache       = $root."/FHEM/FhemUtils/PVCsm_SolarForecast_";                  # Filename-Fragment für Consumer Status (wird mit Devicename ergänzt)
my $scpicache      = $root."/FHEM/FhemUtils/ScApi_SolarForecast_";                  # Filename-Fragment für Werte aus SolCast API (wird mit Devicename ergänzt)
my $statcache      = $root."/FHEM/FhemUtils/StatApi_SolarForecast_";                # Filename-Fragment für Status-API Werte (wird mit Devicename ergänzt)
my $weathercache   = $root."/FHEM/FhemUtils/WeatherApi_SolarForecast_";             # Filename-Fragment für Weather-API Werte (wird mit Devicename ergänzt)
my $aitrained      = $root."/FHEM/FhemUtils/AItra_SolarForecast_";                  # Filename-Fragment für AI Trainingsdaten (wird mit Devicename ergänzt)
my $airaw          = $root."/FHEM/FhemUtils/AIraw_SolarForecast_";                  # Filename-Fragment für AI Input Daten = Raw Trainigsdaten
my $dwdcatalog     = $root."/FHEM/FhemUtils/DWDcat_SolarForecast";                  # Filename für DWD Stationskatalog
my $dwdcatgpx      = $root."/FHEM/FhemUtils/DWDcat_SolarForecast.gpx";              # Export Filename für DWD Stationskatalog im gpx-Format
my $pvhexprtcsv    = $root."/FHEM/FhemUtils/PVH_Export_SolarForecast_";             # Filename-Fragment für PV History Exportfile (wird mit Devicename ergänzt)

my @dweattrmust    = qw(TTT Neff RR1c ww SunUp SunRise SunSet);                     # Werte die im Attr forecastProperties des Weather-DWD_Opendata Devices mindestens gesetzt sein müssen
my @draattrmust    = qw(Rad1h);                                                     # Werte die im Attr forecastProperties des Radiation-DWD_Opendata Devices mindestens gesetzt sein müssen
my @ctypes         = qw(dishwasher dryer washingmachine heater charger other
                        noSchedule);                                                # erlaubte Consumer Typen
                        

## Konstanten
######################
use constant {
  INFINITE       => ~0 >> 1,                                                        # "Unendlich"
  LPOOLLENLIM    => 140,                                                            # Breitenbegrenzung der Ausgabe von List Pooldaten
  KJ2KWH         => 0.0002777777778,                                                # Umrechnungsfaktor kJ in kWh
  KJ2WH          => 0.2777777778,                                                   # Umrechnungsfaktor kJ in Wh
  WH2KJ          => 3.6,                                                            # Umrechnungsfaktor Wh in kJ
  DEFLANG        => 'EN',                                                           # default Sprache wenn nicht konfiguriert
  INPUTSIZE      => 10,                                                             # default Breite eines Textfeldes in graphicHeaderOwnspec
  DEFMAXVAR      => 0.75,                                                           # max. Varianz pro Tagesberechnung Autokorrekturfaktor (geändert V.45.0 mit Median Verfahren)
  DEFINTERVAL    => 70,                                                             # Standard Abfrageintervall
  SLIDENUMMAX    => 3,                                                              # max. Anzahl der Arrayelemente in Schieberegistern
  SPLSLIDEMAX    => 20,                                                             # max. Anzahl der Arrayelemente in Schieberegister PV Überschuß und anderen
  CONDAYSLIDEMAX => 30,                                                             # max. Anzahl der Arrayelemente im Register pvCircular -> con_all / gcons_a -> <Tag>
  WHISTREPEAT    => 851,                                                            # Wiederholungsintervall Cache File Daten schreiben
  EPIECMAXCYCLES => 10,                                                             # Anzahl Einschaltzyklen (Consumer) für verbraucherspezifische Energiestück Ermittlung

  MAXWEATHERDEV  => 3,                                                              # max. Anzahl Wetter Devices (Attr setupWeatherDevX)
  MAXBATTERIES   => 3,                                                              # maximale Anzahl der möglichen Batterien
  MAXCONSUMER    => 20,                                                             # maximale Anzahl der möglichen Consumer (Attribut)
  MAXPRODUCER    => 3,                                                              # maximale Anzahl der möglichen anderen Produzenten (Attribut)
  MAXINVERTER    => 5,                                                              # maximale Anzahl der möglichen Inverter
  MAXBEAMLEVEL   => 3,                                                              # maximale Anzahl der Balkengrafik Ebenen 

  MAXSOCDEF      => 95,                                                             # default Wert (%) auf den die Batterie maximal aufgeladen werden soll bzw. als aufgeladen gilt
  CARECYCLEDEF   => 20,                                                             # default max. Anzahl Tage die zwischen der Batterieladung auf maxSoC liegen dürfen
  BATSOCCHGDAY   => 5,                                                              # Batterie: prozentuale SoC Anpassung pro Tag

  GMFBLTO        => 30,                                                             # Timeout Aholen Message File aus GIT
  GMFILEREPEAT   => 3600,                                                           # Base Wiederholungsuntervall Abholen Message File aus GIT
  GMFILERANDOM   => 10800,                                                          # Random AddOn zu GMFILEREPEAT
  IDXLIMIT       => 900000,                                                         # Notification System: Indexe > IDXLIMIT sind reserviert für Steuerungsaufgaben

  AINUMTREES     => 10,                                                             # Anzahl der Entscheidungsbäume im Ensemble
  AITRBLTO       => 7200,                                                           # KI Training BlockingCall Timeout
  AIBCTHHLD      => 0.2,                                                            # Schwelle der KI Trainigszeit ab der BlockingCall benutzt wird
  AITRSTARTDEF   => 2,                                                              # default Stunde f. Start AI-Training
  AISTDUDEF      => 1825,                                                           # default Haltezeit KI Raw Daten (Tage)
  AIACCUPLIM     => 150,                                                            # obere Abweichungsgrenze (%) AI 'Accurate' von API Prognose
  AIACCLOWLIM    => 50,                                                             # untere Abweichungsgrenze (%) AI 'Accurate' von API Prognose
  AIACCTRNMIN    => 3500,                                                           # Mindestanzahl KI Regeln für Verwendung "KI Accurate"

  MAXNEXTHOURS   => 71,                                                             # max. Anzahl Stunden der Wertebasis (Start mit 0 -> 72h) z.B. in Nexthours
  MAXNEXTDAYS    => 2,                                                              # max. Anzahl volle Tage in NextHours (Start mit 0 -> 3d)                                              
  DWDFCDAYSMIN   => 2,                                                              # Mindestwert Attr 'forecastDays' im DWD-Device
  SOLAPIREPDEF   => 3600,                                                           # default Abrufintervall SolCast API (s)
  FORAPIREPDEF   => 900,                                                            # default Abrufintervall ForecastSolar API (s)
  OMETEOREPDEF   => 900,                                                            # default Abrufintervall Open-Meteo API (s)
  VRMAPIREPDEF   => 300,                                                            # default Abrufintervall Victron VRM API Forecast
  SOLCMAXREQDEF  => 50,                                                             # max. täglich mögliche Requests SolCast API
  OMETMAXREQ     => 8000,                                                           # Beschränkung auf max. mögliche Requests Open-Meteo API
  LEADTIME       => 3600,                                                           # relative Zeit vor Sonnenaufgang zur Freigabe API Abruf / Verbraucherplanung
  LAGTIME        => 1800,                                                           # Nachlaufzeit relativ zu Sunset bis Sperrung API Abruf
  APITIMEOUT     => 30,                                                             # default Timeout HTTP API-Call
  
  PRDEF          => 0.9,                                                            # default Performance Ratio (PR)
  SFTYMARGIN_20  => 20,                                                             # Sicherheitszuschlag 20%
  SFTYMARGIN_50  => 50,                                                             # Sicherheitszuschlag 50%
  STOREFFDEF     => 87,                                                             # default Batterie Effizienz (https://www.energie-experten.org/erneuerbare-energien/photovoltaik/stromspeicher/wirkungsgrad)
  TEMPCOEFFDEF   => -0.45,                                                          # default Temperaturkoeffizient Pmpp (%/°C) lt. Datenblatt Solarzelle
  TEMPMODINC     => 25,                                                             # default Temperaturerhöhung an Solarzellen gegenüber Umgebungstemperatur bei wolkenlosem Himmel
  TEMPBASEDEF    => 25,                                                             # Temperatur Module bei Nominalleistung

  DEFMINTIME     => 60,                                                             # default Einplanungsdauer in Minuten
  CONSFCLDAYS    => 60,                                                             # die Stundenwerte der letzten CONSFCLDAYS Tage zur Kalkulation der Verbrauchvorhersage einbezogen
  DEFCTYPE       => 'other',                                                        # default Verbrauchertyp
  DEFCMODE       => 'can',                                                          # default Planungsmode der Verbraucher
  DEFPOPERCENT   => 1.0,                                                            # Standard % aktuelle Leistung an nominaler Leistung gemäß Typenschild
  DEFHYST        => 0,                                                              # default Hysterese

  CAICONDEF       => 'clock@gold',                                                  # default consumerAdviceIcon
  FLOWGSIZEDEF    => 400,                                                           # default flowGraphicSize
  HISTHOURDEF     => 2,                                                             # default Anzeige vorangegangene Stunden
  WTHCOLDDEF      => 'C7C979',                                                      # Wetter Icon Tag default Farbe
  WTHCOLNDEF      => 'C7C7C7',                                                      # Wetter Icon Nacht default Farbe
  BEAMWIDTH       => 20,                                                            # default Balkenbreite
  HOURCOUNT       => 24,                                                            # default Stundenbalken in Grafik
  SPACESIZE       => 24,                                                            # default Platz in px über oder unter den Balken
  BHEIGHTLEVEL    => 200,                                                           # default Multiplikator zur Festlegung der maximalen Balkenhöhe
  B1COLDEF        => 'FFAC63',                                                      # default Farbe Beam 1
  B1FONTCOLDEF    => '0D0D0D',                                                      # default Schriftfarbe Beam 1
  B2COLDEF        => 'C4C4A7',                                                      # default Farbe Beam 2
  B2FONTCOLDEF    => '000000',                                                      # default Schriftfarbe Beam 2
  B3COLDEF        => 'BED6C0',                                                      # default Farbe Beam 3
  B3FONTCOLDEF    => '000000',                                                      # default Schriftfarbe Beam 3
  B4COLDEF        => 'DBDBD0',                                                      # default Farbe Beam 4
  B4FONTCOLDEF    => '000000',                                                      # default Schriftfarbe Beam 4
  B5COLDEF        => 'A3C8FF',                                                      # default Farbe Beam 5
  B5FONTCOLDEF    => '000000',                                                      # default Schriftfarbe Beam 5
  B6COLDEF        => 'ABABAB',                                                      # default Farbe Beam 6
  B6FONTCOLDEF    => '000000',                                                      # default Schriftfarbe Beam 6
  FGCDDEF         => 130,                                                           # Abstand Verbrauchericons zueinander

  STROKCOLSTDDEF  => 'darkorange',                                                  # Flußgrafik: Standardfarbe aktive normale Kette
  STROKCOLSIGDEF  => 'red',                                                         # Flußgrafik: Standardfarbe aktive Signal-Kette
  STROKCOLINADEF  => 'gray',                                                        # Flußgrafik: Standardfarbe inaktive Kette
  STROKWIDTHDEF   => 25,                                                            # Flußgrafik: Standard Breite der Kette
  STROKCMRREDLIM  => 400,                                                           # Flußgrafik: Consumerpower ab der dynamische Laufkette rot gefärbt wird
  INPUTROWSHIFT   => 150,                                                           # Flußgrafik: Verschiebung bei Anzeige Solarzellen/Input-Zeile
  PRDCRROWSHIFT   => 100,                                                           # Flußgrafik: Verschiebung bei Anzeige Producer/Inverter-Zeile
  PRODICONDEF     => 'sani_garden_pump',                                            # default Producer-Icon
  GENICONDEF      => 'solar',                                                       # default Generator (z.B. Strings) Icon
  GENCOLACT       => 'darkorange',                                                  # default Generator-Icon aktiv Färbung
  GENCOLINACT     => 'grey',                                                        # default Generator-Icon inaktiv Färbung
  CICONDEF        => 'light_light_dim_100',                                         # default Consumer-Icon
  CICONCOLACT     => 'darkorange',                                                  # default Consumer-Icon aktiv Färbung
  CICONCOLINACT   => 'grey',                                                        # default Consumer-Icon inaktiv Färbung
  BICONDEF        => 'measure_battery_75',                                          # default Batterie-Icon
  BICCOLRCDDEF    => 'grey',                                                        # default Batterie-Icon Färbung bei Ladefreigabe und Inaktivität
  BICCOLNRCDDEF   => '#cccccc',                                                     # default Batterie-Icon Färbung bei fehlender Ladefreigabe
  BCHGICONCOLDEF  => 'darkorange',                                                  # default 'Aufladen' Batterie-Icon Färbung
  BDCHICONCOLDEF  => '#b32400',                                                     # default 'Entladen' Batterie-Icon Färbung
  HOMEICONDEF     => 'control_building_control@grey',                               # default Home-Icon
  NODEICONDEF     => 'virtualbox',                                                  # default Knoten-Icon
  INVICONDEF      => 'weather_sun',                                                 # default Inverter-icon
  MOONICONDEF     => 2,                                                             # default Mond-Phase (aus %hmoon)
  MOONCOLDEF      => 'lightblue',                                                   # default Mond Färbung
  ACTCOLDEF       => 'orange',                                                      # default Färbung Icon wenn aktiv
  ACTCOLINVBAT    => '#00e000',                                                     # default Färbung aktiver Batterie-Wechselrichter ohne Solarzellen
  INACTCOLDEF     => 'grey',                                                        # default Färbung Icon wenn inaktiv
  LOCALE_TIME     => setlocale (POSIX::LC_TIME),                                    # installierte locale abfragen

  BPATH           => 'https://svn.fhem.de/trac/browser/trunk/fhem/contrib/SolarForecast/',                 # Basispfad Abruf contrib SolarForecast Files
  PPATH           => '?format=txt',                                                                        # Download Format
  CFILE           => 'controls_solarforecast.txt',                                                         # Controlfile Update FTUI-Files
  BGHPATH         => 'https://raw.githubusercontent.com/nasseeder1/FHEM-SolarForecast/refs/heads/main/',   # Basispfad GitHub SolarForecast Files
  PGHPATH         => '',                                                                                   # GitHub Post Pfad
  MSGFILETEST     => 'controls_solarforecast_messages_test.txt',                                           # TEST Input-File Notification System
  MSGFILEPROD     => 'controls_solarforecast_messages_prod.txt',                                           # PRODUKTIVES Input-File Notification System
};

my $messagefile = MSGFILEPROD;
                                                                                    # mögliche Debug-Module
my @dd = qw( aiProcess
             aiData
             apiCall
             apiProcess
             batteryManagement
             collectData
             collectData_long
             consumerPlanning
             consumption
             consumption_long
             dwdComm
             epiecesCalc
             graphic
             notifyHandling
             pvCorrectionRead
             pvCorrectionWrite
             radiationProcess
             saveData2Cache
           );
                                                                                   # FTUI V2 Widget Files
my @fs = qw( ftui_forecast.css
             widget_forecast.js
             ftui_smaportalspg.css
             widget_smaportalspg.js
           );
                                                                                   # Grafik Selektionsoptionen
my @gsopt = qw ( both
                 both_noHead
                 both_noCons
                 both_noHead_noCons
                 swap
                 swap_noHead
                 swap_noCons
                 swap_noHead_noCons
                 flow
                 flow_noHead
                 flow_noCons
                 flow_noHead_noCons
                 forecast
                 forecast_noHead
                 forecast_noCons
                 forecast_noHead_noCons
                 none
               );
                                                                                 # Anlagenkonfiguration: maßgebliche Readings
my @rconfigs = qw( pvCorrectionFactor_Auto
                   batteryTrigger
                   powerTrigger
                   energyH4Trigger
                 );
                                                                                 # Anlagenkonfiguration: maßgebliche Attribute
my @aconfigs = qw( aiControl
                   consumerControl
                   graphicControl
                   flowGraphicControl
                   plantControl
                   ctrlConsRecommendReadings
                   ctrlLanguage
                   ctrlNextDayForecastReadings
                   ctrlNextHoursSoCForecastReadings
                   ctrlSolCastAPImaxReq
                   ctrlSpecialReadings
                   ctrlUserExitFn
                   disable
                   graphicHeaderOwnspec graphicHeaderOwnspecValForm
                   graphicHistoryHour
                   graphicSelect graphicShowNight graphicShowWeather
                   graphicWeatherColor graphicWeatherColorNight
                   setupMeterDev setupInverterStrings setupRadiationAPI setupStringPeak setupStringAzimuth setupStringDeclination
                   setupWeatherDev1 setupWeatherDev2 setupWeatherDev3
                   setupRoofTops
                 );

  for my $cn (1..MAXCONSUMER) {
      $cn = sprintf "%02d", $cn;
      push @aconfigs, "consumer${cn}";                            # Anlagenkonfiguration: add Consumer Attribute
      push @dd,       "consumerSwitching${cn}";                   # ctrlDebug: add specific Consumer
  }

  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;
      push @aconfigs, "setupBatteryDev${bn}";                     # Anlagenkonfiguration: add Battery Attribute
      push @aconfigs, "ctrlBatSocManagement${bn}";
  }

  for my $in (1..MAXINVERTER) {
      $in = sprintf "%02d", $in;
      push @aconfigs, "setupInverterDev${in}";                    # Anlagenkonfiguration: add Inverter Attribute
  }

  for my $pn (1..MAXPRODUCER) {
      $pn = sprintf "%02d", $pn;
      push @aconfigs, "setupOtherProducer${pn}";                  # Anlagenkonfiguration: add Producer Attribute
  }
  
  for my $bl (1..MAXBEAMLEVEL * 2) {                              # Beamgrafik-Attribute
      push @aconfigs, "graphicBeam${bl}Content";
      push @aconfigs, "graphicBeam${bl}Color";
      push @aconfigs, "graphicBeam${bl}FontColor";
  }

my $allwidgets = 'icon|sortable|uzsu|knob|noArg|time|text|slider|multiple|select|bitfield|widgetList|colorpicker';

## Steuerhashes
#########################

my %svicons = (                                                               # Schweregrad Icons Mitteilungssystem
  '0' => 'message_mail@grey',                                                 # Standard Mitteilungs-Icon 0 - keine Mitteilung
  '1' => 'message_mail_open@darkorange',                                      # Standard Mitteilungs-Icon 1 - Mitteilung
  '2' => 'message_attention@darkorange',                                      # Standard Mitteilungs-Icon 2 - Warnung
  '3' => 'message_attention@red',                                             # Standard Mitteilungs-Icon 3 - Fehler / Problem
);

my %intrptcatic = (                                                           # Unterbrechungscharakteristik 
  '0' => 'simple false',                                                          
  '1' => 'simple true',                                      
  '2' => 'Code return true',                                      
  '3' => 'Code return false',                                            
);

my %hset = (                                                                  # Hash der Set-Funktion
  consumerImmediatePlanning => { fn => \&_setconsumerImmediatePlanning },
  consumerNewPlanning       => { fn => \&_setconsumerNewPlanning       },
  clientAction              => { fn => \&_setclientAction              },
  cycleInterval             => { fn => \&_setcycleInterval             },
  attrKeyVal                => { fn => \&_setattrKeyVal                },
  energyH4Trigger           => { fn => \&_setTrigger                   },
  plantConfiguration        => { fn => \&_setplantConfiguration        },
  batteryTrigger            => { fn => \&_setTrigger                   },
  operationMode             => { fn => \&_setoperationMode             },
  powerTrigger              => { fn => \&_setTrigger                   },
  pvCorrectionFactor_05     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_06     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_07     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_08     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_09     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_10     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_11     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_12     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_13     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_14     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_15     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_16     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_17     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_18     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_19     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_20     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_21     => { fn => \&_setpvCorrectionFactor        },
  pvCorrectionFactor_Auto   => { fn => \&_setpvCorrectionFactorAuto    },
  reset                     => { fn => \&_setreset                     },
  roofIdentPair             => { fn => \&_setroofIdentPair             },
  operatingMemory           => { fn => \&_setoperatingMemory           },
  vrmCredentials            => { fn => \&_setVictronCredentials        },
  aiDecTree                 => { fn => \&_setaiDecTree                 },
);

my %hget = (                                                                      # Hash für Get-Funktion (needcred => 1: Funktion benötigt gesetzte Credentials)
  data               => { fn => \&_getdata,                     needcred => 0 },
  html               => { fn => \&_gethtml,                     needcred => 0 },
  ftui               => { fn => \&_getftui,                     needcred => 0 },
  valBattery         => { fn => \&_getlistvalBattery,           needcred => 0 },
  valCurrent         => { fn => \&_getlistCurrent,              needcred => 0 },
  valInverter        => { fn => \&_getlistvalInverter,          needcred => 0 },
  valProducer        => { fn => \&_getlistvalProducer,          needcred => 0 },
  valStrings         => { fn => \&_getlistvalStrings,           needcred => 0 },
  valConsumerMaster  => { fn => \&_getlistvalConsumerMaster,    needcred => 0 },
  plantConfigCheck   => { fn => \&_setplantConfiguration,       needcred => 0 },
  pvHistory          => { fn => \&_getlistPVHistory,            needcred => 0 },
  pvCircular         => { fn => \&_getlistPVCircular,           needcred => 0 },
  forecastQualities  => { fn => \&_getForecastQualities,        needcred => 0 },
  nextHours          => { fn => \&_getlistNextHours,            needcred => 0 },
  rooftopData        => { fn => \&_getRoofTopData,              needcred => 0 },
  radiationApiData   => { fn => \&_getlistRadiationApiData,     needcred => 0 },
  weatherApiData     => { fn => \&_getlistWeatherApiData,       needcred => 0 },
  statusApiData      => { fn => \&_getlistStatusApiData,        needcred => 0 },
  valDecTree         => { fn => \&_getaiDecTree,                needcred => 0 },
  ftuiFramefiles     => { fn => \&_ftuiFramefiles,              needcred => 0 },
  dwdCatalog         => { fn => \&_getdwdCatalog,               needcred => 0 },
  outputMessages     => { fn => \&_getoutputMessages,           needcred => 0 },
);

my %hattr = (                                                                # Hash für Attr-Funktion
  consumer                  => { fn => \&_attrconsumer            },
  consumerControl           => { fn => \&_attrconsumerControl     },
  ctrlConsRecommendReadings => { fn => \&_attrcreateConsRecRdgs   },
  ctrlSpecialReadings       => { fn => \&_attrcreateSpecialRdgs   },
  ctrlDebug                 => { fn => \&_attrctrlDebug           },
  setupWeatherDev1          => { fn => \&_attrWeatherDev          },
  setupWeatherDev2          => { fn => \&_attrWeatherDev          },
  setupWeatherDev3          => { fn => \&_attrWeatherDev          },
  setupMeterDev             => { fn => \&_attrMeterDev            },
  setupInverterStrings      => { fn => \&_attrInverterStrings     },
  setupRadiationAPI         => { fn => \&_attrRadiationAPI        },
  setupStringPeak           => { fn => \&_attrStringPeak          },
  setupStringAzimuth        => { fn => \&_attrstringAzimuth       },
  setupStringDeclination    => { fn => \&_attrstringDeclination   },
  setupRoofTops             => { fn => \&_attrRoofTops            },
  graphicControl            => { fn => \&_attrgraphicControl      },
  flowGraphicControl        => { fn => \&_attrflowGraphicControl  },
  aiControl                 => { fn => \&_attraiControl           },
  plantControl              => { fn => \&_attrplantControl        },
);

  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;
      $hattr{'setupBatteryDev'.$bn}{fn}      = \&_attrBatteryDev;
      $hattr{'ctrlBatSocManagement'.$bn}{fn} = \&_attrBatSocManagement;
  }

  for my $in (1..MAXINVERTER) {
      $in = sprintf "%02d", $in;
      $hattr{'setupInverterDev'.$in}{fn} = \&_attrInverterDev;
  }

  for my $prn (1..MAXPRODUCER) {
      $prn = sprintf "%02d", $prn;
      $hattr{'setupOtherProducer'.$prn}{fn} = \&_attrProducerDev;
  }

my $hcompoattr = {                                                           # Composit-Attribute
  aiControl              => '',
  consumerControl        => '',
  flowGraphicControl     => '',
  graphicControl         => '',
  plantControl           => '',
  setupMeterDev          => '',
  setupStringAzimuth     => '',
  setupStringDeclination => '',
  setupStringPeak        => '',
};
  
  for my $cn (1..MAXCONSUMER) {
      $cn = sprintf "%02d", $cn;
      $hcompoattr->{'consumer'.${cn}} = '';
  }

  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;
      $hcompoattr->{'setupBatteryDev'.${bn}} = '';
      $hcompoattr->{'ctrlBatSocManagement'.${bn}} = '';
  }

  for my $in (1..MAXINVERTER) {
      $in = sprintf "%02d", $in;
      $hcompoattr->{'setupInverterDev'.${in}} = '';
  }

  for my $pn (1..MAXPRODUCER) {
      $pn = sprintf "%02d", $pn;
      $hcompoattr->{'setupOtherProducer'.${pn}} = '';
  }

my @hcompoattrkeys = sort keys %{$hcompoattr};                               # Array der Schlüssel aller Composit-Attribute

my %htr = (                                                                  # Hash even/odd für <tr>
  0 => { cl => 'even' },
  1 => { cl => 'odd' },
);

                                                                             # Hash Mondphasen
my %hmoon = (
  0 => { icon => 'weather_moon_phases_1_new',  DE => 'Neumond',           EN => 'new moon'            },
  1 => { icon => 'weather_moon_phases_2',      DE => 'zunehmende Sichel', EN => 'increasing crescent' },
  2 => { icon => 'weather_moon_phases_3_half', DE => 'erstes Viertel',    EN => 'first quarter'       },
  3 => { icon => 'weather_moon_phases_4',      DE => 'zunehmender Mond',  EN => 'waxing moon'         },
  4 => { icon => 'weather_moon_phases_5_full', DE => 'Vollmond',          EN => 'full moon'           },
  5 => { icon => 'weather_moon_phases_6',      DE => 'abnehmender Mond',  EN => 'waning moon'         },
  6 => { icon => 'weather_moon_phases_7_half', DE => 'letztes Viertel',   EN => 'last quarter'        },
  7 => { icon => 'weather_moon_phases_8',      DE => 'abnehmende Sichel', EN => 'decreasing crescent' },
);

                                                                             # gekürzte Wochentagsnamen nach locale
my %habwdn = (
  '1' => { DE => 'Mo', EN => 'Mon' },
  '2' => { DE => 'Di', EN => 'Tue' },
  '3' => { DE => 'Mi', EN => 'Wed' },
  '4' => { DE => 'Do', EN => 'Thu' },
  '5' => { DE => 'Fr', EN => 'Fri' },
  '6' => { DE => 'Sa', EN => 'Sat' },
  '7' => { DE => 'So', EN => 'Sun' },
);

my %hrepl = (                                                                # Zeichenersetzungen
  '0'  => 'a',
  '1'  => 'b',
  '2'  => 'c',
  '3'  => 'd',
  '4'  => 'e',
  '5'  => 'f',
  '6'  => 'g',
  '7'  => 'h',
  '8'  => 'i',
  '9'  => 'j',
  '\.' => 'k',
);

my %hqtxt = (                                                                # Hash (Setup) Texte
  entry  => { EN => qq{<b>Warm welcome!</b><br>
                       The next queries will guide you through the basic installation.<br>
                       If all entries are made, please check the configuration finally with
                       "set LINK plantConfiguration check" or by pressing the offered icon.<br>
                       Please correct any errors and take note of possible hints.<br>
                       (The display language can be changed with attribute "ctrlLanguage".)<hr><br> },
              DE => qq{<b>Herzlich Willkommen!</b><br>
                       Die n&auml;chsten Abfragen f&uuml;hren sie durch die Grundinstallation.<br>
                       Sind alle Eingaben vorgenommen, pr&uuml;fen sie bitte die Konfiguration abschlie&szlig;end mit
                       "set LINK plantConfiguration check" oder mit Druck auf das angebotene Icon.<br>
                       Korrigieren sie bitte eventuelle Fehler und beachten sie m&ouml;gliche Hinweise.<br>
                       (Die Anzeigesprache kann mit dem Attribut "ctrlLanguage" umgestellt werden.)<hr><br>}                },
  cfd    => { EN => qq{Please enter at least one weather forecast device with "attr LINK setupWeatherDev1"},
              DE => qq{Bitte geben sie mindestens ein Wettervorhersage Device mit "attr LINK setupWeatherDev1" an}          },
  crd    => { EN => qq{Please select the radiation forecast service with "attr LINK setupRadiationAPI"},
              DE => qq{Bitte geben sie den Strahlungsvorhersage Dienst mit "attr LINK setupRadiationAPI" an}                },
  cid    => { EN => qq{Please specify the Inverter device with "attr LINK setupInverterDev01"},
              DE => qq{Bitte geben sie das Wechselrichter Device mit "attr LINK setupInverterDev01" an}                     },
  mid    => { EN => qq{Please specify the device for energy measurement with "attr LINK setupMeterDev"},
              DE => qq{Bitte geben sie das Device zur Energiemessung mit "attr LINK setupMeterDev" an}                      },
  ist    => { EN => qq{Please define all of your used string names with "attr LINK setupInverterStrings"},
              DE => qq{Bitte geben sie alle von Ihnen verwendeten Stringnamen mit "attr LINK setupInverterStrings" an}      },
  mps    => { EN => qq{Please enter the DC peak power of each string with "attr LINK setupStringPeak"},
              DE => qq{Bitte geben sie die DC Spitzenleistung von jedem String mit "attr LINK setupStringPeak" an}          },
  mdr    => { EN => qq{Please specify the module direction with "attr LINK setupStringAzimuth"},
              DE => qq{Bitte geben sie die Modulausrichtung mit "attr LINK setupStringAzimuth" an}                          },
  mta    => { EN => qq{Please specify the module tilt angle with "attr LINK setupStringDeclination"},
              DE => qq{Bitte geben sie den Modulneigungswinkel mit "attr LINK setupStringDeclination" an}                   },
  rip    => { EN => qq{Please specify at least one combination Rooftop-ID/SolCast-API with "set LINK roofIdentPair"},
              DE => qq{Bitte geben Sie mindestens eine Kombination Rooftop-ID/SolCast-API mit "set LINK roofIdentPair" an}  },
  mrt    => { EN => qq{Please set the assignment String / Rooftop identification with "attr LINK setupRoofTops"},
              DE => qq{Bitte setzen sie die Zuordnung String / Rooftop Identifikation mit "attr LINK setupRoofTops"}        },
  coord  => { EN => qq{Please set attributes 'latitude' and 'longitude' in global device},
              DE => qq{Bitte setzen sie die Attribute 'latitude' und 'longitude' im global Device}                          },
  cnsm   => { EN => qq{Consumer},
              DE => qq{Verbraucher}                                                                                         },
  eiau   => { EN => qq{Off/On},
              DE => qq{Aus/Ein}                                                                                             },
  auto   => { EN => qq{Auto},
              DE => qq{Auto}                                                                                                },
  lupt   => { EN => qq{last&nbsp;update:},
              DE => qq{Stand:}                                                                                              },
  object => { EN => qq{Object},
              DE => qq{Pr&uuml;fobjekt}                                                                                     },
  swonnm => { EN => qq{swoncond not met},
              DE => qq{swoncond nicht erfüllt}                                                                              },
  swonmt => { EN => qq{swoncond met},
              DE => qq{swoncond erfüllt}                                                                                    },
  swofmt => { EN => qq{swoffcond met},
              DE => qq{swoffcond erfüllt}                                                                                   },
  emsple => { EN => qq{max surplus forecast too low},
              DE => qq{max Überschußprognose zu gering}                                                                     },
  nmspld => { EN => qq{no max surplus found for current day},
              DE => qq{kein max Überschuss für den aktuellen Tag gefunden}                                                  },
  state  => { EN => qq{Status},
              DE => qq{Status}                                                                                              },
  result => { EN => qq{Result},
              DE => qq{Ergebnis}                                                                                            },
  attrib => { EN => qq{attribute},
              DE => qq{Attribut}                                                                                            },
  note   => { EN => qq{Note},
              DE => qq{Hinweis}                                                                                             },
  dwdcat => { EN => qq{The Deutscher Wetterdienst Station Catalog},
              DE => qq{Der Stationskatalog des Deutschen Wetterdienstes}                                                    },
  nrsele => { EN => qq{No. selected entries:},
              DE => qq{Anzahl ausgewählter Einträge:}                                                                       },
  wfmdcf => { EN => qq{Wait for more days with a consumption figure},
              DE => qq{Warte auf weitere Tage mit einer Verbrauchszahl}                                                     },
  autoct => { EN => qq{Autocorrection:},
              DE => qq{Autokorrektur:}                                                                                      },
  plrdct => { EN => qq{Reduction:},
              DE => qq{Abregelung:}                                                                                         },
  plntck => { EN => qq{Plant Configurationcheck Information},
              DE => qq{Informationen zur Anlagenkonfigurationspr&uuml;fung}                                                 },
  lbpcq  => { EN => qq{Quality:},
              DE => qq{Qualit&auml;t:}                                                                                      },
  lblPvh => { EN => qq{next&nbsp;4h:},
              DE => qq{n&auml;chste&nbsp;4h:}                                                                               },
  lblPRe => { EN => qq{rest&nbsp;today:},
              DE => qq{Rest&nbsp;heute:}                                                                                    },
  lblPTo => { EN => qq{tomorrow:},
              DE => qq{morgen:}                                                                                             },
  lblPCu => { EN => qq{currently:},
              DE => qq{aktuell:}                                                                                            },
  bnsas  => { EN => qq{from <WT> minutes before the upcoming sunrise},
              DE => qq{ab <WT> Minuten vor dem kommenden Sonnenaufgang}                                                     },
  dvtn   => { EN => qq{Deviation},
              DE => qq{Abweichung}                                                                                          },
  pvgen  => { EN => qq{Generation},
              DE => qq{Erzeugung}                                                                                           },
  conspt => { EN => qq{Consumption},
              DE => qq{Verbrauch}                                                                                           },
  tday   => { EN => qq{today},
              DE => qq{heute}                                                                                               },
  simsg  => { EN => qq{Message},
              DE => qq{Mitteilung}                                                                                          },
  msgsys => { EN => qq{Notification system},
              DE => qq{Mitteilungssystem}                                                                                   },
  msgimp => { EN => qq{Importance},
              DE => qq{Wichtigkeit}                                                                                         },
  number => { EN => qq{Number},
              DE => qq{Nummer}                                                                                              },
  impcha => { EN => qq{Input channels},
              DE => qq{Eingangskan&auml;le}                                                                                 },
  scedld => { EN => qq{scheduled},
              DE => qq{geplant}                                                                                             },
  ctnsly => { EN => qq{continuously},
              DE => qq{fortlaufend}                                                                                         },
  yday   => { EN => qq{yesterday},
              DE => qq{gestern}                                                                                             },
  after  => { EN => qq{after},
              DE => qq{nach}                                                                                                },
  aihtxt => { EN => qq{AI state:},
              DE => qq{KI Status:}                                                                                          },
  aimmts => { EN => qq{Perl module Test2::Suite is missing},
              DE => qq{Perl Modul Test2::Suite ist nicht vorhanden}                                                         },
  aiwook => { EN => qq{AI support works properly, but does not provide a value for the current hour},
              DE => qq{KI Unterst&uuml;tzung arbeitet einwandfrei, liefert jedoch keinen Wert f&uuml;r die aktuelle Stunde} },
  aiwhit => { EN => qq{the PV forecast value for the current hour is provided by the AI support},
              DE => qq{der PV Vorhersagewert f&uuml;r die aktuelle Stunde wird von der KI Unterst&uuml;tzung geliefert}     },
  ailatr => { EN => qq{last AI training:},
              DE => qq{letztes KI-Training:}                                                                                },
  ailgrt => { EN => qq{last AI result generation time:},
              DE => qq{letzte KI-Ergebnis Generierungsdauer:}                                                               },
  aitris => { EN => qq{Runtime in seconds:},
              DE => qq{Laufzeit in Sekunden:}                                                                               },
  airule => { EN => qq{List of strings that describe the tree in rule-form},
              DE => qq{Liste von Zeichenfolgen, die den Baum in Form von Regeln beschreiben}                                },
  ainode => { EN => qq{Number of nodes in the trained decision tree},
              DE => qq{Anzahl der Knoten im trainierten Entscheidungsbaum}                                                  },
  aidept => { EN => qq{Maximum number of decisions that would need to be made a classification},
              DE => qq{Maximale Anzahl von Entscheidungen, die f&uuml;r eine Klassifizierung getroffen werden m&uuml;ssen}  },
  nxtscc => { EN => qq{next SolCast call},
              DE => qq{n&auml;chste SolCast Abfrage}                                                                        },
  fulfd  => { EN => qq{fulfilled},
              DE => qq{erf&uuml;llt}                                                                                        },
  widnin => { EN => qq{FHEM Tablet UI V2 is not installed.},
              DE => qq{FHEM Tablet UI V2 ist nicht installiert.}                                                            },
  widok  => { EN => qq{The FHEM Tablet UI widget Files are up to date.},
              DE => qq{Die FHEM Tablet UI Widget-Dateien sind aktuell.}                                                     },
  widnup => { EN => qq{The SolarForecast FHEM Tablet UI widget files are not up to date.},
              DE => qq{Die FHEM Tablet UI Widget-Dateien sind nicht aktuell.}                                               },
  widerr => { EN => qq{The FHEM Tablet UI V2 is installed but the update status of widget Files can't be checked.},
              DE => qq{FTUI V2 ist installiert, der Aktualisierungsstatus der Widgets kann nicht gepr&uuml;ft werden.}      },
  pmtp   => { EN => qq{produced more than predicted &#128515;},
              DE => qq{mehr produziert als vorhergesagt &#128515;}                                                          },
  petp   => { EN => qq{produced same as predicted &#128522;},
              DE => qq{produziert wie vorhergesagt &#128522;}                                                               },
  pltp   => { EN => qq{produced less than predicted &#128531;},
              DE => qq{weniger produziert als vorhergesagt &#128531;}                                                       },
  wusond => { EN => qq{waiting for data ...},
              DE => qq{warte auf Daten ...}                                                                                 },
  snbefb => { EN => qq{the data will be available tomorrow},
              DE => qq{die Daten werden morgen verf&uuml;gbar sein}                                                         },
  scnp   => { EN => qq{Scheduling of the consumer is not provided},
              DE => qq{Die Einplanung des Verbrauchers ist nicht vorgesehen}                                                },
  vrmcr  => { EN => qq{Please set the Victron VRM Portal credentials with "set LINK vrmCredentials".},
              DE => qq{Bitte setzen sie die Victron VRM Portal Zugangsdaten mit "set LINK vrmCredentials". }                },
  awd    => { EN => qq{LINK is waiting for solar forecast data ... <br>},
              DE => qq{LINK wartet auf Solarvorhersagedaten ... <br>}                                                       },
  wexso  => { EN => qq{switched externally},
              DE => qq{von extern umgeschaltet}                                                                             },
  legimp => { EN => qq{Legend Importance: 1 - general Message, 2 - important Message, 3 - Error or Problem},
              DE => qq{Legende Wichtigkeit: 1 - allgemeine Mitteilung, 2 - wichtige Mitteilung, 3 - Fehler oder Problem}    },
  strok  => { EN => qq{Congratulations &#128522;, the system configuration is error-free. Please note any information (<I>).},
              DE => qq{Herzlichen Glückwunsch &#128522;, die Anlagenkonfiguration ist fehlerfrei. Bitte eventuelle Hinweise (<I>) beachten.}                                                 },
  strwn  => { EN => qq{Looks quite good &#128528;, the system configuration is basically OK. Please note the warnings (<W>).},
              DE => qq{Sieht ganz gut aus &#128528;, die Anlagenkonfiguration ist prinzipiell in Ordnung. Bitte beachte die Warnungen (<W>).}                                                },
  strnok => { EN => qq{Oh no &#128577;, the system configuration is incorrect. Please check the settings and notes!},
              DE => qq{Oh nein &#128546;, die Anlagenkonfiguration ist fehlerhaft. Bitte überprüfen Sie die Einstellungen und Hinweise!}                                                     },
  pstate => { EN => qq{Planning&nbsp;status:&nbsp;<pstate><br>Info:&nbsp;<supplmnt><br>Mode:&nbsp;<mode><br>On:&nbsp;<start><br>Off:&nbsp;<stop><br>Remaining lock time:&nbsp;<RLT> seconds},
              DE => qq{Planungsstatus:&nbsp;<pstate><br>Info:&nbsp;<supplmnt><br>Modus:&nbsp;<mode><br>Ein:&nbsp;<start><br>Aus:&nbsp;<stop><br>verbleibende Sperrzeit:&nbsp;<RLT> Sekunden} },
  dmgsig => { EN => qq{Read messages are not signaled again until a FHEM restart, but are retained if they are relevant.},
              DE => qq{Gelesene Mitteilungen werden bis zu einem FHEM Neustart nicht wieder signalisiert, bleiben bei Relevanz jedoch erhalten.}                                             },
);

my %htitles = (                                                                                                 # Hash Hilfetexte (Mouse Over)
  iaaf     => { EN => qq{Automatic mode off -> Enable automatic mode},
                DE => qq{Automatikmodus aus -> Automatik freigeben}                                                },
  ieas     => { EN => qq{Automatic mode on -> Lock automatic mode},
                DE => qq{Automatikmodus ein -> Automatik sperren}                                                  },
  iave     => { EN => qq{Off -> Switch on consumer},
                DE => qq{Aus -> Verbraucher einschalten}                                                           },
  ians     => { EN => qq{Off -> no on-command defined!},
                DE => qq{Aus -> kein on-Kommando definiert!}                                                       },
  ieva     => { EN => qq{On -> Switch off consumer},
                DE => qq{Ein -> Verbraucher ausschalten}                                                           },
  iens     => { EN => qq{On -> no off-command defined!},
                DE => qq{Ein -> kein off-Kommando definiert!}                                                      },
  natc     => { EN => qq{automatic cycle:},
                DE => qq{automatischer Zyklus:}                                                                    },
  predtime => { EN => qq{Prediction time Radiation data:},
                DE => qq{Vorhersagezeitpunkt Strahlungsdaten:}                                                     },
  dwdtime  => { EN => qq{Forecast time Weather data},
                DE => qq{Vorhersagezeitpunkt Wetterdaten}                                                          },
  upd      => { EN => qq{Click for update},
                DE => qq{Klick f&#252;r Update}                                                                    },
  on       => { EN => qq{switched on},
                DE => qq{eingeschaltet}                                                                            },
  off      => { EN => qq{switched off},
                DE => qq{ausgeschaltet}                                                                            },
  undef    => { EN => qq{undefined},
                DE => qq{undefiniert}                                                                              },
  ischawth => { EN => qq{is charged with},
                DE => qq{wird aufgeladen mit}                                                                      },
  isdchawt => { EN => qq{is discharged with},
                DE => qq{wird entladen mit}                                                                        },
  dela     => { EN => qq{delayed},
                DE => qq{verzoegert}                                                                               },
  autarky  => { EN => qq{Autarky rate},
                DE => qq{Autarkierate}                                                                             },
  azimuth  => { EN => qq{Azimuth},
                DE => qq{Azimut}                                                                                   },
  elevatio => { EN => qq{Elevation},
                DE => qq{H&#246;he}                                                                                },
  sunpos   => { EN => qq{Sun position (decimal degrees)},
                DE => qq{Sonnenstand (Dezimalgrad)}                                                                },
  enconsrl => { EN => qq{real Energy consumption},
                DE => qq{realer Energieverbrauch}                                                                  },
  enconsfc => { EN => qq{forecasted energy consumption},
                DE => qq{prognostizierter Energieverbrauch}                                                        },
  enpchcst => { EN => qq{Energy purchase costs},
                DE => qq{Kosten Energiebezug}                                                                      },
  rengfeed => { EN => qq{Remuneration for the grid feed-in},
                DE => qq{Verg&#252;tung Netzeinspeisung}                                                           },
  enppubgd => { EN => qq{Energy purchase from the public grid},
                DE => qq{Energiebezug aus dem &#246;ffentlichen Netz}                                              },
  enfeedgd => { EN => qq{Feed-in},
                DE => qq{Einspeisung}                                                                              },
  pvgenerl => { EN => qq{real PV generation},
                DE => qq{reale PV-Erzeugung}                                                                       },
  pvgenefc => { EN => qq{forecasted PV generation},
                DE => qq{prognostizierte PV-Erzeugung}                                                             },
  onlybatw => { EN => qq{Battery},
                DE => qq{Batterie}                                                                                 },
  simplyes => { EN => qq{yes},
                DE => qq{ja}                                                                                       },
  simpleno => { EN => qq{no},
                DE => qq{nein}                                                                                     },
  socrfcba => { EN => qq{real battery charge achieved or SoC forecast Battery},
                DE => qq{real erreichte Batterieladung bzw. SoC Prognose Batterie}                                 },
  socfcbat => { EN => qq{SoC forecast Battery},
                DE => qq{SoC Prognose Batterie}                                                                    },
  socfcsum => { EN => qq{SoC forecast (%) summarized across all batteries},
                DE => qq{SoC Prognose (%) zusammengefasst &#252;ber alle Batterien}                                },
  socrebat => { EN => qq{real achieved charge Battery},
                DE => qq{real erreichte Ladung Batterie}                                                           },
  socresum => { EN => qq{real SoC achieved (%) summarized across all batteries},
                DE => qq{real errreichter SoC (%) zusammengefasst &#252;ber alle Batterien}                        },
  socbacur => { EN => qq{SoC current},
                DE => qq{SoC aktuell}                                                                              },
  socbatfc => { EN => qq{SoC forecast},
                DE => qq{SoC Prognose}                                                                             },
  socbaths => { EN => qq{SoC at the end of the hour},
                DE => qq{SoC am Ende der Stunde}                                                                   },
  lcenable => { EN => qq{Charge management enabled},
                DE => qq{Lademanagement aktiviert}                                                                 },
  ldstratg => { EN => qq{Loading strategy},
                DE => qq{Ladestrategie}                                                                            },
  ldreleas => { EN => qq{load release},
                DE => qq{Ladefreigabe}                                                                             }, 
  optchpow => { EN => qq{optimized charging power},
                DE => qq{optimierte Ladeleistung}                                                                  },
  smtchpow => { EN => qq{Target-optimized charging power},
                DE => qq{zieloptimierte Ladeleistung}                                                              },                
  bcharrel => { EN => qq{Charging release (activate release for charging the battery if necessary)},
                DE => qq{Ladefreigabe (evtl. Freigabe zum Laden der Batterie aktivieren)}                          },
  bncharel => { EN => qq{only charge if the feed-in limit is exceeded},
                DE => qq{nur laden wenn Einspeiselimit &#252;berschritten}                                         },
  conrec   => { EN => qq{Current time is within the consumption planning},
                DE => qq{Aktuelle Zeit liegt innerhalb der Verbrauchsplanung}                                      },
  conrecba => { EN => qq{Current time is within the consumption planning, Priority charging Battery is active},
                DE => qq{Aktuelle Zeit liegt innerhalb der Verbrauchsplanung, Vorrangladen Batterie ist aktiv}     },
  connorec => { EN => qq{Consumption planning is outside current time\n(Click for immediate planning)},
                DE => qq{Verbrauchsplanung liegt ausserhalb aktueller Zeit\n(Klick f&#252;r sofortige Einplanung)} },
  akorron  => { EN => qq{switched off\nenable auto correction with:\nset <NAME> pvCorrectionFactor_Auto on*},
                DE => qq{ausgeschaltet\nAutokorrektur einschalten mit:\nset <NAME> pvCorrectionFactor_Auto on*}    },
  splus    => { EN => qq{PV surplus sufficient},
                DE => qq{PV-&#220;berschu&#223; ausreichend}                                                       },
  nosplus  => { EN => qq{PV surplus insufficient},
                DE => qq{PV-&#220;berschu&#223; unzureichend}                                                      },
  plchk    => { EN => qq{Configuration check of the plant},
                DE => qq{Konfigurationspr&#252;fung der Anlage}                                                    },
  jtsfft   => { EN => qq{Open the SolarForecast Forum},
                DE => qq{&#214;ffne das SolarForecast Forum}                                                       },
  opwiki   => { EN => qq{Open the Wiki (German language)},
                DE => qq{&#214;ffne das Wiki}                                                                      },
  outpmsg  => { EN => qq{Messages are available - press the button to open them},
                DE => qq{Mitteilungen sind vorhanden - dr&#252;cke die Taste um sie zu &#246;ffnen}                },
  nomsgfo  => { EN => qq{there are no new messages},
                DE => qq{es sind keine neuen Mitteilungen vorhanden}                                               },
  lstmsgc  => { EN => qq{last message call},
                DE => qq{letzter Mitteilungsabruf}                                                                 },
  nxtmsgc  => { EN => qq{next message call},
                DE => qq{n&auml;chster Mitteilungsabruf}                                                           },
  scaresps => { EN => qq{API request successful},
                DE => qq{API Abfrage erfolgreich}                                                                  },
  dwfcrsu  => { EN => qq{Weather data are up to date according to used DWD model},
                DE => qq{Wetterdaten sind aktuell entsprechend des verwendeten DWD Modell}                         },
  scarespf => { EN => qq{API request failed},
                DE => qq{API Abfrage fehlgeschlagen}                                                               },
  dapic    => { EN => qq{API requests or request equivalents already carried out today},
                DE => qq{Heute bereits durchgef&#252;hrte API-Anfragen bzw. Anfragen-&#196;quivalente}             },
  rapic    => { EN => qq{remaining API requests},
                DE => qq{verf&#252;gbare API-Anfragen}                                                             },
  yheyfdl  => { EN => qq{You have exceeded your free daily limit!},
                DE => qq{Sie haben Ihr kostenloses Tageslimit &#252;berschritten!}                                 },
  rlfaccpr => { EN => qq{Rate limit for API requests reached in current period!},
                DE => qq{Abfragegrenze f&#252;r API-Anfragen im aktuellen Zeitraums erreicht!}                     },
  raricp   => { EN => qq{remaining API requests in the current period},
                DE => qq{verf&#252;gbare API-Anfragen der laufenden Periode}                                       },
  scakdne  => { EN => qq{API key does not exist},
                DE => qq{API Schl&#252;ssel existiert nicht}                                                       },
  scrsdne  => { EN => qq{Rooftop site does not exist or is not accessible},
                DE => qq{Rooftop ID existiert nicht oder ist nicht abrufbar}                                       },
  norate   => { EN => qq{not rated},
                DE => qq{nicht bewertet}                                                                           },
  aimstt   => { EN => qq{Perl module AI::DecisionTree is missing},
                DE => qq{Perl Modul AI::DecisionTree ist nicht vorhanden}                                          },
  dumtxt   => { EN => qq{unassignable consumption (takes into account any hidden consumers)},
                DE => qq{nicht zuordenbarer Verbrauch (ber&#252;cksichtigt evtl. versteckte Verbraucher)}          },
  rdcactiv => { EN => qq{Plant derating active},
                DE => qq{Anlagenabregelung aktiv}                                                                  },
  rdcnoact => { EN => qq{no Plant derating},
                DE => qq{keine Anlagenabregelung}                                                                  },
  pstate   => { EN => qq{Planning&nbsp;status:&nbsp;<pstate>\nInfo:&nbsp;<supplmnt>\n\nMode:&nbsp;<mode>\nOn:&nbsp;<start>\nOff:&nbsp;<stop>\nRemaining lock time:&nbsp;<RLT> seconds},
                DE => qq{Planungsstatus:&nbsp;<pstate>\nInfo:&nbsp;<supplmnt>\n\nModus:&nbsp;<mode>\nEin:&nbsp;<start>\nAus:&nbsp;<stop>\nverbleibende Sperrzeit:&nbsp;<RLT> Sekunden}  },
  ainuse   => { EN => qq{AI Perl module is installed, but the AI support is not used.\nRun 'set <NAME> plantConfiguration check' for hints.},
                DE => qq{KI Perl Modul ist installiert, aber die KI Unterst&uuml;tzung wird nicht verwendet.\nPr&uuml;fen sie 'set <NAME> plantConfiguration check' f&uuml;r Hinweise.} },
  arsrad2o => { EN => qq{API query successful but the radiation values are outdated.\nCheck the plant with 'set <NAME> plantConfiguration check'.},
                DE => qq{API Abfrage erfolgreich aber die Strahlungswerte sind veraltet.\nPr&uuml;fen sie die Anlage mit 'set <NAME> plantConfiguration check'.}                        },
  aswfc2o  => { EN => qq{The weather data is outdated.\nCheck the plant with 'set <NAME> plantConfiguration check'.},
                DE => qq{Die Wetterdaten sind veraltet.\nPr&uuml;fen sie die Anlage mit 'set <NAME> plantConfiguration check'.}                                                         },
  rdcstat  => { EN => qq{no reduction status available\nPlease set the key 'reductionState' with 'attr <NAME> plantControl'},
                DE => qq{kein Abregelungsstatus verf&uuml;gbar\nSetzen sie bitte den Schl&uuml;ssel 'reductionState' mit 'attr <NAME> plantControl'}                                    },
);

# Wetterintertretation
# https://www.dwd.de/DE/forschung/wettervorhersage/num_modellierung/01_num_vorhersagemodelle/01c_wetterinterpretation/wetter_interpretation.pdf?__blob=publicationFile&v=7
#
# Falls keiner ww-Schlüssel >= 45 eintritt, wird das Wetter als nicht signifikant eingestuft. An
# Gitterpunkten ohne signifikantes Wetter wird der Gesamtbedeckungsgrad, verschlüsselt
#
# Wenn ferner keine der zuvor genannten Nebelbedingungen erfüllt ist, wird lediglich der
# Gesamtbedeckungsgrad verschlüsselt.
#  0.00 % -   6.25 % dann ww=0,
#  6.25 % -  43.75 % dann ww=1,
# 43.75 % -  81.25 % dann ww=2,
# 81.25 % - 100.00 % dann ww=3,
#
# ww = 00 wolkenlos
# ww = 01 leicht bewölkt
# ww = 02 wolkig
# ww = 03 stark bewölkt bis bedeckt
#################################################
my %weather_ids = (
  '0'   => { s => '0', icon => 'weather_sun',                       txtd => 'wolkenloser Himmel',                                                       txte => 'cloudless sky'                                                              },
  '1'   => { s => '0', icon => 'weather_cloudy_light',              txtd => 'leicht bewölkt',                                                           txte => 'slightly cloudy'                                                            },
  '2'   => { s => '0', icon => 'weather_cloudy',                    txtd => 'wolkig',                                                                   txte => 'cloudy'                                                                     },
  '3'   => { s => '0', icon => 'weather_cloudy_heavy',              txtd => 'stark bewölkt bis bedeckt',                                                txte => 'very cloudy to overcast'                                                    },
  '4'   => { s => '0', icon => 'unknown',                           txtd => 'Sicht durch Rauch oder Asche vermindert',                                  txte => 'Visibility reduced by smoke or ash'                                         },
  '5'   => { s => '0', icon => 'unknown',                           txtd => 'trockener Dunst (relative Feuchte < 80 %)',                                txte => 'dry haze (relative humidity < 80 %)'                                        },
  '6'   => { s => '0', icon => 'unknown',                           txtd => 'verbreiteter Schwebstaub, nicht vom Wind herangeführt',                    txte => 'widespread airborne dust, not brought in by the wind'                       },
  '7'   => { s => '0', icon => 'unknown',                           txtd => 'Staub oder Sand bzw. Gischt, vom Wind herangeführt',                       txte => 'Dust or sand or spray, brought in by the wind'                              },
  '8'   => { s => '0', icon => 'unknown',                           txtd => 'gut entwickelte Staub- oder Sandwirbel',                                   txte => 'well-developed dust or sand vortex'                                         },
  '9'   => { s => '0', icon => 'unknown',                           txtd => 'Staub- oder Sandsturm im Gesichtskreis, aber nicht an der Station',        txte => 'Dust or sand storm in the visual circle, but not at the station'            },

  '10'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel',                                                                    txte => 'Fog'                                                                        },
  '11'  => { s => '0', icon => 'weather_rain_fog',                  txtd => 'Nebel mit Regen',                                                          txte => 'Fog with rain'                                                              },
  '12'  => { s => '0', icon => 'weather_fog',                       txtd => 'durchgehender Bodennebel',                                                 txte => 'continuous ground fog'                                                      },
  '13'  => { s => '0', icon => 'unknown',                           txtd => 'Wetterleuchten sichtbar, kein Donner gehört',                              txte => 'Weather light visible, no thunder heard'                                    },
  '14'  => { s => '0', icon => 'unknown',                           txtd => 'Niederschlag im Gesichtskreis, nicht den Boden erreichend',                txte => 'Precipitation in the visual circle, not reaching the ground'                },
  '15'  => { s => '0', icon => 'unknown',                           txtd => 'Niederschlag in der Ferne (> 5 km), aber nicht an der Station',            txte => 'Precipitation in the distance (> 5 km), but not at the station'             },
  '16'  => { s => '0', icon => 'unknown',                           txtd => 'Niederschlag in der Nähe (< 5 km), aber nicht an der Station',             txte => 'Precipitation in the vicinity (< 5 km), but not at the station'             },
  '17'  => { s => '0', icon => 'unknown',                           txtd => 'Gewitter (Donner hörbar), aber kein Niederschlag an der Station',          txte => 'Thunderstorm (thunder audible), but no precipitation at the station'        },
  '18'  => { s => '0', icon => 'unknown',                           txtd => 'Markante Böen im Gesichtskreis, aber kein Niederschlag an der Station',    txte => 'marked gusts in the visual circle, but no precipitation at the station'     },
  '19'  => { s => '0', icon => 'unknown',                           txtd => 'Tromben (trichterförmige Wolkenschläuche) im Gesichtskreis',               txte => 'Trombles (funnel-shaped cloud tubes) in the circle of vision'               },

  '20'  => { s => '0', icon => 'unknown',                           txtd => 'nach Sprühregen oder Schneegriesel',                                       txte => 'after drizzle or snow drizzle'                                              },
  '21'  => { s => '0', icon => 'unknown',                           txtd => 'nach Regen',                                                               txte => 'after rain'                                                                 },
  '22'  => { s => '0', icon => 'unknown',                           txtd => 'nach Schnefall',                                                           txte => 'after snowfall'                                                             },
  '23'  => { s => '0', icon => 'unknown',                           txtd => 'nach Schneeregen oder Eiskörnern',                                         txte => 'after sleet or ice grains'                                                  },
  '24'  => { s => '0', icon => 'unknown',                           txtd => 'nach gefrierendem Regen',                                                  txte => 'after freezing rain'                                                        },
  '25'  => { s => '0', icon => 'unknown',                           txtd => 'nach Regenschauer',                                                        txte => 'after rain shower'                                                          },
  '26'  => { s => '0', icon => 'unknown',                           txtd => 'nach Schneeschauer',                                                       txte => 'after snow shower'                                                          },
  '27'  => { s => '0', icon => 'unknown',                           txtd => 'nach Graupel- oder Hagelschauer',                                          txte => 'after sleet or hail showers'                                                },
  '28'  => { s => '0', icon => 'unknown',                           txtd => 'nach Nebel',                                                               txte => 'after fog'                                                                  },
  '29'  => { s => '0', icon => 'unknown',                           txtd => 'nach Gewitter',                                                            txte => 'after thunderstorm'                                                         },

  '30'  => { s => '0', icon => 'unknown',                           txtd => 'leichter oder mäßiger Sandsturm, an Intensität abnehmend',                 txte => 'light or moderate sandstorm, decreasing in intensity'                       },
  '31'  => { s => '0', icon => 'unknown',                           txtd => 'leichter oder mäßiger Sandsturm, unveränderte Intensität',                 txte => 'light or moderate sandstorm, unchanged intensity'                           },
  '32'  => { s => '0', icon => 'unknown',                           txtd => 'leichter oder mäßiger Sandsturm, an Intensität zunehmend',                 txte => 'light or moderate sandstorm, increasing in intensity'                       },
  '33'  => { s => '0', icon => 'unknown',                           txtd => 'schwerer Sandsturm, an Intensität abnehmend',                              txte => 'heavy sandstorm, decreasing in intensity'                                   },
  '34'  => { s => '0', icon => 'unknown',                           txtd => 'schwerer Sandsturm, unveränderte Intensität',                              txte => 'heavy sandstorm, unchanged intensity'                                       },
  '35'  => { s => '0', icon => 'unknown',                           txtd => 'schwerer Sandsturm, an Intensität zunehmend',                              txte => 'heavy sandstorm, increasing in intensity'                                   },
  '36'  => { s => '0', icon => 'weather_snow_light',                txtd => 'leichtes oder mäßiges Schneefegen, unter Augenhöhe',                       txte => 'light or moderate snow sweeping, below eye level'                           },
  '37'  => { s => '0', icon => 'weather_snow_heavy',                txtd => 'starkes Schneefegen, unter Augenhöhe',                                     txte => 'heavy snow sweeping, below eye level'                                       },
  '38'  => { s => '0', icon => 'weather_snow_light',                txtd => 'leichtes oder mäßiges Schneetreiben, über Augenhöhe',                      txte => 'light or moderate blowing snow, above eye level'                            },
  '39'  => { s => '0', icon => 'weather_snow_heavy',                txtd => 'starkes Schneetreiben, über Augenhöhe',                                    txte => 'heavy snow drifting, above eye level'                                       },

  '40'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel in einiger Entfernung',                                              txte => 'Fog in some distance'                                                       },
  '41'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel in Schwaden oder Bänken',                                            txte => 'Fog in swaths or banks'                                                     },
  '42'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel, Himmel erkennbar, dünner werdend',                                  txte => 'Fog, sky recognizable, thinning'                                            },
  '43'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel, Himmel nicht erkennbar, dünner werdend',                            txte => 'Fog, sky not recognizable, thinning'                                        },
  '44'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel, Himmel erkennbar, unverändert',                                     txte => 'Fog, sky recognizable, unchanged'                                           },
  '45'  => { s => '1', icon => 'weather_fog',                       txtd => 'Nebel',                                                                    txte => 'Fog'                                                                        },
  '46'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel, Himmel erkennbar, dichter werdend',                                 txte => 'Fog, sky recognizable, becoming denser'                                     },
  '47'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel, Himmel nicht erkennbar, dichter werdend',                           txte => 'Fog, sky not visible, becoming denser'                                      },
  '48'  => { s => '1', icon => 'weather_fog',                       txtd => 'Nebel mit Reifbildung',                                                    txte => 'Fog with frost formation'                                                   },
  '49'  => { s => '0', icon => 'weather_fog',                       txtd => 'Nebel mit Reifansatz, Himmel nicht erkennbar',                             txte => 'Fog with frost, sky not visible'                                            },

  '50'  => { s => '0', icon => 'weather_rain',                      txtd => 'unterbrochener leichter Sprühregen',                                       txte => 'intermittent light drizzle'                                                 },
  '51'  => { s => '1', icon => 'weather_rain_light',                txtd => 'leichter Sprühregen',                                                      txte => 'light drizzle'                                                              },
  '52'  => { s => '0', icon => 'weather_rain',                      txtd => 'unterbrochener mäßiger Sprühregen',                                        txte => 'intermittent moderate drizzle'                                              },
  '53'  => { s => '1', icon => 'weather_rain_light',                txtd => 'leichter Sprühregen',                                                      txte => 'light drizzle'                                                              },
  '54'  => { s => '0', icon => 'weather_rain_heavy',                txtd => 'unterbrochener starker Sprühregen',                                        txte => 'intermittent heavy drizzle'                                                 },
  '55'  => { s => '1', icon => 'weather_rain_heavy',                txtd => 'starker Sprühregen',                                                       txte => 'heavy drizzle'                                                              },
  '56'  => { s => '1', icon => 'weather_rain_light',                txtd => 'leichter gefrierender Sprühregen',                                         txte => 'light freezing drizzle'                                                     },
  '57'  => { s => '1', icon => 'weather_rain_heavy',                txtd => 'mäßiger oder starker gefrierender Sprühregen',                             txte => 'moderate or heavy freezing drizzle'                                         },
  '58'  => { s => '0', icon => 'weather_rain_light',                txtd => 'leichter Sprühregen mit Regen',                                            txte => 'light drizzle with rain'                                                    },
  '59'  => { s => '0', icon => 'weather_rain_heavy',                txtd => 'mäßiger oder starker Sprühregen mit Regen',                                txte => 'moderate or heavy drizzle with rain'                                        },

  '60'  => { s => '0', icon => 'weather_rain_light',                txtd => 'unterbrochener leichter Regen oder einzelne Regentropfen',                 txte => 'intermittent light rain or single raindrops'                                },
  '61'  => { s => '1', icon => 'weather_rain_light',                txtd => 'leichter Regen',                                                           txte => 'light rain'                                                                 },
  '62'  => { s => '0', icon => 'weather_rain',                      txtd => 'unterbrochener mäßiger Regen',                                             txte => 'intermittent moderate rain'                                                 },
  '63'  => { s => '1', icon => 'weather_rain',                      txtd => 'mäßiger Regen',                                                            txte => 'moderate rain'                                                              },
  '64'  => { s => '0', icon => 'weather_rain_heavy',                txtd => 'unterbrochener starker Regen',                                             txte => 'intermittent heavy rain'                                                    },
  '65'  => { s => '1', icon => 'weather_rain_heavy',                txtd => 'starker Regen',                                                            txte => 'heavy rain'                                                                 },
  '66'  => { s => '1', icon => 'weather_rain_snow_light',           txtd => 'leichter gefrierender Regen',                                              txte => 'light freezing rain'                                                        },
  '67'  => { s => '1', icon => 'weather_rain_snow_heavy',           txtd => 'mäßiger oder starker gefrierender Regen',                                  txte => 'moderate or heavy freezing rain'                                            },
  '68'  => { s => '0', icon => 'weather_rain_snow_light',           txtd => 'leichter Schneeregen',                                                     txte => 'light sleet'                                                                },
  '69'  => { s => '0', icon => 'weather_rain_snow_heavy',           txtd => 'mäßiger oder starker Schneeregen',                                         txte => 'moderate or heavy sleet'                                                    },

  '70'  => { s => '0', icon => 'weather_snow_light',                txtd => 'unterbrochener leichter Schneefall oder einzelne Schneeflocken',           txte => 'intermittent light snowfall or single snowflakes'                           },
  '71'  => { s => '1', icon => 'weather_snow_light',                txtd => 'leichter Schneefall',                                                      txte => 'light snowfall'                                                             },
  '72'  => { s => '0', icon => 'weather_snow',                      txtd => 'unterbrochener mäßiger Schneefall',                                        txte => 'intermittent moderate snowfall'                                             },
  '73'  => { s => '1', icon => 'weather_snow',                      txtd => 'mäßiger Schneefall',                                                       txte => 'moderate snowfall'                                                          },
  '74'  => { s => '0', icon => 'weather_snow_heavy',                txtd => 'unterbrochener starker Schneefall',                                        txte => 'intermittent heavy snowfall'                                                },
  '75'  => { s => '1', icon => 'weather_snow_heavy',                txtd => 'starker Schneefall',                                                       txte => 'heavy snowfall'                                                             },
  '76'  => { s => '0', icon => 'weather_frost',                     txtd => 'Eisnadeln (Polarschnee)',                                                  txte => 'Ice needles (polar snow)'                                                   },
  '77'  => { s => '1', icon => 'weather_frost',                     txtd => 'Schneegriesel',                                                            txte => 'Snow drizzle'                                                               },
  '78'  => { s => '0', icon => 'weather_frost',                     txtd => 'Schneekristalle',                                                          txte => 'Snow crystals'                                                              },
  '79'  => { s => '0', icon => 'weather_frost',                     txtd => 'Eiskörner (gefrorene Regentropfen)',                                       txte => 'Ice grains (frozen raindrops)'                                              },

  '80'  => { s => '1', icon => 'weather_rain_light',                txtd => 'leichter Regenschauer',                                                    txte => 'light rain shower'                                                          },
  '81'  => { s => '1', icon => 'weather_rain',                      txtd => 'mäßiger oder starker Regenschauer',                                        txte => 'moderate or heavy rain shower'                                              },
  '82'  => { s => '1', icon => 'weather_rain_heavy',                txtd => 'sehr starker Regenschauer',                                                txte => 'very heavy rain shower'                                                     },
  '83'  => { s => '0', icon => 'weather_snow',                      txtd => 'mäßiger oder starker Schneeregenschauer',                                  txte => 'moderate or heavy sleet shower'                                             },
  '84'  => { s => '0', icon => 'weather_snow_light',                txtd => 'leichter Schneeschauer',                                                   txte => 'light snow shower'                                                          },
  '85'  => { s => '1', icon => 'weather_snow_light',                txtd => 'leichter Schneeschauer',                                                   txte => 'light snow shower'                                                          },
  '86'  => { s => '1', icon => 'weather_snow_heavy',                txtd => 'mäßiger oder starker Schneeschauer',                                       txte => 'moderate or heavy snow shower'                                              },
  '87'  => { s => '0', icon => 'weather_snow_heavy',                txtd => 'mäßiger oder starker Graupelschauer',                                      txte => 'moderate or heavy sleet shower'                                             },
  '88'  => { s => '0', icon => 'unknown',                           txtd => 'leichter Hagelschauer',                                                    txte => 'light hailstorm'                                                            },
  '89'  => { s => '0', icon => 'weather_sleet',                     txtd => 'mäßiger oder starker Hagelschauer',                                        txte => 'moderate or heavy hailstorm'                                                },

  '90'  => { s => '0', icon => 'weather_storm',                     txtd => 'starke Hagelschauer ohne Gewitter',                                        txte => 'heavy hail showers without thunderstorms'                                   },
  '91'  => { s => '0', icon => 'weather_rain_light',                txtd => 'leichter Regen, letzte Stunde Gewitter hörbar',                            txte => 'light rain, last hour thunderstorm audible'                                 },
  '92'  => { s => '0', icon => 'weather_rain_heavy',                txtd => 'starker Regen, letzte Stunde Gewitter hörbar',                             txte => 'heavy rain, last hour thunderstorm audible'                                 },
  '93'  => { s => '0', icon => 'weather_rain_snow_light',           txtd => 'leichter Schnee oder Regen-Hagel, letzte Stunde Gewitter hörbar',          txte => 'light snow or rain hail, thunderstorms audible for the last hour'           },
  '94'  => { s => '0', icon => 'weather_rain_snow_heavy',           txtd => 'starker Schnee oder Regen-Hagel, letzte Stunde Gewitter hörbar',           txte => 'heavy snow or rain hail, thunderstorm audible for the last hour'            },
  '95'  => { s => '1', icon => 'weather_thunderstorm',              txtd => 'leichtes oder mäßiges Gewitter mit Regen oder Schnee',                     txte => 'light or moderate thunderstorm with rain or snow'                           },
  '96'  => { s => '1', icon => 'weather_thunderstorm',              txtd => 'leichtes oder mäßiges Gewitter mit Hagel',                                 txte => 'light or moderate thunderstorm with hail'                                   },
  '97'  => { s => '0', icon => 'weather_thunderstorm',              txtd => 'schweres Gewitter mit Regen oder Schnee',                                  txte => 'heavy thunderstorm with rain or snow'                                       },
  '98'  => { s => '0', icon => 'weather_thunderstorm',              txtd => 'Gewitter mit Sandsturm',                                                   txte => 'Thunderstorm with sandstorm'                                                },
  '99'  => { s => '1', icon => 'weather_thunderstorm',              txtd => 'Gewitter mit Graupel oder Hagel',                                          txte => 'Thunderstorm with sleet or hail'                                            },

  '100' => { s => '0', icon => 'weather_night_starry',              txtd => 'sternenklarer Himmel',                                                     txte => 'starry sky'                                                                 },
  '101' => { s => '0', icon => 'weather_night_cloudy_light',        txtd => 'leicht bewölkt',                                                           txte => 'slightly cloudy'                                                            },
  '102' => { s => '0', icon => 'weather_night_cloudy',              txtd => 'wolkig',                                                                   txte => 'cloudy'                                                                     },
  '103' => { s => '0', icon => 'weather_night_cloudy_heavy',        txtd => 'stark bewölkt bis bedeckt',                                                txte => 'very cloudy to overcast'                                                    },
  '110' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel',                                                                    txte => 'Fog'                                                                        },
  '111' => { s => '0', icon => 'weather_night_rain_fog',            txtd => 'Nebel mit Regen',                                                          txte => 'Fog with rain'                                                              },
  '112' => { s => '0', icon => 'weather_night_fog',                 txtd => 'durchgehender Bodennebel',                                                 txte => 'continuous ground fog'                                                      },

  '136' => { s => '0', icon => 'weather_night_snow_light',          txtd => 'leichtes oder mäßiges Schneefegen, unter Augenhöhe',                       txte => 'light or moderate snow sweeping, below eye level'                           },
  '137' => { s => '0', icon => 'weather_night_snow_heavy',          txtd => 'starkes Schneefegen, unter Augenhöhe',                                     txte => 'heavy snow sweeping, below eye level'                                       },
  '138' => { s => '0', icon => 'weather_night_snow_light',          txtd => 'leichtes oder mäßiges Schneetreiben, über Augenhöhe',                      txte => 'light or moderate blowing snow, above eye level'                            },
  '139' => { s => '0', icon => 'weather_night_snow_heavy',          txtd => 'starkes Schneetreiben, über Augenhöhe',                                    txte => 'heavy snow drifting, above eye level'                                       },

  '140' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel in einiger Entfernung',                                              txte => 'Fog in some distance'                                                       },
  '141' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel in Schwaden oder Bänken',                                            txte => 'Fog in swaths or banks'                                                     },
  '142' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel, Himmel erkennbar, dünner werdend',                                  txte => 'Fog, sky recognizable, thinning'                                            },
  '143' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel, Himmel nicht erkennbar, dünner werdend',                            txte => 'Fog, sky not recognizable, thinning'                                        },
  '144' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel, Himmel erkennbar, unverändert',                                     txte => 'Fog, sky recognizable, unchanged'                                           },
  '145' => { s => '1', icon => 'weather_night_fog',                 txtd => 'Nebel',                                                                    txte => 'Fog'                                                                        },
  '146' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel, Himmel erkennbar, dichter werdend',                                 txte => 'Fog, sky recognizable, becoming denser'                                     },
  '147' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel, Himmel nicht erkennbar, dichter werdend',                           txte => 'Fog, sky not visible, becoming denser'                                      },
  '148' => { s => '1', icon => 'weather_night_fog',                 txtd => 'Nebel mit Reifbildung',                                                    txte => 'Fog with frost formation'                                                   },
  '149' => { s => '0', icon => 'weather_night_fog',                 txtd => 'Nebel mit Reifansatz, Himmel nicht erkennbar',                             txte => 'Fog with frost, sky not visible'                                            },

  '150' => { s => '0', icon => 'weather_night_rain',                txtd => 'unterbrochener leichter Sprühregen',                                       txte => 'intermittent light drizzle'                                                 },
  '151' => { s => '1', icon => 'weather_night_rain_light',          txtd => 'leichter Sprühregen',                                                      txte => 'light drizzle'                                                              },
  '152' => { s => '0', icon => 'weather_night_rain',                txtd => 'unterbrochener mäßiger Sprühregen',                                        txte => 'intermittent moderate drizzle'                                              },
  '153' => { s => '1', icon => 'weather_night_rain_light',          txtd => 'leichter Sprühregen',                                                      txte => 'light drizzle'                                                              },
  '154' => { s => '0', icon => 'weather_night_rain_heavy',          txtd => 'unterbrochener starker Sprühregen',                                        txte => 'intermittent heavy drizzle'                                                 },
  '155' => { s => '1', icon => 'weather_night_rain_heavy',          txtd => 'starker Sprühregen',                                                       txte => 'heavy drizzle'                                                              },
  '156' => { s => '1', icon => 'weather_night_rain_light',          txtd => 'leichter gefrierender Sprühregen',                                         txte => 'light freezing drizzle'                                                     },
  '157' => { s => '1', icon => 'weather_night_rain_heavy',          txtd => 'mäßiger oder starker gefrierender Sprühregen',                             txte => 'moderate or heavy freezing drizzle'                                         },
  '158' => { s => '0', icon => 'weather_night_rain_light',          txtd => 'leichter Sprühregen mit Regen',                                            txte => 'light drizzle with rain'                                                    },
  '159' => { s => '0', icon => 'weather_night_rain_heavy',          txtd => 'mäßiger oder starker Sprühregen mit Regen',                                txte => 'moderate or heavy drizzle with rain'                                        },

  '160' => { s => '0', icon => 'weather_night_rain_light',          txtd => 'unterbrochener leichter Regen oder einzelne Regentropfen',                 txte => 'intermittent light rain or single raindrops'                                },
  '161' => { s => '1', icon => 'weather_night_rain_light',          txtd => 'leichter Regen',                                                           txte => 'light rain'                                                                 },
  '162' => { s => '0', icon => 'weather_night_rain',                txtd => 'unterbrochener mäßiger Regen',                                             txte => 'intermittent moderate rain'                                                 },
  '163' => { s => '1', icon => 'weather_night_rain',                txtd => 'mäßiger Regen',                                                            txte => 'moderate rain'                                                              },
  '164' => { s => '0', icon => 'weather_night_rain_heavy   ',       txtd => 'unterbrochener starker Regen',                                             txte => 'intermittent heavy rain'                                                    },
  '165' => { s => '1', icon => 'weather_night_rain_heavy',          txtd => 'starker Regen',                                                            txte => 'heavy rain'                                                                 },
  '166' => { s => '1', icon => 'weather_night_snow_rain_light',     txtd => 'leichter gefrierender Regen',                                              txte => 'light freezing rain'                                                        },
  '167' => { s => '1', icon => 'weather_night_snow_rain_heavy',     txtd => 'mäßiger oder starker gefrierender Regen',                                  txte => 'moderate or heavy freezing rain'                                            },
  '168' => { s => '0', icon => 'weather_night_snow_rain_light',     txtd => 'leichter Schneeregen',                                                     txte => 'light sleet'                                                                },
  '169' => { s => '0', icon => 'weather_night_snow_rain_heavy',     txtd => 'mäßiger oder starker Schneeregen',                                         txte => 'moderate or heavy sleet'                                                    },

  '170' => { s => '0', icon => 'weather_night_snow_light',          txtd => 'unterbrochener leichter Schneefall oder einzelne Schneeflocken',           txte => 'intermittent light snowfall or single snowflakes'                           },
  '171' => { s => '1', icon => 'weather_night_snow_light',          txtd => 'leichter Schneefall',                                                      txte => 'light snowfall'                                                             },
  '172' => { s => '0', icon => 'weather_night_snow',                txtd => 'unterbrochener mäßiger Schneefall',                                        txte => 'intermittent moderate snowfall'                                             },
  '173' => { s => '1', icon => 'weather_night_snow',                txtd => 'mäßiger Schneefall',                                                       txte => 'moderate snowfall'                                                          },
  '174' => { s => '0', icon => 'weather_night_snow_heavy',          txtd => 'unterbrochener starker Schneefall',                                        txte => 'intermittent heavy snowfall'                                                },
  '175' => { s => '1', icon => 'weather_night_snow_heavy',          txtd => 'starker Schneefall',                                                       txte => 'heavy snowfall'                                                             },
  '176' => { s => '0', icon => 'weather_frost',                     txtd => 'Eisnadeln (Polarschnee)',                                                  txte => 'Ice needles (polar snow)'                                                   },
  '177' => { s => '1', icon => 'weather_frost',                     txtd => 'Schneegriesel',                                                            txte => 'Snow drizzle'                                                               },
  '178' => { s => '0', icon => 'weather_frost',                     txtd => 'Schneekristalle',                                                          txte => 'Snow crystals'                                                              },
  '179' => { s => '0', icon => 'weather_frost',                     txtd => 'Eiskörner (gefrorene Regentropfen)',                                       txte => 'Ice grains (frozen raindrops)'                                              },

  '180' => { s => '1', icon => 'weather_night_rain_light',          txtd => 'leichter Regenschauer',                                                    txte => 'light rain shower'                                                          },
  '181' => { s => '1', icon => 'weather_night_rain',                txtd => 'mäßiger oder starker Regenschauer',                                        txte => 'moderate or heavy rain shower'                                              },
  '182' => { s => '1', icon => 'weather_night_rain_heavy',          txtd => 'sehr starker Regenschauer',                                                txte => 'very heavy rain shower'                                                     },
  '183' => { s => '0', icon => 'weather_night_snow',                txtd => 'mäßiger oder starker Schneeregenschauer',                                  txte => 'moderate or heavy sleet shower'                                             },
  '184' => { s => '0', icon => 'weather_night_snow_light',          txtd => 'leichter Schneeschauer',                                                   txte => 'light snow shower'                                                          },
  '185' => { s => '1', icon => 'weather_night_snow_light',          txtd => 'leichter Schneeschauer',                                                   txte => 'light snow shower'                                                          },
  '186' => { s => '1', icon => 'weather_night_snow_heavy',          txtd => 'mäßiger oder starker Schneeschauer',                                       txte => 'moderate or heavy snow shower'                                              },
  '187' => { s => '0', icon => 'weather_night_snow_heavy',          txtd => 'mäßiger oder starker Graupelschauer',                                      txte => 'moderate or heavy sleet shower'                                             },
  '189' => { s => '0', icon => 'weather_sleet',                     txtd => 'mäßiger oder starker Hagelschauer',                                        txte => 'moderate or heavy hailstorm'                                                },

  '190' => { s => '0', icon => 'weather_storm',                     txtd => 'starke Hagelschauer ohne Gewitter',                                        txte => 'heavy hail showers without thunderstorms'                                   },
  '191' => { s => '0', icon => 'weather_night_rain_light',          txtd => 'leichter Regen, letzte Stunde Gewitter hörbar',                            txte => 'light rain, last hour thunderstorm audible'                                 },
  '192' => { s => '0', icon => 'weather_night_rain_heavy',          txtd => 'starker Regen, letzte Stunde Gewitter hörbar',                             txte => 'heavy rain, last hour thunderstorm audible'                                 },
  '193' => { s => '0', icon => 'weather_night_snow_rain_light',     txtd => 'leichter Schnee oder Regen-Hagel, letzte Stunde Gewitter hörbar',          txte => 'light snow or rain hail, thunderstorms audible for the last hour'           },
  '194' => { s => '0', icon => 'weather_night_snow_rain_heavy',     txtd => 'starker Schnee oder Regen-Hagel, letzte Stunde Gewitter hörbar',           txte => 'heavy snow or rain hail, thunderstorm audible for the last hour'            },
  '195' => { s => '1', icon => 'weather_night_thunderstorm_light',  txtd => 'leichtes oder mäßiges Gewitter mit Regen oder Schnee',                     txte => 'light or moderate thunderstorm with rain or snow'                           },
  '196' => { s => '1', icon => 'weather_night_thunderstorm_light',  txtd => 'leichtes oder mäßiges Gewitter mit Hagel',                                 txte => 'light or moderate thunderstorm with hail'                                   },
  '197' => { s => '0', icon => 'weather_night_thunderstorm',        txtd => 'schweres Gewitter mit Regen oder Schnee',                                  txte => 'heavy thunderstorm with rain or snow'                                       },
  '198' => { s => '0', icon => 'weather_night_thunderstorm',        txtd => 'Gewitter mit Sandsturm',                                                   txte => 'Thunderstorm with sandstorm'                                                },
  '199' => { s => '1', icon => 'weather_night_thunderstorm',        txtd => 'Gewitter mit Graupel oder Hagel',                                          txte => 'Thunderstorm with sleet or hail'                                            },
);

my %hef = (                                                                      # Energiedaktoren für Verbrauchertypen
  "heater"         => { f => 1.00, m => 1.00, l => 1.00, mt => 240         },
  "other"          => { f => 1.00, m => 1.00, l => 1.00, mt => DEFMINTIME  },    # f   = Faktor Energieverbrauch in erster Stunde (wichtig auch für Kalkulation in __calcEnergyPieces !)
  "charger"        => { f => 1.00, m => 1.00, l => 1.00, mt => 120         },    # m   = Faktor Energieverbrauch zwischen erster und letzter Stunde
  "dishwasher"     => { f => 0.45, m => 0.10, l => 0.45, mt => 180         },    # l   = Faktor Energieverbrauch in letzter Stunde
  "dryer"          => { f => 0.40, m => 0.40, l => 0.20, mt => 90          },    # mt  = default mintime (Minuten)
  "washingmachine" => { f => 0.50, m => 0.30, l => 0.40, mt => 120         },
  "noSchedule"     => { f => 1.00, m => 1.00, l => 1.00, mt => DEFMINTIME  },
);

my %hcsr = (                                                                                                                                 # Funktiontemplate zur Erstellung optionaler Statistikreadings
  currentAPIinterval          => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => 0           },      # par = Parameter zur spezifischen Verwendung
  lastretrieval_time          => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => '-'         },
  lastretrieval_timestamp     => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => '-'         },
  response_message            => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => '-'         },
  todayMaxAPIcalls            => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => 'apimaxreq' },
  todayDoneAPIcalls           => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => 0           },
  todayDoneAPIrequests        => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => 0           },
  todayRemainingAPIcalls      => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => 'apimaxreq' },
  todayRemainingAPIrequests   => { fnr => 1, fn => \&StatusAPIVal,    par => '',                     par1 => '',                  unit => '',     def => 'apimaxreq' },
  runTimeCentralTask          => { fnr => 2, fn => \&CurrentVal,      par => '',                     par1 => '',                  unit => ' s',   def => '-'         },
  runTimeLastAPIAnswer        => { fnr => 2, fn => \&CurrentVal,      par => '',                     par1 => '',                  unit => '',     def => '-'         },
  runTimeLastAPIProc          => { fnr => 2, fn => \&CurrentVal,      par => '',                     par1 => '',                  unit => '',     def => '-'         },
  allStringsFullfilled        => { fnr => 2, fn => \&CurrentVal,      par => '',                     par1 => '',                  unit => '',     def => 0           },
  dummyConsumption            => { fnr => 2, fn => \&CurrentVal,      par => 'dummyConsumption',     par1 => '',                  unit => ' W',   def => 0           },
  todayConForecastTillSunset  => { fnr => 2, fn => \&CurrentVal,      par => 'tdConFcTillSunset',    par1 => '',                  unit => ' Wh',  def => 0           },
  runTimeTrainAI              => { fnr => 3, fn => \&CircularVal,     par => 99,                     par1 => '',                  unit => ' s',   def => '-'         },
  todayConsumption            => { fnr => 3, fn => \&CircularVal,     par => 99,                     par1 => '',                  unit => ' Wh',  def => 0           },
  todayConsumptionForecastDay => { fnr => 4, fn => \&HistoryVal,      par => 99,                     par1 => 'confc',             unit => ' Wh',  def => '-'         },
  BatPowerIn_Sum              => { fnr => 5, fn => \&CurrentVal,      par => 'batpowerinsum',        par1 => '',                  unit => ' W',   def => '-'         },
  BatPowerOut_Sum             => { fnr => 5, fn => \&CurrentVal,      par => 'batpoweroutsum',       par1 => '',                  unit => ' W',   def => '-'         },
  BatWeightedTotalSOC         => { fnr => 2, fn => \&CurrentVal,      par => 'batsoctotal',          par1 => '',                  unit => ' %',   def => 0           },
  SunHours_Remain             => { fnr => 5, fn => \&CurrentVal,      par => '',                     par1 => '',                  unit => '',     def => 0           },      # fnr => 3 -> Custom Calc
  SunMinutes_Remain           => { fnr => 5, fn => \&CurrentVal,      par => '',                     par1 => '',                  unit => '',     def => 0           },
  dayAfterTomorrowPVforecast  => { fnr => 5, fn => \&CurrentVal,      par => 'dayAfterTomorrowPVfc', par1 => '',                  unit => ' Wh',  def => 0           },
  todayGridFeedIn             => { fnr => 5, fn => \&CircularVal,     par => 99,                     par1 => '',                  unit => '',     def => 0           },
  todayGridConsumption        => { fnr => 5, fn => \&CircularVal,     par => 99,                     par1 => '',                  unit => '',     def => 0           },
  todayNotOwnerConsumption    => { fnr => 5, fn => \&CircularVal,     par => 99,                     par1 => 'todayConsumption',  unit => ' Wh',  def => 0           },
  todayConsumptionForecast    => { fnr => 5, fn => \&HistoryVal,      par => '',                     par1 => 'confc',             unit => ' Wh',  def => '-'         },
  tomorrowConsumptionForecast => { fnr => 5, fn => \&NexthoursVal,    par => 'confc',                par1 => '',                  unit => ' Wh',  def => '-'         },
  conForecastTillNextSunrise  => { fnr => 5, fn => \&NexthoursVal,    par => 'confc',                par1 => '',                  unit => ' Wh',  def => 0           },
  conForecastComingNight      => { fnr => 5, fn => \&NexthoursVal,    par => 'confc',                par1 => '',                  unit => ' Wh',  def => 0           },
  todayBatInSum               => { fnr => 5, fn => \&CircularVal,     par => 99,                     par1 => '',                  unit => ' Wh',  def => 0           },
  todayBatOutSum              => { fnr => 5, fn => \&CircularVal,     par => 99,                     par1 => '',                  unit => ' Wh',  def => 0           },
);

  for my $csr (1..MAXCONSUMER) {
      $csr                                       = sprintf "%02d", $csr;

      $hcsr{'currentRunMtsConsumer_'.$csr}{fnr}  = 5;
      $hcsr{'currentRunMtsConsumer_'.$csr}{fn}   = \&ConsumerVal;
      $hcsr{'currentRunMtsConsumer_'.$csr}{par}  = 'cycleTime';
      $hcsr{'currentRunMtsConsumer_'.$csr}{par1} = '';
      $hcsr{'currentRunMtsConsumer_'.$csr}{unit} = ' min';
      $hcsr{'currentRunMtsConsumer_'.$csr}{def}  = 0;

      $hcsr{'runTimeAvgDayConsumer_'.$csr}{fnr}  = 5;
      $hcsr{'runTimeAvgDayConsumer_'.$csr}{fn}   = \&ConsumerVal;
      $hcsr{'runTimeAvgDayConsumer_'.$csr}{par}  = 'runtimeAvgDay';
      $hcsr{'runTimeAvgDayConsumer_'.$csr}{par1} = '';
      $hcsr{'runTimeAvgDayConsumer_'.$csr}{unit} = ' min';
      $hcsr{'runTimeAvgDayConsumer_'.$csr}{def}  = 0;
  }

  for my $bn (1..MAXBATTERIES) {
      $bn                                      = sprintf "%02d", $bn;

      $hcsr{'daysUntilBatteryCare_'.$bn}{fnr}  = 5;
      $hcsr{'daysUntilBatteryCare_'.$bn}{fn}   = \&CircularVal;
      $hcsr{'daysUntilBatteryCare_'.$bn}{par}  = 99;
      $hcsr{'daysUntilBatteryCare_'.$bn}{par1} = '';
      $hcsr{'daysUntilBatteryCare_'.$bn}{unit} = '';
      $hcsr{'daysUntilBatteryCare_'.$bn}{def}  = '-';

      $hcsr{'todayBatIn_'.$bn}{fnr}  = 5;
      $hcsr{'todayBatIn_'.$bn}{fn}   = \&CircularVal;
      $hcsr{'todayBatIn_'.$bn}{par}  = 99;
      $hcsr{'todayBatIn_'.$bn}{par1} = '';
      $hcsr{'todayBatIn_'.$bn}{unit} = ' Wh';
      $hcsr{'todayBatIn_'.$bn}{def}  = 0;

      $hcsr{'todayBatOut_'.$bn}{fnr}  = 5;
      $hcsr{'todayBatOut_'.$bn}{fn}   = \&CircularVal;
      $hcsr{'todayBatOut_'.$bn}{par}  = 99;
      $hcsr{'todayBatOut_'.$bn}{par1} = '';
      $hcsr{'todayBatOut_'.$bn}{unit} = ' Wh';
      $hcsr{'todayBatOut_'.$bn}{def}  = 0;
      
      $hcsr{'remainingHrsWoChargeRcmdBat_'.$bn}{fnr}  = 5;
      $hcsr{'remainingHrsWoChargeRcmdBat_'.$bn}{fn}   = \&NexthoursVal;
      $hcsr{'remainingHrsWoChargeRcmdBat_'.$bn}{par}  = 'rcdchargebat'.$bn;
      $hcsr{'remainingHrsWoChargeRcmdBat_'.$bn}{par1} = '';
      $hcsr{'remainingHrsWoChargeRcmdBat_'.$bn}{unit} = '';
      $hcsr{'remainingHrsWoChargeRcmdBat_'.$bn}{def}  = '-';
      
      $hcsr{'remainingSurplsHrsMinPwrBat_'.$bn}{fnr}  = 5;
      $hcsr{'remainingSurplsHrsMinPwrBat_'.$bn}{fn}   = \&NexthoursVal;
      $hcsr{'remainingSurplsHrsMinPwrBat_'.$bn}{par}  = 'pvfc';
      $hcsr{'remainingSurplsHrsMinPwrBat_'.$bn}{par1} = 'confc';
      $hcsr{'remainingSurplsHrsMinPwrBat_'.$bn}{unit} = '';
      $hcsr{'remainingSurplsHrsMinPwrBat_'.$bn}{def}  = '0';
  }

# Funktiontemplate zur Speicherung von Werten in pvHistory
# storname = Name des Elements in der pvHistory
# nhour    = evtl. abweichend von $nhour
# fpar     = Parameter zur spezifischen Verwendung
my %hfspvh = (
  radiation         => { fn => \&_storeVal, storname => 'rad1h',        validkey => undef,    fpar => undef    },    # irradiation
  DoN               => { fn => \&_storeVal, storname => 'DoN',          validkey => undef,    fpar => undef    },    # Tag 1 oder Nacht 0
  sunaz             => { fn => \&_storeVal, storname => 'sunaz',        validkey => undef,    fpar => undef    },    # Sonnenstand Azimuth
  sunalt            => { fn => \&_storeVal, storname => 'sunalt',       validkey => undef,    fpar => undef    },    # Sonnenstand Altitude
  etotal            => { fn => \&_storeVal, storname => 'etotal',       validkey => undef,    fpar => undef    },    # etotal des Wechselrichters
  weatherid         => { fn => \&_storeVal, storname => 'weatherid',    validkey => undef,    fpar => undef    },    # Wetter ID
  weathercloudcover => { fn => \&_storeVal, storname => 'wcc',          validkey => undef,    fpar => undef    },    # Wolkenbedeckung
  rr1c              => { fn => \&_storeVal, storname => 'rr1c',         validkey => undef,    fpar => undef    },    # Gesamtniederschlag (1-stündig) letzte 1 Stunde
  pvcorrfactor      => { fn => \&_storeVal, storname => 'pvcorrf',      validkey => undef,    fpar => undef    },    # pvCorrectionFactor
  temperature       => { fn => \&_storeVal, storname => 'temp',         validkey => undef,    fpar => undef    },    # Außentemperatur
  conprice          => { fn => \&_storeVal, storname => 'conprice',     validkey => undef,    fpar => undef    },    # Bezugspreis pro kWh der Stunde
  feedprice         => { fn => \&_storeVal, storname => 'feedprice',    validkey => undef,    fpar => undef    },    # Einspeisevergütung pro kWh der Stunde
  socwhsum          => { fn => \&_storeVal, storname => 'socwhsum',     validkey => undef,    fpar => undef    },    # real eerichter SoC (Wh) zusammengefasst über alle Batterien
  socprogwhsum      => { fn => \&_storeVal, storname => 'socprogwhsum', validkey => undef,    fpar => undef    },    # prognostizierter SoC (Wh) zusammengefasst über alle Batterien
  pvapifcraw        => { fn => \&_storeVal, storname => 'pvapifcraw',   validkey => undef,    fpar => undef    },    # prognostizierter Energieertrag Raw
  pvfc              => { fn => \&_storeVal, storname => 'pvfc',         validkey => undef,    fpar => 'comp99' },    # prognostizierter Energieertrag
  confc             => { fn => \&_storeVal, storname => 'confc',        validkey => undef,    fpar => 'comp99' },    # prognostizierter Hausverbrauch
  gcons             => { fn => \&_storeVal, storname => 'gcons',        validkey => undef,    fpar => 'comp99' },    # bezogene Energie
  gfeedin           => { fn => \&_storeVal, storname => 'gfeedin',      validkey => undef,    fpar => 'comp99' },    # eingespeiste Energie
  con               => { fn => \&_storeVal, storname => 'con',          validkey => undef,    fpar => 'comp99' },    # realer Hausverbrauch Energie
  pvrl              => { fn => \&_storeVal, storname => 'pvrl',         validkey => 'pvrlvd', fpar => 'comp99' },    # realer Energieertrag PV
  plantderated      => { fn => \&_storeVal, storname => 'plantderated', validkey => undef,    fpar => undef    },    # Abregelungsstatus der Anlage
);

  for my $in (1..MAXINVERTER) {
      $in                              = sprintf "%02d", $in;
      $hfspvh{'pvrl'.$in}{fn}          = \&_storeVal;                         # realer Energieertrag Inverter
      $hfspvh{'pvrl'.$in}{storname}    = 'pvrl'.$in;
      $hfspvh{'pvrl'.$in}{validkey}    = undef;
      $hfspvh{'pvrl'.$in}{fpar}        = 'comp99';

      $hfspvh{'etotali'.$in}{fn}       = \&_storeVal;                         # etotal Inverter
      $hfspvh{'etotali'.$in}{storname} = 'etotali'.$in;
      $hfspvh{'etotali'.$in}{validkey} = undef;
      $hfspvh{'etotali'.$in}{fpar}     = undef;
  }

  for my $pn (1..MAXPRODUCER) {
      $pn                              = sprintf "%02d", $pn;
      $hfspvh{'pprl'.$pn}{fn}          = \&_storeVal;                         # realer Energieertrag sonstiger Erzeuger
      $hfspvh{'pprl'.$pn}{storname}    = 'pprl'.$pn;
      $hfspvh{'pprl'.$pn}{validkey}    = undef;
      $hfspvh{'pprl'.$pn}{fpar}        = 'comp99';

      $hfspvh{'etotalp'.$pn}{fn}       = \&_storeVal;                         # etotal sonstiger Erzeuger
      $hfspvh{'etotalp'.$pn}{storname} = 'etotalp'.$pn;
      $hfspvh{'etotalp'.$pn}{validkey} = undef;
      $hfspvh{'etotalp'.$pn}{fpar}     = undef;
  }

  for my $bn (1..MAXBATTERIES) {
      $bn                                     = sprintf "%02d", $bn;
      $hfspvh{'batintotal'.$bn}{fn}           = \&_storeVal;                  # totale Batterieladung
      $hfspvh{'batintotal'.$bn}{storname}     = 'batintotal'.$bn;
      $hfspvh{'batintotal'.$bn}{validkey}     = undef;
      $hfspvh{'batintotal'.$bn}{fpar}         = undef;

      $hfspvh{'batouttotal'.$bn}{fn}          = \&_storeVal;                  # totale Batterieentladung
      $hfspvh{'batouttotal'.$bn}{storname}    = 'batouttotal'.$bn;
      $hfspvh{'batouttotal'.$bn}{validkey}    = undef;
      $hfspvh{'batouttotal'.$bn}{fpar}        = undef;

      $hfspvh{'batinthishour'.$bn}{fn}        = \&_storeVal;                  # Batterieladung in Stunde
      $hfspvh{'batinthishour'.$bn}{storname}  = 'batin'.$bn;
      $hfspvh{'batinthishour'.$bn}{validkey}  = undef;
      $hfspvh{'batinthishour'.$bn}{fpar}      = 'comp99';

      $hfspvh{'batoutthishour'.$bn}{fn}       = \&_storeVal;                  # Batterieentladung in Stunde
      $hfspvh{'batoutthishour'.$bn}{storname} = 'batout'.$bn;
      $hfspvh{'batoutthishour'.$bn}{validkey} = undef;
      $hfspvh{'batoutthishour'.$bn}{fpar}     = 'comp99';

      $hfspvh{'batprogsoc'.$bn}{fn}           = \&_storeVal;                  # Prognose-SOC des Tages
      $hfspvh{'batprogsoc'.$bn}{storname}     = 'batprogsoc'.$bn;
      $hfspvh{'batprogsoc'.$bn}{validkey}     = undef;
      $hfspvh{'batprogsoc'.$bn}{fpar}         = undef;
      
      $hfspvh{'lcintimebat'.$bn}{fn}          = \&_storeVal;                  # Ladesteuerung der Batterie In Time, d.h. war sie aktiv? (1 - Ja, 0 - Nein)
      $hfspvh{'lcintimebat'.$bn}{storname}    = 'lcintimebat'.$bn;
      $hfspvh{'lcintimebat'.$bn}{validkey}    = undef;
      $hfspvh{'lcintimebat'.$bn}{fpar}        = undef;
      
      $hfspvh{'strategybat'.$bn}{fn}          = \&_storeVal;                  # Ladestrategie der Batterie
      $hfspvh{'strategybat'.$bn}{storname}    = 'strategybat'.$bn;
      $hfspvh{'strategybat'.$bn}{validkey}    = undef;
      $hfspvh{'strategybat'.$bn}{fpar}        = undef;

      $hfspvh{'batmaxsoc'.$bn}{fn}            = \&_storeVal;                  # max. erreichter SOC des Tages
      $hfspvh{'batmaxsoc'.$bn}{storname}      = 'batmaxsoc'.$bn;
      $hfspvh{'batmaxsoc'.$bn}{validkey}      = undef;
      $hfspvh{'batmaxsoc'.$bn}{fpar}          = undef;

      $hfspvh{'batsetsoc'.$bn}{fn}            = \&_storeVal;                  # gesetzter optimaler SOC für den Tag
      $hfspvh{'batsetsoc'.$bn}{storname}      = 'batsetsoc'.$bn;
      $hfspvh{'batsetsoc'.$bn}{validkey}      = undef;
      $hfspvh{'batsetsoc'.$bn}{fpar}          = undef;

      $hfspvh{'batsoc'.$bn}{fn}               = \&_storeVal;                  # aktueller SOC für Tag / Stunde
      $hfspvh{'batsoc'.$bn}{storname}         = 'batsoc'.$bn;
      $hfspvh{'batsoc'.$bn}{validkey}         = undef;
      $hfspvh{'batsoc'.$bn}{fpar}             = undef;
  }


# Information zu verwendeten internen Datenhashes
####################################################
# Daten die ein Reload überleben und mit reloadCacheFiles nachgeladen werden müssen:
# $data{$name}{pvhist}                                                        # historische Werte
# $data{$name}{weatherapi}                                                    # Zwischenspeicher API-Wetterdaten
# $data{$name}{solcastapi}                                                    # Zwischenspeicher API-Solardaten
# $data{$name}{statusapi}                                                     # Zwischenspeicher API-Status
# $data{$name}{circular}                                                      # Ringspeicher
# $data{$name}{consumers}                                                     # Consumer Daten
# $data{$name}{aidectree}{aitrained}                                          # AI Decision Tree trainierte Daten
# $data{$name}{aidectree}{airaw}                                              # Rohdaten für AI Input = Raw Trainigsdaten

# temporäre Daten die pro Zyklus neu erstellt werden:
# $data{$name}{current}                                                       # temporärer Speicher Current Daten (enthält beim Lesen Cachefiles geladene Statusdaten)
# $data{$name}{nexthours}                                                     # temporärer Speicher NextHours Daten
# $data{$name}{inverters}                                                     # temporärer Speicher Inverter Daten
# $data{$name}{producers}                                                     # temporärer Speicher non-PV Producer Daten
# $data{$name}{batteries}                                                     # temporärer Speicher Battery Daten
# $data{$name}{weatherdata}                                                   # temporärer Speicher Wetterdaten
# $data{$name}{func}                                                          # temporäre interne Funktionen
# $data{$name}{dwdcatalog}                                                    # temporärer Speicher DWD Stationskatalog
# $data{$name}{strings}                                                       # temporärer Speicher Stringkonfiguration
# $data{$name}{aidectree}{object}                                             # AI Decision Tree Object (im BlockingCall)
# $data{$name}{messages}                                                      # Mitteilungssystem - permanent erneuerter Speicher
# $data{$name}{filemessages}                                                  # Mitteilungssystem - Input vom Message File
# $data{$name}{preparedmessages}                                              # Mitteilungssystem - vorbereitete Messages innerhalb des Code

################################################################
#               Init Fn
################################################################
sub Initialize {
  my $hash = shift;

  my $hod = join ",", map { sprintf "%02d", $_} (1..24);
  my $srd = join ",", sort keys (%hcsr);

  my ($consumer, $setupbat, $ctrlbatsm, $setupprod, $setupinv, $beam, $beamhl, @allc, @gb, @gbhl);

  for my $c (1..MAXCONSUMER) {
      $c         = sprintf "%02d", $c;
      $consumer .= "consumer${c}:textField-long ";
      push @allc, $c;
  }

  for my $n (1..MAXBEAMLEVEL * 2) {
      push @gb, "graphicBeam${n}Content";
      push @gb, "graphicBeam${n}Color:colorpicker,RGB";
      push @gb, "graphicBeam${n}FontColor:colorpicker,RGB";
  }

  $beam .= join ' ', sort @gb;
  $beam .= ' ';

  for my $bn (1..MAXBATTERIES) {
      $bn         = sprintf "%02d", $bn;
      $setupbat  .= "setupBatteryDev${bn}:textField-long ";
      $ctrlbatsm .= "ctrlBatSocManagement${bn}:textField-long ";
  }

  for my $in (1..MAXINVERTER) {
      $in        = sprintf "%02d", $in;
      $setupinv .= "setupInverterDev${in}:textField-long ";
  }

  for my $prn (1..MAXPRODUCER) {
      $prn        = sprintf "%02d", $prn;
      $setupprod .= "setupOtherProducer${prn}:textField-long ";
  }

  my $allcs = join ",", @allc;
  my $dm    = 'none,'.join ",", sort @dd;                                             # Optionen der Debugselektion
  my $gol   = join ",", @gsopt;                                                       # Optionen der Grafikselektion

  $hash->{DefFn}              = \&Define;
  $hash->{UndefFn}            = \&Undef;
  $hash->{GetFn}              = \&Get;
  $hash->{SetFn}              = \&Set;
  $hash->{DeleteFn}           = \&Delete;
  $hash->{FW_summaryFn}       = \&FwFn;
  $hash->{FW_detailFn}        = \&FwFn;
  $hash->{ShutdownFn}         = \&Shutdown;
  $hash->{RenameFn}           = \&Rename;
  $hash->{DbLog_splitFn}      = \&DbLogSplit;
  $hash->{AttrFn}             = \&Attr;
  $hash->{NotifyFn}           = \&Notify;
  $hash->{ReadyFn}            = \&runTask;
  $hash->{AttrList}           = "aiControl:textField-long ".
                                "consumerControl:textField-long ".
                                "ctrlConsRecommendReadings:multiple-strict,$allcs ".
                                "ctrlDebug:multiple-strict,$dm,#10 ".
                                "ctrlLanguage:DE,EN ".
                                "ctrlNextDayForecastReadings:multiple-strict,$hod ".
                                "ctrlNextHoursSoCForecastReadings ".
                                "ctrlSolCastAPImaxReq:selectnumbers,5,5,60,0,lin ".
                                "ctrlSpecialReadings:multiple-strict,$srd ".
                                "ctrlUserExitFn:textField-long ".
                                "disable:1,0 ".
                                "flowGraphicControl:textField-long ".
                                "graphicControl:textField-long ".
                                "graphicHeaderOwnspec:textField-long ".
                                "graphicHeaderOwnspecValForm:textField-long ".
                                "graphicHistoryHour:slider,0,1,23 ".
                                "graphicSelect:$gol ".
                                "graphicShowNight:1,0,01 ".
                                "graphicShowWeather:1,0 ".
                                "graphicWeatherColor:colorpicker,RGB ".
                                "graphicWeatherColorNight:colorpicker,RGB ".
                                "plantControl:textField-long ".
                                "setupInverterStrings ".
                                "setupMeterDev:textField-long ".
                                "setupWeatherDev1 ".
                                "setupWeatherDev2 ".
                                "setupWeatherDev3 ".
                                "setupRoofTops ".
                                "setupRadiationAPI ".
                                "setupStringAzimuth ".
                                "setupStringDeclination ".
                                "setupStringPeak ".
                                $beam.
                                $setupbat.
                                $setupinv.
                                $setupprod.
                                $consumer.
                                $ctrlbatsm.
                                $readingFnAttributes;

  ## Hinweis:   graphicBeamXContent wird in _addDynAttr hinzugefügt

  ### nicht mehr benötigte Daten verarbeiten - Bereich kann später wieder raus !!
  ##########################################################################################################################
  # my $av = 'obsolete#-#use#attr#graphicControl#instead';
  # my $av1 = 'obsolete#-#will#be#deleted#soon';
  # my $av2 = 'obsolete#-#use#attr#graphicSelect#instead';
  # $hash->{AttrList} .= " graphicBeamHeightLevel1:$av graphicBeamHeightLevel2:$av graphicBeamHeightLevel3:$av ";
  ##########################################################################################################################

  $hash->{FW_hideDisplayName} = 1;                     # Forum 88667

  # $hash->{FW_addDetailToSummary} = 1;
  # $hash->{FW_atPageEnd} = 1;                         # wenn 1 -> kein Longpoll ohne informid in HTML-Tag

  # $hash->{AttrRenameMap} = { "ctrlStatisticReadings" => "ctrlSpecialReadings",
  #                          };

  eval { FHEM::Meta::InitMod( __FILE__, $hash ) };     ## no critic 'eval'

return;
}

###############################################################
#                  SolarForecast Define
###############################################################
sub Define {
  my ($hash, $def) = @_;

  my @a = split(/\s+/x, $def);

  return "Error: Perl module ".$jsonabs." is missing. Install it on Debian with: sudo apt-get install libjson-perl" if($jsonabs);

  my $name                       = $hash->{NAME};
  my $type                       = $hash->{TYPE};
  $hash->{HELPER}{MODMETAABSENT} = 1 if($modMetaAbsent);                                                 # Modul Meta.pm nicht vorhanden

  my $params = {
      hash        => $hash,
      name        => $name,
      type        => $type,
      notes       => \%vNotesIntern,
      useAPI      => 0,
      useSMUtils  => 1,
      useErrCodes => 1,
      useCTZ      => 1,
  };

  use version 0.77; our $VERSION = moduleVersion ($params);                                              # Versionsinformationen setzen
  delete $params->{hash};

  createAssociatedWith ($hash);
  reloadCacheFiles     ($params);
  singleUpdateState    ( {hash => $hash, state => 'initialized', evt => 1} );

  $readyfnlist{$name} = $hash;                                                                                                   # Registrierung in Ready-Schleife
  InternalTimer (gettimeofday() + WHISTREPEAT  + int(rand(300)), "FHEM::SolarForecast::periodicWriteMemcache",     $hash, 0);   # Einstieg periodisches Schreiben historische Daten
  InternalTimer (gettimeofday() + 120           + int(rand(300)), "FHEM::SolarForecast::getMessageFileNonBlocking", $hash, 0);

return;
}

###############################################################
#                  SolarForecast Set
###############################################################
sub Set {
  my ($hash, @a) = @_;
  return qq{"set X" needs at least an argument} if(@a < 2);
  my $name  = shift @a;
  my $opt   = shift @a;
  my @args  = @a;
  my $arg   = join " ", map { my $p = $_; $p =~ s/\s+/ /xg; $p; } @a;     ## no critic 'Map blocks'
  my $prop  = shift @a;
  my $prop1 = shift @a;
  my $prop2 = shift @a;

  return if((controller($name))[1]);

  my ($setlist,@cfs,@condevs,@bkps);
  my ($fcd,$ind,$med,$cf,$sp,$coms) = ('','','','','','');
  my $type = $hash->{TYPE};

  my @re = qw( aiData
               batteryTriggerSet
               consumerMaster
               consumerPlanning
               consumptionHistory
               energyH4TriggerSet
               powerTriggerSet
               pvCorrection
               roofIdentPair
               pvHistory
             );

  my $resets = join ",", @re;

  for my $h (@chours) {
      push @cfs, 'pvCorrectionFactor_'. sprintf("%02d",$h);
  }

  $cf = join " ", @cfs;

  for my $c (sort{$a<=>$b} keys %{$data{$name}{consumers}}) {
      push @condevs, $c if($c);
  }

  $coms    = @condevs ? join ",", @condevs : 'noArg';
  my $ipai = isPrepared4AI ($hash);

  opendir (my $dh, $cachedir);

  while (my $file = readdir $dh) {
      next unless (-f "$cachedir/$file");
      next unless ($file =~ /_${name}_/);
      next unless ($file =~ /_\d{4}_\d{2}_\d{2}_\d{2}_\d{2}_\d{2}$/);
      push @bkps, 'recover-'.$file;
  }

  closedir $dh;
  my $rf = @bkps ? ','.join ",", reverse sort @bkps : '';

  my $cakeys = join ',', @hcompoattrkeys;
  my $keynum = scalar @hcompoattrkeys + 1;

  ## allg. gültige Setter
  #########################
  $setlist = "Unknown argument $opt, choose one of ".
             "consumerImmediatePlanning:$coms ".
             "consumerNewPlanning:$coms ".
             "cycleInterval ".
             "energyH4Trigger:textField-long ".                                                          # vor attrKeyVal textField-long laden
             "attrKeyVal:widgetList,$keynum,select,$cakeys,1,textField-long ".
             "operatingMemory:backup,save".$rf." ".
             "operationMode:active,inactive ".
             "plantConfiguration:check,save,restore ".
             "powerTrigger:textField-long ".
             "pvCorrectionFactor_Auto:noLearning,on_simple".($ipai ? ',on_simple_ai,' : ',')."on_complex".($ipai ? ',on_complex_ai,on_complex_api_ai,' : ',')."off ".
             "reset:$resets ".
             $cf." "
             ;

  ## API spezifische Setter
  ###########################
  if (isSolCastUsed ($hash)) {
      $setlist .= "roofIdentPair "
                  ;
  }
  elsif (isVictronKiUsed ($hash)) {
      $setlist .= "vrmCredentials "
                  ;
  }

  ## KI spezifische Setter
  ##########################
  if ($ipai) {
      $setlist .= "aiDecTree:addInstAndTrain,addRawData,rawDataGHIreplace ";
  }

  ## Batterie spezifische Setter
  ################################
  if (isBatteryUsed ($name)) {
      $setlist .= "batteryTrigger:textField-long ";
  }

  ## inactive (Setter überschreiben)
  ####################################
  if ((controller($name))[2]) {
      $setlist = "operationMode:active,inactive ";
  }

  my $params = {
      name    => $name,
      type    => $type,
      opt     => $opt,
      arg     => $arg,
      argsref => \@args,
      prop    => $prop,
      prop1   => $prop1,
      prop2   => $prop2,
      lang    => getLang  ($hash),
      debug   => getDebug ($hash)
  };

  if ($hset{$opt} && defined &{$hset{$opt}{fn}}) {
      my $ret = q{};
      $ret    = &{$hset{$opt}{fn}} ($params);
      return $ret;
  }

return "$setlist";
}

################################################################
#                      Setter consumerImmediatePlanning
################################################################
sub _setconsumerImmediatePlanning {      ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{prop};
  my $evt   = $paref->{prop1} // 0;                                                          # geändert V 1.1.0 - 1 -> 0
  my $hash  = $defs{$name};

  return qq{no consumer number specified} if(!$c);
  return qq{no valid consumer id "$c"}    if(!ConsumerVal ($hash, $c, "name", ""));

  if (ConsumerVal ($hash, $c, 'type', DEFCTYPE) eq 'noSchedule') {
      debugLog ($paref, "consumerPlanning", qq{consumer "$c" - }.$hqtxt{scnp}{EN});

      $paref->{ps}       = 'noSchedule';
      $paref->{consumer} = $c;

      ___setConsumerPlanningState ($paref);

      delete $paref->{ps};
      delete $paref->{consumer};
      return;
  }

  my ($err, $mintime) = getConsumerMintime ( { name    => $name,
                                               c       => $c,
                                               lang    => $paref->{lang},
                                               debug   => $paref->{debug}
                                             }
                                           );
  if ($err) {
      Log3 ($name, 1, "$name - ERROR in consumer $c config: $err");
      return;
  }

  my $startts  = time;
  my $stopdiff = $mintime * 60;
  my $stopts   = $startts + $stopdiff;

  $paref->{consumer} = $c;
  $paref->{ps}       = 'planned:';
  $paref->{startts}  = $startts;                                                               # Unix Timestamp für geplanten Switch on
  $paref->{stopts}   = $stopts;                                                                # Unix Timestamp für geplanten Switch off

  ___setConsumerPlanningState ($paref);
  ___saveEhodpieces           ($paref);
  ___setPlanningDeleteMeth    ($paref);

  my $planstate = ConsumerVal ($hash, $c, 'planstate', '');
  my $calias    = ConsumerVal ($hash, $c, 'alias',     '');

  writeCacheToFile ($hash, 'consumers', $csmcache.$name);                                      # Cache File Consumer schreiben

  Log3 ($name, 3, qq{$name - Consumer "$calias" $planstate}) if($planstate);

  centralTask ($hash, $evt);

return;
}

################################################################
#         Setter consumerNewPlanning
################################################################
sub _setconsumerNewPlanning {            ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{prop};
  my $evt   = $paref->{prop1} // 0;                                                            # geändert V 1.1.0 - 1 -> 0
  my $hash  = $defs{$name};

  return qq{no consumer number specified} if(!$c);
  return qq{no valid consumer id "$c"}    if(!ConsumerVal ($hash, $c, 'name', ''));

  if ($c) {
      deleteConsumerPlanning ($hash, $c);
      writeCacheToFile       ($hash, 'consumers', $csmcache.$name);                            # Cache File Consumer schreiben
  }

  centralTask ($hash, $evt);

return;
}

################################################################
#                      Setter cycleInterval
################################################################
sub _setcycleInterval {                   ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $opt   = $paref->{opt};
  my $prop  = $paref->{prop} // return;

  return if(!$init_done);

  my $pc = AttrVal ($name, 'plantControl', undef);
  my $new;

  if (!defined $pc) {
      $new = "$name plantControl cycleInterval=$prop";
  }
  elsif ($pc =~ /cycleInterval=\d+/xs) {
      $pc  =~ s/cycleInterval=\d+/cycleInterval=$prop/gs;
      $new = "$name plantControl $pc";
  }
  else {
      my $npc = $pc." cycleInterval=$prop";
      $new    = "$name plantControl $npc";
  }

  my $ret = CommandAttr (undef, "$new");
  return $ret if($ret);

  ::CommandSave (undef, undef) if(!$ret);

return;
}

####################################################################
#                      Setter attrKeyVal
#   set <name> attrKeyVal <Sammelattribut> [<Device>] <Key>=<Wert>
####################################################################
sub _setattrKeyVal {                         ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $opt   = $paref->{opt};
  my $arg   = $paref->{arg} // return;

  return if(!$init_done);
  
  #Log3 ($name, 1, "$name - Arg Orig: $arg");
  
  $arg =~ s/=\s*/=/g;                                                                    # V 1.59.6 wichtig für graphicHeaderOwnspec Behandlung einzelner Keys -> ersetze jedes = samt folgendem Leerraum durch ein reines =
  $arg =~ s/^([^,]*)\s+/$1,/;                                                            # das erste auftretende Leerzeichen-Cluster durch ',' ersetzen, aber nur wenn es in dem String vor dem Leerzeichen-Cluster noch kein Komma gibt
  $arg =~ s/^([^=]*?),/$1 /;                                                             
   
  #Log3 ($name, 1, "$name - Arg Substitute: $arg");
   
  my ($a, $h)    = parseParams ($arg);
  my $targetattr = $a->[0];
  my $devn       = $a->[1] // '';

  return "The '$opt' command requires a valid attribute as a passed parameter." if(!$targetattr || !grep /^$targetattr$/, keys %{$hcompoattr});

  my $av = AttrVal ($name, $targetattr, undef);

  if (defined $av) {                                                                     # vohandenes Attribut ändern
      my ($ao, $ho) = parseParams ($av);

      while (my ($key, $value) = each %$h) {
          return "The target attribut '$targetattr' requires '<key>=<value>' as a passed parameter." if(!$key || !defined $value);
          $ho->{$key} = $value;
      }

      my $repl = '';

      for my $k (sort keys %$ho) {
          $repl .= "$k=$ho->{$k}\n";
      }

      my $dev = $devn    ? $devn    :
                $ao->[0] ? $ao->[0] :
                '';
      $dev   .= "\n" if($dev);

      my $new = "$name $targetattr $dev".$repl;
      my $ret = CommandAttr (undef, "$new");
      return $ret if($ret);
  }
  else {                                                                                # Attribut komplett neu setzen
      my $nkv = '';

      while (my ($key, $value) = each %$h) {
          return "The target attribut '$targetattr' requires '<key>=<value>' as a passed parameter." if(!$key || !defined $value);
          $nkv .= "\n" if($nkv);
          $nkv .= "$key=$value";
      }

      $devn   .= "\n" if($devn);
      my $new  = "$name $targetattr $devn".$nkv;
      my $ret  = CommandAttr (undef, "$new");
      return $ret if($ret);
  }

  ::CommandSave (undef, undef);

return;
}

################################################################
#                      Setter roofIdentPair
################################################################
sub _setroofIdentPair {                 ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $opt   = $paref->{opt};
  my $arg   = $paref->{arg};

  my $hash  = $defs{$name};

  if (!$arg) {
      return qq{The command "$opt" needs an argument !};
  }

  my ($a,$h) = parseParams ($arg);
  my $pk  = $a->[0] // "";

  if (!$pk) {
      return qq{Every roofident pair needs a pairkey! Use: <pairkey> rtid=<Rooftop ID> apikey=<api key>};
  }

  if (!$h->{rtid} || !$h->{apikey}) {
      return qq{The syntax of "$opt" is not correct. Please consider the commandref.};
  }

  $data{$name}{statusapi}{'?IdPair'}{'?'.$pk}{rtid}   = $h->{rtid};
  $data{$name}{statusapi}{'?IdPair'}{'?'.$pk}{apikey} = $h->{apikey};

  writeCacheToFile ($hash, 'statusapi', $statcache.$name);                               # Status-API Cache sichern

  my $msg = qq{The Roof identification pair "$pk" has been saved. }.
            qq{Repeat the command if you want to save more Roof identification pairs.};

return $msg;
}

######################################################################
#                      Setter victronCredentials
# user, pwd,
# idsite nach /installation// aus:
# https://vrm.victronenergy.com/installation/XXXXX/...
######################################################################
sub _setVictronCredentials {                 ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $opt   = $paref->{opt};
  my $arg   = $paref->{arg};

  my $hash  = $defs{$name};
  my $msg;

  if (!$arg) {
      return qq{The command "$opt" needs an argument !};
  }

  my ($a,$h) = parseParams ($arg);

  if ($a->[0] && $a->[0] eq 'delete') {
      delete $data{$name}{statusapi}{'?VRM'};
      $msg = qq{Credentials for the Victron VRM API are deleted. };
  }
  else {
      if (!$h->{user} || !$h->{pwd} || !$h->{idsite}) {
          return qq{The syntax of "$opt" is not correct. Please consider the commandref.};
      }

      my $serial = eval { freeze ($h)
                        }
                        or do { return "Serialization ERROR: $@" };

      $data{$name}{statusapi}{'?VRM'}{'?API'}{credentials} = chew ($serial);
      $msg = qq{Credentials for the Victron VRM API has been saved.};
  }

  writeCacheToFile ($hash, 'statusapi', $statcache.$name);                               # Status-API Cache sichern

return $msg;
}

################################################################
#       Setter operationMode
################################################################
sub _setoperationMode {                  ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $prop  = $paref->{prop} // return qq{no mode specified};

  my $hash  = $defs{$name};

  singleUpdateState ( {hash => $hash, state => $prop, evt => 1} );

return;
}

################################################################
#     Setter powerTrigger / batterytrigger / energyH4Trigger
################################################################
sub _setTrigger {                        ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $opt   = $paref->{opt};
  my $arg   = $paref->{arg};

  if (!$arg) {
      return qq{The command "$opt" needs an argument !};
  }

  my ($a,$h) = parseParams ($arg);

  if (!$h) {
      return qq{The syntax of "$opt" is not correct. Please consider the commandref.};
  }

  for my $key (keys %{$h}) {
      if ($key !~ /^[0-9]+(?:on|off)$/x || $h->{$key} !~ /^[0-9]+$/x) {
          return qq{The key "$key" is invalid. Please consider the commandref.};
      }
  }

  my $hash = $defs{$name};

  if ($opt eq 'powerTrigger') {
      deleteReadingspec    ($hash, 'powerTrigger.*');
      readingsSingleUpdate ($hash, 'powerTrigger',    $arg, 1);
  }
  elsif ($opt eq 'batteryTrigger') {
      deleteReadingspec    ($hash, 'batteryTrigger.*');
      readingsSingleUpdate ($hash, 'batteryTrigger',  $arg, 1);
  }
  elsif ($opt eq 'energyH4Trigger') {
      deleteReadingspec    ($hash, 'energyH4Trigger.*');
      readingsSingleUpdate ($hash, 'energyH4Trigger', $arg, 1);
  }

  writeCacheToFile ($hash, 'plantconfig', $plantcfg.$name);                              # Anlagenkonfiguration File schreiben

return;
}

################################################################
#      Setter / (verborgener) Getter plantConfiguration
################################################################
sub _setplantConfiguration {             ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $opt   = $paref->{opt};
  my $arg   = $paref->{arg};

  my $hash  = $defs{$name};
  my ($err,$nr,$na,@pvconf);

  $arg = 'check' if (!$arg);

  if ($arg eq "check") {
      my $out = checkPlantConfig ($hash);
      $out    = qq{<html>$out</html>};

      ## asynchrone Ausgabe
      #######################
      #$err          = getClHash($hash);
      #$paref->{out} = $out;
      #InternalTimer(gettimeofday()+3, "FHEM::SolarForecast::__plantCfgAsynchOut", $paref, 0);

      return $out;
  }

  if ($arg eq "save") {
      ($err, $nr, $na) = writeCacheToFile ($hash, 'plantconfig', $plantcfg.$name);             # Anlagenkonfiguration fileStore schreiben

      if ($err) {
          return $err;
      }
      else {
          return qq{Plant Configuration has been written to file "$plantcfg.$name". Number of saved Readings/Attributes: $nr/$na};
      }
  }

  if ($arg eq "restore") {
      $paref->{file}      = $plantcfg.$name;
      $paref->{cachename} = 'plantconfig';
      $paref->{title}     = 'Plant Configuration';
      ($err, $nr, $na)    = readCacheFile ($paref);

      if (!$err) {
          if ($nr || $na) {
              setModel ($hash);
              return qq{Plant Configuration restored from file "$plantcfg.$name". Number of restored Readings/Attributes: $nr/$na};
          }
          else {
              return qq{The Plant Configuration file "}.$plantcfg.$name.qq{" was empty, nothing restored};
          }
      }
      else {
          return $err;
      }
  }

return;
}

################################################################
#   asynchrone Ausgabe Ergbnis Plantconfig Check
################################################################
sub __plantCfgAsynchOut {
  my $paref = shift;
  my $name  = $paref->{name};
  my $out   = $paref->{out};

  my $hash  = $defs{$name};

  asyncOutput($hash->{HELPER}{CL}{1}, $out);
  delClHash  ($name);

return;
}

################################################################
#                      Setter pvCorrectionFactor
################################################################
sub _setpvCorrectionFactor {             ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $opt   = $paref->{opt};
  my $prop  = $paref->{prop} // return qq{no correction value specified};

  my $hash  = $defs{$name};

  if ($prop !~ /[0-9,.]/x) {
      return qq{The correction value must be specified by numbers and optionally with decimal places};
  }

  $prop =~ s/,/./x;

  my ($acu, $aln) = isAutoCorrUsed ($name);
  my $mode        = $acu =~ /on/xs ? 'manual flex' : 'manual fix';

  readingsSingleUpdate ($hash, $opt, $prop." ($mode)", 1);
  centralTask          ($hash, 0);

return;
}

################################################################
#                 Setter pvCorrectionFactor_Auto
################################################################
sub _setpvCorrectionFactorAuto {         ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $opt   = $paref->{opt};
  my $prop  = $paref->{prop} // return qq{no correction value specified};

  my $hash  = $defs{$name};

  if ($prop eq 'noLearning') {
      my $pfa = ReadingsVal ($name, 'pvCorrectionFactor_Auto', 'off');           # aktuelle Autokorrektureinstellung
      $prop   = $pfa.' '.$prop;
  }

  readingsSingleUpdate ($hash, 'pvCorrectionFactor_Auto', $prop, 1);

  if ($prop eq 'off') {
      for my $n (1..24) {
          $n     = sprintf "%02d", $n;
          my $rv = ReadingsVal ($name, "pvCorrectionFactor_${n}", "");

          if ($rv !~ /manual/xs) {
              deleteReadingspec ($hash, "pvCorrectionFactor_${n}.*");
          }
          else {
              $rv =~ s/flex/fix/xs;
              readingsSingleUpdate ($hash, "pvCorrectionFactor_${n}", $rv, 0);
          }
      }
  }
  elsif ($prop =~ /on/xs) {
      for my $n (1..24) {
          $n     = sprintf "%02d", $n;
          my $rv = ReadingsVal ($name, "pvCorrectionFactor_${n}", "");

          if ($rv =~ /manual/xs) {
              $rv =~ s/fix/flex/xs;
              readingsSingleUpdate ($hash, "pvCorrectionFactor_${n}", $rv, 0);
          }
      }
  }

  writeCacheToFile ($hash, 'plantconfig', $plantcfg.$name);                    # Anlagenkonfiguration sichern

return;
}

################################################################
#                      Setter reset
################################################################
sub _setreset {                          ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $prop  = $paref->{prop} // return qq{no source specified for reset};
  my $type  = $paref->{type};
  my $hash  = $defs{$name};

  if ($prop eq 'pvHistory') {
      my $dday  = $paref->{prop1} // "";                                       # ein bestimmter Tag der pvHistory angegeben ?
      my $dhour = $paref->{prop2} // "";                                       # eine bestimmte Stunde eines Tages der pvHistory angegeben ?

      if ($dday) {
          $dday = sprintf "%02d", $dday;
          if ($dhour) {
              $dhour = sprintf "%02d", $dhour;

              delete $data{$name}{pvhist}{$dday}{$dhour};

              Log3 ($name, 3, qq{$name - Day "$dday" hour "$dhour" deleted from pvHistory});

              $paref->{reorg}    = 1;                                          # den Tag Stunde "99" reorganisieren
              $paref->{reorgday} = $dday;
              $paref->{histname} = '';

              setPVhistory ($paref);

              delete $paref->{reorg};
              delete $paref->{reorgday};
              delete $paref->{histname};
          }
          else {
              delete $data{$name}{pvhist}{$dday};
              Log3 ($name, 3, qq{$name - Day "$dday" deleted from pvHistory});
          }
      }
      else {
          delete $data{$name}{pvhist};
          Log3 ($name, 3, qq{$name - all days deleted from pvHistory});
      }

      return;
  }

  if ($prop eq 'consumptionHistory') {
      my $dday  = $paref->{prop1} // "";                                       # ein bestimmter Tag der pvHistory angegeben ?
      my $dhour = $paref->{prop2} // "";                                       # eine bestimmte Stunde eines Tages der pvHistory angegeben ?

      if ($dday) {
          if ($dhour) {
              delete $data{$name}{pvhist}{$dday}{$dhour}{con};
              Log3 ($name, 3, qq{$name - consumption day "$dday" hour "$dhour" deleted from pvHistory});

              $paref->{reorg}    = 1;                                          # den Tag Stunde "99" reorganisieren
              $paref->{reorgday} = $dday;
              $paref->{histname} = '';

              setPVhistory ($paref);

              delete $paref->{reorg};
              delete $paref->{reorgday};
              delete $paref->{histname};
          }
          else {
              for my $hr (sort keys %{$data{$name}{pvhist}{$dday}}) {
                  delete $data{$name}{pvhist}{$dday}{$hr}{con};
              }

              Log3 ($name, 3, qq{$name - consumption day "$dday" deleted from pvHistory});
          }
      }
      else {
          for my $dy (sort keys %{$data{$name}{pvhist}}) {
              for my $hr (sort keys %{$data{$name}{pvhist}{$dy}}) {
                  delete $data{$name}{pvhist}{$dy}{$hr}{con};
              }
          }

          Log3 ($name, 3, qq{$name - all saved consumption deleted from pvHistory});
      }

      return;
  }

  if ($prop eq 'pvCorrection') {
      my $dt  = timestringsFromOffset (time, 0);
      my $hod = $dt->{hour} + 1;
      
      for my $n (1..24) {
          $n = sprintf "%02d", $n;
          deleteReadingspec ($hash, "pvCorrectionFactor_${n}.*");
          deleteReadingspec ($hash, ".signaldone_${n}") if($n >= $hod);      # Steuerreadings vor aktueller Stunde nicht löschen -> Dopplungsgefahr im Korrektursystem
      }

      my $circ  = $paref->{prop1} // 'no';                                   # alle pvKorr-Werte aus Caches löschen ?
      my $circh = $paref->{prop2} // q{};                                    # pvKorr-Werte einer bestimmten Stunde aus Caches löschen ?

      if ($circ eq 'cached') {
          if ($circh) {
              delete $data{$name}{circular}{$circh}{pvcorrf};
              delete $data{$name}{circular}{$circh}{quality};
              delete $data{$name}{circular}{$circh}{pvrlsum};
              delete $data{$name}{circular}{$circh}{pvfcsum};
              delete $data{$name}{circular}{$circh}{dnumsum};

              for my $k (keys %{$data{$name}{circular}{$circh}}) {
                  delete $data{$name}{circular}{$circh}{$k} if($k =~ /^(pvrl_|pvfc_)/xs);
              }

              for my $hid (keys %{$data{$name}{pvhist}}) {
                  delete $data{$name}{pvhist}{$hid}{$circh}{pvcorrf};
              }

              Log3($name, 3, qq{$name - stored PV correction factor of hour "$circh" from pvCircular and pvHistory deleted});
              return;
          }

          for my $hod (keys %{$data{$name}{circular}}) {
              delete $data{$name}{circular}{$hod}{pvcorrf};
              delete $data{$name}{circular}{$hod}{quality};
              delete $data{$name}{circular}{$hod}{pvrlsum};
              delete $data{$name}{circular}{$hod}{pvfcsum};
              delete $data{$name}{circular}{$hod}{dnumsum};

              for my $k (keys %{$data{$name}{circular}{$hod}}) {
                  delete $data{$name}{circular}{$hod}{$k} if($k =~ /^(pvrl_|pvfc_)/xs);
              }
          }

          for my $hid (keys %{$data{$name}{pvhist}}) {
              for my $hidh (keys %{$data{$name}{pvhist}{$hid}}) {
                  delete $data{$name}{pvhist}{$hid}{$hidh}{pvcorrf};
              }
          }

          Log3 ($name, 3, qq{$name - all stored PV correction factors from pvCircular and pvHistory deleted});
      }

      return;
  }

  if ($prop eq 'aiData') {
      delete $data{$name}{current}{aiinitstate};
      delete $data{$name}{current}{aitrainstate};
      delete $data{$name}{current}{aiaddistate};
      delete $data{$name}{current}{aigetresult};

      delete $data{$name}{aidectree}{airaw};

      my @ftd = ( $airaw.$name,
                  $aitrained.$name
                );

      for my $f (@ftd) {
          my $err = FileDelete ($f);

          if ($err) {
              Log3 ($name, 1, qq{$name - ERROR deleting file $err});
          }
      }

      return;
  }

  if ($prop eq 'powerTriggerSet') {
      deleteReadingspec ($hash, "powerTrigger.*");
      writeCacheToFile  ($hash, "plantconfig", $plantcfg.$name);               # Anlagenkonfiguration File schreiben
      return;
  }

  if ($prop eq 'batteryTriggerSet') {
      deleteReadingspec ($hash, "batteryTrigger.*");
      writeCacheToFile  ($hash, "plantconfig", $plantcfg.$name);
      return;
  }

  if ($prop eq 'energyH4TriggerSet') {
      deleteReadingspec ($hash, "energyH4Trigger.*");
      writeCacheToFile  ($hash, "plantconfig", $plantcfg.$name);
      return;
  }

  readingsDelete ($hash, $prop);

  if ($prop eq 'roofIdentPair') {
      my $pk   = $paref->{prop1} // "";                                        # ein bestimmter PairKey angegeben ?

      if ($pk) {
          delete $data{$name}{statusapi}{'?IdPair'}{'?'.$pk};
          Log3 ($name, 3, qq{$name - roofIdentPair: pair key "$pk" deleted});
      }
      else {
          delete $data{$name}{statusapi}{'?IdPair'};
          Log3($name, 3, qq{$name - roofIdentPair: all pair keys deleted});
      }

      writeCacheToFile ($hash, 'solcastapi', $scpicache.$name);                      # Cache File SolCast API Werte schreiben
      return;
  }

  if ($prop eq 'consumerPlanning') {                                                 # Verbraucherplanung resetten
      my $c = $paref->{prop1} // "";                                                 # bestimmten Verbraucher setzen falls angegeben

      if ($c) {
          deleteConsumerPlanning ($hash, $c);
      }
      else {
          for my $cs (keys %{$data{$name}{consumers}}) {
              deleteConsumerPlanning ($hash, $cs);
          }
      }

      writeCacheToFile ($hash, 'consumers', $csmcache.$name);                        # Cache File Consumer schreiben
  }

  if ($prop eq 'consumerMaster') {                                                   # Verbraucherhash löschen
      my $c = $paref->{prop1} // '';                                                 # bestimmten Verbraucher setzen falls angegeben

      if ($c) {
          $paref->{c} = $c;
          delConsumerFromMem ($paref);                                               # spezifischen Consumer aus History löschen
      }
      else {
          for my $c (keys %{$data{$name}{consumers}}) {
              $paref->{c} = $c;
              delConsumerFromMem ($paref);                                           # alle Consumer aus History löschen
          }
      }

      delete $paref->{c};
      $data{$name}{current}{consumerCollected} = 0;                                  # Consumer neu sammeln

      writeCacheToFile ($hash, 'consumers', $csmcache.$name);                        # Cache File Consumer schreiben
      centralTask      ($hash, 0);
  }

  createAssociatedWith ($hash);

return;
}

################################################################
#                Setter operatingMemory
#          (Ersatz für Setter writeHistory)
################################################################
sub _setoperatingMemory {                ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $prop  = $paref->{prop} // return qq{no operation specified for command};

  my $hash  = $defs{$name};

  if ($prop eq 'save') {
      periodicWriteMemcache ($hash);                                           # Cache Files schreiben
  }

  if ($prop eq 'backup') {
      periodicWriteMemcache ($hash, 'bckp');                                   # Backup Files erstellen und alte Versionen löschen
  }

  if ($prop =~ /^recover-/xs) {                                                # Sicherung wiederherstellen
      my $file = (split "-", $prop)[1];

      Log3 ($name, 3, "$name - recover saved cache file: $file");

      if ($file =~ /^PVH_/xs) {                                                # Cache File PV History einlesen
          $paref->{cachename} = 'pvhist';
          $paref->{title}     = 'pvHistory';
      }

      if ($file =~ /^PVC_/xs) {                                                # Cache File PV Circular einlesen
          $paref->{cachename} = 'circular';
          $paref->{title}     = 'pvCircular';
      }

      $paref->{file} = "$cachedir/$file";
      readCacheFile ($paref);

      delete $paref->{file};
      delete $paref->{cachename};
      delete $paref->{title};
  }

return;
}

################################################################
#              Setter clientAction
#      ohne Menüeintrag ! für Aktivität aus Grafik
################################################################
sub _setclientAction {                 ## no critic "not used"
  my $paref   = shift;
  my $name    = $paref->{name};
  my $opt     = $paref->{opt};
  my $arg     = $paref->{arg};
  my $argsref = $paref->{argsref};

  my $hash    = $defs{$name};

  if (!$arg) {
      return qq{The command "$opt" needs an argument !};
  }

  my @args = @{$argsref};

  my $c        = shift @args;                                                 # Consumer Index (Nummer)
  my $evt      = shift @args;                                                 # Readings Event (state wird nicht gesteuert)
  my $action   = shift @args;                                                 # z.B. set, setreading
  my $cname    = shift @args;                                                 # Consumername
  my $tail     = join " ", map { my $p = $_; $p =~ s/\s//xg; $p; } @args;     ## no critic 'Map blocks' # restliche Befehlsargumente

  Log3 ($name, 4, qq{$name - Client Action received / execute: "$action $cname $tail"});

  if ($action eq 'set') {
      CommandSet (undef, "$cname $tail");
      my $async = ConsumerVal ($hash, $c, 'asynchron', 0);
      centralTask ($hash, $evt) if(!$async);                                  # nur wenn Consumer synchron arbeitet direkte Statusabfrage, sonst via Notify
      return;
  }

  if ($action eq 'get') {
      if($tail eq 'data') {
          centralTask ($hash, $evt);
          return;
      }
  }

  if ($action eq 'setreading') {
      CommandSetReading (undef, "$cname $tail");
  }

  if ($action eq 'consumerImmediatePlanning') {
      CommandSet (undef, "$name $action $cname $evt");
      return;
  }

  centralTask ($hash, $evt);

return;
}

################################################################
#                      Setter aiDecTree
################################################################
sub _setaiDecTree {                   ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $prop  = $paref->{prop} // return;

  if ($prop eq 'addInstAndTrain') {
      aiManageInstance ($paref);
  }
  elsif ($prop eq 'addRawData') {
      aiAddRawData ($paref);
  }
  elsif ($prop eq 'rawDataGHIreplace') {
      __getopenMeteoGHIreplace ($paref);
  }

return;
}

###############################################################
#                  SolarForecast Get
###############################################################
sub Get {
  my ($hash, @a) = @_;
  return "\"get X\" needs at least an argument" if ( @a < 2 );
  my $name = shift @a;
  my $opt  = shift @a;
  my $arg  = join " ", map { my $p = $_; $p =~ s/\s+/ /xg; $p; } @a;     ## no critic 'Map blocks'

  my $type = $hash->{TYPE};

  my @pha  = map {sprintf "%02d", $_} sort {$a<=>$b} keys %{$data{$name}{pvhist}};
  my @cla  = map {sprintf "%02d", $_} sort {$a<=>$b} keys %{$data{$name}{circular}};
  my @vcm  = map {sprintf "%02d", $_} sort {$a<=>$b} keys %{$data{$name}{consumers}};
  my @vba  = map {sprintf "%02d", $_} sort {$a<=>$b} keys %{$data{$name}{batteries}};
  my @vin  = map {sprintf "%02d", $_} sort {$a<=>$b} keys %{$data{$name}{inverters}};
  my @vpn  = map {sprintf "%02d", $_} sort {$a<=>$b} keys %{$data{$name}{producers}};
  my @vst  = sort keys %{$data{$name}{strings}};

  my $gol  = join ",", @gsopt;                                                       # Optionen der Grafikselektion
  my $pvl  = join ",", @pha;
  my $cll  = join ",", @cla;
  my $cml  = join ",", @vcm;
  my $bal  = join ",", @vba;
  my $inl  = join ",", @vin;
  my $pnl  = join ",", @vpn;
  my $str  = join ",", @vst;

  my $getlist = "Unknown argument $opt, choose one of ".
                "valBattery:#,$bal ".
                "valConsumerMaster:#,$cml ".
                "valInverter:#,$inl ".
                "valProducer:#,$pnl ".
                "valStrings:#,$str ".
                "data:noArg ".
                "dwdCatalog ".
                "forecastQualities:noArg ".
                "ftuiFramefiles:noArg ".
                "html:$gol ".
                "nextHours:noArg ".
                "pvCircular:#,$cll ".
                "pvHistory:#,exportToCsv,$pvl ".
                "rooftopData:noArg ".
                "radiationApiData:noArg ".
                "statusApiData:noArg ".
                "valCurrent:noArg ".
                "weatherApiData:noArg "
                ;

  ## KI spezifische Getter
  ##########################                                                 
  my $vdtopt = 'aiRawData';

  if (isPrepared4AI ($hash)) {
       $vdtopt .= ',';
       $vdtopt .= 'aiRuleStrings';
  }

  if ($vdtopt) {
      $getlist .= "valDecTree:$vdtopt ";
  }

  my (undef, $disabled, $inactive) = controller ($name);
  return if($disabled || $inactive);

  my $t      = int time;
  my $params = {
      name  => $name,
      type  => $type,
      opt   => $opt,
      arg   => $arg,
      t     => $t,
      chour => (strftime "%H",       localtime($t)),                                            # aktuelle Stunde in 24h format (00-23)
      date  => (strftime "%Y-%m-%d", localtime($t)),
      day   => (strftime "%d",       localtime($t)),                                            # aktueller Tag (range 01 .. 31)
      debug => getDebug ($hash),
      lang  => getLang  ($hash)
  };

  if ($hget{$opt} && defined &{$hget{$opt}{fn}}) {
      my $ret = q{};

      if (!$hash->{CREDENTIALS} && $hget{$opt}{needcred}) {
          return qq{Credentials for "$opt" are not set. Please save the the credentials with the appropriate Set command."};
      }

      $params->{force} = 1 if($opt eq 'rooftopData');                       # forcierter (manueller) Abruf SolCast API

      $ret = &{$hget{$opt}{fn}} ($params);
      return $ret;
  }

return $getlist;
}

################################################################
#                Getter roofTop data
################################################################
sub _getRoofTopData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $hash  = $defs{$name};

  delete $data{$name}{current}{dwdRad1hAge};
  delete $data{$name}{current}{dwdRad1hAgeTS};

  my ($rapi, $wapi) = getStatusApiName ($hash);                                       # $rapi - Radiation-API, $wapi - Weather-API
  my $ret           = "$name is not a valid Radiation ($rapi) and/or Weather ($wapi) Model";


  if ($rapi eq 'SolCast') {
      $ret = __getSolCastData ($paref);
  }
  elsif ($rapi eq 'ForecastSolar') {
      $ret = __getForecastSolarData ($paref);
  }
  elsif ($rapi eq 'DWD') {
      $ret = __getDWDSolarData ($paref);
  }
  elsif ($rapi eq 'VictronKi') {
      $ret = __getVictronSolarData ($paref);
  }

  if ($rapi eq 'OpenMeteo' || $wapi eq 'OpenMeteo') {
      if ($rapi eq 'OpenMeteo') {
          $paref->{reqm} = 'MODEL';
      }
      else {
          $paref->{reqm} = 'WEATHERMODEL';
      }

      $ret = __getopenMeteoData ($paref);
  }

  delete $paref->{reqm};

return $ret;
}

################################################################
#                Abruf SolCast roofTop data
################################################################
sub __getSolCastData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $force = $paref->{force} // 0;
  my $t     = $paref->{t}     // time;
  my $debug = $paref->{debug};
  my $lang  = $paref->{lang};

  my $hash  = $defs{$name};

  my $msg;
  if ($ctzAbsent) {
      $msg = qq{The library FHEM::Utility::CTZ is missing. Please update FHEM completely.};
      Log3 ($name, 1, "$name - ERROR - $msg");
      return $msg;
  }

  my $rmf = reqModFail();
  if ($rmf) {
      $msg = "You have to install the required perl module: ".$rmf;
      Log3 ($name, 1, "$name - ERROR - $msg");
      return $msg;
  }

  ## statische SolCast API Kennzahlen
  ## (solCastAPIcallMultiplier, todayMaxAPIcalls) berechnen
  ##########################################################
  my %mx;
  my $maxcnt = 1;

  my $type = $paref->{type};

  for my $pk (keys %{$data{$name}{statusapi}{'?IdPair'}}) {
      my $apikey = StatusAPIVal ($hash, '?IdPair', $pk, 'apikey', '');
      next if(!$apikey);

      $mx{$apikey} += 1;
      $maxcnt       = $mx{$apikey} if(!$maxcnt || $mx{$apikey} > $maxcnt);
  }

  my $apimaxreq = AttrVal ($name, 'ctrlSolCastAPImaxReq', SOLCMAXREQDEF);
  my $madc      = sprintf "%.0f", ($apimaxreq / $maxcnt);                                          # max. tägliche Anzahl API Calls
  my $mpk       = $maxcnt;                                                                         # Requestmultiplikator

  $data{$name}{statusapi}{SolCast}{'?All'}{solCastAPIcallMultiplier}  = $mpk;
  $data{$name}{statusapi}{SolCast}{'?All'}{todayMaxAPIcalls}          = $madc;

  #########################

  if (!$force) {                                                                                   # regulärer SolCast API Abruf
      my ($rapi, $wapi) = getStatusApiName ($hash);
      my $trc           = StatusAPIVal ($hash, $rapi, '?All', 'todayRemainingAPIcalls', $madc);
      my $etxt          = $hqtxt{bnsas}{$lang};
      $etxt            =~ s{<WT>}{(LEADTIME/60)}eg;

      if ($trc <= 0) {
          readingsSingleUpdate ($hash, 'nextRadiationAPICall', $etxt, 1);
          return qq{SolCast free daily limit is used up};
      }

      my $date   = $paref->{date};
      my $srtime = timestringToTimestamp ($date.' '.ReadingsVal($name, "Today_SunRise", '23:59').':59');
      my $sstime = timestringToTimestamp ($date.' '.ReadingsVal($name, "Today_SunSet",  '00:00').':00');

      if ($t < $srtime - LEADTIME || $t > $sstime + LAGTIME) {
          readingsSingleUpdate($hash, 'nextRadiationAPICall', $etxt, 1);
          return "The current time is not between sunrise minus ".(LEADTIME/60)." minutes and sunset";
      }

      my $lrt    = StatusAPIVal ($hash, $rapi, '?All', 'lastretrieval_timestamp',           0);
      my $apiitv = StatusAPIVal ($hash, $rapi, '?All', 'currentAPIinterval',     SOLAPIREPDEF);

      if ($lrt && $t < $lrt + $apiitv) {
          my $rt = $lrt + $apiitv - $t;
          return qq{The waiting time to the next SolCast API call has not expired yet. The remaining waiting time is $rt seconds};
      }
  }

  if ($debug =~ /apiCall/x) {
      Log3 ($name, 1, "$name DEBUG> SolCast API Call - max possible daily API requests: $apimaxreq");
      Log3 ($name, 1, "$name DEBUG> SolCast API Call - Requestmultiplier: $mpk");
      Log3 ($name, 1, "$name DEBUG> SolCast API Call - possible daily API Calls: $madc");
  }

  $paref->{allstrings} = AttrVal ($name, 'setupInverterStrings', '');
  $paref->{firstreq}   = 1;                                                                   # 1. Request, V 0.80.18

  __solCast_ApiRequest ($paref);

return;
}

################################################################################################
#                SolCast Api Request
#
# noch testen und einbauen Abruf aktuelle Daten ohne Rooftops
# (aus https://www.solarquotes.com.au/blog/how-to-use-solcast/):
# https://api.solcast.com.au/pv_power/estimated_actuals?longitude=12.067722&latitude=51.285272&
# capacity=5130&azimuth=180&tilt=30&format=json&api_key=....
#
################################################################################################
sub __solCast_ApiRequest {
  my $paref      = shift;
  my $name       = $paref->{name};
  my $allstrings = $paref->{allstrings};                                # alle Strings
  my $debug      = $paref->{debug};

  my $hash       = $defs{$name};

  if (!$allstrings) {                                                   # alle Strings wurden abgerufen
      return;
  }

  my $string;
  ($string, $allstrings) = split ",", $allstrings, 2;

  my $rft    = AttrVal     ($name, 'setupRoofTops', '');
  my ($a,$h) = parseParams ($rft);

  my $pk     = $h->{$string} // q{};
  my $roofid = StatusAPIVal ($hash, '?IdPair', '?'.$pk, 'rtid',   '');
  my $apikey = StatusAPIVal ($hash, '?IdPair', '?'.$pk, 'apikey', '');

  if (!$roofid || !$apikey) {
      my $err = qq{The roofIdentPair "$pk" of String "$string" has no Rooftop-ID and/or SolCast-API key assigned !};
      singleUpdateState ( {hash => $hash, state => $err, evt => 1} );
      return $err;
  }

  my $url = "https://api.solcast.com.au/rooftop_sites/".
            $roofid.
            "/forecasts?format=json".
            "&hours=72".                                               # Forum:#134226 -> Abruf 72h statt 48h
            "&api_key=".
            $apikey;

  debugLog ($paref, "apiProcess|apiCall", qq{Request SolCast API for PV-String "$string": $url});

  my $caller = (caller(0))[3];                                         # Rücksprungmarke

  my $param = {
      url        => $url,
      timeout    => APITIMEOUT,
      name       => $name,
      type       => $paref->{type},
      debug      => $debug,
      caller     => \&$caller,
      stc        => [gettimeofday],
      allstrings => $allstrings,
      string     => $string,
      lang       => $paref->{lang},
      firstreq   => $paref->{firstreq},
      method     => "GET",
      callback   => \&__solCast_ApiResponse
  };

  if ($debug =~ /apiCall/x) {
      $param->{loglevel} = 1;
  }

  HttpUtils_NonblockingGet ($param);

return;
}

###############################################################
#                  SolCast Api Response
###############################################################
sub __solCast_ApiResponse {
  my $paref      = shift;
  my $err        = shift;
  my $myjson     = shift;

  my $name        = $paref->{name};
  my $caller      = $paref->{caller};
  my $string      = $paref->{string};
  my $allstrings  = $paref->{allstrings};
  my $stc         = $paref->{stc};                                                                          # Startzeit API Abruf
  my $lang        = $paref->{lang};
  my $debug       = $paref->{debug};
  my $type        = $paref->{type};

  $paref->{t}     = time;

  my $msg;
  my $hash = $defs{$name};
  my $sta  = [gettimeofday];                                                                                # Start Response Verarbeitung

  if ($err ne "") {
      $msg = 'SolCast API server response: '.$err;

      Log3 ($name, 1, "$name - $msg");

      $data{$name}{statusapi}{SolCast}{'?All'}{response_message} = $err;

      singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );
      $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
      $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

      return;
  }
  elsif ($myjson ne "") {                                                                                  # Evaluiere ob Daten im JSON-Format empfangen wurden
      my ($success) = evaljson ($hash, $myjson);

      if (!$success) {
          $msg = 'ERROR - invalid SolCast API server response';

          Log3 ($name, 1, "$name - $msg");

          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );
          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          return;
      }

      my $jdata = decode_json ($myjson);

      if ($debug eq 'apiProcess') {
          Log3 ($name, 1, qq{$name DEBUG> SolCast API server response for string "$string":\n}. Dumper $jdata);
      }

      ## bei Überschreitung Limit kommt:
      ####################################
      #  'response_status' => {
      #                         'message' => 'You have exceeded your free daily limit.',
      #                         'errors' => [],
      #                         'error_code' => 'TooManyRequests'
      #                       }

      if (defined $jdata->{'response_status'}) {
          $msg = 'SolCast API server response: '.$jdata->{'response_status'}{'message'};

          Log3 ($name, 3, "$name - $msg");

          ___setSolCastAPIcallKeyData ($paref);

          $data{$name}{statusapi}{SolCast}{'?All'}{response_message} = $jdata->{'response_status'}{'message'};

          if ($jdata->{'response_status'}{'error_code'} eq 'TooManyRequests') {
              $data{$name}{statusapi}{SolCast}{'?All'}{todayRemainingAPIrequests} = 0;
          }

          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );
          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          if ($debug =~ /apiProcess|apiCall/x) {
              my $apimaxreq = AttrVal ($name, 'ctrlSolCastAPImaxReq', SOLCMAXREQDEF);

              Log3 ($name, 1, "$name DEBUG> SolCast API Call - response status: ".$jdata->{'response_status'}{'message'});
              Log3 ($name, 1, "$name DEBUG> SolCast API Call - todayRemainingAPIrequests: ".StatusAPIVal ($hash, 'SolCast', '?All', 'todayRemainingAPIrequests', $apimaxreq));
          }

          return;
      }

      my ($period,$starttmstr);
      my $k = 0;

      while ($jdata->{'forecasts'}[$k]) {                                                                # vorhandene Startzeiten Schlüssel im SolCast API Hash löschen
          my $petstr          = $jdata->{'forecasts'}[$k]{'period_end'};
          ($err, $starttmstr) = ___convPendToPstart ($name, $lang, $petstr);

          if ($err) {
              Log3 ($name, 1, "$name - $err");

              singleUpdateState ( {hash => $hash, state => $err, evt => 1} );
              return;
          }

          if (!$k && $petstr =~ /T\d{2}:00/xs) {                                                         # spezielle Behandlung ersten Datensatz wenn period_end auf volle Stunde fällt (es fehlt dann der erste Teil der Stunde)
              $period   = $jdata->{'forecasts'}[$k]{'period'};                                           # -> dann bereits beim letzten Abruf gespeicherte Daten der aktuellen Stunde durch 2 teilen damit
              $period   =~ s/.*(\d\d).*/$1/;                                                             # -> die neuen Daten (in dem Fall nur die einer halben Stunde) im nächsten Schritt addiert werden

              my $est50 = RadiationAPIVal ($hash, $string, $starttmstr, 'pv_estimate50', 0) / (60/$period);
              $data{$name}{solcastapi}{$string}{$starttmstr}{pv_estimate50} = sprintf "%.0f", $est50 if($est50);

              $k++;
              next;
          }

          delete $data{$name}{solcastapi}{$string}{$starttmstr};

          $k++;
      }

      $k = 0;

      while ($jdata->{'forecasts'}[$k]) {
          if (!$jdata->{'forecasts'}[$k]{'pv_estimate'}) {                                              # keine PV Prognose -> Datensatz überspringen -> Verarbeitungszeit sparen
              $k++;
              next;
          }

          my $petstr          = $jdata->{'forecasts'}[$k]{'period_end'};
          ($err, $starttmstr) = ___convPendToPstart ($name, $lang, $petstr);

          my $pvest50         = $jdata->{'forecasts'}[$k]{'pv_estimate'};

          $period             = $jdata->{'forecasts'}[$k]{'period'};
          $period             =~ s/.*(\d\d).*/$1/;

          $pvest50            = sprintf "%.0f", ($pvest50 * ($period/60) * 1000);

          if ($debug =~ /apiProcess/x) {                                                                     # nur für Debugging
              if (exists $data{$name}{solcastapi}{$string}{$starttmstr}) {
                  Log3 ($name, 1, qq{$name DEBUG> SolCast API Hash - Start Date/Time: }. $starttmstr);
                  Log3 ($name, 1, qq{$name DEBUG> SolCast API Hash - pv_estimate50 add: }.$pvest50.qq{, contains already: }.RadiationAPIVal ($hash, $string, $starttmstr, 'pv_estimate50', 0));
              }
          }

          $data{$name}{solcastapi}{$string}{$starttmstr}{pv_estimate50} += $pvest50;

          $k++;
      }
  }

  Log3 ($name, 4, qq{$name - SolCast API answer received for string "$string"});

  ___setSolCastAPIcallKeyData ($paref);

  $data{$name}{statusapi}{SolCast}{'?All'}{response_message} = 'success';

  my $param = {
      name       => $name,
      type       => $type,
      debug      => $debug,
      allstrings => $allstrings,
      lang       => $lang
  };

  $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
  $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

return &$caller($param);
}

###############################################################
#      SolCast API: berechne Startzeit aus 'period_end'
###############################################################
sub ___convPendToPstart {
  my $name   = shift;
  my $lang   = shift;
  my $petstr = shift;

  my $cpar = {
      name      => $name,
      pattern   => '%Y-%m-%dT%H:%M:%S',
      dtstring  => $petstr,
      tzcurrent => 'UTC',
      tzconv    => 'local',
      writelog  => 0
  };

  my ($err, $cpets) = convertTimeZone ($cpar);

  if ($err) {
      $err = 'ERROR while converting time zone: '.$err;
      return $err;
  }

  my ($cdatest,$ctimestr) = split " ", $cpets;                                            # Datumstring YYYY-MM-TT / Zeitstring hh:mm:ss
  my ($chrst,$cminutstr)  = split ":", $ctimestr;
  $chrst                  = int ($chrst);

  if ($cminutstr eq '00') {                                                               # Zeit/Periodenkorrektur
      $chrst -= 1;

      if ($chrst < 0) {
          my $nt     = (timestringToTimestamp ($cdatest.' 00:00:00')) - 3600;
          $nt        = (timestampToTimestring ($nt, $lang))[1];
          ($cdatest) = split " ", $nt;
          $chrst     = 23;
      }
  }

  my $starttmstr = $cdatest." ".(sprintf "%02d", $chrst).":00:00";                        # Startzeit von pv_estimate

return ($err, $starttmstr);
}

################################################################
#  Kennzahlen des letzten Abruf SolCast API setzen
#  $t - Unix Timestamp
################################################################
sub ___setSolCastAPIcallKeyData {
  my $paref = shift;

  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $lang  = $paref->{lang};
  my $debug = $paref->{debug};
  my $t     = $paref->{t} // time;

  my $hash  = $defs{$name};

  $data{$name}{statusapi}{SolCast}{'?All'}{lastretrieval_time}      = (timestampToTimestring ($t, $lang))[3];       # letzte Abrufzeit
  $data{$name}{statusapi}{SolCast}{'?All'}{lastretrieval_timestamp} = $t;                                           # letzter Abrufzeitstempel

  my $apimaxreq = AttrVal       ($name, 'ctrlSolCastAPImaxReq',        SOLCMAXREQDEF);
  my $mpl       = StatusAPIVal ($hash, 'SolCast', '?All', 'solCastAPIcallMultiplier', 1);
  my $ddc       = StatusAPIVal ($hash, 'SolCast', '?All', 'todayDoneAPIcalls',        0);

  $ddc         += 1 if($paref->{firstreq});
  my $drc       = StatusAPIVal ($hash, 'SolCast', '?All', 'todayMaxAPIcalls', $apimaxreq / $mpl) - $ddc;               # verbleibende SolCast API Calls am aktuellen Tag
  $drc          = 0 if($drc < 0);

  $data{$name}{statusapi}{SolCast}{'?All'}{todayDoneAPIrequests} = $ddc * $mpl;

  my $drr       = $apimaxreq - ($mpl * $ddc);
  $drr          = 0 if($drr < 0);

  $data{$name}{statusapi}{SolCast}{'?All'}{todayRemainingAPIrequests} = $drr;
  $data{$name}{statusapi}{SolCast}{'?All'}{todayRemainingAPIcalls}    = $drc;
  $data{$name}{statusapi}{SolCast}{'?All'}{todayDoneAPIcalls}         = $ddc;

  debugLog ($paref, "apiProcess|apiCall", "SolCast API Call - done API Calls: $ddc");

  ## Berechnung des optimalen Request Intervalls
  ################################################
  my $date   = strftime "%Y-%m-%d", localtime($t);
  my $sunset = $date.' '.ReadingsVal ($name, "Today_SunSet", '00:00').':00';
  my $sstime = timestringToTimestamp ($sunset);
  my $dart   = $sstime - $t;                                                                                          # verbleibende Sekunden bis Sonnenuntergang
  $dart      = 0 if($dart < 0);
  $drc      += 1;

  $data{$name}{statusapi}{SolCast}{'?All'}{currentAPIinterval} = SOLAPIREPDEF;
  $data{$name}{statusapi}{SolCast}{'?All'}{currentAPIinterval} = int ($dart / $drc) if($dart && $drc);

  debugLog ($paref, "apiProcess|apiCall", "SolCast API Call - Sunset: $sunset, remain Sec to Sunset: $dart, new interval: ".StatusAPIVal ($hash, 'SolCast', '?All', 'currentAPIinterval', SOLAPIREPDEF));

  my $apiitv = StatusAPIVal ($hash, 'SolCast', '?All', 'currentAPIinterval', SOLAPIREPDEF);

  if ($debug =~ /apiProcess|apiCall/x) {
      Log3 ($name, 1, "$name DEBUG> SolCast API Call - remaining API Calls: ".($drc - 1));
      Log3 ($name, 1, "$name DEBUG> SolCast API Call - next API Call: ".(timestampToTimestring ($t + $apiitv, $lang))[0]);
  }

  readingsSingleUpdate ($hash, 'nextRadiationAPICall', $hqtxt{after}{$lang}.' '.(timestampToTimestring ($t + $apiitv, $lang))[0], 1);

return;
}

################################################################
#             Abruf ForecastSolar-API data
################################################################
sub __getForecastSolarData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $force = $paref->{force} // 0;
  my $t     = $paref->{t}     // time;
  my $lang  = $paref->{lang};

  my $hash  = $defs{$name};

  if (!$force) {                                                                                   # regulärer API Abruf
      my $etxt   = $hqtxt{bnsas}{$lang};
      $etxt      =~ s{<WT>}{(LEADTIME/60)}eg;
      my $date   = strftime "%Y-%m-%d", localtime($t);
      my $srtime = timestringToTimestamp ($date.' '.ReadingsVal($name, "Today_SunRise", '23:59').':59');
      my $sstime = timestringToTimestamp ($date.' '.ReadingsVal($name, "Today_SunSet",  '00:00').':00');

      if ($t < $srtime - LEADTIME || $t > $sstime + LAGTIME) {
          readingsSingleUpdate ($hash, 'nextRadiationAPICall', $etxt, 1);
          return "The current time is not between sunrise minus ".(LEADTIME/60)." minutes and sunset";
      }

      my $lrt    = StatusAPIVal ($hash, 'ForecastSolar', '?All', 'lastretrieval_timestamp',            0);
      my $apiitv = StatusAPIVal ($hash, 'ForecastSolar', '?All', 'currentAPIinterval',     FORAPIREPDEF);

      if ($lrt && $t < $lrt + $apiitv) {
          my $rt = $lrt + $apiitv - $t;
          return qq{The waiting time to the next SolCast API call has not expired yet. The remaining waiting time is $rt seconds};
      }
  }

  $paref->{allstrings} = AttrVal ($name, 'setupInverterStrings', '');

  __forecastSolar_ApiRequest ($paref);

return;
}

################################################################################################
#                ForecastSolar Api Request
#
#  Quelle Seite: https://doc.forecast.solar/api:estimate
#  Aufruf:       https://api.forecast.solar/estimate/:lat/:lon/:dec/:az/:kwp
#  Beispiel:     https://api.forecast.solar/estimate/51.285272/12.067722/45/S/5.13
#
#  Locate Check: https://api.forecast.solar/check/:lat/:lon
#  Docku:        https://doc.forecast.solar/api
#
# :!:   Please note that the forecasts are updated at the earliest every 15 min.
#       due to the weather data used, so it makes no sense to query more often than every 15 min.!
#
# :!:   If you get an 404 Page not found please always double check your URL.
#       The API ist very strict configured to reject maleformed queries as early as possible to
#       minimize server load!
#
# :!:   Each quarter (1st of month around midnight UTC) there is a scheduled maintenance planned.
#       You will get then a HTTP code 503 as response.
#
################################################################################################
sub __forecastSolar_ApiRequest {
  my $paref      = shift;
  my $name       = $paref->{name};
  my $type       = $paref->{type};
  my $allstrings = $paref->{allstrings};                                               # alle Strings
  my $debug      = $paref->{debug};

  my $hash       = $defs{$name};

  if (!$allstrings) {                                                                  # alle Strings wurden abgerufen
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{todayDoneAPIcalls} += 1;
      return;
  }

  my $string;
  ($string, $allstrings) = split ",", $allstrings, 2;

  my ($set, $lat, $lon) = locCoordinates();

  if (!$set) {
      my $err = qq{the attribute 'latitude' and/or 'longitude' in global device is not set};
      singleUpdateState ( {hash => $hash, state => $err, evt => 1} );
      return $err;
  }

  my $tilt = StringVal ($name, $string, 'tilt',   '<unknown>');
  my $az   = StringVal ($name, $string, 'azimut', '<unknown>');
  my $peak = StringVal ($name, $string, 'peak',   '<unknown>');

  my $url = "https://api.forecast.solar/estimate/watthours/period/".
            $lat."/".
            $lon."/".
            $tilt."/".
            $az."/".
            $peak;

  debugLog ($paref, "apiCall", qq{ForecastSolar API Call - Request for PV-String "$string":\n$url});

  my $caller = (caller(0))[3];                                                                        # Rücksprungmarke

  my $param = {
      url        => $url,
      timeout    => APITIMEOUT,
      name       => $name,
      type       => $type,
      debug      => $debug,
      header     => 'Accept: application/json',
      caller     => \&$caller,
      stc        => [gettimeofday],
      allstrings => $allstrings,
      string     => $string,
      lang       => $paref->{lang},
      method     => 'GET',
      callback   => \&__forecastSolar_ApiResponse
  };

  if ($debug =~ /apiCall/x) {
      $param->{loglevel} = 1;
  }

  HttpUtils_NonblockingGet ($param);

return;
}

###############################################################
#                  ForecastSolar API Response
###############################################################
sub __forecastSolar_ApiResponse {
  my $paref      = shift;
  my $err        = shift;
  my $myjson     = shift;

  my $name        = $paref->{name};
  my $caller      = $paref->{caller};
  my $string      = $paref->{string};
  my $allstrings  = $paref->{allstrings};
  my $stc         = $paref->{stc};                                                                          # Startzeit API Abruf
  my $lang        = $paref->{lang};
  my $debug       = $paref->{debug};
  my $type        = $paref->{type};

  my $hash        = $defs{$name};
  my $t           = time;
  $paref->{t}     = $t;

  my $msg;

  my $sta = [gettimeofday];                                                                                # Start Response Verarbeitung

  if ($err ne "") {
      $msg = 'ForecastSolar API server response: '.$err;

      Log3 ($name, 1, "$name - $msg");

      $data{$name}{statusapi}{ForecastSolar}{'?All'}{response_message} = $err;

      singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );
      $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
      $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

      return;
  }
  elsif ($myjson ne "") {                                                                                  # Evaluiere ob Daten im JSON-Format empfangen wurden
      my ($success) = evaljson($hash, $myjson);

      if (!$success) {
          $msg = 'ERROR - invalid ForecastSolar API server response';

          Log3 ($name, 1, "$name - $msg");

          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );
          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          return;
      }

      my $jdata = decode_json ($myjson);

      if ($debug eq 'apiProcess') {
          Log3 ($name, 1, qq{$name DEBUG> ForecastSolar API Call - response for string "$string":\n}. Dumper $jdata);
      }

      ## bei Überschreitung des Stundenlimit kommt:
      ###############################################
      # message -> code 429                                        (sonst 0)
      # message -> type error                                      (sonst 'success')
      # message -> text Rate limit for API calls reached.          (sonst leer)
      # message -> ratelimit ->  period    3600
      #                      ->  limit     12
      #                      ->  retry-at  2023-05-27T11:01:53+02:00  (= lokale Zeit)

      if ($jdata->{'message'}{'code'}) {
          $msg = "ForecastSolar API server ERROR response: $jdata->{'message'}{'text'} ($jdata->{'message'}{'code'})";

          Log3 ($name, 3, "$name - $msg");

          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

          $data{$name}{statusapi}{ForecastSolar}{'?All'}{response_message}        = $jdata->{'message'}{'text'};
          $data{$name}{statusapi}{ForecastSolar}{'?All'}{response_code}           = $jdata->{'message'}{'code'};
          $data{$name}{statusapi}{ForecastSolar}{'?All'}{lastretrieval_time}      = (timestampToTimestring ($t, $lang))[3];                # letzte Abrufzeit
          $data{$name}{statusapi}{ForecastSolar}{'?All'}{lastretrieval_timestamp} = $t;

          if (defined $jdata->{'message'}{'ratelimit'}{'remaining'}) {
              $data{$name}{statusapi}{ForecastSolar}{'?All'}{requests_remaining} = $jdata->{'message'}{'ratelimit'}{'remaining'};          # verbleibende Requests in Periode
          }
          else {
              delete $data{$name}{statusapi}{ForecastSolar}{'?All'}{requests_remaining};                                                   # verbleibende Requests unbestimmt
          }

          if ($debug =~ /apiCall/x) {
              Log3 ($name, 1, "$name DEBUG> ForecastSolar API Call - $msg");
              Log3 ($name, 1, "$name DEBUG> ForecastSolar API Call - limit period: ".$jdata->{'message'}{'ratelimit'}{'period'});
              Log3 ($name, 1, "$name DEBUG> ForecastSolar API Call - limit: ".$jdata->{'message'}{'ratelimit'}{'limit'});
          }

          my $rtyat = timestringFormat ($jdata->{'message'}{'ratelimit'}{'retry-at'});

          if ($rtyat) {
              my $rtyatts = timestringToTimestamp ($rtyat);

              $data{$name}{statusapi}{ForecastSolar}{'?All'}{retryat_time}      = $rtyat;
              $data{$name}{statusapi}{ForecastSolar}{'?All'}{retryat_timestamp} = $rtyatts;

              debugLog ($paref, "apiCall", "ForecastSolar API Call - retry at: ".$rtyat." ($rtyatts)");
          }

          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          ___setForeCastAPIcallKeyData ($paref);

          return;
      }

      my $rt  = timestringFormat      ($jdata->{'message'}{'info'}{'time'});
      my $rts = timestringToTimestamp ($rt);

      $data{$name}{statusapi}{ForecastSolar}{'?All'}{lastretrieval_time}      = $rt;                                                    # letzte Abrufzeit
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{lastretrieval_timestamp} = $rts;                                                   # letzter Abrufzeitstempel
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{response_message}        = $jdata->{'message'}{'type'};
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{response_code}           = $jdata->{'message'}{'code'};
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{requests_remaining}      = $jdata->{'message'}{'ratelimit'}{'remaining'};          # verbleibende Requests in Periode
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{requests_limit_period}   = $jdata->{'message'}{'ratelimit'}{'period'};             # Requests Limit Periode
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{requests_limit}          = $jdata->{'message'}{'ratelimit'}{'limit'};              # Requests Limit in Periode
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{place}                   = encode ('utf8', $jdata->{'message'}{'info'}{'place'});

      if ($debug =~ /apiCall/x) {
          Log3 ($name, 1, qq{$name DEBUG> ForecastSolar API Call - server response for PV string "$string"});
          Log3 ($name, 1, "$name DEBUG> ForecastSolar API Call - request time: ".      $rt." ($rts)");
          Log3 ($name, 1, "$name DEBUG> ForecastSolar API Call - requests remaining: ".$jdata->{'message'}{'ratelimit'}{'remaining'});
          Log3 ($name, 1, "$name DEBUG> ForecastSolar API Call - status: ".            $jdata->{'message'}{'type'}." ($jdata->{'message'}{'code'})");
      }

      for my $k (sort keys %{$jdata->{'result'}}) {                                   # Vorhersagedaten in Hash eintragen
          my $kts        = (timestringToTimestamp ($k)) - 3600;                       # Endezeit der Periode auf Startzeit umrechnen
          my $starttmstr = (timestampToTimestring ($kts, $lang))[3];

          $data{$name}{solcastapi}{$string}{$starttmstr}{pv_estimate50} = $jdata->{'result'}{$k};

          debugLog ($paref, "apiProcess", "ForecastSolar API Call - PV estimate: ".$starttmstr.' => '.$jdata->{'result'}{$k}.' Wh');
      }
  }

  Log3 ($name, 4, qq{$name - ForecastSolar API answer received for string "$string"});

  ___setForeCastAPIcallKeyData ($paref);

  my $param = {
      name       => $name,
      type       => $type,
      debug      => $debug,
      allstrings => $allstrings,
      lang       => $lang
  };

  $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
  $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

return &$caller($param);
}

################################################################
#  Kennzahlen des letzten Abruf ForecastSolar API setzen
################################################################
sub ___setForeCastAPIcallKeyData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $lang  = $paref->{lang};
  my $debug = $paref->{debug};
  my $t     = $paref->{t} // time;

  my $hash  = $defs{$name};

  $data{$name}{statusapi}{ForecastSolar}{'?All'}{todayDoneAPIrequests} += 1;

  ## Berechnung des optimalen Request Intervalls
  ################################################
  my $snum   = scalar (split ",", AttrVal ($name, 'setupInverterStrings',  'Dummy'));               # Anzahl der Strings (mindestens ein String als Dummy)
  my $period = StatusAPIVal ($hash, 'ForecastSolar', '?All', 'requests_limit_period', 3600);        # Requests Limit Periode
  my $limit  = StatusAPIVal ($hash, 'ForecastSolar', '?All', 'requests_limit',          12);        # Request Limit in Periode

  $data{$name}{statusapi}{ForecastSolar}{'?All'}{currentAPIinterval} = FORAPIREPDEF;

  my $interval = int ($period / ($limit / $snum));
  $interval    = 900 if($interval < 900);

  $data{$name}{statusapi}{ForecastSolar}{'?All'}{currentAPIinterval} = $interval;

  ####

  my $apiitv  = StatusAPIVal ($hash, 'ForecastSolar', '?All', 'currentAPIinterval', FORAPIREPDEF);
  my $rtyatts = StatusAPIVal ($hash, 'ForecastSolar', '?All', 'retryat_timestamp',  0);
  my $smt     = q{};

  if ($rtyatts && $rtyatts > $t) {                                                          # Zwangswartezeit durch API berücksichtigen
      $apiitv = $rtyatts - $t;
      $data{$name}{statusapi}{ForecastSolar}{'?All'}{currentAPIinterval} = $apiitv;
      $smt    = '(forced waiting time)';
  }

  readingsSingleUpdate ($hash, 'nextRadiationAPICall', $hqtxt{after}{$lang}.' '.(timestampToTimestring ($t + $apiitv, $lang))[0].' '.$smt, 1);

return;
}

##################################################################################################
# Abruf DWD Strahlungsdaten und Rohdaten ohne Korrektur
#
# Berechnung nach Formel 1 aus http://www.ing-büro-junge.de/html/photovoltaik.html
# als Jahreserträge:
#
#    * Faktor für Umwandlung kJ in kWh:   0.00027778
#    * Eigene Modulfläche in qm z.B.:     31,04
#    * Wirkungsgrad der Module in % z.B.: 16,52
#    * Wirkungsgrad WR in % z.B.:         98,3
#    * Korrekturwerte wegen Ausrichtung/Verschattung etc.
#
#    Die Formel wäre dann:
#    Ertrag in Wh = Rad1h * 0.00027778 * 31,04 qm * 16,52% * 98,3% * 100% * 1000
#
# Berechnung nach Formel 2 aus http://www.ing-büro-junge.de/html/photovoltaik.html:
#
#    * Globalstrahlung:                G = kWh/m2   (DWD Rad1h = kJ/m2)
#    * Korrektur mit Flächenfaktor f:  Gk = G * f
#    * Globalstrahlung (STC):          1 kW/m2
#    * Peak Leistung String (kWp):     Pnenn = x kW
#    * Performance Ratio:              PR (typisch 0,85 bis 0,9)
#    * weitere Korrekturwerte für Regen, Wolken etc.: Korr
#
#    pv (kWh) = G * f * 0.00027778 (kWh/m2) / 1 kW/m2 * Pnenn (kW) * PR * Korr
#    pv (Wh)  = G * f * 0.00027778 (kWh/m2) / 1 kW/m2 * Pnenn (kW) * PR * Korr * 1000
#
# Die Abhängigkeit der Strahlungsleistung der Sonnenenergie nach Wetterlage und Jahreszeit ist
# hier beschrieben:
# https://www.energie-experten.org/erneuerbare-energien/photovoltaik/planung/sonnenstunden
#
# PV Berechnungsgrundlagen
# https://www.energie-experten.org/erneuerbare-energien/photovoltaik/planung/ertrag
# http://www.ing-büro-junge.de/html/photovoltaik.html
#
##################################################################################################
sub __getDWDSolarData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $date  = $paref->{date};                                                                  # aktuelles Datum "YYYY-MM-DD"
  my $day   = $paref->{day};                                                                   # aktuelles Tagesdatum 01 .. 31
  my $t     = $paref->{t}     // time;
  my $lang  = $paref->{lang};

  my $hash  = $defs{$name};

  my $raname = AttrVal ($name, 'setupRadiationAPI', '');                                       # Radiation Forecast API
  return if(!$raname || !$defs{$raname});

  my $fcdays  = AttrVal ($raname, 'forecastDays', 2);                                          # Anzahl Forecast Days in DWD Device
  my $stime   = $date.' 00:00:00';                                                             # Startzeit Soll Übernahmedaten
  my $sts     = timestringToTimestamp ($stime);
  my @strings = sort keys %{$data{$name}{strings}};
  my $ret     = q{};

  $data{$name}{statusapi}{DWD}{'?All'}{lastretrieval_time}      = (timestampToTimestring ($t, $lang))[3];
  $data{$name}{statusapi}{DWD}{'?All'}{lastretrieval_timestamp} = $t;
  $data{$name}{statusapi}{DWD}{'?All'}{todayDoneAPIrequests}   += 1;

  my $fctime                           = ReadingsVal ($raname, 'fc_time', '-');
  $data{$name}{current}{dwdRad1hDev}   = $raname;
  $data{$name}{current}{dwdRad1hAge}   = $fctime;
  $data{$name}{current}{dwdRad1hAgeTS} = timestringToTimestamp ($fctime);

  debugLog ($paref, "apiCall", "DWD API - collect DWD Radiation data with start >$stime<- device: $raname =>");

  my $end = (24 + $fcdays * 24) - 1;                                                           # V 1.55.0 -> default 71

  for my $num (0..$end) {                                                                      # V 1.36.0
      my ($fd, $fh) = calcDayHourMove (0, $num);
      next if($fh == 24);

      my $dateTime = strftime "%Y-%m-%d %H:%M:00", localtime($sts + (3600 * $num));            # abzurufendes Datum ' ' Zeit
      my $runh     = int strftime "%H",            localtime($sts + (3600 * $num) + 3600);     # Stunde in 24h format (00-23), Rad1h = Absolute Globalstrahlung letzte 1 Stunde
      my $rad      = ReadingsVal ($raname, "fc${fd}_${runh}_Rad1h", '0.00');                   # kJ/m2
      
      my ($ddate, $dtime) = split ' ', $dateTime;                                              # abzurufendes Datum + Zeit
      my $dtpart          = (split ":", $dateTime)[0];
      my $hod             = sprintf "%02d", ((split ':', $dtime)[0] + 1);                      # abzurufende Zeit
      my $dday            = (split '-', $ddate)[2];                                            # abzurufender Tag: 01, 02 ... 31

      if ($runh == 12 && !$rad) {
          $ret = "The reading 'fc${fd}_${runh}_Rad1h' does not appear to be present or has an unusual value.\nRun 'set $name plantConfiguration check' for further information.";
          $data{$name}{statusapi}{DWD}{'?All'}{response_message} = $ret;

          debugLog ($paref, "apiCall", "DWD API - ERROR - got unusual data of starttime: $dtpart. ".$ret);
      }
      else {
          debugLog ($paref, "apiCall", "DWD API - got data -> starttime: $dtpart, reading: fc${fd}_${runh}_Rad1h, rad: $rad kJ/m2");
      }

      $data{$name}{solcastapi}{'?All'}{$dateTime}{Rad1h} = sprintf "%.0f", $rad;

      my $cafd = 'trackFlex';                                                                  # Art der Flächenfaktor Berechnung ('fix' wäre alternativ möglich = alte Methode)

      for my $string (@strings) {                                                              # für jeden String der Config ..
          my $ti   = StringVal ($name, $string, 'tilt',   undef);                              # Neigungswinkel Solarmodule
          my $peak = StringVal ($name, $string, 'peak',   undef);                              # String Peak (kWp)
          my $az   = StringVal ($name, $string, 'azimut', undef);                              # Ausrichtung der Solarmodule
          
          if (!defined $ti || !defined $peak || !defined $az) {
              $ti   //= 'undef';
              $peak //= 'undef';
              $az   //= 'undef';
              Log3 ($name, 1, "$name - ERROR - no of these parameter must be undef -> azimuth: $az, peak: $peak, tilt: $ti");
              next;
          }
          
          $peak *= 1000;                                                                       # kWp in Wp umrechnen                                 
          $az    = azSolar2Astro ($az);                                                        # Konvertiert Azimut der Solar-Konvention in die astronomische Konvention

          my ($af, $pv, $sdr, $wcc);

          if ($cafd eq 'trackFlex') {                                                          # Flächenfaktor Sonnenstand geführt
              ($af, $sdr, $wcc) = ___areaFactorTrack ( { name   => $name,
                                                         day    => $day,
                                                         dday   => $dday,
                                                         chour  => $paref->{chour},
                                                         hod    => $hod,
                                                         debug  => $paref->{debug},
                                                         tilt   => $ti,
                                                         azimut => $az
                                                       }
                                                     );

              #if ($wcc >= 80 || !$af) {                                                             
                  my $dirrad = $rad * $sdr;                                                         # Anteil Direktstrahlung an Globalstrahlung
                  my $difrad = $rad - $dirrad;                                                      # Anteil Diffusstrahlung an Globalstrahlung

                  $pv = (($dirrad * $af) + $difrad) * KJ2KWH * $peak * PRDEF;                       # Rad wird in kW/m2 erwartet
                  
                  debugLog ($paref, "apiProcess", "DWD API - PV estimate String >$string< => $dtpart, rad: $rad, direct share: $dirrad, diffuse share: $difrad");
              #}
              #else {                                                                                # Flächenfaktor auf volle Rad1h anwenden
              #    $pv = $rad * $af * KJ2KWH * $peak * PRDEF;
              #}
          }
          else {                                                                                    # Flächenfaktor Fix
              $af = ___areaFactorFix ($ti, $az);                                                    # Flächenfaktor: https://wiki.fhem.de/wiki/Ertragsprognose_PV
              $pv = $rad * $af * KJ2KWH * $peak * PRDEF;                                            # Rad wird in kW/m2 erwartet
          }

          $af = sprintf "%.2f", $af;
          $pv = sprintf "%.1f", $pv;

          $data{$name}{solcastapi}{$string}{$dateTime}{pv_estimate50} = $pv;                        # Startzeit wird verwendet, nicht laufende Stunde

          debugLog ($paref, "apiProcess", "DWD API - PV estimate String >$string< => $dtpart, $pv Wh, AF: $af, dirfac: $sdr");
      }
  }

  $data{$name}{statusapi}{DWD}{'?All'}{response_message} = 'success' if(!$ret);

return;
}

##################################################################################################
#  Flächenfaktor Photovoltaik
#  Prof. Dr. Peter A. Henning, September 2024
#  ersetzt die Tabelle auf Basis http://www.ing-büro-junge.de/html/photovoltaik.html
#  (für den Jahresertrag!)
#  siehe Wiki: https://wiki.fhem.de/wiki/Ertragsprognose_PV
##################################################################################################
sub ___areaFactorFix {
  my $tilt   = shift;
  my $azimut = shift;

  my $pi180  = 0.0174532918889;                                                                               # Grad in Radiant Umrechnungsfaktor

  my $x  = $tilt * sin ($azimut * $pi180);
  my $y  = $tilt * cos ($azimut * $pi180);
  my $x2 = $x**2;
  my $x4 = $x2**2;

  my $af = 3.808301895960147E-7 - 8.650170178954599E-11 * $x2 + 5.50016483344622E-15 * $x4;
  $af    = $af * $y + 0.00007319316326291892 - 3.604294916743569E-9   * $x2 - 2.343747951073022E-13 * $x4;
  $af    = $af * $y - 0.00785953342909065    + 1.1197340251684106E-6  * $x2 - 8.99915952119488E-11  * $x4;
  $af    = $af * $y - 0.8432627150525525     + 0.00010392051567819936 * $x2 - 3.979206287671085E-9  * $x4;
  $af    = $af * $y + 99.49627151067648      - 0.006340200119196879   * $x2 + 2.052575360270524E-7  * $x4;
  $af    = $af / 100;                                                                                        # Prozenz in Faktor

return $af;
}

##########################################################################################################
#  Flächenfaktor Photovoltaik und Direktstrahlungsanteilsfaktor in Abhängigkeit des Sonnenstandes
#
#  Die Globalstrahlung  (Summe aus diffuser und direkter Sonnenstrahlung)
#  ----------------------------------------------------------------------
#  Die Globalstrahlung ist die am Boden von einer horizontalen Ebene empfangene Sonnenstrahlung
#  und setzt sich aus der direkten Strahlung (der Schatten werfenden Strahlung) und der
#  gestreuten Sonnenstrahlung (diffuse Himmelsstrahlung) aus der Himmelshalbkugel zusammen.
#  Bei Sonnenhöhen von mehr als 50° und wolkenlosem Himmel besteht die Globalstrahlung zu ca. 3/4
#  aus direkter Sonnenstrahlung, bei tiefen Sonnenständen (bis etwa 10°) nur noch zu ca. 1/3.
#
#  Direktstrahlung = Globalstrahlung * 0.75   (bei >  50° sunalt)
#  Direktstrahlung = Globalstrahlung * 0.33   (bei <= 10° sunalt)
#
#  Quelle: https://www.dwd.de/DE/leistungen/solarenergie/globalstrahlung.html?nn=16102&lsbId=416798
#
#  Return:
#  $daf - direct Area Faktor für den Anteil Direktstrahlung der Globalstrahlung
#  $sdr - Share of direct radiation = Faktor Anteil Direktstrahlung an Globalstrahlung (0.33 .. 0.75)
#
##########################################################################################################
sub ___areaFactorTrack {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $day    = $paref->{day};                                                   # aktueller Tag 01 .. 31
  my $dday   = $paref->{dday};                                                  # abzufragender Tag: 01 .. 31
  my $chour  = $paref->{chour};                                                 # aktuelle Stunde (00 .. 23)
  my $hod    = $paref->{hod};                                                   # abzufragende Stunde des Tages 01, 02 ... 24
  my $tilt   = $paref->{tilt};                                                  # String Anstellwinkel / Neigung
  my $azimut = $paref->{azimut};                                                # String Ausrichtung / Azimut

  my ($sunalt, $sunaz, $wcc);

  if ($dday eq $day) {
      $sunalt = HistoryVal ($name, $dday, $hod, 'sunalt', undef);               # Sonne Höhe (Altitude)
      $sunaz  = HistoryVal ($name, $dday, $hod, 'sunaz',  undef);               # Sonne Azimuth
      $wcc    = HistoryVal ($name, $dday, $hod, 'wcc',        0);               # Bewölkung
  }
  else {
      my $nhtstr = 'NextHour'.sprintf "%02d",  (23 - (int $chour) + $hod);
      $sunalt    = NexthoursVal ($name, $nhtstr, 'sunalt', undef);
      $sunaz     = NexthoursVal ($name, $nhtstr, 'sunaz',  undef);
      $wcc       = NexthoursVal ($name, $nhtstr, 'wcc',        0);
  }

  if (!defined $sunalt || !defined $sunaz) {
      debugLog ($paref, "apiProcess", "DWD API - hod: $hod -> Value of sunaz/sunalt not stored in pvHistory, workaround using 1.00/0.75");
      return (1.00, 0.75, 0);
  }
  
  my $pi180 = 0.0174532918889;                                                  # PI/180
  $wcc      = cloud2bin ($wcc);  

  #-- Normale der Anlage (Nordrichtung = y-Achse, Ostrichtung = x-Achse)
  my $nz = cos ($tilt * $pi180);
  my $ny = sin ($tilt * $pi180) * cos ($azimut * $pi180);
  my $nx = sin ($tilt * $pi180) * sin ($azimut * $pi180);

  #-- Vektor zur Sonne
  my $sz = sin ($sunalt * $pi180);
  my $sy = cos ($sunalt * $pi180) * cos ($sunaz * $pi180);
  my $sx = cos ($sunalt * $pi180) * sin ($sunaz * $pi180);

  #-- Normale N = ($nx,$ny,$nz) Richtung Sonne S = ($sx,$sy,$sz)
  my $daf = $nx * $sx + $ny * $sy + $nz * $sz;
  $daf    = max ($daf, 0);
  #$daf   += 1 if($daf);                                                                    # V 1.53.4 -> Bugfix
  
  ## Schätzung Anteil Direktstrahlung an Globalstrahlung
  ########################################################
  my $drif = 0.0105;                                                                        # Faktor Zunahme Direktstrahlung pro Grad sunalt von 10° bis 50°
  my $sdr  = $sunalt <= 10                  ? 0.33                             :            # Share of direct radiation = Faktor Anteil Direktstrahlung an Globalstrahlung (0.33 .. 0.75)
             $sunalt >  10 && $sunalt <= 50 ? (($sunalt - 10) * 0.0105) + 0.33 :
             0.75;

return ($daf, $sdr, $wcc);
}

####################################################################################################
#                Abruf Victron VRM API Forecast
#
# https://community.victronenergy.com/questions/216543/new-vrm-feature-solar-forecast.html
# API Beschreibung: https://vrm-api-docs.victronenergy.com/#/operations/installations/idSite/stats
####################################################################################################
sub __getVictronSolarData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $force = $paref->{force} // 0;
  my $t     = $paref->{t};
  my $lang  = $paref->{lang};

  my $hash  = $defs{$name};

  my $lrt    = StatusAPIVal ($hash, 'VictronKi', '?All', 'lastretrieval_timestamp', 0);
  my $apiitv = VRMAPIREPDEF;

  if (!$force) {
      if ($lrt && $t < $lrt + $apiitv) {
          my $rt = $lrt + $apiitv - $t;
          return qq{The waiting time to the next SolCast API call has not expired yet. The remaining waiting time is $rt seconds};
      }
  }

  readingsSingleUpdate ($hash, 'nextRadiationAPICall', $hqtxt{after}{$lang}.' '.(timestampToTimestring ($t + $apiitv, $lang))[0], 1);

  __VictronVRM_ApiRequestLogin ($paref);

return;
}

################################################################
#                Victron VRM API Login
# https://vrm-api-docs.victronenergy.com/#/
################################################################
sub __VictronVRM_ApiRequestLogin {
  my $paref = shift;
  my $name  = $paref->{name};
  my $debug = $paref->{debug};
  my $type  = $paref->{type};

  my $hash  = $defs{$name};
  my $url   = 'https://vrmapi.victronenergy.com/v2/auth/login';

  debugLog ($paref, "apiProcess|apiCall", qq{Request VictronVRM API Login: $url});

  my $caller = (caller(0))[3];                                                     # Rücksprungmarke

  my ($user, $pwd, $idsite);

  my $serial = StatusAPIVal ($hash, '?VRM', '?API', 'credentials', '');

  if ($serial) {
      my $h   = eval { thaw (assemble ($serial)) };                                # Deserialisierung
      $user   = $h->{user}   // q{};
      $pwd    = $h->{pwd}    // q{};
      $idsite = $h->{idsite} // q{};

      debugLog ($paref, "apiCall", qq{Used credentials for Login: user->$user, pwd->$pwd, idsite->$idsite});
  }
  else {
      my $msg = "Victron VRM API credentials are not set or couldn't be decrypted. Use 'set $name vrmCredentials' to set it.";
      Log3              ($name, 2, "$name - $msg");
      singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

      $data{$name}{statusapi}{VictronKi}{'?All'}{response_message} = $msg;
      return;
  }

  my $param = {
      url        => $url,
      timeout    => APITIMEOUT,
      name       => $name,
      type       => $paref->{type},
      stc        => [gettimeofday],
      debug      => $debug,
      caller     => \&$caller,
      lang       => $paref->{lang},
      chour      => $paref->{chour},                                            # aktuelle Stunde in 24h format (00-23)
      date       => $paref->{date},
      idsite     => $idsite,
      header     => { "Content-Type" => "application/json" },
      data       => qq({ "username": "$user",  "password": "$pwd" }),
      method     => 'POST',
      callback   => \&__VictronVRM_ApiResponseLogin
  };

  if ($debug =~ /apiCall/x) {
      $param->{loglevel} = 1;
  }

  HttpUtils_NonblockingGet ($param);

return;
}

###############################################################
#                  Victron VRM API Login Response
###############################################################
sub __VictronVRM_ApiResponseLogin {
  my $paref  = shift;
  my $err    = shift;
  my $myjson = shift;

  my $name   = $paref->{name};
  my $type   = $paref->{type};
  my $caller = $paref->{caller};
  my $stc    = $paref->{stc};
  my $lang   = $paref->{lang};
  my $debug  = $paref->{debug};

  my $msg;
  my $hash = $defs{$name};
  my $t    = time;
  my $sta  = [gettimeofday];                                                                                # Start Response Verarbeitung

  if ($err ne "") {
      $msg = 'Victron VRM API error response: '.$err;
      Log3              ($name, 1, "$name - $msg");
      singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

      $data{$name}{statusapi}{VictronKi}{'?All'}{response_message} = $err;
      $data{$name}{current}{runTimeLastAPIProc}                = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
      $data{$name}{current}{runTimeLastAPIAnswer}              = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

      return;
  }
  elsif ($myjson ne "") {                                                                                  # Evaluiere ob Daten im JSON-Format empfangen wurden
      my ($success) = evaljson ($hash, $myjson);

      if (!$success) {
          $msg = 'ERROR - invalid Victron VRM API response';
          Log3              ($name, 1, "$name - $msg");
          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          return;
      }

      my $jdata = decode_json ($myjson);

      if (defined $jdata->{'error_code'}) {
          $msg = 'Victron VRM API error_code response: '.$jdata->{'error_code'};
          Log3              ($name, 3, "$name - $msg");
          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          $data{$name}{statusapi}{VictronKi}{'?All'}{response_message}        = $jdata->{'error_code'};
          $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_time}      = (timestampToTimestring ($t, $lang))[3];  # letzte Abrufzeit
          $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_timestamp} = $t;

          if ($debug =~ /apiProcess|apiCall/x) {
              Log3 ($name, 1, "$name DEBUG> SolCast API Call - error_code: ".$jdata->{'error_code'});
              Log3 ($name, 1, "$name DEBUG> SolCast API Call - errors: "    .$jdata->{'errors'});
          }

          return;
      }
      else {
          $data{$name}{statusapi}{VictronKi}{'?All'}{response_message}        = 'success';
          $data{$name}{statusapi}{VictronKi}{'?All'}{idUser}                  = $jdata->{'idUser'};
          $data{$name}{statusapi}{VictronKi}{'?All'}{verification_mode}       = $jdata->{'verification_mode'};
          $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_time}      = (timestampToTimestring ($t, $lang))[3];                # letzte Abrufzeit
          $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_timestamp} = $t;

          if ($debug eq 'apiProcess') {
              Log3 ($name, 1, qq{$name DEBUG> Victron VRM API response Login:\n}. Dumper $jdata);
          }

          if (defined $jdata->{'token'}) {
              $data{$name}{statusapi}{VictronKi}{'?All'}{token} = 'got successful at '.StatusAPIVal ($hash, 'VictronKi', '?All', 'lastretrieval_time', '-');
              $paref->{token}                                      = $jdata->{'token'};
              __VictronVRM_ApiRequestForecast ($paref);
          }
          else {
              $data{$name}{statusapi}{VictronKi}{'?All'}{response_message} = 'empty Token';
          }
      }
  }

return;
}

######################################################################################################
#                Victron VRM API Forecast Data
# https://vrm-api-docs.victronenergy.com/#/
# # API Beschreibung: https://vrm-api-docs.victronenergy.com/#/operations/installations/idSite/stats
######################################################################################################
sub __VictronVRM_ApiRequestForecast {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $token  = $paref->{token};
  my $debug  = $paref->{debug};
  my $lang   = $paref->{lang};
  my $idsite = $paref->{idsite};
  my $chour  = $paref->{chour};                                                   # aktuelle Stunde in 24h format (00-23)
  my $date   = $paref->{date};

  my $hash   = $defs{$name};
  my $tstart = timestringToTimestamp ("$date $chour:00:00");
  my $tend   = $tstart + 259200;                                                  # 172800 = 2 Tage

  my $url = "https://vrmapi.victronenergy.com/v2/installations/$idsite/stats?type=forecast&interval=hours&start=$tstart&end=$tend";

  debugLog ($paref, "apiProcess|apiCall", qq{Request VictronVRM API Forecast: $url});

  my $caller = (caller(0))[3];                                                    # Rücksprungmarke

  my $param = {
      url     => $url,
      timeout => APITIMEOUT,
      name    => $name,
      type    => $paref->{type},
      stc     => [gettimeofday],
      debug   => $debug,
      token   => $token,
      caller  => \&$caller,
      lang    => $paref->{lang},
      header  => { "Content-Type" => "application/json", "x-authorization" => "Bearer $token" },
      method  => 'GET',
      callback => \&__VictronVRM_ApiResponseForecast
  };

  if ($debug =~ /apiCall/x) {
      $param->{loglevel} = 1;
  }

  HttpUtils_NonblockingGet ($param);

return;
}

###############################################################
#                  Victron VRM API Forecast Response
###############################################################
sub __VictronVRM_ApiResponseForecast {
  my $paref  = shift;
  my $err    = shift;
  my $myjson = shift;

  my $name   = $paref->{name};
  my $type   = $paref->{type};
  my $caller = $paref->{caller};
  my $stc    = $paref->{stc};
  my $lang   = $paref->{lang};
  my $debug  = $paref->{debug};

  my $msg;
  my $hash = $defs{$name};
  my $t    = time;
  my $sta  = [gettimeofday];                                                                                           # Start Response Verarbeitung

  if ($err ne "") {
      $msg = 'Victron VRM API Forecast response: '.$err;
      Log3              ($name, 1, "$name - $msg");
      singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

      $data{$name}{statusapi}{VictronKi}{'?All'}{response_message} = $err;
      $data{$name}{current}{runTimeLastAPIProc}                    = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
      $data{$name}{current}{runTimeLastAPIAnswer}                  = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

      return;
  }
  elsif ($myjson ne "") {                                                                                              # Evaluiere ob Daten im JSON-Format empfangen wurden
      my ($success) = evaljson($hash, $myjson);

      if (!$success) {
          $msg = 'ERROR - invalid Victron VRM API Forecast response';
          Log3              ($name, 1, "$name - $msg");
          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          return;
      }

      my $jdata = decode_json ($myjson);

      if (defined $jdata->{'error_code'}) {
          $msg = 'Victron VRM API Forecast response: '.$jdata->{'error_code'};
          Log3              ($name, 3, "$name - $msg");
          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          $data{$name}{statusapi}{VictronKi}{'?All'}{response_message}        = $jdata->{'error_code'};
          $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_time}      = (timestampToTimestring ($t, $lang))[3];  # letzte Abrufzeit
          $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_timestamp} = $t;

          if ($debug =~ /apiProcess|apiCall/x) {
              Log3 ($name, 1, "$name DEBUG> Victron VRM API Call - error_code: ".$jdata->{'error_code'});
              Log3 ($name, 1, "$name DEBUG> Victron VRM API Call - errors: "    .$jdata->{'errors'});
          }

          return;
      }
      else {
          $data{$name}{statusapi}{VictronKi}{'?All'}{todayDoneAPIrequests} += 1;
          $data{$name}{statusapi}{VictronKi}{'?All'}{todayDoneAPIcalls}    += 1;
                                                             
          my $syforecast = $jdata->{records}{solar_yield_forecast} // 'undefined';                                         # Forum: https://forum.fhem.de/index.php?msg=1346820
          
          if (ref $syforecast ne 'ARRAY') {                                                                                
              $msg = 'ERROR - invalid Victron VRM API Forecast response';
              singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

              $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
              $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

              $data{$name}{statusapi}{VictronKi}{'?All'}{response_message}        = $msg;
              $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_time}      = (timestampToTimestring ($t, $lang))[3];  # letzte Abrufzeit
              $data{$name}{statusapi}{VictronKi}{'?All'}{lastretrieval_timestamp} = $t;
             
              debugLog ($paref, 'apiProcess|apiCall', 'Victron VRM API Call - ERROR - records are not an ARRAY: '.$syforecast);
             
              return;
          }
          
          my $k = 0;
          
          while ($jdata->{'records'}{'solar_yield_forecast'}[$k]) {
              if (ref $jdata->{'records'}{'solar_yield_forecast'}[$k] ne "ARRAY") {             # Forum: https://forum.fhem.de/index.php?msg=1288637
                  $k++;
                  next;
              }

              my $starttmstr = $jdata->{'records'}{'solar_yield_forecast'}[$k][0];              # Millisekunden geliefert
              my $val        = $jdata->{'records'}{'solar_yield_forecast'}[$k][1];
              $starttmstr    = (timestampToTimestring ($starttmstr, $lang))[3];

              debugLog ($paref, 'apiProcess', 'Victron VRM API - PV estimate: '.$starttmstr.' => '.$val.' Wh');

              if ($val) {
                  $val = sprintf "%.0f", $val;

                  my $string = AttrVal ($name, 'setupInverterStrings', '?');

                  $data{$name}{solcastapi}{$string}{$starttmstr}{pv_estimate50} = $val;
              }

              $k++;
          }

          $k = 0;
          while ($jdata->{'records'}{'vrm_consumption_fc'}[$k]) {
              if (ref $jdata->{'records'}{'vrm_consumption_fc'}[$k] ne "ARRAY") {              # Forum: https://forum.fhem.de/index.php?msg=1288637
                  $k++;
                  next;
              }

              my $starttmstr = $jdata->{'records'}{'vrm_consumption_fc'}[$k][0];               # Millisekunden geliefert
              my $val        = $jdata->{'records'}{'vrm_consumption_fc'}[$k][1];
              $starttmstr    = (timestampToTimestring ($starttmstr, $lang))[3];

              debugLog ($paref, "apiProcess", "Victron VRM API - CO estimate: ".$starttmstr.' => '.$val.' Wh');

              if ($val) {
                  $val       = sprintf "%.2f", $val;
                  my $string = AttrVal ($name, 'setupInverterStrings', '?');

                  $data{$name}{solcastapi}{$string.'_co'}{$starttmstr}{co_estimate} = $val;
              }

              $k++;
          }
      }
  }

  $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval  ($sta);                             # Verarbeitungszeit ermitteln
  $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval ($stc) - tv_interval ($sta));       # API Laufzeit ermitteln

  __VictronVRM_ApiRequestLogout ($paref);

return;
}

################################################################
#                Victron VRM API Logout
# https://vrm-api-docs.victronenergy.com/#/
################################################################
sub __VictronVRM_ApiRequestLogout {
  my $paref = shift;
  my $name  = $paref->{name};
  my $token = $paref->{token};
  my $debug = $paref->{debug};

  my $hash  = $defs{$name};

  my $url = 'https://vrmapi.victronenergy.com/v2/auth/logout';

  debugLog ($paref, "apiProcess|apiCall", qq{Request VictronVRM API Logout: $url});

  my $caller = (caller(0))[3];                                                    # Rücksprungmarke

  my $param = {
      url        => $url,
      timeout    => APITIMEOUT,
      name       => $name,
      type       => $paref->{type},
      debug      => $debug,
      caller     => \&$caller,
      lang       => $paref->{lang},
      header     => { "Content-Type" => "application/json", "x-authorization" => "Bearer $token" },
      method     => 'GET',
      callback   => \&__VictronVRM_ApiResponseLogout
  };

  if ($debug =~ /apiCall/x) {
      $param->{loglevel} = 1;
  }

  HttpUtils_NonblockingGet ($param);

return;
}

###############################################################
#                  Victron VRM API Logout Response
###############################################################
sub __VictronVRM_ApiResponseLogout {
  my $paref  = shift;
  my $err    = shift;
  my $myjson = shift;

  my $name   = $paref->{name};
  my $debug  = $paref->{debug};
  my $hash   = $defs{$name};

  my $msg;

  if ($err ne "") {
      $msg = 'Victron VRM API error response: '.$err;
      Log3 ($name, 1, "$name - $msg");
      return;
  }
  elsif ($myjson ne "") {                                                                                  # Evaluiere ob Daten im JSON-Format empfangen wurden
      my ($success) = evaljson($hash, $myjson);

      if (!$success) {
          $msg = 'ERROR - invalid Victron VRM API response';
          Log3 ($name, 1, "$name - $msg");
          return;
      }

      my $jdata = decode_json ($myjson);

      if ($debug eq 'apiCall') {
          Log3 ($name, 1, qq{$name DEBUG> Victron VRM API response Logout:\n}. Dumper $jdata);
      }
  }

return;
}

################################################################################################
#             Abruf Open-Meteo API Daten
################################################################################################
sub __getopenMeteoData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $force = $paref->{force} // 0;
  my $t     = $paref->{t};
  my $lang  = $paref->{lang};
  my $debug = $paref->{debug};
  my $reqm  = $paref->{reqm};

  if (!$force) {                                                                                      # regulärer API Abruf
      my $lrt    = StatusAPIVal ($name, 'OpenMeteo', '?All', 'lastretrieval_timestamp',       0);
      my $apiitv = StatusAPIVal ($name, 'OpenMeteo', '?All', 'currentAPIinterval', OMETEOREPDEF);

      if ($lrt && $t < $lrt + $apiitv) {
          my $rt = $lrt + $apiitv - $t;
          return qq{The waiting time to the next Open-Meteo API call has not expired yet. The remaining waiting time is $rt seconds};
      }
  }

  my $donearq = StatusAPIVal ($name, 'OpenMeteo', '?All', 'todayDoneAPIrequests', 0);

  if ($donearq >= OMETMAXREQ) {
      my $msg = "The limit of maximum ".OMETMAXREQ." daily API requests is reached or already exceeded. Process is exited.";
      Log3 ($name, 1, "$name - ERROR - $msg");
      return $msg;
  }

  debugLog ($paref, 'apiCall', "Open-Meteo API Call - the daily API requests -> limited to: ".OMETMAXREQ.", done: $donearq");

  my $submodel   = InternalVal ($name, $reqm, 'unknown');
  my $allstrings = AttrVal     ($name, 'setupInverterStrings', '');

  #if ($reqm eq 'MODEL' && $submodel eq 'OpenMeteoDWDD2API') {                      # Satellitenunterstützung dazuladen
  #    $allstrings .= ',SatelliteRadiation,'.$allstrings;
  #}

  $paref->{callequivalent} = $submodel eq 'OpenMeteoDWDEnsembleAPI' ? 20 : 1;
  $paref->{allstrings}     = $allstrings;
  $paref->{begin}          = 1;
  $paref->{submodel}       = $submodel;
  $paref->{requestmode}    = $reqm;

  __openMeteoDWD_ApiRequest ($paref);

return;
}

################################################################################################
#       historische GHI Daten von OpenMeteo abrufen und in aiRawData ersetzen
################################################################################################
sub __getopenMeteoGHIreplace {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};
  my $debug = $paref->{debug};

  my $hash    = $defs{$name};
  my $donearq = StatusAPIVal ($hash, 'OpenMeteo', '?All', 'todayDoneAPIrequests', 0);

  if ($donearq >= OMETMAXREQ) {
      my $msg = "The limit of maximum ".OMETMAXREQ." daily API requests is reached or already exceeded. Process is exited.";
      Log3 ($name, 1, "$name - ERROR - $msg");
      return $msg;
  }

  my $nk = scalar keys %{$data{$name}{aidectree}{airaw}};
  return if(!$nk);

  my @ha = sort keys %{$data{$name}{aidectree}{airaw}};
  my $fstidx = $ha[0];
  my $lstidx = $ha[$nk-1];

  my $fsty = substr $fstidx, 0, 4;
  my $fstm = substr $fstidx, 4, 2;
  my $fstd = substr $fstidx, 6, 2;

  my $lsty = substr $lstidx, 0, 4;
  my $lstm = substr $lstidx, 4, 2;
  my $lstd = substr $lstidx, 6, 2;

  debugLog ($paref, 'apiCall', "Open-Meteo API Call - the daily API requests -> limited to: ".OMETMAXREQ.", done: $donearq");
  debugLog ($paref, 'apiCall', "Open-Meteo API Call - Refill Global Horizontal Irradiance (GHI) - Start: $fsty-$fstm-$fstd, End: $lsty-$lstm-$lstd");

  $paref->{callequivalent} = 1;
  $paref->{allstrings}     = 'Dummy';
  $paref->{begin}          = 1;
  $paref->{submodel}       = 'HistoricalData';
  $paref->{requestmode}    = 'GHIREFILL';
  $paref->{t}              = int time;
  $paref->{startdate}      = "$fsty-$fstm-$fstd";
  $paref->{enddate}        = "$lsty-$lstm-$lstd";

  __openMeteoDWD_ApiRequest ($paref);

return;
}

########################################################################################################################
#                Open-Meteo API Request
#  Open data weather forecasts from the German weather service DWD
#  Quelle Seite: https://open-meteo.com/
#
#  Aufruf:    https://api.open-meteo.com/v1/dwd-icon?latitude=<>&longitude=<>&hourly=<Werte Komma getrennt>&daily=<Werte Komma getrennt>&forecast_hours=<>&tilt=<>&azimuth=<>
#
#  Beispiel:  https://api.open-meteo.com/v1/dwd-icon?latitude=51.285272&longitude=12.067722&hourly=temperature_2m,rain,weather_code,cloud_cover,is_day,global_tilted_irradiance_instant&daily=sunrise,sunset&forecast_hours=48&tilt=45&azimuth=0
#
#  temperature_2m - Air temperature at 2 meters above ground
#  rain           - Regen aus Großwetterlagen der vorangegangenen Stunde in Millimeter
#  weather_code   - Wetterlage als numerischer Code. Befolgen Sie die WMO-Wetterinterpretationscodes.
#  cloud_cover    - Gesamtbewölkung als Flächenanteil (%)
#  is_day         - Tag oder Nacht
#  timeformat     - Wenn das Format unixtime gewählt wird, werden alle Zeitwerte in UNIX-Epochenzeit in Sekunden
#                   zurückgegeben. Bitte beachten Sie, dass alle Zeitstempel in GMT+0 sind!
#  global_tilted_irradiance_instant - Gesamte Strahlung, die auf eine geneigte Scheibe fällt, als Durchschnitt der
#  (GTI)                              vorangegangenen Stunde.
#                                     Die Berechnung erfolgt unter der Annahme einer festen Albedo von 20% und eines
#                                     isotropen Himmels. (in W/m²)
#  timezone       - If auto is set as a time zone, the coordinates will be automatically resolved to the local time zone.
#
########################################################################################################################
sub __openMeteoDWD_ApiRequest {
  my $paref       = shift;
  my $name        = $paref->{name};
  my $allstrings  = $paref->{allstrings};                                     # alle Strings
  my $debug       = $paref->{debug};
  my $lang        = $paref->{lang};
  my $t           = $paref->{t}       // int time;
  my $submodel    = $paref->{submodel};                                       # abzufragendes Datenmodell
  my $requestmode = $paref->{requestmode};

  my $hash        = $defs{$name};

  if (!$allstrings) {                                                         # alle Strings wurden abgerufen
      my $apiitv = StatusAPIVal ($hash, 'OpenMeteo', '?All', 'currentAPIinterval', OMETEOREPDEF);
      readingsSingleUpdate ($hash, 'nextRadiationAPICall', $hqtxt{after}{$lang}.' '.(timestampToTimestring ($t + $apiitv, $lang))[0], 1);

      $data{$name}{statusapi}{OpenMeteo}{'?All'}{todayDoneAPIcalls} += 1;

      return;
  }

  my ($string, $err);
  ($string, $allstrings) = split ",", $allstrings, 2;

  if ($string eq 'SatelliteRadiation') {                                      # Trenner-String: ab jetzt Satelliten Abfrage
      $submodel              = 'SatelliteRadiation';
      $paref->{submodel}     = $submodel;
      ($string, $allstrings) = split ",", $allstrings, 2;
  }

  $paref->{string} = $string;
  my $url = ___createOpenMeteoURL ($paref);
  delete $paref->{string};

  if (!$url) {
      $err = qq{ERROR OpenMeteo API Call - no URL could be created for submodel: $submodel};
      Log3 ($name, 1, "$name - $err");
      return;
  }

  my $deburl = $url;
  $deburl    =~ s/&/&amp;/g;

  debugLog ($paref, 'apiCall', qq{Open-Meteo API Call - Request for PV-String "$string" with Data Model >$submodel<:\n$deburl});
  debugLog ($paref, 'apiCall|apiProcess', qq{Open-Meteo API Call - Request Mode: $requestmode});

  my $caller = (caller(0))[3];                                                                                  # Rücksprungmarke

  my $param = {
      url            => $url,
      timeout        => APITIMEOUT,
      name           => $name,
      debug          => $debug,
      header         => 'Accept: application/json',
      submodel       => $submodel,
      begin          => $paref->{begin},
      callequivalent => $paref->{callequivalent},
      requestmode    => $requestmode,
      caller         => \&$caller,
      stc            => [gettimeofday],
      allstrings     => $allstrings,
      string         => $string,
      lang           => $paref->{lang},
      method         => "GET",
      callback       => \&__openMeteoDWD_ApiResponse
  };

  if ($debug =~ /apiCall/x) {
      $param->{loglevel} = 1;
  }

  HttpUtils_NonblockingGet ($param);

return;
}

################################################################################################
#                               Open-Meteo API Response
#
#  Rad1h vom DWD  - Globalstrahlung in kJ/m2
#
# Berechnung nach Formel 2 aus http://www.ing-büro-junge.de/html/photovoltaik.html:
#
#    * Globalstrahlung:                G = kWh/m2   (GTI = W/m2), (DWD Rad1h = kJ/m2)
#    * Korrektur mit Flächenfaktor f:  Gk = G * f
#    * Globalstrahlung (STC):          1 kW/m2
#    * Peak Leistung String (kWp):     Pnenn = x kW
#    * Performance Ratio:              PR (typisch 0,85 bis 0,9)
#    * weitere Korrekturwerte für Regen, Wolken etc.: Korr
#
#    pv (Wh)  = GTI * f / 1000 (kWh/m2) / 1 kW/m2 * Pnenn (kW) * PR * Korr * 1000
#              (GTI * f) ist bereits in dem API-Ergebnis $rad enthalten in Wh/m2
#             -> $rad / 1000 (kWh/m2) / 1 kW/m2 * Pnenn (kW) * PR * Korr   (bezogen auf 1 Stunde)
#             -> my $pv = sprintf "%.0f", ($rad / 1000 * $peak * PRDEF);
#
################################################################################################
sub __openMeteoDWD_ApiResponse {
  my $paref      = shift;
  my $err        = shift;
  my $myjson     = shift;

  my $name        = $paref->{name};
  my $caller      = $paref->{caller};
  my $string      = $paref->{string};
  my $allstrings  = $paref->{allstrings};
  my $requestmode = $paref->{requestmode};                # MODEL / WEATHERMODEL / GHIREFILL
  my $stc         = $paref->{stc};                        # Startzeit API Abruf
  my $lang        = $paref->{lang};
  my $debug       = $paref->{debug};
  my $submodel    = $paref->{submodel};

  my $hash    = $defs{$name};
  my $t       = int time;
  my $sta     = [gettimeofday];                           # Start Response Verarbeitung
  my $nghi    = 0;
  $paref->{t} = $t;

  my $msg;

  if ($err ne "") {
      $msg = 'Open-Meteo API server response: '.$err;

      Log3 ($name, 1, "$name - $msg");

      $data{$name}{statusapi}{OpenMeteo}{'?All'}{response_message} = $err;

      singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );
      $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                                 # Verarbeitungszeit ermitteln
      $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));           # API Laufzeit ermitteln

      return;
  }
  elsif ($myjson ne "") {                                                                                              # Evaluiere ob Daten im JSON-Format empfangen wurden
      my ($success) = evaljson ($hash, $myjson);

      if (!$success) {
          $msg = 'ERROR - invalid Open-Meteo API server response';

          Log3 ($name, 1, "$name - $msg");

          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );
          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          return;
      }

      my $rt    = (timestampToTimestring ($t, $lang))[3];
      my $jdata = decode_json ($myjson);

      $data{$name}{statusapi}{OpenMeteo}{'?All'}{lastretrieval_time}      = $rt;
      $data{$name}{statusapi}{OpenMeteo}{'?All'}{lastretrieval_timestamp} = $t;

      ## bei Fehler in API intern kommt
      ###################################
      # error:  true
      # reason: <Grund>

      if ($jdata->{'error'}) {
          $msg = "Open-Meteo API server ERROR response: ".$jdata->{'reason'};

          Log3 ($name, 3, "$name - $msg");

          singleUpdateState ( {hash => $hash, state => $msg, evt => 1} );

          $data{$name}{statusapi}{OpenMeteo}{'?All'}{response_message} = $jdata->{'reason'};

          $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
          $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

          return;
      }

      $data{$name}{statusapi}{OpenMeteo}{'?All'}{response_message} = 'success';

      if ($debug =~ /apiCall/xs) {
          Log3 ($name, 1, qq{$name DEBUG> Open-Meteo API Call - server response for PV string "$string"});
          Log3 ($name, 1, "$name DEBUG> Open-Meteo API Call - status: success");
      }

      my $date  = strftime "%Y-%m-%d", localtime(time);
      my $refts = timestringToTimestamp ($date.' 00:00:00');                                      # Referenztimestring
      my $peak  = StringVal ($name, $string, 'peak', 0);                                          # String Peak (kWp)
      $peak    *= 1000;                                                                           # kWp in Wp

      ## aktuelle Wetterdaten
      #########################
      my ($curwid, $currain, $curwcc, $curtmp, $curstr);

      if ($submodel ne 'SatelliteRadiation') {
          if (defined $jdata->{current}{time}) {
              ($err, $curstr) = timestringUTCtoLocal ($name, $jdata->{current}{time}, '%Y-%m-%dT%H:%M');

              if ($err) {
                  $msg = 'ERROR - Open-Meteo invalid time conversion: '.$err;
                  Log3 ($name, 1, "$name - $msg");
                  singleUpdateState ( {hash => $hash, state => $err, evt => 1} );
                  return;
              }

              $curwid  = $jdata->{current}{weather_code};
              $curwcc  = $jdata->{current}{cloud_cover};
              $currain = $jdata->{current}{rain};
              $curtmp  = $jdata->{current}{temperature_2m};
          }
      }

      ## Stundenwerte
      #################
      my $k = 0;

      while ($jdata->{hourly}{time}[$k]) {
          ($err, my $otmstr) = timestringUTCtoLocal ($name, $jdata->{hourly}{time}[$k], '%Y-%m-%dT%H:%M');

          if ($err) {
              $msg = 'ERROR - Open-Meteo invalid time conversion: '.$err;
              Log3 ($name, 1, "$name - $msg");
              singleUpdateState ( {hash => $hash, state => $err, evt => 1} );
              return;
          }

          my $ots     = timestringToTimestamp  ($otmstr);
          my $pvtmstr = (timestampToTimestring ($ots - 3600))[0];                                   # Strahlung wird als Durchschnitt der !vorangegangenen! Stunde geliefert!

          if (timestringToTimestamp ($pvtmstr) < $refts && $submodel ne 'HistoricalData') {
              $k++;
              next;                                                                                 # Daten älter als akt. Tag 00:00:00 verwerfen
          }

          ## Strahlungsdaten
          ####################
          if ($submodel ne 'HistoricalData') {
              if ($requestmode eq 'MODEL') {
                  my $gtiwh = $jdata->{hourly}{global_tilted_irradiance}[$k];                           # GTI in Wh/m2
                  my $radwh = $jdata->{hourly}{shortwave_radiation}[$k];                                # Solarstrahlung GHI

                  if (defined $radwh) {                                                                 # Globalstrahlung für KI
                      my $radkJ = 10 * (sprintf "%.0f", ($radwh * WH2KJ) / 10);                         # Umrechnung Wh/m2 in kJ/m2
                      $data{$name}{solcastapi}{'?All'}{$pvtmstr}{Rad1h} = $radkJ;                       # Startstunde verschieben

                      debugLog ($paref, 'apiProcess', "Open-Meteo API $pvtmstr - Global Radiation Rad1h: $radkJ");
                  }

                  if (defined $gtiwh) {                                                                 # Global Tilted Radiation - zur PV Berechnung jedes Strings
                      my $pv = sprintf "%.2f", int ($gtiwh / 1000 * $peak * PRDEF);                     # GTI wird in kWh/m2 genutzt

                      $data{$name}{solcastapi}{$string}{$pvtmstr}{pv_estimate50} = $pv;                 # Startstunde verschieben
                      $data{$name}{solcastapi}{$string}{$pvtmstr}{GTIWh}         = $gtiwh;              # Startstunde verschieben, GTI wird für jeden String separat geliefert

                      debugLog ($paref, 'apiProcess', "Open-Meteo API $pvtmstr - GTIWh: $gtiwh, PV estimate: $pv Wh");
                  }
              }
          }

          ## Refill GHI Strahlungsdaten
          ###############################
          if ($submodel eq 'HistoricalData') {
              if ($requestmode eq 'GHIREFILL') {
                  my $srwh = $jdata->{hourly}{shortwave_radiation}[$k];                                 # Solarstrahlung GHI

                  if ($srwh) {                                                                          # Globalstrahlung für KI
                      my $ghikj = 10 * (sprintf "%.0f", ($srwh * WH2KJ) / 10);                          # Umrechnung Wh/m2 in kJ/m2

                      $pvtmstr =~ /^(\d{4})-(\d{2})-(\d{2})\s(\d{2})/xs;
                      my $tidx = $1.$2.$3.(sprintf "%02d", ($4 + 1));

                      if (AiRawdataVal ($name, $tidx, 'rad1h', 0)) {
                          $data{$name}{aidectree}{airaw}{$tidx}{rad1h} = $ghikj;
                          $nghi++;
                          debugLog ($paref, 'apiProcess', "Open-Meteo API Index $tidx - Global Radiation GHI replaced: $ghikj");
                      }
                  }
              }
          }

          ## Wetterdaten
          ################
          if ($submodel ne 'SatelliteRadiation' && $submodel ne 'HistoricalData') {
              my $don  = $jdata->{hourly}{is_day}[$k];
              my $temp = $jdata->{hourly}{temperature_2m}[$k];
              my $rain = $jdata->{hourly}{rain}[$k];                                                    # Regen in Millimeter = kg/m2
              my $wid  = $jdata->{hourly}{weather_code}[$k];
              my $wcc  = $jdata->{hourly}{cloud_cover}[$k];

              my $fwtg = formatWeatherTimestrg ($pvtmstr);                                              # Zeit gemäß DWD_OpenData-Format

              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{rr1c}       = $rain if(defined $rain);
              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{StartTime}  = $pvtmstr;

              $fwtg = formatWeatherTimestrg ($otmstr);                                                  # Zeit gemäß DWD_OpenData-Format

              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{don}        = $don  if(defined $don);
              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{neff}       = $wcc  if(defined $wcc);
              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{ww}         = $wid  if(defined $wid);
              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{ttt}        = $temp if(defined $temp);
              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{UpdateTime} = $rt;
              $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{StartTime}  = $otmstr;

              if ($k == 0) {
                  $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{neff} = $curwcc  if(defined $curwcc);
                  $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{ww}   = $curwid  if(defined $curwid);
                  $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{ttt}  = $curtmp  if(defined $curtmp);
                  $data{$name}{weatherapi}{OpenMeteo}{$fwtg}{rr1c} = $currain if(defined $currain);
              }

              if ($debug =~ /apiProcess/xs) {
                  Log3 ($name, 1, "$name DEBUG> Open-Meteo API $pvtmstr - RR1c: ".       (defined $rain ? $rain : '-'));
                  Log3 ($name, 1, "$name DEBUG> Open-Meteo API $otmstr - DoN: ".         (defined $don  ? $don  : '-'));
                  Log3 ($name, 1, "$name DEBUG> Open-Meteo API $otmstr - Temp: ".        (defined $temp ? $temp : '-'));
                  Log3 ($name, 1, "$name DEBUG> Open-Meteo API $otmstr - Weather Code: ".(defined $wid  ? $wid  : '-'));
                  Log3 ($name, 1, "$name DEBUG> Open-Meteo API $otmstr - Cloud Cover: ". (defined $wcc  ? $wcc  : '-'));

                  if ($curstr && $k == 0) {
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API $curstr - current Temp: ".        (defined $curtmp  ? $curtmp   : '-'));
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API $curstr - current Weather Code: ".(defined $curwid  ? $curwid   : '-'));
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API $curstr - current Cloud Cover: ". (defined $curwcc  ? $curwcc   : '-'));
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API $curstr - current Rain: ".        (defined $currain ? $currain  : '-'));
                  }
              }
          }

          $k++;
      }

      ## Tageswerte (Sonnenauf- und untergang)
      ##########################################
      if ($submodel ne 'SatelliteRadiation') {
          $k = 0;

          while ($jdata->{daily}{time}[$k]) {
              my $oday = $jdata->{daily}{time}[$k];

              ($err, my $sunrise) = timestringUTCtoLocal ($name, $jdata->{daily}{sunrise}[$k], '%Y-%m-%dT%H:%M');
              ($err, my $sunset)  = timestringUTCtoLocal ($name, $jdata->{daily}{sunset}[$k],  '%Y-%m-%dT%H:%M');

              if ($err) {
                  $msg = 'ERROR - Open-Meteo invalid time conversion: '.$err;
                  Log3 ($name, 1, "$name - $msg");
                  singleUpdateState ( {hash => $hash, state => $err, evt => 1} );
                  return;
              }

              if ($k == 0) {
                  $data{$name}{weatherapi}{OpenMeteo}{sunrise}{today} = $sunrise;
                  $data{$name}{weatherapi}{OpenMeteo}{sunset}{today}  = $sunset;

                  if ($debug =~ /apiProcess/xs) {
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API - Sunrise Today: $sunrise");
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API - SunSet Today: $sunset");
                  }
              }

              if ($k == 1) {
                  $data{$name}{weatherapi}{OpenMeteo}{sunrise}{tomorrow} = $sunrise;
                  $data{$name}{weatherapi}{OpenMeteo}{sunset}{tomorrow}  = $sunset;

                  if ($debug =~ /apiProcess/xs) {
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API - Sunrise Tomorrow: $sunrise");
                      Log3 ($name, 1, "$name DEBUG> Open-Meteo API - SunSet Tomorrow: $sunset");
                  }
              }

              $k++;
          }
      }

      ## 15 Minuten Werte
      #####################
      if ($requestmode eq 'MODEL' && $submodel ne 'SatelliteRadiation') {
          $paref->{jdata}     = $jdata;
          $paref->{indicator} = 'global_tilted_irradiance';

          my $haggr = ___15Minutes2HourAggregator ($paref);                                        # 15 Minuten zu 1h Aggregation

          if ($haggr) {
              for my $tmstr (sort keys %{$haggr->{hourly}}) {
                  my $gtiwh = $haggr->{hourly}{$tmstr}{$paref->{indicator}};
                  my $pv    = sprintf "%.2f", int ($gtiwh / 1000 * $peak * PRDEF);

                  #$data{$name}{solcastapi}{$string}{$tmstr}{GTIWh}         = $gtiwh;
                  #$data{$name}{solcastapi}{$string}{$tmstr}{pv_estimate50} = $pv;

                  #debugLog ($paref, 'apiProcess', "Open-Meteo API - do 15 min Aggr $tmstr - GTIWh: $gtiwh, PV estimate: $pv Wh");
              }
          }

          delete $paref->{indicator};
          delete $paref->{jdata};
      }
  }

  ___setOpenMeteoAPIcallKeyData ($paref);

  if ($nghi) {
      $err = writeCacheToFile ($hash, 'airaw', $airaw.$name);

      if (!$err) {
          $data{$name}{current}{aitrawstate} = 'ok';
          Log3 ($name, 3, qq{$name - aiRawData -> number of datasets replaced rad1h: $nghi});
          debugLog ($paref, 'aiProcess', "AI raw data saved into file: ".$airaw.$name);
      }
  }

  Log3 ($name, 4, qq{$name - Open-Meteo API answer received for string "$string"});

  my $param = {
      name           => $name,
      debug          => $debug,
      allstrings     => $allstrings,
      submodel       => $submodel,
      callequivalent => $paref->{callequivalent},
      requestmode    => $requestmode,
      lang           => $lang
  };

  $data{$name}{current}{runTimeLastAPIProc}   = sprintf "%.4f", tv_interval($sta);                             # Verarbeitungszeit ermitteln
  $data{$name}{current}{runTimeLastAPIAnswer} = sprintf "%.4f", (tv_interval($stc) - tv_interval($sta));       # API Laufzeit ermitteln

return &$caller($param);
}

################################################################
#            OpenMeteo URL zusammenstellen
################################################################
sub ___createOpenMeteoURL {
  my $paref       = shift;
  my $name        = $paref->{name};
  my $submodel    = $paref->{submodel};                                       # abzufragendes Datenmodell
  my $requestmode = $paref->{requestmode};
  my $string      = $paref->{string};

  my $err;
  my ($set, $lat, $lon, $elev) = locCoordinates();

  if (!$set) {
      $err = qq{ERROR - the attribute 'latitude' and/or 'longitude' in global device is not set};
      Log3 ($name, 1, "$name - $err");
      return;
  }

  my $tilt = StringVal ($name, $string, 'tilt',   '<unknown>');
  my $az   = StringVal ($name, $string, 'azimut', '<unknown>');

  if ($requestmode eq 'WEATHERMODEL' && $string eq 'KI-based') {$tilt = 0; $az = 0;}                              # Dummy Settings
  if ($requestmode eq 'GHIREFILL'    && $string eq 'Dummy')    {$tilt = 0; $az = 0;}                              # Dummy Settings

  if ($tilt eq '<unknown>' || $az eq '<unknown>') {
      $err = qq{ERROR OpenMeteo API Call - the attribute 'setupStringAzimuth' and/or 'setupStringDeclination' is not set};
      Log3 ($name, 1, "$name - $err");
      return;
  }

  my $url;

  if ($submodel eq 'OpenMeteoDWDEnsembleAPI') {                                                                   # Ensemble Modell gewählt
      $url  = "https://ensemble-api.open-meteo.com/v1/ensemble?";
      $url .= "&latitude=".$lat;
      $url .= "&longitude=".$lon;
      $url .= "&hourly=temperature_2m,rain,weather_code,cloud_cover,is_day,global_tilted_irradiance,shortwave_radiation";
      $url .= "&forecast_hours=72";
      $url .= "&forecast_days=2";
      $url .= "&tilt=".$tilt;
      $url .= "&azimuth=".$az;
  }

  if ($submodel eq 'OpenMeteoDWDAPI' || $submodel eq 'OpenMeteoDWDD2API' || $submodel eq 'OpenMeteoWorldAPI') {
      $url  = "https://api.open-meteo.com/v1/forecast?";
      $url .= "models=icon_seamless"                            if($submodel eq 'OpenMeteoDWDAPI');
      $url .= "models=icon_d2"                                  if($submodel eq 'OpenMeteoDWDD2API');
      $url .= "models=best_match"                               if($submodel eq 'OpenMeteoWorldAPI');
      $url .= "&latitude=".$lat;
      $url .= "&longitude=".$lon;
      $url .= "&hourly=temperature_2m,rain,weather_code,cloud_cover,is_day,global_tilted_irradiance,shortwave_radiation";
      $url .= "&current=temperature_2m,weather_code,rain,cloud_cover";
      $url .= "&minutely_15=rain,global_tilted_irradiance,shortwave_radiation";
      $url .= "&daily=sunrise,sunset";
      $url .= "&forecast_hours=72";
      $url .= "&forecast_days=2";
      $url .= "&tilt=".$tilt;
      $url .= "&azimuth=".$az;
  }

  if ($submodel eq 'SatelliteRadiation') {
      $url  = "https://satellite-api.open-meteo.com/v1/archive?";
      $url .= "models=satellite_radiation_seamless";
      $url .= "&latitude=".$lat;
      $url .= "&longitude=".$lon;
      $url .= "&hourly=global_tilted_irradiance";
      $url .= "&forecast_hours=24";
      $url .= "&utm_source=substack";
      $url .= "&utm_medium=email";
      $url .= "&tilt=".$tilt;
      $url .= "&azimuth=".$az;
  }

  if ($submodel eq 'HistoricalData') {
      $url  = "https://archive-api.open-meteo.com/v1/archive?";
      $url .= "latitude=".$lat;
      $url .= "&longitude=".$lon;
      $url .= "&hourly=shortwave_radiation";
      $url .= "&start_date=".$paref->{startdate};
      $url .= "&end_date=".$paref->{enddate};
  }

return $url;
}

################################################################
#        15-Minuten Werte auf eine Stunde aggregieren
#   Return: Referenz auf Ergebnishash
################################################################
sub ___15Minutes2HourAggregator {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $jdata     = $paref->{jdata};
  my $indicator = $paref->{indicator};              # der zu bearbeitende Indikator

  return if(!$jdata || !$indicator);

  my ($haggr, $nct, $lzstr);
  my $k = 0;

  while ($jdata->{minutely_15}{time}[$k]) {
      my $tstr = $jdata->{minutely_15}{time}[$k];

      $lzstr = $jdata->{minutely_15}{time}[$k] if($tstr =~ /T..:00/xs);

      if (!$lzstr) {
          $k++;
          next;
      }

      if ($tstr =~ /T..:15/xs) {
          $nct = $lzstr;
      }

      if (!$nct) {
          $k++;
          next;
      }

      $haggr->{hourly}{$nct}{$indicator} = $jdata->{minutely_15}{$indicator}[$k];

      $k++;
  }

  if ($haggr) {
      for my $key (sort keys %{$haggr->{hourly}}) {
          my ($err, $otmstr) = timestringUTCtoLocal ($name, $key, '%Y-%m-%dT%H:%M');

          if ($err) {
              Log3 ($name, 1, "$name - ERROR - Open-Meteo invalid time conversion in Aggregator: $err");
              delete $haggr->{hourly}{$key}{$indicator};
              next;
          }

          $haggr->{hourly}{$otmstr}{$indicator} = sprintf "%.0f", $haggr->{hourly}{$key}{$indicator} if(defined $haggr->{hourly}{$key}{$indicator});
          delete $haggr->{hourly}{$key};
      }
  }

return $haggr;
}

################################################################
#     Kennzahlen aus letzten Open-Meteo Request ableiten
################################################################
sub ___setOpenMeteoAPIcallKeyData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $lang  = $paref->{lang};
  my $debug = $paref->{debug};
  my $cequ  = $paref->{callequivalent};
  my $t     = $paref->{t} // time;

  $data{$name}{statusapi}{OpenMeteo}{'?All'}{todayDoneAPIrequests} += $cequ;

  my $dar = StatusAPIVal ($name, 'OpenMeteo', '?All', 'todayDoneAPIrequests', 0);
  my $dac = StatusAPIVal ($name, 'OpenMeteo', '?All', 'todayDoneAPIcalls',    0);
  my $asc = CurrentVal   ($name, 'allstringscount', 1);

  my $drr = OMETMAXREQ - $dar;                                                         # verbleibende Requests
  $drr    = 0 if($drr < 0);
  my $rac = $drr / ($cequ * $asc);                                                     # verbleibende Calls

  $data{$name}{statusapi}{OpenMeteo}{'?All'}{todayRemainingAPIrequests} = $drr;
  $data{$name}{statusapi}{OpenMeteo}{'?All'}{currentAPIinterval}        = OMETEOREPDEF;

  ## Berechnung des optimalen Request Intervalls
  ################################################
  my $edate = strftime "%Y-%m-%d 23:58:00", localtime($t);
  my $ets   = 3600 + timestringToTimestamp ($edate);                                   # V 1.50.3 1h Sicherheitspuffer -> Intervall vergößern
  my $rmdif = $ets - int $t;

  if ($rac) {
      my $optrep = sprintf "%.0f", ($rmdif / $rac);
      $optrep    = OMETEOREPDEF if($optrep < OMETEOREPDEF);

      $data{$name}{statusapi}{OpenMeteo}{'?All'}{currentAPIinterval} = $optrep;
  }

  debugLog ($paref, "apiProcess|apiCall", "Open-Meteo API Call - remaining Requests: $drr, Call equivalent: $cequ, new call interval: ".StatusAPIVal ($name, 'OpenMeteo', '?All', 'currentAPIinterval', OMETEOREPDEF));

return;
}

###############################################################
#                       Getter data
###############################################################
sub _getdata {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};
  
  centralTask ($hash);

return 'Data cycle triggered, watch readings';
}

###############################################################
#                       Getter html
###############################################################
sub _gethtml {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg} // 'both';

return pageAsHtml ($name, '-', $arg);
}

###############################################################
#                       Getter ftui
#                ohne Eintrag in Get-Liste
###############################################################
sub _getftui {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg} // '';

return pageAsHtml ($name, 'ftui', $arg);
}

################################################################
#          verborgener Getter outputMessages
################################################################
sub _getoutputMessages {             ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $out = outputMessages ($paref);
  $out    = qq{<html>$out</html>};

  $data{$name}{messages}{999999}{RD} = 1;                   # Lesekennzeichen setzen

  ## asynchrone Ausgabe
  #######################
  #$err          = getClHash($hash);
  #$paref->{out} = $out;
  #InternalTimer(gettimeofday()+3, "FHEM::SolarForecast::__plantCfgAsynchOut", $paref, 0);

return $out;
}

###############################################################
#                       Getter pvQualities
###############################################################
sub _getForecastQualities {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg} // q{};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'qualities');
  $ret   .= lineFromSpaces ($ret, 5);

  if ($arg eq 'imgget') {                                # Ausgabe aus dem Grafikheader Qualitätsicon
      $ret =~ s/\n/<br>/g;
  }

return $ret;
}

###############################################################
#                       Getter pvHistory
###############################################################
sub _getlistPVHistory {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'pvhist', $arg);
  return if(!$ret);

  $ret   .= lineFromSpaces ($ret, 20);
  $ret    =~ s/\n/<br>/g;

return $ret;
}

###############################################################
#                       Getter pvCircular
###############################################################
sub _getlistPVCircular {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'circular', $arg);
  $ret   .= lineFromSpaces ($ret, 10);

return $ret;
}

###############################################################
#                       Getter nextHours
###############################################################
sub _getlistNextHours {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'nexthours');
  $ret   .= lineFromSpaces ($ret, 20);

return $ret;
}

###############################################################
#                       Getter valCurrent
###############################################################
sub _getlistCurrent {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'current');
  $ret   .= lineFromSpaces ($ret, 30);

return $ret;
}

###############################################################
#                       Getter valBattery
###############################################################
sub _getlistvalBattery {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'batteries', $arg);
  $ret   .= lineFromSpaces ($ret, 30);

return $ret;
}

###############################################################
#                       Getter valConsumerMaster
###############################################################
sub _getlistvalConsumerMaster {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'consumers', $arg);
  $ret   .= lineFromSpaces ($ret, 10);

return $ret;
}

###############################################################
#                       Getter valInverter
###############################################################
sub _getlistvalInverter {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'inverters', $arg);
  $ret   .= lineFromSpaces ($ret, 30);

return $ret;
}

###############################################################
#                       Getter valProducer
###############################################################
sub _getlistvalProducer {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'producers', $arg);
  $ret   .= lineFromSpaces ($ret, 30);

return $ret;
}

###############################################################
#                       Getter valStrings
###############################################################
sub _getlistvalStrings {
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'strings', $arg);
  $ret   .= lineFromSpaces ($ret, 30);

return $ret;
}

###############################################################
#                       Getter radiationApiData
###############################################################
sub _getlistRadiationApiData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'radiationApiData');
  $ret   .= lineFromSpaces ($ret, 10);

return $ret;
}

###############################################################
#                       Getter weatherApiData
###############################################################
sub _getlistWeatherApiData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'weatherApiData');
  $ret   .= lineFromSpaces ($ret, 20);

return $ret;
}

###############################################################
#                       Getter statusApiData
###############################################################
sub _getlistStatusApiData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $ret = listDataPool   ($hash, 'statusApiData');
  $ret   .= lineFromSpaces ($ret, 20);

return $ret;
}

###############################################################
#                       Getter dwdCatalog
###############################################################
sub _getdwdCatalog {
  my $paref = shift;
  my $arg   = $paref->{arg} // 'byID';
  my $name  = $paref->{name};

  my ($aa,$ha) = parseParams ($arg);

  my $sort    = grep (/byID/,   @$aa) ? 'byID'      :
                grep (/byName/, @$aa) ? 'byName'    :
                'byID';
  my $export  = grep (/exportgpx/, @$aa) ? 'exportgpx' : '';
  my $force   = grep (/force/,     @$aa) ? 'force'     : '';

  $paref->{sort}    = $sort;
  $paref->{export}  = $export;
  $paref->{filtid}  = $ha->{id}   ? $ha->{id}   : '';
  $paref->{filtnam} = $ha->{name} ? $ha->{name} : '';
  $paref->{filtlat} = $ha->{lat}  ? $ha->{lat}  : '';
  $paref->{filtlon} = $ha->{lon}  ? $ha->{lon}  : '';

  my $msg = "The DWD Station catalog is initially loaded into SolarForecast.\n".
            "Please execute the command 'get $name $paref->{opt} $arg' again.";

  if ($force) {
      __dwdStatCatalog_Request ($paref);
      return 'The DWD Station Catalog is forced to loaded into SolarForecast.';
  }

  if (!scalar keys %{$data{$name}{dwdcatalog}}) {                             # Katalog ist nicht geladen
      readCacheFile ({ name      => $name,
                       debug     => $paref->{debug},
                       file      => $dwdcatalog,
                       cachename => 'dwdcatalog',
                       title     => 'DWD Station Catalog'
                     }
                    );

      if (!scalar keys %{$data{$name}{dwdcatalog}}) {                         # Ladung von File nicht erfolgreich
          __dwdStatCatalog_Request ($paref);
          return $msg;
      }
  }

  return __generateCatOut ($paref);

return;
}

###############################################################
#         Ausgabe DWD Katalog formatieren
###############################################################
sub __generateCatOut {
  my $paref = shift;
  my $arg   = $paref->{arg};
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $lang  = $paref->{lang};

  my $sort    = $paref->{sort};
  my $export  = $paref->{export};
  my $filtid  = $paref->{filtid};
  my $filtnam = $paref->{filtnam};
  my $filtlat = $paref->{filtlat};
  my $filtlon = $paref->{filtlon};

  my $filter  = $filtid ? 'id:'.$filtid : '';
  $filter    .= ',' if($filter && $filtnam);
  $filter    .= $filtnam ? 'name:'.$filtnam : '';
  $filter    .= ',' if($filter && $filtlat);
  $filter    .= $filtlat ? 'lat:'.$filtlat : '';
  $filter    .= ',' if($filter && $filtlon);
  $filter    .= $filtlon ? 'lon:'.$filtlon : '';

  my $select = 'sort='.$sort;
  if ($filter) {
      $select .= ' filter=';
      $select .= trim ($filter);
  }
  $select .= ' ' if($export);
  $select .= $export;

  # Katalog Organisation (default ist 'byID)
  ############################################
  my ($err, $isfil);
  my %temp;

  if ($sort eq 'byName') {
      for my $id (keys %{$data{$name}{dwdcatalog}}) {
          $paref->{id} = $id;

          ($err, $isfil) = ___isCatFiltered ($paref);
          return (split " at", $err)[0] if($err);
          next                          if($isfil);

          my $nid             = $data{$name}{dwdcatalog}{$id}{stnam};
          $temp{$nid}{stnam}  = $data{$name}{dwdcatalog}{$id}{stnam};
          $temp{$nid}{id}     = $data{$name}{dwdcatalog}{$id}{id};
          $temp{$nid}{latdec} = $data{$name}{dwdcatalog}{$id}{latdec};                         # Latitude Dezimalgrad
          $temp{$nid}{londec} = $data{$name}{dwdcatalog}{$id}{londec};                         # Longitude Dezimalgrad
          $temp{$nid}{elev}   = $data{$name}{dwdcatalog}{$id}{elev};
      }
  }
  elsif ($sort eq 'byID') {
      for my $id (keys %{$data{$name}{dwdcatalog}}) {
          $paref->{id} = $id;
          ($err, $isfil) = ___isCatFiltered ($paref);
          return (split " at", $err)[0] if($err);
          next                          if($isfil);

          $temp{$id}{stnam}  = $data{$name}{dwdcatalog}{$id}{stnam};
          $temp{$id}{id}     = $data{$name}{dwdcatalog}{$id}{id};
          $temp{$id}{latdec} = $data{$name}{dwdcatalog}{$id}{latdec};                          # Latitude Dezimalgrad
          $temp{$id}{londec} = $data{$name}{dwdcatalog}{$id}{londec};                          # Longitude Dezimalgrad
          $temp{$id}{elev}   = $data{$name}{dwdcatalog}{$id}{elev};
      }
  }

  if ($export eq 'exportgpx') {                                                                   # DWD Katalog als gpx speichern
      my @data = ();
      push @data, '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>';
      push @data, '<gpx xmlns="http://www.topografix.com/GPX/1/1" creator="FHEM::SolarForecast"';
      push @data, 'version="1.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"';
      push @data, 'xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">';

      for my $idx (sort keys %temp) {
          my $londec = $temp{"$idx"}{londec};
          my $latdec = $temp{"$idx"}{latdec};
          my $elev   = $temp{"$idx"}{elev};
          my $id     = $temp{"$idx"}{id};
          my $stnam  = $temp{"$idx"}{stnam};

          push @data, qq{<wpt lat="$latdec" lon="$londec">};
          push @data, qq{ <ele>$elev</ele>};
          push @data, qq{ <name>$stnam (ID=$id, Latitude=$latdec, Longitude=$londec)</name>};
          push @data, qq{ <sym>City</sym>};
          push @data, qq{</wpt>};
      }

      push @data, '</gpx>';

      $err = FileWrite ( {FileName  => $dwdcatgpx,
                          ForceType => 'file'
                         }, @data
                       );

      if (!$err) {
          debugLog ($paref, 'dwdComm', qq{DWD catalog saved as gpx content: }.$dwdcatgpx);
      }
      else {
          Log3 ($name, 1, "$name - ERROR - $err");
          return $err;
      }
  }

  my $noe = scalar keys %temp;

  ## Ausgabe                                                   
  ############
  my $out  = '<html>';
  $out    .= '<b>'.encode('utf8', $hqtxt{dwdcat}{$lang}).'</b><br>';                             # The Deutscher Wetterdienst Station Catalog
  $out    .= encode('utf8', $hqtxt{nrsele}{$lang}).' '.$noe.'<br>';                              # Selected entries
  $out    .= "($select) <br><br>";

  $out    .= qq{<table class="roomoverview" style="text-align:left; border:1px solid; padding:5px; border-spacing:5px; margin-left:auto; margin-right:auto;">};
  $out    .= qq{<tr style="font-weight:bold;">};
  $out    .= qq{<td style="text-decoration:underline; padding: 5px;"> ID          </td>};
  $out    .= qq{<td style="text-decoration:underline; padding: 5px;"> NAME        </td>};
  $out    .= qq{<td style="text-decoration:underline; padding: 5px;"> LATITUDE    </td>};
  $out    .= qq{<td style="text-decoration:underline; padding: 5px;"> LONGITUDE   </td>};
  $out    .= qq{<td style="text-decoration:underline; padding: 5px;"> ELEVATION   </td>};
  $out    .= qq{</tr>};
  $out    .= qq{<tr></tr>};

  for my $key (sort keys %temp) {
      $out .= qq{<tr>};
      $out .= qq{<td style="padding: 5px;                    "> $temp{"$key"}{id}       </td>};
      $out .= qq{<td style="padding: 5px; white-space:nowrap;"> $temp{"$key"}{stnam}    </td>};
      $out .= qq{<td style="padding: 5px;                    "> $temp{"$key"}{latdec}   </td>};
      $out .= qq{<td style="padding: 5px;                    "> $temp{"$key"}{londec}   </td>};
      $out .= qq{<td style="padding: 5px;                    "> $temp{"$key"}{elev}     </td>};
      $out .= qq{</tr>};
  }

  $out    .= qq{</table>};
  $out    .= qq{</html>};

  undef %temp;

return $out;
}

###############################################################
#         Ausgabe DWD Katalog Einträge filtern
###############################################################
sub ___isCatFiltered {
  my $paref = shift;
  my $id    = $paref->{id};
  my $name  = $paref->{name};
  my $type  = $paref->{type};

  my $filtid  = $paref->{filtid};
  my $filtnam = $paref->{filtnam};
  my $filtlat = $paref->{filtlat};
  my $filtlon = $paref->{filtlon};

  my $isfil = 0;

  eval {$isfil = 1 if($filtid  && $id !~ /^$filtid$/ixs);
        $isfil = 1 if($filtnam && $data{$name}{dwdcatalog}{$id}{stnam}  !~ /^$filtnam$/ixs);
        $isfil = 1 if($filtlat && $data{$name}{dwdcatalog}{$id}{latdec} !~ /^$filtlat$/ixs);
        $isfil = 1 if($filtlon && $data{$name}{dwdcatalog}{$id}{londec} !~ /^$filtlon$/ixs);
       };

  if ($@) {
      return $@;
  }

return ('', $isfil);
}

####################################################################################################################
#   Download DWD Stationskatalog
#   https://www.dwd.de/DE/leistungen/met_verfahren_mosmix/mosmix_stationskatalog.cfg?view=nasPublication&nn=16102
####################################################################################################################
sub __dwdStatCatalog_Request {
  my $paref = shift;
  my $name  = $paref->{name};
  my $debug = $paref->{debug};

  my $hash  = $defs{$name};

  my $url = "https://www.dwd.de/DE/leistungen/met_verfahren_mosmix/mosmix_stationskatalog.cfg?view=nasPublication&nn=16102";

  debugLog ($paref, 'dwdComm', "Download DWD Station catalog from URL: $url");

  my $param = {
      url      => $url,
      timeout  => 10,
      name     => $name,
      debug    => $debug,
      stc      => [gettimeofday],
      lang     => $paref->{lang},
      method   => 'GET',
      callback => \&__dwdStatCatalog_Response
  };

  if ($debug =~ /dwdComm/x) {
      $param->{loglevel} = 1;
  }

  HttpUtils_NonblockingGet ($param);

return;
}

###############################################################
#          Download DWD Stationskatalog Response
# Für die Stationsliste im cfg-Format gilt:
# Die Angabe der Längen- und Breitengrade erfolgt in der Form
# Grad und Minuten, also beispielsweise wird die Angabe 53◦ 23′
# in Grad und Minuten hier mit Punkt als 53.23 repräsentiert.
###############################################################
sub __dwdStatCatalog_Response {
  my $paref = shift;
  my $err   = shift;
  my $dat   = shift;

  my $name  = $paref->{name};
  my $stc   = $paref->{stc};                                                                 # Startzeit API Abruf
  my $lang  = $paref->{lang};
  my $debug = $paref->{debug};

  my $msg;
  my $hash = $defs{$name};
  my $sta  = [gettimeofday];                                                                 # Start Response Verarbeitung

  if ($err ne "") {
      Log3 ($name, 1, "$name - ERROR - $err");

      return;
  }
  elsif ($dat ne "") {
      my @datarr = split "\n", $dat;

      for my $s (@datarr) {
          $s = encode ('utf8', $s);

          my ($id, $tail) = split " ", $s, 2;

          next if($id !~ /[A-Z0-9]+$/xs || $id eq 'ID');

          my $ri   = rindex ($tail, " ");
          my $elev = substr ($tail, $ri + 1);                                                # Meereshöhe
          $tail    = trim   (substr ($tail, 0, $ri));

          $ri      = rindex ($tail, " ");
          my $lon  = substr ($tail, $ri + 1);                                                # Longitude
          $tail    = trim   (substr ($tail, 0, $ri));

          $ri      = rindex ($tail, " ");
          my $lat  = substr ($tail, $ri + 1);                                                # Latitude
          $tail    = trim   (substr ($tail, 0, $ri));

          my ($icao, $stnam) = split " ", $tail, 2;                                          # ICAO = International Civil Aviation Organization, Stationsname

          my ($latg, $latm) = split /\./, $lat;                                              # in Grad und Minuten splitten
          my ($long, $lonm) = split /\./, $lon;
          my $latdec        = sprintf "%.2f", ($latg + ($latm / 60));
          my $londec        = sprintf "%.2f", ($long + ($lonm / 60));

          $data{$name}{dwdcatalog}{$id}{id}     = $id;
          $data{$name}{dwdcatalog}{$id}{stnam}  = $stnam;
          $data{$name}{dwdcatalog}{$id}{icao}   = $icao;
          $data{$name}{dwdcatalog}{$id}{lat}    = $lat;
          $data{$name}{dwdcatalog}{$id}{latdec} = $latdec;                                # Latitude Dezimalgrad
          $data{$name}{dwdcatalog}{$id}{lon}    = $lon;
          $data{$name}{dwdcatalog}{$id}{londec} = $londec;                                # Longitude Dezimalgrad
          $data{$name}{dwdcatalog}{$id}{elev}   = $elev;
      }

      $err = writeCacheToFile ($hash, 'dwdcatalog', $dwdcatalog);                            # DWD Stationskatalog speichern

      if (!$err) {
          debugLog ($paref, 'dwdComm', qq{DWD catalog saved into file: }.$dwdcatalog);
      }
      else {
          Log3 ($name, 1, "$name - ERROR - $err");
      }

      readCacheFile ({ name      => $name,
                       debug     => $debug,
                       file      => $dwdcatalog,
                       cachename => 'dwdcatalog',
                       title     => 'DWD Station Catalog'
                     }
                    );
  }

  my $prt = sprintf "%.4f", (tv_interval ($stc) - tv_interval ($sta));                                     # Laufzeit ermitteln
  debugLog ($paref, 'dwdComm', "DWD Station Catalog retrieval and processing required >$prt< seconds");

return;
}

###############################################################
#                       Getter aiDecTree
###############################################################
sub _getaiDecTree {                   ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $arg   = $paref->{arg} // return;

  my $ret;
  my $hash = $defs{$name};

  if ($arg eq 'aiRawData') {
      $ret  = "<span style='font-size:90%;'>";
      $ret .= listDataPool ($hash, 'aiRawData');
      $ret .= "</span>";
  }

  if ($arg eq 'aiRuleStrings') {
      $ret = __getaiRuleStrings ($paref);
  }

  $ret .= lineFromSpaces ($ret, 5);

return $ret;
}

################################################################
#  Gibt eine Liste von Zeichenketten zurück, die den AI
#  Entscheidungsbaum in Form von Regeln beschreiben
################################################################
sub __getaiRuleStrings {                 ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};

  my $hash  = $defs{$name};

  return 'the AI usage is not prepared' if(!isPrepared4AI ($hash));

  my $objref = AiDetreeVal ($hash, 'aitrained', '');
  return 'AI trained object is missed or not an ARRAY' if(ref $objref ne 'ARRAY');

  my $rs = 'no rules delivered';
  my (@rsl, %entities);
  my $tn = 0;

  for my $dtree (@{$objref}) {
      eval { my @rules = $dtree->rule_statements();                      # Returns a list of strings that describe the tree in rule-form
             $tn++;

             if ($tn == 1) {                                             # nur den ersten Tree ausgeben
                 push @rsl, '&nbsp;';
                 push @rsl, 'Tree: '.$tn;
                 push @rsl, '&nbsp;';
                 push @rsl, @rules;
             }

             $entities{$tn}{rules} = scalar @rules;                      # Anzahl der Regeln
             $entities{$tn}{nodes} = $dtree->nodes();                    # Returns the number of nodes in the trained decision tree
             $entities{$tn}{depth} = $dtree->depth();                    # Returns the depth of the tree. This is the maximum number of decisions that would need to be made to classify an unseen instance, i.e. the length of the longest path from the tree's root to a leaf.
             1;
           }
           or do { return $@;
                 };
  }

  my $atf = CircularVal ($hash, 99, 'aitrainLastFinishTs', 0);
  $atf    = '<b>'.$hqtxt{ailatr}{$lang}.' </b>'.($atf ? (timestampToTimestring ($atf, $lang))[0] : '-');
  my $art = $hqtxt{aitris}{$lang}.' '.CircularVal ($hash, 99, 'runTimeTrainAI', '-');

  my $agt = CurrentVal  ($hash, 'aiLastGetResultTime', '');
  $agt    = '<b>'.$hqtxt{ailgrt}{$lang}.'</b> '.($agt ? ($agt * 1000).' ms' : '-');

  if (@rsl) {
      my $l = scalar @rsl;
      $rs   = "<b>Trained AI Object contains an Ensemble of $tn trees (only the first Tree is printed out)</b>\n\n";

      for my $tree (1..$tn) {
          $rs .= "<b>Tree: $tree</b> -> Number of Rules: $entities{$tree}{rules} / Number of Nodes: $entities{$tree}{nodes} / Depth: $entities{$tree}{depth} \n";
      }

      $rs  .= "\n\n";
      $rs  .= "Rules: ".$hqtxt{airule}{$lang}."\n";
      $rs  .= "Nodes: ".$hqtxt{ainode}{$lang}."\n";
      $rs  .= "Depth: ".$hqtxt{aidept}{$lang};
      $rs  .= "\n\n";
      $rs  .= $atf.' / '.$art;
      $rs  .= "\n";
      $rs  .= $agt;
      $rs  .= "\n\n";
      $rs  .= join "\n", @rsl;
  }

return $rs;
}

###############################################################
#                       Getter ftuiFramefiles
# hole Dateien aus dem online Verzeichnis
# /fhem/contrib/SolarForecast/
# Ablage entsprechend Definition in controls_solarforecast.txt
###############################################################
sub _ftuiFramefiles {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $ret;
  my $upddo = 0;
  my $cfurl = BPATH.CFILE.PPATH;

  for my $file (@fs) {
      my $lencheck = 1;

      my ($cmerr, $cmupd, $cmmsg, $cmrec, $cmfile, $cmlen) = checkModVer ($name, $file, $cfurl);

      if ($cmerr && $cmmsg =~ /Automatic\scheck/xs && $cmrec =~ /Compare\syour\slocal/xs) {        # lokales control file ist noch nicht vorhanden -> update ohne Längencheck
          $cmfile   = 'FHEM/'.CFILE;
          $file     = CFILE;
          $lencheck = 0;
          $cmerr    = 0;
          $cmupd    = 1;

          Log3 ($name, 3, "$name - automatic install local control file $root/$cmfile");
      }

      if ($cmerr) {
          $ret = "$cmmsg<br>$cmrec";
          return $ret;
      }

      if ($cmupd) {
          $upddo = 1;
          $ret = __updPreFile ( { name     => $name,
                                  root     => $root,
                                  cmfile   => $cmfile,
                                  cmlen    => $cmlen,
                                  file     => $file,
                                  lencheck => $lencheck
                                }
                              );

          return $ret if($ret);
      }
  }

  ## finales Update control File
  ################################
  $ret = __updPreFile ( { name     => $name,
                          root     => $root,
                          cmfile   => 'FHEM/'.CFILE,
                          cmlen    => 0,
                          file     => CFILE,
                          lencheck => 0,
                          finalupd => 1
                        }
                      );

  return $ret if($ret);

  if (!$upddo) {
      return 'SolarForecast FTUI files are already up to date';
  }

return 'SolarForecast FTUI files updated';
}

###############################################################
#    File zum Abruf von url vorbereiten und in das
#    Zielverzeichnis schreiben
###############################################################
sub __updPreFile {
  my $pars     = shift;
  my $name     = $pars->{name};
  my $root     = $pars->{root};
  my $cmfile   = $pars->{cmfile};
  my $cmlen    = $pars->{cmlen};
  my $file     = $pars->{file};
  my $lencheck = $pars->{lencheck};
  my $finalupd = $pars->{finalupd} // 0;

  my $err;

  my $dir = $cmfile;
  $dir    =~ m,^(.*)/([^/]*)$,;
  $dir    = $1;
  $dir    = "" if(!defined $dir);                                                          # file in .

  my @p = split "/", $dir;

  for (my $i = 0; $i < int @p; $i++) {
      my $path = "$root/".join ("/", @p[0..$i]);

      if (!-d $path) {
          $err  = "The FTUI does not appear to be installed.<br>";
          $err .= "Please check whether the path $path is present and accessible.<br>";
          $err .= "After installing FTUI, come back and execute the get command again.";
          return $err;
      }
  }

  ($err, my $remFile) = __httpBlockingGet ($name, BPATH.$file.PPATH);

  if ($err) {
      Log3 ($name, 1, "$name - $err");
      return $err;
  }

  if ($lencheck && length ($remFile) ne $cmlen) {
      $err = "update ERROR: length of $file is not $cmlen Bytes";
      Log3 ($name, 1, "$name - $err");
      return $err;
  }

  $err = __updWriteFile ($root, $cmfile, $remFile);

  if ($err) {
      Log3 ($name, 1, "$name - $err");
      return $err;
  }

  Log3 ($name, 3, "$name - update done $file to $root/$cmfile ".($cmlen ? "(length: $cmlen Bytes)" : ''));

  if(!$lencheck && !$finalupd) {
      return 'SolarForecast update control file installed. Please retry the get command to update FTUI files.';
  }

return;
}

###############################################################
#                     File von url holen
###############################################################
sub __httpBlockingGet {
  my $name = shift;
  my $url  = shift;

  $url =~ s/%/%25/g;
  my %connecthash;
  my $unicodeEncoding = 1;

  $connecthash{url}           = $url;
  $connecthash{keepalive}     = ($url =~ m/localUpdate/ ? 0 : 1);                        # Forum #49798
  $connecthash{forceEncoding} = '' if($unicodeEncoding);

  my ($err, $dat) = HttpUtils_BlockingGet (\%connecthash);

  if ($err) {
      $err = "GetUrl ERROR: $err";
      return ($err, '');
  }

  if (!$dat) {
      $err = 'WARNING - empty file received';
      return ($err, '');
  }

return ('', $dat);
}

###############################################################
#               Updated File schreiben
###############################################################
sub __updWriteFile {
  my $root    = shift;
  my $fName   = shift;
  my $content = shift;

  my $fPath = "$root/$fName";
  
  open my $fh, '>:raw', $fPath or return "update ERROR open $fPath failed: $!";

  my $bytes = encode ('UTF-8', $content);
  my $written = syswrite $fh, $bytes;
  close $fh or return "update ERROR closing $fPath failed: $!";
  
  unless (defined $written) {
      return "update ERROR writing $fPath failed: $!";
  }
  
  my $expected = length $bytes;

  if ($written != $expected) {
      return sprintf "update ERROR wrote %d of %d bytes to %s", $written, $expected, $fPath;
  }

return;
}

################################################################
#                      Attr
# $cmd can be "del" or "set"
# $name is device name
# aName and aVal are Attribute name and value
################################################################
sub Attr {
  my $cmd   = shift;
  my $name  = shift;
  my $aName = shift;
  my $aVal  = shift;

  my $hash  = $defs{$name};
  my $type  = $hash->{TYPE};

  my ($do,$val, $err);

  ### nicht mehr benötigte Daten verarbeiten - Bereich kann später wieder raus !!
  ######################################################################################################################
  #if ($cmd eq 'set' && $aName =~ /^graphicShowDiff$/) {                            # 25.06.
  #    my $msg  = "The attribute $aName is replaced by 'graphicControl'.";
  #    if (!$init_done) {
  #        Log3 ($name, 1, "$name - $msg");
  #    }
  #    else {
  #        return $msg;
  #    }
  #}

  #if ($cmd eq 'set' && $aName =~ /^graphicHeaderShow$/) {                          # 15.04.
  #    my $msg  = "The attribute $aName is replaced by 'graphicSelect'.";
  #    if (!$init_done) {
  #        Log3 ($name, 1, "$name - $msg");
  #    }
  #    else {
  #        return $msg;
  #    }
  #}

  #if ($cmd eq 'set' && $aName =~ /^affectSolCastPercentile$/) {
  #    my $msg1 = "The attribute $aName is obsolete and will be deleted soon. Please press 'save config' when restart is finished.";
  #    my $msg2 = "The attribute $aName is obsolete and will be deleted soon.";
  #    if (!$init_done) {
  #        Log3 ($name, 1, "$name - $msg1");
  #        return $msg1;
  #    }
  #    else {
  #        return $msg2;
  #    }
  #}
  ######################################################################################################################

  if ($aName eq 'disable') {
      if($cmd eq 'set') {
          $do = $aVal ? 1 : 0;
      }

      $do  = 0 if($cmd eq 'del');
      $val = ($do == 1 ? 'disabled' : 'initialized');
      singleUpdateState ( {hash => $hash, state => $val, evt => 1} );
  }

  if ($aName eq 'ctrlNextDayForecastReadings') {
      deleteReadingspec ($hash, "Tomorrow_Hour.*");
  }

  if ($aName eq 'ctrlNextHoursSoCForecastReadings') {
      deleteReadingspec ($hash, "Battery_NextHour.._SoCforecast_..");
  }

  if ($aName eq 'graphicHeaderOwnspecValForm') {
      $err = isGhoValFormValid ($name, $aVal);
      return $err if($err);
  }

  if ($cmd eq 'set') {
      if ($init_done && $aName eq 'ctrlUserExitFn') {
          ($err) = checkCode ($name, $aVal, 'cc1');
          return $err if($err);
      }
  }

  my $params = {
      name  => $name,
      type  => $type,
      cmd   => $cmd,
      aName => $aName,
      aVal  => $aVal
  };

  $aName = 'consumer' if($aName =~ /consumer?(\d+)$/xs);

  if ($hattr{$aName} && defined &{$hattr{$aName}{fn}}) {
      my $ret = q{};
      $ret    = &{$hattr{$aName}{fn}} ($params);
      return $ret;
  }

return;
}

################################################################
#                      Attr consumer
################################################################
sub _attrconsumer {                      ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};

  return if(!$init_done);                                                                  # Forum: https://forum.fhem.de/index.php/topic,117864.msg1159959.html#msg1159959

  my $hash  = $defs{$name};

  my $valid = {
      aliasshort    => '',
      type          => '',
      power         => '',
      switchdev     => '',
      mode          => '',
      icon          => '',
      mintime       => '',
      on            => '',
      off           => '',
      swstate       => '',
      asynchron     => '',
      notbefore     => '',
      notafter      => '',
      auto          => '',
      pcurr         => '',
      etotal        => '',
      swoncond      => '',
      swoffcond     => '',
      surpmeth      => '',
      spignorecond  => '',
      interruptable => '',
      locktime      => '',
      noshow        => '',
      exconfc       => '',
  };

  if ($cmd eq "set") {      
      my ($err, $codev, $h) = isDeviceValid ( { name => $name, obj => $aVal, method => 'string' } );
      return $err if($err);

      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }
      }

      if (!$h->{type} || !exists $h->{power}) {
          return qq{The syntax of "$aName" is not correct. Please consider the command reference.};
      }

      my $alowt = grep (/^$h->{type}$/, @ctypes) ? 1 : 0;
      if (!$alowt) {
          return qq{The type "$h->{type}" isn't allowed!};
      }

      if (exists $h->{switchdev}) {                                                       # alternatives Schaltdevice
          ($err) = isDeviceValid ( { name => $name, obj => $h->{switchdev}, method => 'string' } );
          return $err if($err);
      }

      if ($h->{power} !~ /^[0-9]+$/xs) {
          return qq{The key 'power' must be specified only by numbers without decimal places};
      }
      
      if (exists $h->{etotal}) {
          my ($rtot, $utot, $ethreshold) = split ":", $h->{etotal};
          
          if (!$utot || $utot !~ /^(Wh|kWh)$/xs) {
              return qq{The Unit of key 'etotal' must be 'Wh' or 'kWh'};
          }
          
          if (defined $ethreshold && !isNumeric ($ethreshold)) {
              return qq{The optional 'Threshold' of key 'etotal' must be numeric if specified};
          }
      }

      if (defined $h->{exconfc} && $h->{exconfc} !~ /^[012]$/xs) {
          return qq{The key 'exconfc' is not set correct. Please consider the command reference.};
      }
      
      if (exists $h->{aliasshort}) {                                                       # Kurzalias
          return qq{The short alias "$h->{aliasshort}" longer than allowed. See command reference.} 
                 if(strlength ($h->{aliasshort})> 10);
      }

      if (exists $h->{mode} && $h->{mode} !~ /^(?:can|must)$/xs) {
          if ($h->{mode} =~ /.*:.*/xs) {
              my ($dv, $rd) = split ':', $h->{mode};
              ($err)        = isDeviceValid ( { name => $name, obj => $dv, method => 'string' } );
              return $err if($err);

              my $mode = ReadingsVal ($dv, $rd, '');
              if ($mode !~ /^(?:can|must)$/xs) {
                  return "The reading '$rd' of device '$dv' is invalid or doesn't contain a valid mode";
              }
          }
          else {
              return qq{The mode "$h->{mode}" isn't allowed!};
          }
      }

      if (exists $h->{surpmeth}) {
          if ($h->{surpmeth} =~ /.*:.*/xs) {
              my ($dv, $rd) = split ':', $h->{surpmeth};
              ($err)        = isDeviceValid ( { name => $name, obj => $dv, method => 'string' } );
              return $err if($err);

              if (!isNumeric( ReadingsVal ($dv, $rd, '') )) {
                  return "The reading '$rd' of device '$dv' is invalid or doesn't contain a valid numeric value";
              }
          }
          elsif ($h->{surpmeth} !~ /^(?:median|average)(?:_(?:[2-9]|1[0-9]|20))?$|^default$/xs) {
              return qq{The surpmeth "$h->{surpmeth}" is wrong. It must contain a '<device>:<reading>', 'median[_2..20]', 'average[_2..20]' or 'default'.};
          }
      }

      my $valid;

      if (exists $h->{notbefore}) {
          if ($h->{notbefore} =~ m/^\s*\{.*\}\s*$/xs) {
              ($err) = checkCode ($name, $h->{notbefore}, 'cc1');
              return $err if($err);
          }
          else {
              $valid = checkhhmm ($h->{notbefore});
              return qq{The syntax "notbefore=$h->{notbefore}" is wrong!} if(!$valid);
          }
      }

      if (exists $h->{notafter}) {
          if ($h->{notafter} =~ m/^\s*\{.*\}\s*$/xs) {
              ($err) = checkCode ($name, $h->{notafter}, 'cc1');
              return $err if($err);
          }
          else {
              $valid = checkhhmm ($h->{notafter});
              return qq{The syntax "notafter=$h->{notafter}" is wrong!} if(!$valid);
          }
      }

      if (exists $h->{interruptable}) {
          if ($h->{interruptable} !~ /^[01]$/xs) {
              my ($dev, $rd, $code, $hyst);

              if ($h->{interruptable} =~ m/\{.*\}/xs) {                                            # interruptable prüft Perl-Code
                  if ($h->{interruptable} =~ m/:\{.*\}:/xs) {
                      return qq{The Code specified for the 'interruptable' key must not end with a hysteresis value};
                  }

                  ($dev, $rd, $code) = split ":", $h->{interruptable}, 3;
              }
              else {
                  ($dev, $rd, $code, $hyst) = split ":", $h->{interruptable};
              }

              if (!$dev || !$rd || !defined $code) {
                  return qq{A Device, Reading and Regex/Code must be specified for the 'interruptable' key};
              }

              if ($code =~ m/^\s*\{.*\}\s*$/xs) {                                                  # interruptable prüft Perl-Code
                  $code  =~ s/\s//xg;
                  ($err) = checkCode ($name, $code);
                  return "interruptable: $err" if($err);
              }
              else {                                                                               # interruptable prüft Regex
                  $err = checkRegex ($code);
                  return "interruptable: $err" if($err);
              }

              if ($hyst && !isNumeric ($hyst)) {
                  return qq{The hysteresis of key "interruptable" must be a numeric value};
              }
          }
      }

      if (exists $h->{swoncond}) {
          my ($dev, $rd, $code) = split ":", $h->{swoncond}, 3;

          if (!$dev || !$rd || !defined $code) {
              return qq{A Device, Reading and Regex/Code must be specified for the 'swoncond' key};
          }

          if ($code =~ m/^\s*\{.*\}\s*$/xs) {                                                      # swoncond prüft Perl-Code
              $code  =~ s/\s//xg;
              ($err) = checkCode ($name, $code);
              return "swoncond: $err" if($err);
          }
          else {                                                                                   # swoncond prüft Regex
              $err = checkRegex ($code);
              return "swoncond: $err" if($err);
          }
      }

      if (exists $h->{swoffcond}) {
          my ($dev, $rd, $code) = split ":", $h->{swoffcond}, 3;

          if (!$dev || !$rd || !defined $code) {
              return qq{A Device, Reading and Regex/Code must be specified for the 'swoffcond' key};
          }

          if ($code =~ m/^\s*\{.*\}\s*$/xs) {                                                      # swoffcond prüft Perl-Code
              $code  =~ s/\s//xg;
              ($err) = checkCode ($name, $code);
              return "swoffcond: $err" if($err);
          }
          else {                                                                                   # swoffcond prüft Regex
              $err = checkRegex ($code);
              return "swoffcond: $err" if($err);
          }
      }

      if (exists $h->{spignorecond}) {
          my ($dev, $rd, $code) = split ":", $h->{spignorecond}, 3;

          if (!$dev || !$rd || !defined $code) {
              return qq{A Device, Reading and Regex/Code must be specified for the 'spignorecond' key};
          }

          if ($code =~ m/^\s*\{.*\}\s*$/xs) {                                                      # spignorecond prüft Perl-Code
              $code  =~ s/\s//xg;
              ($err) = checkCode ($name, $code);
              return "spignorecond: $err" if($err);
          }
          else {                                                                                   # spignorecond prüft Regex
              $err = checkRegex ($code);
              return "spignorecond: $err" if($err);
          }
      }

      if (exists $h->{swstate}) {                                                                  # Check Regex
          my (undef,$onregex,$offregex) = split ":", $h->{swstate};

          $err = checkRegex ($onregex);
          return "swstate on-Regex: $err" if($err);

          $err = checkRegex ($offregex);
          return "swstate off-Regex: $err" if($err);
      }

      if (exists $h->{mintime}) {
          my $mintime = $h->{mintime};

          if ($mintime !~ /^SunPath/xsi && $mintime =~ /.*:.*/xs) {
              my ($dv, $rd) = split ':', $mintime;
              ($err)        = isDeviceValid ( { name => $name, obj => $dv, method => 'string' } );
              return $err if($err);

              my $val = ReadingsVal ($dv, $rd, '');
              if (!isNumeric ($val)) {
                  return "The reading '$rd' of device '$dv' is invalid or doesn't contain a numeric value";
              }
          }
          elsif (!isNumeric ($mintime) && $mintime !~ /^SunPath/xsi) {
              return qq(The key "mintime" must be an integer or a string starting with "SunPath.");
          }
      }
  }
  else {
      my $day  = strftime "%d", localtime(time);                                                   # aktueller Tag  (range 01 to 31)
      my ($c)  = $aName =~ /consumer([0-9]+)/xs;

      $paref->{c} = $c;
      delConsumerFromMem ($paref);                                                                 # Consumerdaten aus Speicher löschen
      delete $paref->{c};

      deleteReadingspec  ($hash, "consumer${c}.*");
  }

  writeCacheToFile ($hash, 'consumers', $csmcache.$name);                                          # Cache File Consumer schreiben

  $data{$name}{current}{consumerCollected} = 0;                                                    # Consumer neu sammeln

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask',          [$name, 0], 0);
  InternalTimer (gettimeofday() + 2,   'FHEM::SolarForecast::createAssociatedWith', $hash,      0);

return;
}

################################################################
#                  Attr consumerControl
################################################################
sub _attrconsumerControl {               ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};

  my $valid = {
      adviceIcon => { comp => '.*',                                          act => 0 },
      detailLink => { comp => '(0|1)',                                       act => 0 },
      dummyIcon  => { comp => '.*',                                          act => 0 },
      showLegend => { comp => '(icon_top|icon_bottom|text_top|text_bottom)', act => 0 },
  };

  my ($a, $h) = parseParams ($aVal);

  if ($cmd eq 'set') {      
      ## 1. Durchlauf - Prüfungen
      #############################
      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }

          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} !~ /^$comp$/xs) {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      ## 2. Durchlauf - Umsetzung
      #############################
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }

      for my $key (keys %{$h}) {
          $data{$name}{current}{$key} = $h->{$key};
      }
  }
  else {                                                                  # Current Keys mit Attribut löschen
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }
  }

  for my $akey (keys %{$h}) {                                             # von bestimmten Schlüsseln abhängige Aktionen ausführen
      if ($valid->{$akey}{act}) {
          $paref->{akey}   = $akey;
          $paref->{keyval} = $h->{$akey};

          my $err = __attrKeyAction ($paref);

          delete $paref->{keyval};
          delete $paref->{akey};

          return $err if($err);
      }
  }

return;
}

################################################################
#               Attr ctrlConsRecommendReadings
################################################################
sub _attrcreateConsRecRdgs {             ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};

  my $hash  = $defs{$name};

  if ($aName eq 'ctrlConsRecommendReadings') {
      deleteReadingspec ($hash, "consumer.*_ConsumptionRecommended");
  }

return;
}

################################################################
#               Attr ctrlSpecialReadings
################################################################
sub _attrcreateSpecialRdgs {             ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  
  return if(!$init_done);
  
  my @klist = split ",", $aVal;
  
  for my $avl (@klist) {
      if ($avl =~ /currentRunMtsConsumer_|runTimeAvgDayConsumer_/xs) {
          my $cn = (split "_", $avl)[1];                                                # Consumer Nummer extrahieren

          if (!AttrVal ($name, 'consumer'.$cn, '')) {
              return qq{The consumer "consumer$cn" is currently not registered as an active consumer!};
          }
      }
      elsif ($avl =~ /remainingSurplsHrsMinPwrBat_/xs) {
          my $bn        = (split "_", $avl)[1];
          my $parsed    = __parseAttrBatSoc ($name, AttrVal ($name, 'ctrlBatSocManagement'.$bn, undef));
          my $loadAbort = $parsed->{loadAbort}; 
          
          if (!$loadAbort) {
              return qq{Set attribute "ctrlBatSocManagement${bn}->loadAbort" first. This indicator needs the <MinPwr> parameter.};
          }
      }
  }

return;
}

################################################################
#               Attr ctrlDebug
################################################################
sub _attrctrlDebug {                     ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal} // '';

  my $te = 'consumerSwitching';

  if ($aVal =~ /$te/xs && $init_done) {
      my @aa = split ",", $aVal;

      for my $elm (@aa) {
          next if($elm !~ /$te/xs);
          $elm =~ /([0-9]{2})/xs;                                               # Consumer Nummer filetieren

          if (!AttrVal ($name, 'consumer'.$1, '')) {
              return qq{The consumer 'consumer$1' is currently not registered as an active consumer!};
          }
      }
  }

return;
}

################################################################
#                  Attr graphicControl
################################################################
sub _attrgraphicControl {                ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};

  my $valid = {
      beamPaddingBottom => { comp => '\d+',                                                            act => 0 },
      beamPaddingTop    => { comp => '\d+',                                                            act => 0 },
      beamWidth         => { comp => '([2-9][0-9]|100)',                                               act => 0 },
      energyUnit        => { comp => '(Wh|kWh)',                                                       act => 0 },
      beamHeightlevel   => { comp => '(?:[1-3]:(?:[1-9][0-9]*))(?:,(?:[1-3]:(?:[1-9][0-9]*)))*',       act => 0 },
      headerDetail      => { comp => '.*',                                                             act => 1 },
      hourCount         => { comp => '([4-9]|1[0-9]|2[0-4])',                                          act => 0 },
      hourStyle         => { comp => ':(0{1,2})',                                                      act => 0 },
      layoutType        => { comp => '(single|double|diff)',                                           act => 0 },
      scaleMode         => { comp => '(?:[1-3]:(?:log|lin|staple))(?:,(?:[1-3]:(?:log|lin|staple)))*', act => 0 },
      showDiff          => { comp => '(?:[1-3]:(?:top|bottom))(?:,(?:[1-3]:(?:top|bottom)))*',         act => 0 },
      spaceSize         => { comp => '\d+',                                                            act => 0 },
  };

  my ($a, $h) = parseParams ($aVal);

  if ($cmd eq 'set') {      
      ## 1. Durchlauf - Prüfungen
      #############################
      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }

          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} =~ /^$comp$/xs) {
              if ($valid->{$key}{act}) {
                  $paref->{akey}   = $key;
                  $paref->{keyval} = $h->{$key};

                  my $err = __attrKeyAction ($paref);

                  delete $paref->{keyval};
                  delete $paref->{akey};

                  return $err if($err);
              }
          }
          else {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      ## 2. Durchlauf - Umsetzung
      #############################
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }

      for my $key (keys %{$h}) {
          $data{$name}{current}{$key} = $h->{$key};
      }
  }
  else {                                                               # Current Keys mit Attribut löschen
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }
  }

return;
}

################################################################
#                  Attr flowGraphicControl
################################################################
sub _attrflowGraphicControl {            ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};

  my $hash  = $defs{$name};

  my $valid = {
      animate                => { comp => '(0|1)',                     act => 0 },
      consumerdist           => { comp => '[89]\d{1}|[1234]\d{2}|500', act => 0 },
      h2consumerdist         => { comp => '\d{1,3}',                   act => 0 },
      homenodedyncol         => { comp => '(0|1)',                     act => 0 },
      inverterNodeIcon       => { comp => '',                          act => 0 },
      shiftx                 => { comp => '-?\d+',                     act => 0 },
      shifty                 => { comp => '\d+',                       act => 0 },
      size                   => { comp => '\d+',                       act => 0 },
      showconsumer           => { comp => '(0|1)',                     act => 0 },
      showconsumerdummy      => { comp => '(0|1)',                     act => 0 },
      showconsumerremaintime => { comp => '(0|1)',                     act => 0 },
      showconsumerpower      => { comp => '(0|1)',                     act => 0 },
      showGenerators         => { comp => '(0|1)',                     act => 0 },
      strokeconsumerdyncol   => { comp => '(0|1)',                     act => 0 },
      strokeCmrRedColLimit   => { comp => '\d+',                       act => 0 },
      strokecolstd           => { comp => '.*',                        act => 0 },
      strokecolsig           => { comp => '.*',                        act => 0 },
      strokecolina           => { comp => '.*',                        act => 0 },
      strokewidth            => { comp => '\d+',                       act => 0 },
  };

  my ($a, $h) = parseParams ($aVal);

  if ($cmd eq 'set') {
      return 'The parameters entered must not contain square brackets [...]' if($aVal =~ /[\[\]]+/xs);          # Absturzschutz!
      
      ## 1. Durchlauf - Prüfungen
      #############################
      for my $key (keys %{$h}) {
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }

          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} !~ /^$comp$/xs) {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      ## 2. Durchlauf - Umsetzung
      #############################
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }

      for my $key (keys %{$h}) {
          $data{$name}{current}{$key} = $h->{$key};
      }
  }
  else {                                                                  # Current Keys mit Attribut löschen
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }
  }

  for my $akey (keys %{$h}) {                                             # von bestimmten Schlüsseln abhängige Aktionen ausführen
      if ($valid->{$akey}{act}) {
          $paref->{akey}   = $akey;
          $paref->{keyval} = $h->{$akey};

          my $err = __attrKeyAction ($paref);

          delete $paref->{keyval};
          delete $paref->{akey};

          return $err if($err);
      }
  }

return;
}

################################################################
#                  Attr aiControl
################################################################
sub _attraiControl {                     ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};

  my $valid = {
      aiStorageDuration => { comp => '\d+',                        act => 0 },
      aiTrainStart      => { comp => '(1?[1-9]|10|2[0-3])',        act => 0 },
      aiTreesPV         => { comp => '(1?[1-9]|10|[2-4][0-9]|50)', act => 0 },
  };

  my ($a, $h) = parseParams ($aVal);

  if ($cmd eq 'set') {      
      ## 1. Durchlauf - Prüfungen
      #############################
      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }

          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} !~ /^$comp$/xs) {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      ## 2. Durchlauf - Umsetzung
      #############################
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }

      for my $key (keys %{$h}) {
          $data{$name}{current}{$key} = $h->{$key};
      }
  }
  else {                                                                  # Current Keys mit Attribut löschen
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }
  }

  for my $akey (keys %{$h}) {                                             # von bestimmten Schlüsseln abhängige Aktionen ausführen
      if ($valid->{$akey}{act}) {
          $paref->{akey}   = $akey;
          $paref->{keyval} = $h->{$akey};

          my $err = __attrKeyAction ($paref);

          delete $paref->{keyval};
          delete $paref->{akey};

          return $err if($err);
      }
  }

return;
}

################################################################
#                  Attr plantControl
################################################################
sub _attrplantControl {                  ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};

  my $valid = {
      backupFilesKeep           => { comp => '\d+',                                               act => 0 },
      batteryPreferredCharge    => { comp => '([0-9]|[1-9][0-9]|100)',                            act => 0 },
      consForecastIdentWeekdays => { comp => '(0|1)',                                             act => 0 },
      consForecastLastDays      => { comp => '([1-9]|[1-9][0-9]|1[0-7][0-9]|180)',                act => 0 },
      consForecastInPlanning    => { comp => '(0|1)',                                             act => 0 },
      cycleInterval             => { comp => '\d+',                                               act => 1 },
      feedinPowerLimit          => { comp => '\d+',                                               act => 0 },
      genPVdeviation            => { comp => '^(?:daily|continuously)(?::(?:default|reverse))?$', act => 1 },
      genPVforecastsToEvent     => { comp => '(adapt4(?:f)?Steps)',                               act => 0 },
      reductionState            => { comp => '[^\s]+:[^\s]+:[^\s]+',                              act => 1 },
      showLink                  => { comp => '(0|1)',                                             act => 0 },
  };

  my ($a, $h) = parseParams ($aVal);

  if ($cmd eq 'set') {      
      ## 1. Durchlauf - Prüfungen
      #############################
      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }

          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} !~ /^$comp$/xs) {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      ## 2. Durchlauf - Umsetzung
      #############################
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }

      for my $key (keys %{$h}) {
          $data{$name}{current}{$key} = $h->{$key};
      }
  }
  else {                                                                  # Current Keys mit Attribut löschen
      for my $av (keys %{$valid}) {
          delete $data{$name}{current}{$av};
      }
  }

  for my $akey (keys %{$h}) {                                             # von bestimmten Schlüsseln abhängige Aktionen ausführen
      if ($valid->{$akey}{act}) {
          $paref->{akey}   = $akey;
          $paref->{keyval} = $h->{$akey};

          my $err = __attrKeyAction ($paref);

          delete $paref->{keyval};
          delete $paref->{akey};

          return $err if($err);
      }
  }

return;
}

################################################################
#                      Attr setupMeterDev
################################################################
sub _attrMeterDev {                    ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};
  my $aName = $paref->{aName};
  my $type  = $paref->{type};

  return if(!$init_done);

  my $hash = $defs{$name};

  my $valid = {
      gcon      => '',
      contotal  => '',
      gfeedin   => '',
      feedtotal => '',
      conprice  => '',
      feedprice => '',
      asynchron => '',
  };

  if ($paref->{cmd} eq 'set') {      
      my ($err, $medev, $h) = isDeviceValid ( { name => $name, obj => $aVal, method => 'string' } );
      return $err if($err);

      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }
      }

      if (!$h->{gcon} || !$h->{contotal} || !$h->{gfeedin} || !$h->{feedtotal}) {
          return qq{The syntax of '$aName' is not correct. Please consider the commandref.};
      }

      if ($h->{gcon} eq "-gfeedin" && $h->{gfeedin} eq "-gcon") {
          return qq{Incorrect input. It is not allowed that the keys gcon and gfeedin refer to each other.};
      }

      if ($h->{conprice}) {                                                                       # Bezugspreis (Arbeitspreis) pro kWh
          my @acp = split ":", $h->{conprice};
          return qq{Incorrect input for key 'conprice'. Please consider the commandref.} if(scalar(@acp) != 2 && scalar(@acp) != 3);
      }

      if ($h->{feedprice}) {                                                                       # Einspeisevergütung pro kWh
          my @afp = split ":", $h->{feedprice};
          return qq{Incorrect input for key 'feedprice'. Please consider the commandref.} if(scalar(@afp) != 2 && scalar(@afp) != 3);
      }
  }
  elsif ($paref->{cmd} eq 'del') {
      readingsDelete ($hash, "Current_GridConsumption");
      readingsDelete ($hash, "Current_GridFeedIn");
      delete $data{$name}{circular}{99}{initdayfeedin};
      delete $data{$name}{circular}{99}{gridcontotal};
      delete $data{$name}{circular}{99}{initdaygcon};
      delete $data{$name}{circular}{99}{feedintotal};
      delete $data{$name}{current}{gridconsumption};
      delete $data{$name}{current}{tomorrowconsumption};
      delete $data{$name}{current}{gridfeedin};
      delete $data{$name}{current}{consumption};
      delete $data{$name}{current}{autarkyrate};
      delete $data{$name}{current}{selfconsumption};
      delete $data{$name}{current}{selfconsumptionrate};
      delete $data{$name}{current}{eFeedInTariff};
      delete $data{$name}{current}{eFeedInTariffCcy};
      delete $data{$name}{current}{ePurchasePrice};
      delete $data{$name}{current}{ePurchasePriceCcy};
  }

  InternalTimer (gettimeofday() + 2, 'FHEM::SolarForecast::createAssociatedWith', $hash, 0);
  InternalTimer (gettimeofday() + 3, 'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                      Attr setupOtherProducer
################################################################
sub _attrProducerDev {                   ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};
  my $aName = $paref->{aName};
  my $type  = $paref->{type};

  return if(!$init_done);

  my $hash = $defs{$name};
  my $pn   = (split 'Producer', $aName)[1];

  my $valid = {
      icon   => '',
      pcurr  => '',
      etotal => '',
  };

  if ($paref->{cmd} eq 'set') {      
      my ($err, $dev, $h) = isDeviceValid ( { name => $name, obj => $aVal, method => 'string' } );
      return $err if($err);

      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }
      }

      if (!$h->{pcurr} || !$h->{etotal}) {
          return qq{The syntax of '$aName' is not correct. Please consider the commandref.};
      }

      delete $data{$name}{producers}{$pn}{picon};
  }
  elsif ($paref->{cmd} eq 'del') {
      for my $k (keys %{$data{$name}{producers}}) {
          delete $data{$name}{producers}{$k} if($k eq $pn);
      }

      readingsDelete    ($hash, 'Current_PP_'.$pn);
      deleteReadingspec ($hash, ".*_PPreal_".$pn);

      for my $hod (keys %{$data{$name}{circular}}) {
          delete $data{$name}{circular}{$hod}{'pprl'.$pn};
      }
  }

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask', [$name, 0], 0);
  InternalTimer (gettimeofday() + 2,   'FHEM::SolarForecast::createAssociatedWith', $hash, 0);
  InternalTimer (gettimeofday() + 3,   'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                      Attr setupInverterDev
################################################################
sub _attrInverterDev {                   ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};
  my $aName = $paref->{aName};

  return if(!$init_done);

  my $hash = $defs{$name};
  my $in   = (split 'setupInverterDev', $aName)[1];

  my $valid = {
      pvIn      => { comp => '.*:(W|kW)',     act => 0 },
      pvOut     => { comp => '.*:(W|kW)',     act => 0 },
      ac2dc     => { comp => '.*:(W|kW)',     act => 0 },
      dc2ac     => { comp => '.*:(W|kW)',     act => 0 },
      etotal    => { comp => '.*:(Wh|kWh)',   act => 0 },
      capacity  => { comp => '.*',            act => 1 },
      strings   => { comp => '',              act => 0 },
      feed      => { comp => '(grid|bat)',    act => 0 },
      limit     => { comp => '.*',            act => 1 },
      icon      => { comp => '',              act => 0 },
      asynchron => { comp => '(0|1)',         act => 0 },
  };

  if ($paref->{cmd} eq 'set') {
      if ($aVal =~ /strings=/xs && $aVal !~ /strings=(?!.*(\s,|,\s)).*$/xs) {
          return "The key 'string' is not specified correctly. Please refer to the command reference.";
      }
      
      my ($err, $indev, $h) = isDeviceValid ( { name => $name, obj => $aVal, method => 'string' } );
      return $err if($err);

      if ($in ne '01' && !AttrVal ($name, 'setupInverterDev01', '')) {
          return qq{Set the first Inverter device with attribute 'setupInverterDev01'};
      }

      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }

          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} =~ /^$comp$/xs) {
              if ($valid->{$key}{act}) {
                  $paref->{akey}   = $key;
                  $paref->{keyval} = $h->{$key};

                  my $err = __attrKeyAction ($paref);

                  delete $paref->{keyval};
                  delete $paref->{akey};

                  return $err if($err);
              }
          }
          else {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      my $none = 0;

      if ($h->{strings}) {
          my @as = split ',', $h->{strings};

          for my $s (@as) {
              if ($s eq 'none') {
                  $none = 1;
                  next;
              }

              if (!grep /^$s$/, keys %{$data{$name}{strings}}) {
                  return qq{The string '$s' is not a valid string name defined in attribute 'setupInverterStrings'.};
              }
          }

          if ($none && scalar(@as) > 1) {
              return qq{If 'strings=none' is defined, no other string may be specified.};
          }
      }

      if ($none) {                                                                             # Batterie-Wechselrichter
          if (!$h->{ac2dc}) {
              return qq{A battery inverter requires a set key 'ac2dc'. Please consider the commandref.};
          }

          if (!$h->{dc2ac}) {
              return qq{A battery inverter requires a set key 'dc2ac'. Please consider the commandref.};
          }

          if ($h->{pvOut}) {
              return qq{A battery inverter without associated solar cells don't need the key 'pvOut'. Please delete this key.};
          }

          if ($h->{etotal}) {
              return qq{A battery inverter without associated solar cells don't need the key 'etotal'. Please delete this key.};
          }
      }

      if (!$none) {                                                                            # Standard oder Hybrid-Wechselrichter
          if ($h->{ac2dc}) {
              return qq{An inverter with connected solar cells don't need the key 'ac2dc'. Please delete this key.};
          }

          if ($h->{dc2ac}) {
              return qq{An inverter with connected solar cells don't need the key 'dc2ac'. Please delete this key.};
          }
      }

      if ((!$none && !$h->{pvOut}) || (!$none && !$h->{etotal}) || !$h->{capacity}) {
          return qq{One or more of the keys 'pvOut, etotal, capacity' are missing. Please consider the commandref.};
      }

      $data{$name}{circular}{99}{attrInvChangedTs} = int time;
  }
  elsif ($paref->{cmd} eq 'del') {
      readingsDelete ($hash, 'Current_PV');
      undef @{$data{$name}{current}{genslidereg}};

      if ($in eq '01') {                                                        # wenn der letzte Inverter gelöscht wurde
          deleteReadingspec ($hash, '.*_PVreal' );
          delete $data{$name}{circular}{99}{attrInvChangedTs};
      }
  }

  delete $data{$name}{inverters}{$in};

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask', [$name, 0], 0);
  InternalTimer (gettimeofday() + 2,   'FHEM::SolarForecast::createAssociatedWith', $hash, 0);
  InternalTimer (gettimeofday() + 3,   'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                      Attr setupInverterStrings
################################################################
sub _attrInverterStrings {               ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};
  my $aName = $paref->{aName};
  my $type  = $paref->{type};

  return if(!$init_done);

  if ($paref->{cmd} eq 'set') {
      if ($aVal =~ /\?/xs) {
          return qq{The inverter string designation is wrong. An inverter string name must not contain a '?' character};
      }

      my @istrings = split ",", $aVal;

      for my $s (@istrings) {
          return qq{An inverter string must not be named 'none'} if($s eq 'none');
      }

      for my $k (keys %{$data{$name}{solcastapi}}) {
          next if ($k =~ /\?/xs || grep /^$k$/, @istrings);
          delete $data{$name}{solcastapi}{$k};
      }

      $data{$name}{current}{allStringsFullfilled} = 0;                                             # Stringkonfiguration neu prüfen lassen
  }

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask', [$name, 0], 0);
  InternalTimer (gettimeofday() + 3,   'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                      Attr setupStringPeak
################################################################
sub _attrStringPeak {                    ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};

  return if(!$init_done);

  my $hash  = $defs{$name};

  if ($paref->{cmd} eq 'set') {
      $aVal =~ s/,/./xg;

      my ($a,$h) = parseParams ($aVal);

      if (!keys %$h) {
          return qq{The attribute content has wrong format};
      }

      while (my ($key, $value) = each %$h) {
          if ($value !~ /[0-9.]/x) {
              return qq{The module peak of '$key' must be specified by numbers and optionally with decimal places};
          }
      }

      return if(_checkSetupNotComplete ($hash));                                                      # keine Stringkonfiguration wenn Setup noch nicht komplett

      my @istrings = split ",", AttrVal ($name, 'setupInverterStrings', '');                          # Stringbezeichner

      if (!@istrings) {
          return qq{Define all used strings with command "attr $name setupInverterStrings" first.};
      }

      while (my ($strg, $pp) = each %$h) {
          if (!grep /^$strg$/, @istrings) {
              return qq{The stringname '$strg' is not defined as valid string in attribute 'setupInverterStrings'};
          }
      }

      $data{$name}{current}{allStringsFullfilled} = 0;                                               # Stringkonfiguration neu prüfen lassen
  }

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask', [$name, 0], 0);
  InternalTimer (gettimeofday() + 3,   'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                 Attr setupStringAzimuth
#
#  Angabe entweder als Azimut-Bezeichner oder direkte
#  Azimut Angabe -180 ...0...180
#
################################################################
sub _attrstringAzimuth {                  ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};

  return if(!$init_done);

  my $dirs = "N|NE|E|SE|S|SW|W|NW";                                                # mögliche Azimut-Bezeichner wenn keine direkte Azimut Angabe
  my $hash = $defs{$name};

  if ($paref->{cmd} eq 'set') {
      my ($a,$h) = parseParams ($aVal);

      if (!keys %$h) {
          return qq{The provided module direction has wrong format};
      }

      while (my ($key, $value) = each %$h) {
          if ($value !~ /^(?:$dirs)$/x && ($value !~ /^(?:-?[0-9]{1,3})$/x || $value < -180 || $value > 180)) {
              return qq{The module direction of "$key" is wrong: $value};
          }
      }

      return if(_checkSetupNotComplete ($hash));                                                      # keine Stringkonfiguration wenn Setup noch nicht komplett

      my @istrings = split ",", AttrVal ($name, 'setupInverterStrings', '');                          # Stringbezeichner

      if (!@istrings) {
          return qq{Define all used strings with command "attr $name setupInverterStrings" first.};
      }

      while (my ($strg, $pp) = each %$h) {
          if (!grep /^$strg$/, @istrings) {
              return qq{The stringname '$strg' is not defined as valid string name in attribute 'setupInverterStrings'};
          }
      }

      $data{$name}{current}{allStringsFullfilled} = 0;                                               # Stringkonfiguration neu prüfen lassen
  }

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask', [$name, 0], 0);
  InternalTimer (gettimeofday() + 3,   'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                 Attr setupStringDeclination
################################################################
sub _attrstringDeclination {             ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};

  return if(!$init_done);

  my $hash = $defs{$name};

  if ($paref->{cmd} eq 'set') {
      my ($a,$h) = parseParams ($aVal);

      if (!keys %$h) {
          return qq{The specified inclination angle has an incorrect format};
      }

      while (my ($key, $value) = each %$h) {
          if ($value !~ /^(?:[0-9]{1,2})$/x || $value > 90) {
              return qq{The inclination angle of "$key" is incorrect};
          }
      }

      return if(_checkSetupNotComplete ($hash));                                                      # keine Stringkonfiguration wenn Setup noch nicht komplett

      my @istrings = split ",", AttrVal ($name, 'setupInverterStrings', '');                          # Stringbezeichner

      if (!@istrings) {
          return qq{Define all used strings with command "attr $name setupInverterStrings" first.};
      }

      while (my ($strg, $pp) = each %$h) {
          if (!grep /^$strg$/, @istrings) {
              return qq{The stringname '$strg' is not defined as valid string name in attribute 'setupInverterStrings'};
          }
      }

      $data{$name}{current}{allStringsFullfilled} = 0;                                               # Stringkonfiguration neu prüfen lassen
  }

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask', [$name, 0], 0);
  InternalTimer (gettimeofday() + 3,   'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                 Attr setupRoofTops
################################################################
sub _attrRoofTops {                      ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};

  return if(!$init_done);

  my $hash  = $defs{$name};

  if ($paref->{cmd} eq 'set') {
      my ($a,$h) = parseParams ($aVal);

      if (!keys %$h) {
          return qq{The attribute content has wrong format};
      }

      while (my ($is, $pk) = each %$h) {
          my $rtid   = StatusAPIVal ($hash, '?IdPair', '?'.$pk, 'rtid',   '');
          my $apikey = StatusAPIVal ($hash, '?IdPair', '?'.$pk, 'apikey', '');

          if (!$rtid || !$apikey) {
              return qq{The roofIdentPair "$pk" of String "$is" has no Rooftop-ID and/or SolCast-API key assigned! \n}.
                     qq{Set the roofIdentPair "$pk" previously with "set $name roofIdentPair".} ;
          }
      }

      my @istrings = split ",", AttrVal ($name, 'setupInverterStrings', '');                          # Stringbezeichner

      if (!@istrings) {
          return qq{Define all used strings with command "attr $name setupInverterStrings" first.};
      }

      while (my ($strg, $pp) = each %$h) {
          if (!grep /^$strg$/, @istrings) {
              return qq{The stringname '$strg' is not defined as valid string in attribute 'setupInverterStrings'};
          }
      }
  }

  InternalTimer (gettimeofday() + 3, 'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                      Attr setupBatteryDev
################################################################
sub _attrBatteryDev {                    ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};
  my $aName = $paref->{aName};
  my $type  = $paref->{type};

  return if(!$init_done);

  my $hash = $defs{$name};
  my $bn   = (split 'setupBatteryDev', $aName)[1];

  my $valid = {
      pin        => { comp => '.+',                                           must => 1, act => 0 },
      pout       => { comp => '.+',                                           must => 1, act => 0 },
      pinmax     => { comp => '\d+',                                          must => 0, act => 0 },
      pinreduced => { comp => '\d+',                                          must => 0, act => 0 },
      poutmax    => { comp => '\d+',                                          must => 0, act => 0 },
      intotal    => { comp => '.*',                                           must => 0, act => 0 },
      outtotal   => { comp => '.*',                                           must => 0, act => 0 },
      cap        => { comp => '((?:\d+$|(?!\d+(?:\.\d+)?:)[^:]+:(?:k?Wh)$))', must => 1, act => 0 },
      charge     => { comp => '.*',                                           must => 0, act => 0 },
      icon       => { comp => '.*',                                           must => 0, act => 0 },
      show       => { comp => '(?:[0-3](?::(?:top|bottom))?)',                must => 0, act => 0 },
      label      => { comp => '(none|below|beside)',                          must => 0, act => 0 },
      asynchron  => { comp => '(0|1)',                                        must => 0, act => 0 },
      efficiency => { comp => '(100|[1-9]?[0-9])',                            must => 0, act => 0 },
  };

  if ($paref->{cmd} eq 'set') {      
      my ($err, $badev, $h) = isDeviceValid ( { name => $name, obj => $aVal, method => 'string' } );
      return $err if($err);
      
      for my $mkey (keys %{$valid}) {
          return qq{The key '$mkey' is mandatory for setting in attribute '$aName'} if($valid->{$mkey}{must} && !exists $h->{$mkey});
      }

      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }
          
          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} =~ /^$comp$/xs) {
              if ($valid->{$key}{act}) {
                  $paref->{akey}   = $key;
                  $paref->{keyval} = $h->{$key};

                  my $err = __attrKeyAction ($paref);

                  delete $paref->{keyval};
                  delete $paref->{akey};

                  return $err if($err);
              }
          }
          else {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      ## 2. Durchlauf - Endprüfung
      #############################
      if (($h->{pin}  !~ /-/xs && $h->{pin} !~ /:/xs)   ||
         ($h->{pout} !~ /-/xs && $h->{pout} !~ /:/xs)) {
          return qq{The keys 'pin' and/or 'pout' are not set correctly. Please note the command reference.};
      }

      if ($h->{pin} eq "-pout" && $h->{pout} eq "-pin") {
          return qq{Incorrect input. It is not allowed that the keys pin and pout refer to each other.};
      }

      delete $data{$name}{batteries}{$bn}{basynchron};
      delete $data{$name}{batteries}{$bn}{bicon};
      delete $data{$name}{batteries}{$bn}{bshowingraph};
      delete $data{$name}{batteries}{$bn}{bposingraph};
      delete $data{$name}{batteries}{$bn}{blabel};
      delete $data{$name}{batteries}{$bn}{bpinmax}; 
      delete $data{$name}{batteries}{$bn}{bpinreduced};
      delete $data{$name}{batteries}{$bn}{bpoutmax};
      delete $data{$name}{batteries}{$bn}{befficiency};
  }
  elsif ($paref->{cmd} eq 'del') {                                                          
      my @fields = qw(                                                                
          Current_PowerBatIn
          Current_PowerBatOut
          Current_BatCharge
          Battery_ChargeOptTargetPower
          Battery_ChargeUnrestricted
          Battery_ChargeRequest
          Battery_OptimumTargetSoC
          Battery_TargetAchievable
      );
      
      map { readingsDelete ($hash, "${_}_$bn") } @fields;

      deleteReadingspec ($hash, "Battery_NextHour.._SoCforecast_".$bn);   

      undef @{$data{$name}{current}{batsocslidereg}};

      delete $data{$name}{circular}{99}{'lastTsMaxSocRchd'.$bn};
      delete $data{$name}{circular}{99}{'nextTsMaxSocChge'.$bn};
      delete $data{$name}{circular}{99}{'initdaybatintot'.$bn};
      delete $data{$name}{circular}{99}{'initdaybatouttot'.$bn};
      delete $data{$name}{circular}{99}{'batintot'.$bn};
      delete $data{$name}{circular}{99}{'batouttot'.$bn};
      delete $data{$name}{circular}{99}{'days2care'.$bn};

      delete $data{$name}{batteries}{$bn};
  }

  InternalTimer (gettimeofday() + 0.5, 'FHEM::SolarForecast::centralTask', [$name, 0], 0);
  InternalTimer (gettimeofday() + 2,   'FHEM::SolarForecast::createAssociatedWith', $hash, 0);
  InternalTimer (gettimeofday() + 3,   'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);   # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                  Attr ctrlBatSocManagementXX
################################################################
sub _attrBatSocManagement {              ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aName = $paref->{aName};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};
  
  return if(!$init_done);

  my $hash = $defs{$name};
  my $bn   = (split 'ctrlBatSocManagement', $aName)[1];
  
  return qq{Define the key 'cap' with "attr $name setupBatteryDev${bn}" before this attribute.}
                 if(!BatteryVal ($name, $bn, 'binstcap', 0));                    # https://forum.fhem.de/index.php?msg=1310930

  my $valid = {
      lowSoc       => { comp => '(100|[1-9]?[0-9])',                                     must => 1, act => 0 },
      upSoC        => { comp => '(100|[1-9]?[0-9])',                                     must => 1, act => 0 },
      maxSoC       => { comp => '(100|[1-9]?[0-9])',                                     must => 0, act => 0 },
      stepSoC      => { comp => '[0-5]',                                                 must => 0, act => 0 },
      careCycle    => { comp => '\d+',                                                   must => 0, act => 0 },
      lcSlot       => { comp => '((?:[01]\d|2[0-3]):[0-5]\d-(?:[01]\d|2[0-3]):[0-5]\d)', must => 0, act => 1 },
      careCycle    => { comp => '\d+',                                                   must => 0, act => 0 },
      loadAbort    => { comp => '(?:100|[1-9]?[0-9]):\d+(?::(?:100|[1-9]?[0-9]))?',      must => 0, act => 0 },
      loadStrategy => { comp => '(loadRelease|optPower|smartPower)',                     must => 0, act => 0 },
      loadTarget   => { comp => '(100|[1-9]?[0-9])',                                     must => 0, act => 0 },
      safetyMargin => { comp => '(?:100|[1-9]?\d)(?::(?:100|[1-9]?\d))?',                must => 0, act => 0 },
      weightOwnUse => { comp => '(100|[1-9]?[0-9])',                                     must => 0, act => 0 },
  };

  my ($a, $h) = parseParams ($aVal);

  if ($cmd eq 'set') {      
      ## 1. Durchlauf - Prüfungen
      #############################
      for my $mkey (keys %{$valid}) {
          return qq{The key '$mkey' is mandatory for setting in attribute '$aName'} if($valid->{$mkey}{must} && !exists $h->{$mkey});
      }
      
      for my $key (keys %{$h}) {
          return 'The keys entered must not contain square brackets [...]' if($key =~ /[\[\]]+/xs);                      # Absturzschutz!
          
          if (!grep /^$key$/, keys %{$valid}) {
              return qq{The key '$key' is not a valid key in attribute '$aName'};
          }

          my $comp = $valid->{$key}{comp};
          next if(!$comp);

          if ($h->{$key} =~ /^$comp$/xs) {
              if ($valid->{$key}{act}) {
                  $paref->{akey}   = $key;
                  $paref->{keyval} = $h->{$key};

                  my $err = __attrKeyAction ($paref);

                  delete $paref->{keyval};
                  delete $paref->{akey};

                  return $err if($err);
              }
          }
          else {
              return "The key '$key=$h->{$key}' is not specified correctly. Please refer to the command reference.";
          }
      }

      ## 2. Durchlauf - Endprüfung
      #############################
      my $parsed = __parseAttrBatSoc ($name, $aVal);
      my $lowSoc = $parsed->{lowSoc};
      my $upSoc  = $parsed->{upSoc};
      my $maxSoc = $parsed->{maxSoc};

      if (!($lowSoc > 0 && $lowSoc < $upSoc && $upSoc < $maxSoc)) {
          return 'The specified values are not plausible. Compare the attribute help.';
      }
  }                                                             
  else {
      deleteReadingspec ($hash, 'Battery_.*');
  }
  
  delete $data{$name}{circular}{99}{'lastTsMaxSocRchd'.$bn};
  delete $data{$name}{circular}{99}{'nextTsMaxSocChge'.$bn};

return;
}

################################################################
#                      Attr setupWeatherDevX
################################################################
sub _attrWeatherDev {                    ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal} // return qq{no weather forecast device specified} if($paref->{cmd} eq 'set');
  my $aName = $paref->{aName};

  return if(!$init_done);

  my $hash  = $defs{$name};

  if ($paref->{cmd} eq 'set') {
      if ($aVal !~ /^OpenMeteo/xs && (!$defs{$aVal} || $defs{$aVal}{TYPE} ne "DWD_OpenData")) {
          return qq{The device "$aVal" doesn't exist or has no TYPE 'DWD_OpenData'};
      }

      if ($aVal =~ /^OpenMeteo/xs) {
          if ($aName ne 'setupWeatherDev1') {
              return qq{Only the leading weather attribute 'setupWeatherDev1' can set to '$aVal'};
          }

          my @istrings = split ",", AttrVal ($name, 'setupInverterStrings', '');          # Stringbezeichner

          if ((!AttrVal ($name, 'setupStringAzimuth', '') || !AttrVal ($name, 'setupStringDeclination', '')) &&
              !grep /KI-based/, @istrings) {
              return qq{Execute 'attr $name setupStringAzimuth' and/or 'attr $name setupStringDeclination' first.};
          }
      }

      if ($aVal !~ /-API$/xs) {                                                      # Attribute des DWD-Devices prüfen
          my ($err, $warnmsg) = checkdwdattr ($name, $aVal, \@dweattrmust);
          return $err if($err);
      }
  }

  InternalTimer (gettimeofday() + 1, 'FHEM::SolarForecast::__harmonizeAPIdelayed', $hash, 0);
  InternalTimer (gettimeofday() + 2, 'FHEM::SolarForecast::setModel',              $hash, 0);
  InternalTimer (gettimeofday() + 3, 'FHEM::SolarForecast::createAssociatedWith',  $hash, 0);

return;
}

################################################################
#                      Attr setupRadiationAPI
################################################################
sub _attrRadiationAPI {                  ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};
  my $aName = $paref->{aName};
  my $type  = $paref->{type};

  return if(!$init_done);

  my $hash = $defs{$name};

  if ($paref->{cmd} eq 'set') {
      if ($aVal !~ /-API$/x && (!$defs{$aVal} || $defs{$aVal}{TYPE} ne "DWD_OpenData")) {
          return qq{The device "$aVal" doesn't exist or has no TYPE "DWD_OpenData"};
      }

      if ($aVal =~ /(SolCast|OpenMeteoDWD|OpenMeteoDWDEnsemble|OpenMeteoWorld)-API/xs) {
          return "The library FHEM::Utility::CTZ is missing. Please update FHEM completely." if($ctzAbsent);

          my $rmf = reqModFail();
          return "You have to install the required perl module: ".$rmf if($rmf);
      }

      return if(_checkSetupNotComplete ($hash));                                                   # keine Stringkonfiguration wenn Setup noch nicht komplett

      if ($aVal =~ /(ForecastSolar|OpenMeteoDWD|OpenMeteoDWDEnsemble|OpenMeteoWorld)-API/xs) {
          my ($set, $lat, $lon, $elev) = locCoordinates();
          return qq{set attributes 'latitude' and 'longitude' in global device first} if(!$set);

          my $tilt = AttrVal ($name, 'setupStringDeclination', '');                                # Modul Neigungswinkel für jeden Stringbezeichner
          return qq{Please complete command "attr $name setupStringDeclination".} if(!$tilt);

          my $dir = AttrVal ($name, 'setupStringAzimuth', '');                                     # Modul Ausrichtung für jeden Stringbezeichner
          return qq{Please complete command "attr $name setupStringAzimuth".} if(!$dir);
      }

      $data{$name}{current}{allStringsFullfilled} = 0;                                             # Stringkonfiguration neu prüfen lassen
  }

  readingsDelete ($hash, 'nextRadiationAPICall');

  InternalTimer (gettimeofday() + 1, 'FHEM::SolarForecast::__harmonizeAPIdelayed', $hash, 0);
  InternalTimer (gettimeofday() + 2, 'FHEM::SolarForecast::setModel',              $hash, 0);                                 # Model setzen
  InternalTimer (gettimeofday() + 3, 'FHEM::SolarForecast::createAssociatedWith',  $hash, 0);
  InternalTimer (gettimeofday() + 4, 'FHEM::SolarForecast::writeCacheToFile', [$name, 'plantconfig', $plantcfg.$name], 0);    # Anlagenkonfiguration File schreiben

return;
}

################################################################
#                      Attr graphicBeamXContent
################################################################
sub _attrgraphicBeamXContent {           ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $aVal  = $paref->{aVal};
  my $cmd   = $paref->{cmd};

  return if(!$init_done);

  my $medev  = AttrVal ($name, 'setupMeterDev', '');                                 # aktuelles Meter device
  my ($a,$h) = parseParams ($medev);

  if ($cmd eq 'set') {
      if ($aVal eq 'energycosts') {
          return "Define key 'conprice' in the setupMeterDev attribute first before setting $aVal" if(!defined $h->{conprice});
      }

      if ($aVal eq 'feedincome') {
          return "Define key 'feedprice' in the setupMeterDev attribute first before setting $aVal" if(!defined $h->{feedprice});
      }
  }

return;
}

################################################################
#  von bestimmten Schlüsseln abhängige Aktionen ausführen
################################################################
sub __attrKeyAction {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $akey   = $paref->{akey};
  my $keyval = $paref->{keyval};
  my $cmd    = $paref->{cmd};

  my $hash = $defs{$name};
  my $err  = q{};

  if ($cmd eq 'set') {
      if ($init_done && $akey eq 'cycleInterval') {
          _newCycTime ($hash, time, $keyval);
          my $nct = CurrentVal ($name, 'nextCycleTime', 0);                                                         # gespeicherte nächste CyleTime
          readingsSingleUpdate ($hash, 'nextCycletime', (!$nct ? 'Manual / Event-controlled' : FmtTime($nct)), 0);
      }

      if ($akey eq 'capacity') {
          if (!isNumeric ($keyval)) {
              return qq{The value of key '$akey' must be numeric. Please consider the commandref.};
          }
      }

      if ($akey eq 'limit') {
          if (!isNumeric ($keyval) || $keyval < 0 || $keyval > 100) {
              return qq{The value of key '$akey' is not valid. Please consider the commandref.};
          }
      }

      if ($init_done && $akey eq 'headerDetail') {
          my @hda = split ",", $keyval;

          for my $val (@hda) {
              if (!grep /^$val$/, qw (all co pv own status)) {
                  return qq{The value '$val' is not valid for key '$akey'};
              }
          }
      }
      
      if ($init_done && $akey eq 'reductionState') {
          my $rdcinfo = CurrentVal ($name, 'reductionState', ''); 
          my ($rdcdev, $rdcrd, $code) = split ":", $rdcinfo;                                      

          ($err) = isDeviceValid ( { name   => $name,
                                     obj    => $rdcdev,
                                     method => 'string',
                                   }
                                 );
          
          if ($err) {
              delete $data{$name}{current}{$akey};
              return $err;
          }
  
          if ($code =~ m/^\s*\{.*\}\s*$/xs) {                                                      # prüft Perl-Code
              $code  =~ s/\s//xg;
              ($err) = checkCode ($name, $code);
          }
          else {                                                                                   # prüft Regex
              $err = checkRegex ($code);
          }
          
          if ($err) {
              delete $data{$name}{current}{$akey};
              return $err;
          }
      }   
  }
  
  if ($akey eq 'lcSlot') {
      my $dt                = timestringsFromOffset (time, 0);
      my ($lcstart, $lcend) = split "-", $keyval;
      my $lcstartts         = timestringToTimestamp ("$dt->{date} ${lcstart}:00");
      my $lcendts           = timestringToTimestamp ("$dt->{date} ${lcend}:59");
      return qq{The value '$keyval' is not valid for key '$akey'. The slot start must be earlier than the slot end.} if($lcstartts > $lcendts); 
  }
  elsif ($init_done && $akey eq 'genPVdeviation') {
      readingsDelete ($hash, 'Today_PVdeviation');
      delete $data{$name}{circular}{99}{tdayDvtn};
      delete $data{$name}{circular}{99}{ydayDvtn};
  }

return $err;
}

################################################################
#   Attr setupRadiationAPI und setupWeatherDev1
#   harmonisieren wenn erforderlich
#   setupRadiationAPI ist führend
################################################################
sub __harmonizeAPIdelayed {
  my $hash = shift;

  my $name   = $hash->{NAME};
  my $wedev1 = AttrVal ($name, 'setupWeatherDev1',  '');
  my $radapi = AttrVal ($name, 'setupRadiationAPI', '');

  return if($wedev1 eq $radapi);

  if ($radapi =~ /OpenMeteo/xs && $wedev1 =~ /OpenMeteo/xs) {      # auf OpenMeteo Datenmodell harmonisieren
      CommandAttr (undef, "$name setupWeatherDev1 $radapi");
  }

return;
}

###################################################################################
#       Eventverarbeitung
#       - Aktualisierung Consumerstatus bei asynchronen Consumern
###################################################################################
sub Notify {
  # Es werden nur die Events von Geräten verarbeitet die im Hash $hash->{NOTIFYDEV} gelistet sind (wenn definiert).

  my $myHash   = shift;
  my $dev_hash = shift;
  my $myName   = $myHash->{NAME};                                                         # Name des eigenen Devices
  my $devName  = $dev_hash->{NAME};                                                       # Device welches Events erzeugt hat

  return if((controller($myName))[1] || !$myHash->{NOTIFYDEV});

  my $events = deviceEvents($dev_hash, 1);
  return if(!$events);

  my $debug = getDebug ($myHash);                                                         # Debug Mode

  my ($err, $medev, $bname, $iname, $h, $async);

  ## Meter Event?
  #################
  ($err, $medev, $h) = isDeviceValid ( { name => $myName, obj => 'setupMeterDev', method => 'attr' } );

  if (!$err) {
      if ($devName eq $medev) {
          $async = $h->{asynchron} // 0;

          if ($debug =~ /notifyHandling/x) {
              Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - Event of Meter device >$devName< received - asynchronous mode: $async});
          }

          if ($async) {
              if (CurrentVal ($myHash, 'ctrunning', 0)) {
                  if ($debug =~ /notifyHandling/x) {
                      Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - central task was called from NOTIFY when it is already running ... end this call});
                  }

                  return;
              }

              centralTask ($myHash, 1);
              return;
          }
      }
  }

  ## Battery Event?
  ###################
  for my $bn (1..MAXBATTERIES) {
      $bn    = sprintf "%02d", $bn;
      $bname = BatteryVal ($myHash, $bn, 'bname', '');

      if ($devName eq $bname) {
          $async = BatteryVal ($myHash, $bn, 'basynchron', 0);

          if ($debug =~ /notifyHandling/x) {
              Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - Event of Battery device >$devName< received - asynchronous mode: $async});
          }

          if ($async) {
              if (CurrentVal ($myHash, 'ctrunning', 0)) {
                  if ($debug =~ /notifyHandling/x) {
                      Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - central task was called from NOTIFY when it is already running ... end this call});
                  }

                  return;
              }

              centralTask ($myHash, 1);
              return;
          }
      }

  }

  ## Inverter Event?
  ####################
  for my $in (1..MAXINVERTER) {
      $in    = sprintf "%02d", $in;
      $iname = InverterVal ($myHash, $in, 'iname', '');

      if ($devName eq $iname) {
          $async = InverterVal ($myHash, $in, 'iasynchron', 0);

          if ($debug =~ /notifyHandling/x) {
              Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - Event of Inverter device >$devName< received - asynchronous mode: $async});
          }

          if ($async) {
              if (CurrentVal ($myHash, 'ctrunning', 0)) {
                  if ($debug =~ /notifyHandling/x) {
                      Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - central task was called from NOTIFY when it is already running ... end this call});
                  }

                  return;
              }

              centralTask ($myHash, 1);
              return;
          }
      }
  }

  ## consumer Event?
  ####################
  my $cdref     = CurrentVal ($myHash, 'consumerdevs', '');                              # alle registrierten Consumer und Schaltdevices
  my @consumers = ();
  @consumers    = @{$cdref} if(ref $cdref eq "ARRAY");

  if (@consumers && grep /^$devName$/, @consumers) {
      my ($cname, $cindex, $dswname);

      for my $c (sort{$a<=>$b} keys %{$data{$myName}{consumers}}) {
          ($err, $cname, $dswname) = getCDnames ($myHash, $c);

          if ($devName eq $cname) {
              $cindex = $c;

              if ($debug =~ /notifyHandling/x) {
                  Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - Event of consumer >$devName< (index: $c) received});
              }

              last;
          }

          if ($devName eq $dswname) {
              $cindex = $c;

              if ($debug =~ /notifyHandling/x) {
                  Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - Event of device >$devName< which is switching device of consumer >$cname< (index: $c) received});
              }

              last;
          }
      }

      if (!$cindex) {
         Log3 ($myName, 2, qq{$myName notifyHandling - Device >$devName< has no consumer index and/or ist not a known switching device. Exiting...});
         return;
      }

      $async       = ConsumerVal ($myHash, $cindex, 'asynchron',      0);
      my $rswstate = ConsumerVal ($myHash, $cindex, 'rswstate', 'state');

      if ($debug =~ /notifyHandling/x) {
          Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - Consumer >$cindex< asynchronous mode: $async});
      }

      return if(!$async);                                                                 # Consumer synchron -> keine Weiterverarbeitung

      my ($reading,$value,$unit);

      for my $event (@{$events}) {
          $event  = "" if(!defined($event));

          my @parts = split (/: /,$event, 2);
          $reading  = shift @parts;

          if (@parts == 2) {
            $value = $parts[0];
            $unit  = $parts[1];
          }
          else {
            $value = join(": ", @parts);
            $unit  = "";
          }

          if (!defined($reading)) { $reading = ""; }
          if (!defined($value))   { $value   = ""; }
          if ($value eq "") {
              if ($event =~ /^.*:\s$/) {
                  $reading = (split(":", $event))[0];
              }
              else {
                  $reading = "state";
                  $value   = $event;
              }
          }

          if ($reading eq $rswstate) {

              if ($debug =~ /notifyHandling/x) {
                  Log3 ($myName, 1, qq{$myName DEBUG> notifyHandling - start centralTask by Notify device: $devName, reading: $reading, value: $value});
              }

              centralTask ($myHash, 0);                                                  # keine Events in SolarForecast außer 'state'
          }
      }
  }

return;
}

###############################################################
#                  DbLog_splitFn
###############################################################
sub DbLogSplit {
  my $event  = shift;
  my $device = shift;
  my ($reading, $value, $unit) = ("","","");

  if($event =~ /\s(k?Wh?|%)$/xs) {
      my @parts = split(/\s/x, $event, 3);
      $reading  = $parts[0];
      $reading  =~ tr/://d;
      $value    = $parts[1];
      $unit     = $parts[2];

      # Log3 ($device, 1, qq{$device - Split for DbLog done -> Reading: $reading, Value: $value, Unit: $unit});
  }

return ($reading, $value, $unit);
}

################################################################
#                         Rename
################################################################
sub Rename {
  my $new_name = shift;
  my $old_name = shift;

  my $hash = $defs{$old_name};
  my $type = (split '::', __PACKAGE__)[1];

  $data{$new_name} = $data{$old_name};
  delete $data{$old_name};

  my @ftd = searchCacheFiles ($old_name);

  for my $oldf (@ftd) {
      my $newf = $oldf;
      $newf    =~ s/_SolarForecast_${old_name}/_SolarForecast_${new_name}/xsg;
      rename ($oldf, $newf) or
          Log3 ($new_name, 2, qq{$new_name - WARNING - File "$oldf" could not be renamed: $!});
  }

  # Log3 ($new_name, 1, qq{$new_name - Dump -> \n}. Dumper $data{$new_name});

return;
}

################################################################
#                         Shutdown
################################################################
sub Shutdown {
  my $hash = shift;
  my $name = $hash->{NAME};
  my $type = $hash->{TYPE};

  writeCacheToFile ($hash, 'pvhist',          $pvhcache.$name, 'nolog');             # Cache File für PV History schreiben
  writeCacheToFile ($hash, 'circular',        $pvccache.$name, 'nolog');             # Cache File für PV Circular schreiben
  writeCacheToFile ($hash, 'consumers',       $csmcache.$name, 'nolog');             # Cache File Consumer schreiben
  writeCacheToFile ($hash, 'solcastapi',     $scpicache.$name, 'nolog');             # Cache File SolCast API Werte schreiben
  writeCacheToFile ($hash, 'statusapi',      $statcache.$name, 'nolog');             # Status-API Cache sichern
  writeCacheToFile ($hash, 'weatherapi',  $weathercache.$name, 'nolog');             # Weather-API Cache sichern

return;
}

################################################################
# Die Undef-Funktion wird aufgerufen wenn ein Gerät mit delete
# gelöscht wird oder bei der Abarbeitung des Befehls rereadcfg,
# der ebenfalls alle Geräte löscht und danach das
# Konfigurationsfile neu einliest. Entsprechend müssen in der
# Funktion typische Aufräumarbeiten durchgeführt werden wie das
# saubere Schließen von Verbindungen oder das Entfernen von
# internen Timern.
################################################################
sub Undef {
 my $hash = shift;
 my $name = shift;

 RemoveInternalTimer($hash);
 delete $readyfnlist{$name};

return;
}

#################################################################
# Wenn ein Gerät in FHEM gelöscht wird, wird zuerst die Funktion
# X_Undef aufgerufen um offene Verbindungen zu schließen,
# anschließend wird die Funktion X_Delete aufgerufen.
# Funktion: Aufräumen von dauerhaften Daten, welche durch das
# Modul evtl. für dieses Gerät spezifisch erstellt worden sind.
# Es geht hier also eher darum, alle Spuren sowohl im laufenden
# FHEM-Prozess, als auch dauerhafte Daten bspw. im physikalischen
# Gerät zu löschen die mit dieser Gerätedefinition zu tun haben.
#################################################################
sub Delete {
  my $hash = shift;
  my $arg  = shift;
  my $name = $hash->{NAME};

  my @ftd = searchCacheFiles ($name);

  for my $f (@ftd) {
      my $err = FileDelete ($f);

      if ($err) {
          Log3 ($name, 1, qq{$name - ERROR deleting file $err});
      }
      else {
          Log3 ($name, 3, qq{$name - INFO - File "$f" deleted.});
      }
  }

  delete $data{$name};

return;
}

################################################################
#        Timer schreiben Memory Struktur in File
################################################################
sub periodicWriteMemcache {
  my $hash = shift;
  my $bckp = shift // '';

  my $name = $hash->{NAME};

  RemoveInternalTimer ($hash, "FHEM::SolarForecast::periodicWriteMemcache");
  InternalTimer       (gettimeofday() + WHISTREPEAT, "FHEM::SolarForecast::periodicWriteMemcache", $hash, 0);

  my (undef, $disabled, $inactive) = controller ($name);
  return if($disabled || $inactive);

  writeCacheToFile ($hash, 'circular',        $pvccache.$name);             # Cache File PV Circular schreiben
  writeCacheToFile ($hash, 'pvhist',          $pvhcache.$name);             # Cache File PV History schreiben
  writeCacheToFile ($hash, 'solcastapi',     $scpicache.$name);             # Cache File Strahlungsdaten-API Werte schreiben
  writeCacheToFile ($hash, 'statusapi',      $statcache.$name);             # Status-API Cache sichern
  writeCacheToFile ($hash, 'weatherapi',  $weathercache.$name);             # Weather-API Cache sichern

  $hash->{LCACHEFILE} = "last write time: ".FmtTime(gettimeofday())." whole Operating Memory";

  Log3 ($name, 4, "$name - The working memory >circular, pvhist, solcastapi, statusapi, weatherapi< has been saved to persistance");

  if ($bckp) {
      my $tstr = (timestampToTimestring (0))[2];
      $tstr    =~ s/[-: ]/_/g;

      writeCacheToFile ($hash, "circular", $pvccache.$name.'_'.$tstr);        # Cache File PV Circular Sicherung schreiben
      writeCacheToFile ($hash, "pvhist",   $pvhcache.$name.'_'.$tstr);        # Cache File PV History Sicherung schreiben

      deleteOldBckpFiles ($name, 'PVH_SolarForecast_'.$name);                 # alte Backup Files löschen
      deleteOldBckpFiles ($name, 'PVC_SolarForecast_'.$name);
  }

return;
}

################################################################
#                       Backupfiles löschen
################################################################
sub deleteOldBckpFiles {
  my $name = shift;
  my $file = shift;

  my $dfk    = CurrentVal ($name, 'backupFilesKeep', 3);
  my $bfform = $file.'_.*';

  if (!opendir (DH, $cachedir)) {
      Log3 ($name, 1, "$name - ERROR - Can't open path '$cachedir'");
      return;
  }

  my @files = sort grep {/^$bfform$/} readdir(DH);
  return if(!@files);

  my $fref = stat ("$cachedir/$file");

  if ($fref) {
      if ($fref =~ /ARRAY/) {
          @files = sort { (@{stat "$cachedir/$a"})[9] cmp (@{stat "$cachedir/$b"})[9] } @files;
      }
      else {
          @files = sort { (stat "$cachedir/$a")[9] cmp (stat "$cachedir/$b")[9] } @files;
      }
  }

  closedir (DH);

  Log3 ($name, 4, "$name - Backup files were found in '$cachedir' directory: ".join(', ',@files));

  my $max = int @files - $dfk;

  for (my $i = 0; $i < $max; $i++) {
      my $done = 1;
      unlink "$cachedir/$files[$i]" or do { Log3 ($name, 1, "$name - WARNING - Could not delete '$cachedir/$files[$i]': $!");
                                            $done = 0;
                                          };

      Log3 ($name, 3, "$name - old backup file '$cachedir/$files[$i]' deleted") if($done);
  }

return;
}

################################################################
#       Consumer Daten aus Speicher löschen
################################################################
sub delConsumerFromMem {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{c} // return;

  my $hash   = $defs{$name};
  my $calias = ConsumerVal ($hash, $c, 'alias', '');

  for my $d (1..31) {
      $d = sprintf("%02d", $d);
      delete $data{$name}{pvhist}{$d}{99}{"csme${c}"};
      delete $data{$name}{pvhist}{$d}{99}{"cyclescsm${c}"};
      delete $data{$name}{pvhist}{$d}{99}{"hourscsme${c}"};
      delete $data{$name}{pvhist}{$d}{99}{"avgcycmntscsm${c}"};

      for my $i (1..24) {
          $i = sprintf("%02d", $i);
          delete $data{$name}{pvhist}{$d}{$i}{"csmt${c}"};
          delete $data{$name}{pvhist}{$d}{$i}{"csme${c}"};
          delete $data{$name}{pvhist}{$d}{$i}{"minutescsm${c}"};
      }
  }

  delete $data{$name}{consumers}{$c};

  Log3 ($name, 2, qq{$name - Consumer "$c - $calias" deleted from memory});

return;
}

#################################################################
#  Cache Files im Cache Directory suchen und als Array
#  zurückliefern
#################################################################
sub searchCacheFiles {
  my $name = shift;

  my @ftd;

  opendir (DIR, $cachedir);

  while (my $file = readdir (DIR)) {
      next unless (-f "$cachedir/$file");
      next unless ($file =~ /_SolarForecast_${name}/);
      push @ftd, "$cachedir/$file";
  }

  closedir (DIR);

return @ftd;
}

################################################################
#   gesicherte Cache-Files vom Filesystem nachladen falls die
#   jeweiligen Online-Speicher nicht gefüllt sind (zum
#   Beispiel nach einem reload 76_SolarForecast.pm)
################################################################
sub reloadCacheFiles {
  my $paref = shift;
  my $name  = $paref->{name};

  return if(CurrentVal ($name, 'cachefilesloaded', 0));

  $paref->{file}      = $pvhcache.$name;                       # Cache File PV History einlesen wenn vorhanden
  $paref->{cachename} = 'pvhist';
  $paref->{title}     = 'pvHistory';
  readCacheFile ($paref);

  $paref->{file}      = $pvccache.$name;                       # Cache File PV Circular einlesen wenn vorhanden
  $paref->{cachename} = 'circular';
  $paref->{title}     = 'pvCircular';
  readCacheFile ($paref);

  $paref->{file}      = $csmcache.$name;                       # Cache File Consumer einlesen wenn vorhanden
  $paref->{cachename} = 'consumers';
  $paref->{title}     = 'consumerMaster';
  readCacheFile ($paref);

  $paref->{file}      = $scpicache.$name;                      # Cache File SolCast API Werte einlesen wenn vorhanden
  $paref->{cachename} = 'solcastapi';
  $paref->{title}     = 'radiationApiData';
  readCacheFile ($paref);

  $paref->{file}      = $statcache.$name;                      # Cache File API-Status einlesen wenn vorhanden
  $paref->{cachename} = 'statusapi';
  $paref->{title}     = 'statusApiData';
  readCacheFile ($paref);

  $paref->{file}      = $weathercache.$name;                   # Cache File Weather-API Daten einlesen wenn vorhanden
  $paref->{cachename} = 'weatherapi';
  $paref->{title}     = 'weatherApiData';
  readCacheFile ($paref);

  $paref->{file}      = $aitrained.$name;                      # AI Cache File einlesen wenn vorhanden
  $paref->{cachename} = 'aitrained';
  $paref->{title}     = 'aiTrainedData';
  readCacheFile ($paref);

  $paref->{file}      = $airaw.$name;                          # AI Rawdaten File einlesen wenn vorhanden
  $paref->{cachename} = 'airaw';
  $paref->{title}     = 'aiRawData';
  readCacheFile ($paref);

  delete $paref->{file};
  delete $paref->{cachename};
  delete $paref->{title};

  $data{$name}{current}{cachefilesloaded} = 1;

return;
}

################################################################
#                   Cachefile lesen
################################################################
sub readCacheFile {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $file      = $paref->{file};
  my $cachename = $paref->{cachename};
  my $title     = $paref->{title};

  my $hash      = $defs{$name};

  if ($cachename eq 'aitrained') {
      my ($err, $objref) = fileRetrieve ($file);
      
      if (!$err && $objref) {
          if (ref $objref ne 'ARRAY') {
              return "The file $file was restored but the content is not an ARRAY";
          }

          for my $obj (@{$objref}) {
              my $class = blessed ($obj);
              return 'The trained object is not AI::DecisionTree' unless $obj->isa('AI::DecisionTree');
          }
          
          $data{$name}{aidectree}{aitrained} = $objref;
          $data{$name}{current}{aitrainstate} = 'ok';

          Log3 ($name, 3, qq{$name - cached data "$title" restored});
          return;
      }

      delete $data{$name}{circular}{99}{aitrainLastFinishTs};
      delete $data{$name}{circular}{99}{runTimeTrainAI};
      return;
  }

  if ($cachename eq 'airaw') {
      my ($err, $dat) = fileRetrieve ($file);

      if (!$err && $dat) {
          $data{$name}{aidectree}{airaw}     = $dat;
          $data{$name}{current}{aitrawstate} = 'ok';

          Log3 ($name, 3, qq{$name - cached data "$title" restored});
      }

      return;
  }

  if ($cachename eq 'statusapi') {
      my ($err, $statapi) = fileRetrieve ($file);

      if (!$err && $statapi) {
          $data{$name}{statusapi} = $statapi;

          Log3 ($name, 3, qq{$name - cached data "$title" restored});
      }

      return;
  }

  if ($cachename eq 'weatherapi') {
      my ($err, $wthtapi) = fileRetrieve ($file);

      if (!$err && $wthtapi) {
          $data{$name}{weatherapi} = $wthtapi;

          Log3 ($name, 3, qq{$name - cached data "$title" restored});
      }

      return;
  }

  if ($cachename eq 'dwdcatalog') {
      my ($err, $dwdc) = fileRetrieve ($file);

      if (!$err && $dwdc) {
          $data{$name}{dwdcatalog} = $dwdc;

          debugLog ($paref, 'dwdComm', qq{$title restored});
      }

      return;
  }

  if ($cachename eq 'plantconfig') {
      my ($err, $plantcfg) = fileRetrieve ($file);
      return $err if($err);
      my ($nr, $na);

      if ($plantcfg) {
          ($nr, $na) = _restorePlantConfig ($hash, $plantcfg);
          Log3 ($name, 3, qq{$name - cached data "$title" restored. Number of restored Readings/Attributes: $nr/$na});
      }

      return ('', $nr, $na);
  }

  my ($error, @content) = FileRead ($file);

  if (!$error) {
      my $json      = join "", @content;
      my ($success) = evaljson ($hash, $json);

      if ($success) {
          $data{$name}{$cachename} = decode_json ($json);
          Log3 ($name, 3, qq{$name - cached data "$title" restored});
      }
      else {
          Log3 ($name, 1, qq{$name - WARNING - The content of file "$file" is not readable or may be corrupt});
      }
  }

return;
}

################################################################
#             Daten in File wegschreiben
################################################################
sub writeCacheToFile {
  my $hash      = shift;
  my $cachename = shift;
  my $file      = shift;
  my $nolog     = shift // '';

  my $name;
  if (ref $hash eq 'HASH') {
      $name = $hash->{NAME};
  }
  elsif (ref $hash eq 'ARRAY') {                                        # Array Referenz wurde übergeben
      $name      = $hash->[0];
      $cachename = $hash->[1];
      $file      = $hash->[2];
      $hash      = $defs{$name};
  }

  my $type = $hash->{TYPE};
  my ($error, $err, $lw);

  if ($cachename eq 'aitrained') {
      my $objref = AiDetreeVal ($hash, 'aitrained', '');
      return 'trained object is not an ARRAY' if(ref $objref ne 'ARRAY');

      for my $obj (@{$objref}) {
          return 'wrong trained object' if(ref $obj ne 'AI::DecisionTree');
      }

      $error = fileStore ($objref, $file);

      if ($error) {
          $err = qq{ERROR while writing AI data to file "$file": $error};
          Log3 ($name, 1, "$name - $err");
          return $err;
      }

      $lw                 = gettimeofday();
      $hash->{LCACHEFILE} = "last write time: ".FmtTime($lw)." File: $file";
      singleUpdateState ( {hash => $hash, state => "wrote cachefile $cachename successfully", evt => 1} );

      return;
  }

  if ($cachename eq 'airaw') {
      my $dat = AiRawdataVal ($hash, '', '', undef);

      if (defined $dat) {
          $error = fileStore ($dat, $file);

          if ($error) {
              $err = qq{ERROR while writing AI data to file "$file": $error};
              Log3 ($name, 1, "$name - $err");
              return $err;
          }
      }

      $lw                 = gettimeofday();
      $hash->{LCACHEFILE} = "last write time: ".FmtTime($lw)." File: $file";
      singleUpdateState ( {hash => $hash, state => "wrote cachefile $cachename successfully", evt => 1} );

      return;
  }

  if ($cachename eq 'dwdcatalog') {
      if (scalar keys %{$data{$name}{dwdcatalog}}) {
          $error = fileStore ($data{$name}{dwdcatalog}, $file);

          if ($error) {
              $err = qq{ERROR while writing DWD Station Catalog to file "$file": $error};
              Log3 ($name, 1, "$name - $err");
              return $err;
          }
      }
      else {
          return "The DWD Station Catalog is empty";
      }

      return;
  }

  if ($cachename eq 'statusapi') {
      if (scalar keys %{$data{$name}{statusapi}}) {
          $error = fileStore ($data{$name}{statusapi}, $file);

          if ($error) {
              $err = qq{ERROR while writing API Status to file "$file": $error};
              Log3 ($name, 1, "$name - $err");
              return $err;
          }
      }
      else {
          return "The API Status is empty";
      }

      return;
  }

  if ($cachename eq 'weatherapi') {
      if (scalar keys %{$data{$name}{weatherapi}}) {
          $error = fileStore ($data{$name}{weatherapi}, $file);

          if ($error) {
              $err = qq{ERROR while writing API Status to file "$file": $error};
              Log3 ($name, 1, "$name - $err");
              return $err;
          }
      }
      else {
          return "The API Status is empty";
      }

      return;
  }

  if ($cachename eq 'plantconfig') {
      my ($plantcfg, $nr, $na) = _storePlantConfig ($hash);

      if (scalar keys %{$plantcfg}) {
          $error = fileStore ($plantcfg, $file);

          if ($error) {
              $err = qq{ERROR writing cache file "$file": $error};
              Log3 ($name, 1, "$name - $err");
              return $err;
          }
      }

      $lw                 = gettimeofday();
      $hash->{LCACHEFILE} = "last write time: ".FmtTime($lw)." File: $file";
      singleUpdateState ( {hash => $hash, state => "wrote cachefile $cachename successfully", evt => 1} );

      return ('', $nr, $na);
  }

  if (!keys %{$data{$name}{$cachename}}) {
      if (-e $file) {
          my $err = FileDelete ($file);

          if ($err) {
              Log3 ($name, 1, qq{$name - ERROR deleting file $err}) if(!$nolog);
          }
      }

      return;
  }

  push my @arr, encode_json ($data{$name}{$cachename});

  $error = FileWrite ($file, @arr);

  if ($error) {
      $err = qq{ERROR writing cache file "$file": $error};
      Log3 ($name, 1, "$name - $err");
      return $err;
  }

  $lw                 = gettimeofday();
  $hash->{LCACHEFILE} = "last write time: ".FmtTime($lw)." File: $file";
  singleUpdateState ( {hash => $hash, state => "wrote cachefile $cachename successfully", evt => 1} );

return;
}

################################################################
#          Anlagenkonfiguration mit fileStore sichern
################################################################
sub _storePlantConfig {
  my $hash = shift;
  my $name = $hash->{NAME};

  my $plantcfg;
  my ($nr, $na) = (0,0);

  for my $rcfg (@rconfigs) {
      my $val = ReadingsVal ($name, $rcfg, '');
      next if(!$val);
      $plantcfg->{$rcfg} = $val;
      $nr++;
  }

  for my $acfg (@aconfigs) {
      my $val = AttrVal ($name, $acfg, '');
      next if(!$val);
      $plantcfg->{$acfg} = $val;
      $na++;
  }

return ($plantcfg, $nr, $na);
}

################################################################
#    Anlagenkonfiguration aus fileRetrieve wiederherstellen
################################################################
sub _restorePlantConfig {
  my $hash     = shift;
  my $plantcfg = shift;
  my $name     = $hash->{NAME};

  my ($nr, $na) = (0,0);

  while (my ($key, $val) = each %{$plantcfg}) {
      if (grep /^$key$/, @rconfigs) {                                          # Reading wiederherstellen
          CommandSetReading (undef,"$name $key $val");
          $nr++;
      }

      if (grep /^$key$/, @aconfigs) {                                          # Attribut wiederherstellen
          CommandAttr (undef, "$name $key $val");
          $na++;
      }
  }

return ($nr, $na);
}

################################################################
#              centralTask Start Management
#     Achtung: relevant für CPU Auslastung!
################################################################
sub runTask {
  my $hash = shift;

  return if(!$init_done || CurrentVal ($hash, 'ctrunning', 0));

  my $t           = time;
  my $ms          = strftime "%M:%S", localtime($t);
  my ($min, $sec) = split ':', $ms;                                                  # aktuelle Minute (00-59), aktuelle Sekunde (00-61)
  $min            = int $min;
  $sec            = int $sec;

  if ($sec > 10) {                                                                   # Attribute zur Laufzeit hinzufügen
      if (!exists $hash->{HELPER}{S10DONE}) {
          $hash->{HELPER}{S10DONE} = 1;
          _addDynAttr ($hash);                                                       # relevant für CPU Auslastung!!
      }
  }
  else {
      delete $hash->{HELPER}{S10DONE};
  }

  my $name                             = $hash->{NAME};
  my ($interval, $disabled, $inactive) = controller ($name);

  if (!$interval) {
      $hash->{MODE} = 'Manual / Event-controlled';
      storeReading ('nextCycletime', 'Manual / Event-controlled');
      return;
  }

  if ($disabled) {
      $hash->{MODE} = 'disabled';
      return;
  }

  if ($inactive) {
      $hash->{MODE} = 'inactive';
      return;
  }

  my $nct = CurrentVal ($hash, 'nextCycleTime', 0);                                  # gespeicherte nächste CyleTime

  if ($t >= $nct) {
       _newCycTime ($hash, $t, $interval);
      centralTask  ($hash, 1);
  }

  my $debug = getDebug ($hash);

  if ($min == 59 && $sec > 48) {
      if (!defined $hash->{HELPER}{S48DONE}) {
          $hash->{HELPER}{S48DONE} = 1;

          if ($debug =~ /collectData_long/x) {
              Log3 ($name, 1, "$name DEBUG> INFO - runTask starts data collection at the end of an hour");
          }

          releaseCentralTask ($hash);
          centralTask        ($hash, 1);
      }
  }
  else {
      delete $hash->{HELPER}{S48DONE};
  }

  if ($min == 0 && $sec > 3) {
      if (!defined $hash->{HELPER}{S03DONE}) {
          $hash->{HELPER}{S03DONE} = 1;

          if ($debug =~ /collectData_long/x) {
              Log3 ($name, 1, "$name DEBUG> INFO - runTask starts data collection at the beginning of an hour");
          }

          releaseCentralTask ($hash);
          centralTask        ($hash, 1);
      }
  }
  else {
      delete $hash->{HELPER}{S03DONE};
  }

return;
}

################################################################
#                   neue Zykluszeit bestimmen
################################################################
sub _newCycTime {
  my $hash     = shift;
  my $t        = shift;
  my $interval = shift;

  my $name     = $hash->{NAME};

  if (!$interval) {
      $hash->{MODE} = 'Manual / Event-controlled';
      $data{$name}{current}{nextCycleTime} = 0;
      storeReading ('nextCycletime', 'Manual / Event-controlled');
      return;
  }

  my $new       = $t + $interval;                                                # nächste Wiederholungszeit
  $hash->{MODE} = 'Automatic / Event-controlled - next planned Cycletime: '.FmtTime($new);

  $data{$name}{current}{nextCycleTime} = $new;
  storeReading ('nextCycletime', FmtTime($new));

return;
}

################################################################
#       neue Attribute zur Laufzeit hinzufügen
# Device spezifische ".AttrList" überschreibt Modul AttrList!
# relevant für CPU Auslastung!!
################################################################
sub _addDynAttr {
  my $hash = shift;
  my $name = $hash->{NAME};
  my $type = $hash->{TYPE};

  my $adwds  = '';
  my @alldwd = devspec2array ("TYPE=DWD_OpenData");
  $adwds     = join ",", @alldwd if(@alldwd);

  my @fcdevs = qw( OpenMeteoDWD-API
                   OpenMeteoDWD_D2-API
                   OpenMeteoDWDEnsemble-API
                   OpenMeteoWorld-API
                   SolCast-API
                   ForecastSolar-API
                   VictronKI-API
                 );

  push @fcdevs, @alldwd if(@alldwd);
  my $rdd = join ",", @fcdevs;

  ## Attributhüllen entfernen
  #############################
  my @deva = split " ", $modules{$type}{AttrList};
  my $atd  = 'setupWeatherDev|setupRadiationAPI|graphicBeam*Content|ctrlNextHoursSoCForecastReadings';
  @deva    = grep {!/$atd/} @deva;

  ## Attr setupWeatherDevX / setupRadiationAPI zur Laufzeit hinzufügen
  ######################################################################
  for my $step (1..MAXWEATHERDEV) {
      if ($step == 1) {
          push @deva, ($adwds ? "setupWeatherDev1:OpenMeteoDWD-API,OpenMeteoDWD_D2-API,OpenMeteoDWDEnsemble-API,OpenMeteoWorld-API,$adwds" :
                       "setupWeatherDev1:OpenMeteoDWD-API,OpenMeteoDWD_D2-API,OpenMeteoDWDEnsemble-API,OpenMeteoWorld-API");
          next;
      }

      push @deva, ($adwds ? "setupWeatherDev".$step.":$adwds" : "");
  }

  push @deva, "setupRadiationAPI:$rdd ";

  ## Attr graphicBeamXContent, ctrlNextDayForecastReadings zur Laufzeit hinzufügen
  ##################################################################################
  my ($gbc, @absoc);

  if (isBatteryUsed ($name)) {
      for my $bn (1..MAXBATTERIES) {
          $bn = sprintf "%02d", $bn;
          push @absoc, "batsocCombi_${bn}";
          push @absoc, "batsocForecast_${bn}";
          push @absoc, "batsocReal_${bn}";
      }

      push @absoc, 'batsocForecastSum';
      push @absoc, 'batsocRealSum';

      $gbc .= join ",", sort @absoc;
      $gbc .= ',';

      my $hod = join ",", (map { sprintf "%02d", $_} (0..23));
      push @deva, "ctrlNextHoursSoCForecastReadings:multiple-strict,$hod";
  }

  $gbc .= 'consumption,consumptionForecast,energycosts,feedincome,gridconsumption,gridfeedin,pvForecast,pvReal';

  for my $n (1..6) {
      push @deva, "graphicBeam${n}Content:$gbc";
  }

  $hash->{".AttrList"} = join " ", @deva;

return;
}

################################################################
#                       Zentraler Datenabruf
################################################################
sub centralTask {
  my $par = shift;
  my $evt = shift // 1;                                                # Readings Event generieren

  my ($hash, $name);
  if (ref $par eq 'HASH') {                                            # Standard Fn Aufruf
      $hash = $par;
      $name = $hash->{NAME};
  }
  elsif (ref $par eq 'ARRAY') {                                        # Array Referenz wurde übergeben
      $name = $par->[0];
      $evt  = $par->[1] // 1;                                          # Readings Event generieren
      $hash = $defs{$name};
  }
  else {
      Log (1, "ERROR module ".__PACKAGE__." - function >centralTask< was called with wrong data reference type: >".(ref $par)."<");
      return;
  }

  my $type = $hash->{TYPE};
  my $cst  = [gettimeofday];                                           # Zyklus-Startzeit

  RemoveInternalTimer ($hash, 'FHEM::SolarForecast::centralTask');
  RemoveInternalTimer ($hash, 'FHEM::SolarForecast::singleUpdateState');

  return if(!$init_done);

  setModel ($hash);                                                    # Model setzen

  my (undef, $disabled, $inactive) = controller ($name);
  return if($disabled || $inactive);                                   # disabled / inactive

  reloadCacheFiles ( {name => $name, type => $type} );                 # Cache-Files vom Filesystem nachladen falls nötig

  ### nicht mehr benötigte Daten verarbeiten - Bereich kann später wieder raus !!
  ########################################################################################################################
  #for my $hodc (25..38) {
  #    delete $data{$name}{circular}{$hodc};
  #}
  
  # delete $data{$name}{circular}{'00'};
  
  #my $gbw = AttrVal ($name, 'graphicBeamWidth', undef);                 # 27.04.
  #my $gco = AttrVal ($name, 'graphicControl', '');

  #if (defined $gbw) {
  #    my $newval = $gco." beamWidth=$gbw";
  #    CommandAttr (undef, "$name graphicControl $newval");
  #    ::CommandDeleteAttr (undef, "$name graphicBeamWidth");
  #}  
  
  for my $c (1..MAXCONSUMER) {                                          # 23.07.                      
      $c = sprintf "%02d", $c;
      my $surpmeth = ConsumerVal ($hash, $c, 'surpmeth', '');               
      
      if ($surpmeth =~ /^[2-9]$|^1[0-9]$|^20$/xs) {
          fhem ("set $name attrKeyVal consumer${c} surpmeth=average_${surpmeth}"); 
      }
  }
  
  for my $bn (1..MAXBATTERIES) {                                        # 02.10.
      $bn = sprintf "%02d", $bn;
      readingsDelete ($hash, 'Battery_ChargeRecommended_'.$bn);
  }
  
  
  ##########################################################################################################################

  if (!CurrentVal ($hash, 'allStringsFullfilled', 0)) {                                        # die String Konfiguration erstellen wenn noch nicht erfolgreich ausgeführt
      my $ret = _createStringConfig ($hash);

      if ($ret) {
          if (!CurrentVal ($hash, 'setupcomplete', 0)) {
              $ret = 'The setup routine is still incomplete';
          }
          singleUpdateState ( {hash => $hash, state => $ret, evt => 1} );                      # Central Task running Statusbit

          return;
      }
  }

  if (CurrentVal ($hash, 'ctrunning', 0)) {
      Log3 ($name, 4, "$name - INFO - central task was called when it was already running ... end this call");
      return;
  }

  $data{$name}{current}{ctrunning} = 1;                                                        # Central Task running Statusbit
  InternalTimer (gettimeofday() + 2.0, "FHEM::SolarForecast::releaseCentralTask", $hash, 0);   # Freigabe centralTask

  my $t     = time;                                                                            # aktuelle Unix-Zeit
  my $debug = getDebug ($hash);                                                                # Debug Module

  my $dt    = timestringsFromOffset ($t, 0);
  my $chour = $dt->{hour};
  
  my $centpars = {
      name    => $name,
      type    => $type,
      t       => $t,
      date    => $dt->{date},                                                                  # aktuelles Datum
      minute  => $dt->{minute},                                                                # aktuelle Minute (00-59)
      chour   => $dt->{hour},                                                                  # aktuelle Stunde in 24h format (00-23)
      day     => $dt->{day},                                                                   # aktueller Tag (range 01 .. 31)
      dayname => $dt->{dayname},                                                               # aktueller Wochentagsname (locale-dependent!!)
      debug   => $debug,
      lang    => getLang ($hash),
      state   => 'running',
      evt     => 0
  };

  if ($debug !~ /^none$/xs) {
      Log3 ($name, 4, "$name DEBUG> ################################################################");
      Log3 ($name, 4, "$name DEBUG> ###                  New centralTask cycle                   ###");
      Log3 ($name, 4, "$name DEBUG> ################################################################");
      Log3 ($name, 4, "$name DEBUG> current hour of day: ".($chour+1));
  }

  singleUpdateState ( {hash => $hash, state => $centpars->{state}, evt => $centpars->{evt}} );

  $centpars->{state} = 'updated';                                                     # kann durch Subs überschrieben werden!

  _getMoonPhase               ($centpars);                                            # aktuelle Mondphase ermittteln und speichern
  _collectAllRegConsumers     ($centpars);                                            # alle Verbraucher Infos laden
  _specialActivities          ($centpars);                                            # zusätzliche Events generieren + Sonderaufgaben
  _transferWeatherValues      ($centpars);                                            # Wetterwerte übertragen

  readingsDelete              ($hash, 'AllPVforecastsToEvent');

  _getRoofTopData             ($centpars);                                            # Strahlungs/Wetter-Daten der gewählten API's abrufen und in internen Strukturen speichern
  _transferInverterValues     ($centpars);                                            # WR Werte übertragen
  _transferAPIRadiationValues ($centpars);                                            # Raw Erzeugungswerte aus solcastapi-Hash übertragen und Forecast mit/ohne Korrektur erstellen
  _calcMaxEstimateToday       ($centpars);                                            # heutigen Max PV Estimate & dessen Tageszeit ermitteln
  _transferProducerValues     ($centpars);                                            # Werte anderer Erzeuger übertragen
  _transferMeterValues        ($centpars);                                            # Energy Meter auswerten
  _transferBatteryValues      ($centpars);                                            # Batteriewerte einsammeln
  _batSocTarget               ($centpars);                                            # Batterie Optimum Ziel SOC berechnen
  _batChargeMgmt              ($centpars);                                            # Batterie Ladefreigabe berechnen und erstellen
  _manageConsumerData         ($centpars);                                            # Consumer Daten sammeln und Zeiten planen

  _calcConsForecast_circular  ($centpars);                                            # neue Verbrauchsprognose über pvCircular

  _evaluateThresholds         ($centpars);                                            # Schwellenwerte bewerten und signalisieren
  _calcReadingsTomorrowPVFc   ($centpars);                                            # zusätzliche Readings Tomorrow_HourXX_PVforecast berechnen
  _calcTodayPVdeviation       ($centpars);                                            # Vorhersageabweichung erstellen (nach Sonnenuntergang)
  _calcDataEveryFullHour      ($centpars);                                            # Daten berechnen/speichern die nur einmal nach jeder vollen Stunde ermittelt werden
  _saveEnergyConsumption      ($centpars);                                            # Energie Hausverbrauch speichern
  _createSummaries            ($centpars);                                            # Zusammenfassungen erstellen
  _genSpecialReadings         ($centpars);                                            # optionale Spezialreadings erstellen

  userExit                    ($centpars);                                            # User spezifische Funktionen ausführen
  setTimeTracking             ($hash, $cst, 'runTimeCentralTask');                    # Zyklus-Laufzeit ermitteln

  createReadingsFromArray     ($hash, $evt);                                          # Readings erzeugen
  _readSystemMessages         ($centpars);                                            # Notification System - System Messages zusammenstellen

  if ($evt) {
      $centpars->{evt} = $evt;
      InternalTimer (gettimeofday() + 1, "FHEM::SolarForecast::singleUpdateState", {hash => $hash, state => $centpars->{state}, evt => $centpars->{evt}}, 0);
  }
  else {
      $centpars->{evt} = 1;
      singleUpdateState ( {hash => $hash, state => $centpars->{state}, evt => $centpars->{evt}} );
  }

  undef %{$centpars};

return;
}

################################################################
#       Erstellen der Stringkonfiguration
################################################################
sub _createStringConfig {                 ## no critic "not used"
  my $hash = shift;
  my $name = $hash->{NAME};
  my $type = $hash->{TYPE};

  delete $data{$name}{strings};                                                                   # Stringhash zurücksetzen
  $data{$name}{current}{allStringsFullfilled} = 0;

  my @istrings = split ",", AttrVal ($name, 'setupInverterStrings', '');                          # Stringbezeichner
  $data{$name}{current}{allstringscount} = scalar @istrings;                                      # Anzahl der Anlagenstrings

  if (!@istrings) {
      return qq{Define all used strings with command "attr $name setupInverterStrings" first.};
  }

  my $peak = AttrVal ($name, 'setupStringPeak', '');                                              # kWp für jeden Stringbezeichner
  return qq{Please complete attribute 'setupStringPeak'} if(!$peak);

  my ($aa,$ha) = parseParams ($peak);
  delete $data{$name}{current}{allstringspeak};

  while (my ($strg, $pp) = each %$ha) {
      if (grep /^$strg$/, @istrings) {
          $data{$name}{strings}{$strg}{peak}     = $pp;
          $data{$name}{current}{allstringspeak} += $pp * 1000;                                    # insgesamt installierte Peakleistung in W
      }
      else {
          return qq{Check 'setupStringPeak' -> the stringname '$strg' is not defined as valid string in attribute 'setupInverterStrings'};
      }
  }

  if (isSolCastUsed ($hash)) {                                                                   # SolCast-API Strahlungsquelle
      my $mrt = AttrVal ($name, 'setupRoofTops', '');                                            # RoofTop Konfiguration -> Zuordnung <pk>
      return qq{Please complete command "attr $name setupRoofTops".} if(!$mrt);

      my ($ad,$hd) = parseParams ($mrt);

      while (my ($is, $pk) = each %$hd) {
          if (grep /^$is$/, @istrings) {
              $data{$name}{strings}{$is}{pk} = $pk;
          }
          else {
              return qq{Check "setupRoofTops" -> the stringname "$is" is not defined as valid string in attribute "setupInverterStrings"};
          }
      }
  }
  elsif (isVictronKiUsed ($hash)) {
      my $invs = AttrVal ($name, 'setupInverterStrings', '');

      if ($invs ne 'KI-based') {
          return qq{You use a KI based model. Please set only "KI-based" as String with command "attr $name setupInverterStrings".};
      }
  }

  if (!grep /^KI-based$/, @istrings) {
      my $tilt = AttrVal ($name, 'setupStringDeclination', '');                                        # Modul Neigungswinkel für jeden Stringbezeichner
      return qq{Please complete command "attr $name setupStringDeclination"} if(!$tilt);

      my ($at,$ht) = parseParams ($tilt);

      while (my ($key, $value) = each %$ht) {
          if (grep /^$key$/, @istrings) {
              $data{$name}{strings}{$key}{tilt} = $value;
          }
          else {
              return qq{Check "setupStringDeclination" -> the stringname "$key" is not defined as valid string in attribute "setupInverterStrings"};
          }
      }

      my $dir = AttrVal ($name, 'setupStringAzimuth', '');                                             # Modul Ausrichtung für jeden Stringbezeichner
      return qq{Please complete command "attr $name setupStringAzimuth"} if(!$dir);

      my ($ad,$hd) = parseParams ($dir);
      my $iwrong   = qq{Please check the input of attr "setupStringAzimuth". It seems to be wrong.};

      while (my ($key, $value) = each %$hd) {
          if (grep /^$key$/, @istrings) {
              $data{$name}{strings}{$key}{azimut} = __ident2azimuth ($value) // return $iwrong;
          }
          else {
              return qq{Check "setupStringAzimuth" -> the stringname "$key" is not defined as valid string in attribute "setupInverterStrings"};
          }
      }
  }

  if (!keys %{$data{$name}{strings}}) {
      return qq{The string configuration seems to be incomplete. \n}.
             qq{Please check the settings of setupInverterStrings, setupStringPeak, setupStringAzimuth, setupStringDeclination }.
             qq{and/or setupRoofTops if SolCast-API is used.};
  }

  my @sca = keys %{$data{$name}{strings}};                                               # Gegencheck ob nicht mehr Strings in setupInverterStrings enthalten sind als eigentlich verwendet
  my @tom;

  for my $sn (@istrings) {
      next if(grep /^$sn$/, @sca);
      push @tom, $sn;
  }

  if (@tom) {
      return qq{Some Strings are not used. Please delete this string names from "setupInverterStrings" :}.join ",",@tom;
  }

  $data{$name}{current}{allStringsFullfilled} = 1;

return;
}

################################################################
#  formt einen Azimut-Bezeichner in ein Azimut um
#  numerische  werden direkt zurück gegeben
################################################################
sub __ident2azimuth {
  my $id = shift;

  return $id if(isNumeric ($id));

  my $az = $id eq 'N'  ? -180 :
           $id eq 'NE' ? -135 :
           $id eq 'E'  ? -90  :
           $id eq 'SE' ? -45  :
           $id eq 'S'  ? 0    :
           $id eq 'SW' ? 45   :
           $id eq 'W'  ? 90   :
           $id eq 'NW' ? 135  :
           undef;

return $az;
}

################################################################
#            Ermittlung der Mondphase
################################################################
sub _getMoonPhase {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};                                          # Epoche Zeit

  my $moonphasei;
  my $tstr = (timestampToTimestring ($t))[2];

  eval {
      $moonphasei = FHEM::Astro::Get (undef, 'global', 'text', 'MoonPhaseI', $tstr);
      1;
  }
  or do { Log3 ($name, 1, "$name - ERROR - $@");
          return;
        };

  $data{$name}{current}{moonPhaseI} = $moonphasei;

return;
}

################################################################
#         Grunddaten aller registrierten Consumer speichern
################################################################
sub _collectAllRegConsumers {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  return if(CurrentVal ($hash, 'consumerCollected', 0));                                          # Abbruch wenn Consumer bereits gesammelt

  delete $data{$name}{current}{consumerdevs};

  for my $c (1..MAXCONSUMER) {
      $c = sprintf "%02d", $c;
      my ($err, $consumer, $hc, $alias) = isDeviceValid ( { name => $name, obj => "consumer${c}", method => 'attr' } );
      next if($err);

      push @{$data{$name}{current}{consumerdevs}}, $consumer;                                     # alle Consumerdevices in CurrentHash eintragen

      my $dswitch = $hc->{switchdev};                                                             # alternatives Schaltdevice

      if ($dswitch) {
          my ($err) = isDeviceValid ( { name => $name, obj => $dswitch, method => 'string' } );
          next if($err);

          push @{$data{$name}{current}{consumerdevs}}, $dswitch if($dswitch ne $consumer);        # Switchdevice zusätzlich in CurrentHash eintragen
      }
      else {
          $dswitch = $consumer;
      }

      $alias = AttrVal ($consumer, 'alias', $consumer) if(!$alias);

      my ($rtot,$utot,$ethreshold);
      if (exists $hc->{etotal}) {
          my $etotal                = $hc->{etotal};
          ($rtot,$utot,$ethreshold) = split ":", $etotal;
      }

      my ($rpcurr,$upcurr,$pthreshold);
      if (exists $hc->{pcurr}) {
          my $pcurr                     = $hc->{pcurr};
          ($rpcurr,$upcurr,$pthreshold) = split ":", $pcurr;
      }

      my $asynchron;
      if (exists $hc->{asynchron}) {
          $asynchron = $hc->{asynchron};
      }

      my $noshow;
      if (exists $hc->{noshow}) {                                                                  # Consumer ausblenden in Grafik
          $noshow = $hc->{noshow};
      }

      my $exconfc;
      if (exists $hc->{exconfc}) {                                                                 # Consumer Verbrauch von Erstelleung der Verbrauchsprognose ausschließen
          $exconfc = $hc->{exconfc};
      }

      my ($rswstate, $onreg, $offreg);
      if(exists $hc->{swstate}) {
          ($rswstate, $onreg, $offreg) = split ":", $hc->{swstate}, 3;
      }

      my ($dswoncond, $rswoncond, $swoncondition);
      if (exists $hc->{swoncond}) {                                                                # zusätzliche Einschaltbedingung
          ($dswoncond, $rswoncond, $swoncondition) = split ":", $hc->{swoncond}, 3;
      }

      my ($dswoffcond, $rswoffcond, $swoffcondition);
      if (exists $hc->{swoffcond}) {                                                               # vorrangige Ausschaltbedingung
          ($dswoffcond, $rswoffcond, $swoffcondition) = split ":", $hc->{swoffcond}, 3;
      }

      my ($dspignorecond, $rigncond, $spignorecondition);
      if (exists $hc->{spignorecond}) {                                                            # Bedingung um vorhandenen PV Überschuß zu ignorieren
          ($dspignorecond, $rigncond, $spignorecondition) = split ":", $hc->{spignorecond}, 3;
      }

      my $interruptable = 0;
      my $hyst;
      if (exists $hc->{interruptable} && $hc->{interruptable} ne '0') {
          $interruptable = $hc->{interruptable};

          if ($interruptable ne '1') {
              my ($dv, $rd, $code);

              if ($interruptable =~ m/:\{.*\}/xs) {                                                 # interruptable prüft Perl-Code
                  ($dv, $rd, $code) = split ":", $interruptable, 3;
              }
              else {
                  ($dv, $rd, $code, $hyst) = split ":", $interruptable;
              }

              $interruptable = "$dv:$rd:$code";
          }
      }

      $hyst = DEFHYST if(!$hyst);

      my ($riseshift, $setshift);

      if (exists $hc->{mintime}) {                                                                # Check Regex
          my $mintime = $hc->{mintime};

          if ($mintime =~ /^SunPath/xsi) {
              (undef, $riseshift, $setshift) = split ":", $mintime, 3;
              $riseshift *= 60 if(defined $riseshift && isNumeric($riseshift));
              $setshift  *= 60 if(defined $setshift  && isNumeric($setshift));
          }
      }

      my $clt;
      if (exists $hc->{locktime}) {
          $clt = $hc->{locktime};
      }

      delete $data{$name}{consumers}{$c}{sunriseshift};
      delete $data{$name}{consumers}{$c}{sunsetshift};
      delete $data{$name}{consumers}{$c}{icon};

      my $rauto = $hc->{auto} // q{};
      my $ctype = $hc->{type} // DEFCTYPE;

      $data{$name}{consumers}{$c}{name}              = $consumer;                                # Name des Verbrauchers (Device)
      $data{$name}{consumers}{$c}{alias}             = $alias;                                   # Alias des Verbrauchers (Device)
      $data{$name}{consumers}{$c}{aliasshort}        = $hc->{aliasshort}   // q{};               # Kurzalias des Verbrauchers
      $data{$name}{consumers}{$c}{type}              = $hc->{type}         // DEFCTYPE;          # Typ des Verbrauchers
      $data{$name}{consumers}{$c}{power}             = $hc->{power};                             # Leistungsaufnahme des Verbrauchers in W
      $data{$name}{consumers}{$c}{avgenergy}         = q{};                                      # Initialwert Energieverbrauch (evtl. Überschreiben in manageConsumerData)
      $data{$name}{consumers}{$c}{mintime}           = $hc->{mintime}      // $hef{$ctype}{mt};  # Initialwert min. Einplanungsdauer (evtl. Überschreiben in manageConsumerData)
      $data{$name}{consumers}{$c}{mode}              = $hc->{mode}         // DEFCMODE;          # Planungsmode des Verbrauchers
      $data{$name}{consumers}{$c}{oncom}             = $hc->{on}           // q{};               # Setter Einschaltkommando
      $data{$name}{consumers}{$c}{offcom}            = $hc->{off}          // q{};               # Setter Ausschaltkommando
      $data{$name}{consumers}{$c}{dswitch}           = $dswitch;                                 # Switchdevice zur Kommandoausführung
      $data{$name}{consumers}{$c}{autoreading}       = $rauto;                                   # Readingname zur Automatiksteuerung
      $data{$name}{consumers}{$c}{retotal}           = $rtot               // q{};               # Reading der Leistungsmessung
      $data{$name}{consumers}{$c}{uetotal}           = $utot               // q{};               # Unit der Leistungsmessung
      $data{$name}{consumers}{$c}{rpcurr}            = $rpcurr             // q{};               # Reading der aktuellen Leistungsaufnahme
      $data{$name}{consumers}{$c}{upcurr}            = $upcurr             // q{};               # Unit der aktuellen Leistungsaufnahme
      $data{$name}{consumers}{$c}{energythreshold}   = $ethreshold;                              # Schwellenwert (Wh pro Stunde) ab der ein Verbraucher als aktiv gewertet wird
      $data{$name}{consumers}{$c}{powerthreshold}    = $pthreshold;                              # Schwellenwert d. aktuellen Leistung(W) ab der ein Verbraucher als aktiv gewertet wird
      $data{$name}{consumers}{$c}{notbefore}         = $hc->{notbefore}    // q{};               # nicht einschalten vor Stunde in 24h Format (00-23)
      $data{$name}{consumers}{$c}{notafter}          = $hc->{notafter}     // q{};               # nicht einschalten nach Stunde in 24h Format (00-23)
      $data{$name}{consumers}{$c}{rswstate}          = $rswstate           // 'state';           # Schaltstatus Reading
      $data{$name}{consumers}{$c}{asynchron}         = $asynchron          // 0;                 # Arbeitsweise FHEM Consumer Device
      $data{$name}{consumers}{$c}{noshow}            = $noshow             // 0;                 # ausblenden in Grafik
      $data{$name}{consumers}{$c}{exconfc}           = $exconfc            // 0;                 # Verbrauch von Erstelleung der Verbrauchsprognose ausschließen
      $data{$name}{consumers}{$c}{surpmeth}          = $hc->{surpmeth}     // 'default';         # Ermittlungsmethode des PV-Überschusses, default -> direkte Messung
      $data{$name}{consumers}{$c}{locktime}          = $clt                // '0:0';             # Sperrzeit im Automatikmodus ('offlt:onlt')
      $data{$name}{consumers}{$c}{onreg}             = $onreg              // 'on';              # Regex für 'ein'
      $data{$name}{consumers}{$c}{offreg}            = $offreg             // 'off';             # Regex für 'aus'
      $data{$name}{consumers}{$c}{dswoncond}         = $dswoncond          // q{};               # Device zur Lieferung einer zusätzliche Einschaltbedingung
      $data{$name}{consumers}{$c}{rswoncond}         = $rswoncond          // q{};               # Reading zur Lieferung einer zusätzliche Einschaltbedingung
      $data{$name}{consumers}{$c}{swoncondition}     = $swoncondition      // q{};               # Regex einer zusätzliche Einschaltbedingung
      $data{$name}{consumers}{$c}{dswoffcond}        = $dswoffcond         // q{};               # Device zur Lieferung einer vorrangigen Ausschaltbedingung
      $data{$name}{consumers}{$c}{rswoffcond}        = $rswoffcond         // q{};               # Reading zur Lieferung einer vorrangigen Ausschaltbedingung
      $data{$name}{consumers}{$c}{swoffcondition}    = $swoffcondition     // q{};               # Regex einer vorrangigen Ausschaltbedingung
      $data{$name}{consumers}{$c}{dspignorecond}     = $dspignorecond      // q{};               # Device liefert Ignore Bedingung
      $data{$name}{consumers}{$c}{rigncond}          = $rigncond           // q{};               # Reading liefert Ignore Bedingung
      $data{$name}{consumers}{$c}{spignorecondition} = $spignorecondition  // q{};               # Code/Regex der Ignore Bedingung
      $data{$name}{consumers}{$c}{interruptable}     = $interruptable;                           # Ein-Zustand des Verbrauchers ist unterbrechbar
      $data{$name}{consumers}{$c}{hysteresis}        = $hyst;                                    # Hysterese
      $data{$name}{consumers}{$c}{sunriseshift}      = $riseshift     if(defined $riseshift);    # Verschiebung (Sekunden) Sonnenaufgang bei SunPath Verwendung
      $data{$name}{consumers}{$c}{sunsetshift}       = $setshift      if(defined $setshift);     # Verschiebung (Sekunden) Sonnenuntergang bei SunPath Verwendung
      $data{$name}{consumers}{$c}{icon}              = $hc->{icon}    if(defined $hc->{icon});   # Icon für den Verbraucher
  }

  $data{$name}{current}{consumerCollected} = 1;

  Log3 ($name, 4, "$name - INFO - all registered consumers collected");

return;
}

################################################################
#                       Sonderaufgaben !
################################################################
sub _specialActivities {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $type   = $paref->{type};
  my $date   = $paref->{date};                                              # aktuelles Datum
  my $chour  = $paref->{chour};
  my $minute = $paref->{minute};
  my $t      = $paref->{t};                                                 # aktuelle Zeit
  my $day    = $paref->{day};

  my $hash  = $defs{$name};
  my ($ts,$ts1,$pvfc,$pvrl,$gcon);

  $ts1  = $date." ".sprintf("%02d",$chour).":00:00";

  $pvfc = ReadingsNum ($name, "Today_Hour".sprintf("%02d",$chour)."_PVforecast", 0);
  storeReading ('LastHourPVforecast', "$pvfc Wh", $ts1);

  $pvrl = ReadingsNum ($name, "Today_Hour".sprintf("%02d",$chour)."_PVreal", 0);
  storeReading ('LastHourPVreal', "$pvrl Wh", $ts1);

  $gcon = ReadingsNum ($name, "Today_Hour".sprintf("%02d",$chour)."_GridConsumption", 0);
  storeReading ('LastHourGridconsumptionReal', "$gcon Wh", $ts1);
  
  ## überhängende Daten in Nexthours löschen 
  ############################################
  for my $num (0..MAXNEXTHOURS) {
      my ($fd, $fh) = calcDayHourMove ($chour, $num);
      my $nhtstr    = 'NextHour'.(sprintf "%02d", $num);

      if ($fd > 2 && exists $data{$name}{nexthours}{$nhtstr}) {
         delete $data{$name}{nexthours}{$nhtstr};
         next;
      }
  }  

  ## Planungsdaten spezifisch löschen (Anfang und Ende nicht am selben Tag)
  ##########################################################################
  for my $c (keys %{$data{$name}{consumers}}) {
      next if(ConsumerVal ($hash, $c, 'plandelete', 'regular') eq 'regular');

      my $planswitchoff = ConsumerVal    ($hash, $c, 'planswitchoff', $t);
      my $simpCstat     = simplifyCstate (ConsumerVal ($hash, $c, 'planstate', ''));

      if ($t > $planswitchoff && $simpCstat =~ /planned|finished|unknown/xs) {
          deleteConsumerPlanning ($hash, $c);
      }
  }

  ## bestimmte einmalige Aktionen
  ##################################
  $chour    = int $chour;
  $minute   = int $minute;
  my $aitrh = CurrentVal ($name, 'aiTrainStart', AITRSTARTDEF);                                   # Stunde f. Start AI-Training

  ## Task 1
  ###########
  if ($chour == 0) {
      if (!defined $hash->{HELPER}{T1RUN}) {
          $hash->{HELPER}{T1RUN} = 1;

          Log3 ($name, 4, "$name - Daily special tasks - Task 1 started");

          __deleteEveryHourControls ($paref);                                                     # Sperrsignale der Stundenwerte-Steuerung löschen

          Log3 ($name, 4, "$name - Daily special tasks - Task 1 finished");
      }
  }
  else {
      delete $hash->{HELPER}{T1RUN};
  }

  ## Task 2
  ###########
  if ($chour == 0 && $minute >= 0) {
      if (!defined $hash->{HELPER}{T2RUN}) {
          $hash->{HELPER}{T2RUN} = 1;

          Log3 ($name, 4, "$name - Daily special tasks - Task 2 started");

          $date = strftime "%Y-%m-%d", localtime($t-7200);                                         # Vortag (2 h Differenz reichen aus)
          $ts   = $date." 23:59:59";

          $pvfc = ReadingsNum ($name, "Today_Hour24_PVforecast", 0);
          storeReading ('LastHourPVforecast', "$pvfc Wh", $ts);

          $pvrl = ReadingsNum ($name, "Today_Hour24_PVreal", 0);
          storeReading ('LastHourPVreal', "$pvrl Wh", $ts);

          $gcon = ReadingsNum ($name, "Today_Hour24_GridConsumption", 0);
          storeReading ('LastHourGridconsumptionReal', "$gcon Wh", $ts);

          deleteReadingspec ($hash, '(Today_Hour(.*_Grid.*|.*_PV.*|.*_PPreal.*|.*_Bat.*)|powerTrigger_.*|Today_MaxPVforecast.*)');
          readingsDelete    ($hash, 'Today_PVdeviation');
          readingsDelete    ($hash, 'Today_PVreal');

          readingsDelete    ($hash, 'Error');
          readingsDelete    ($hash, 'Errorcode');

          if (scalar(@widgetreadings)) {                                                          # vermeide Schleife falls FHEMWEB geöfffnet
              my @acopy       = @widgetreadings;
              @widgetreadings = ();

              for my $wdr (@acopy) {                                                              # Array der Hilfsreadings (Attributspeicher) löschen
                  readingsDelete ($hash, $wdr);
              }
          }

          my ($rapi, $wapi) = getStatusApiName ($hash);
          delete $data{$name}{statusapi}{$rapi}{'?All'} if($rapi);                                # Radiation-API Statusdaten (Tageszähler) löschen
          delete $data{$name}{statusapi}{$wapi}{'?All'} if($wapi);                                # V 1.42.0 - Weather-API Statusdaten (Tageszähler) löschen

          delete $data{$name}{circular}{99}{initdayfeedin};
          delete $data{$name}{circular}{99}{initdaygcon};
          delete $data{$name}{current}{sunriseToday};
          delete $data{$name}{current}{sunriseTodayTs};
          delete $data{$name}{current}{sunsetToday};
          delete $data{$name}{current}{sunsetTodayTs};

          for my $bn (1..MAXBATTERIES) {
              $bn = sprintf "%02d", $bn;
              delete $data{$name}{circular}{99}{'initdaybatintot'.$bn};
              delete $data{$name}{circular}{99}{'initdaybatouttot'.$bn};
          }

          $data{$name}{circular}{99}{ydayDvtn} = CircularVal ($hash, 99, 'tdayDvtn', '-');
          delete $data{$name}{circular}{99}{tdayDvtn};

          delete $data{$name}{pvhist}{$day};                                                     # den (alten) aktuellen Tag aus History löschen

          if (int $day == 1) {                                                                   # Monatswechsel: überhängende Tage löschen
              my $dtp  = timestringsFromOffset ($t, -86000);                                     # Berechne die Anzahl der Tage im Vormonat
              my $dipm = int $dtp->{day};

              for my $dtr ($dipm + 1 .. 31) {                                                    # Lösche ungültige Tage des Vormonats
                  if (exists $data{$name}{pvhist}{$dtr}) {
                      delete $data{$name}{pvhist}{$dtr};
                      Log3 ($name, 3, "$name - history day >$dtr< deleted");
                  }
              }
          }

          writeCacheToFile ($hash, 'plantconfig', $plantcfg.$name);                              # Anlagenkonfiguration sichern

          Log3 ($name, 3, "$name - history day >$day< deleted");
          Log3 ($name, 4, "$name - Daily special tasks - Task 2 finished");
      }
  }
  else {
      delete $hash->{HELPER}{T2RUN};
  }

  ## Task 3
  ###########
  if ($chour == 0 && $minute >= 2) {
      if (!defined $hash->{HELPER}{T3RUN}) {
          $hash->{HELPER}{T3RUN} = 1;

          Log3 ($name, 4, "$name - Daily special tasks - Task 3 started");

          for my $c (keys %{$data{$name}{consumers}}) {                                         # Planungsdaten regulär löschen
              next if(ConsumerVal ($hash, $c, "plandelete", "regular") ne "regular");
              deleteConsumerPlanning ($hash, $c);
          }

          writeCacheToFile ($hash, 'consumers', $csmcache.$name);                               # Cache File Consumer schreiben

          Log3 ($name, 4, "$name - Daily special tasks - Task 3 finished");
      }
  }
  else {
      delete $hash->{HELPER}{T3RUN};
  }

  ## Task 4
  ###########
  if ($chour == 0 && $minute >= 5) {
      if (!defined $hash->{HELPER}{T4RUN}) {
          $hash->{HELPER}{T4RUN} = 1;

          Log3 ($name, 4, "$name - Daily special tasks - Task 4 started");

          __createAdditionalEvents ($paref);                                                   # zusätzliche Events erzeugen - PV Vorhersage bis Ende des kommenden Tages
          __delObsoleteAPIData     ($paref);                                                   # Bereinigung obsoleter Daten im solcastapi Hash

          Log3 ($name, 4, "$name - Daily special tasks - Task 4 finished");
      }
  }
  else {
      delete $hash->{HELPER}{T4RUN};
  }

  ## Task 5
  ###########
  if ($chour == 0 && $minute >= 9) {
      if (!defined $hash->{HELPER}{T5RUN}) {
          $hash->{HELPER}{T5RUN} = 1;

          Log3 ($name, 4, "$name - Daily special tasks - Task 5 started");

          if (CurrentVal ($name, 'backupFilesKeep', 3)) {
              periodicWriteMemcache ($hash, 'bckp');                                          # Backup Files erstellen und alte Versionen löschen (unterbleibt bei 'backupFilesKeep' == 0)
          }

          Log3 ($name, 4, "$name - Daily special tasks - Task 5 finished");
      }
  }
  else {
      delete $hash->{HELPER}{T5RUN};
  }

  ## Task 6
  ###########
  if ($chour == $aitrh && $minute >= 15) {
      if (!defined $hash->{HELPER}{T6RUN}) {
          $hash->{HELPER}{T6RUN} = 1;

          Log3 ($name, 4, "$name - Daily special tasks - Task 6 started");

          aiDelRawData     ($paref);                                                           # KI Raw Daten löschen welche die maximale Haltezeit überschritten haben
          aiManageInstance ($paref);                                                           # AI PV-Forecast füllen, trainieren und sichern

          Log3 ($name, 4, "$name - Daily special tasks - Task 6 finished");
      }
  }
  else {
      delete $hash->{HELPER}{T6RUN};
  }

return;
}

#############################################################################
#         Readings der pvCorrectionFactor-Steuerung löschen
#############################################################################
sub __deleteEveryHourControls  {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  for my $n (0..24) {
      $n = sprintf "%02d", $n;

      readingsDelete ($hash, ".signaldone_${n}");

      if (ReadingsVal ($name, 'pvCorrectionFactor_Auto', 'off') =~ /on/xs) {
          my $pcf = ReadingsVal ($name, "pvCorrectionFactor_${n}", '');
          ($pcf)  = split " / ", $pcf if($pcf =~ /\s\/\s/xs);

          if ($pcf !~ /manual/xs) {                                                   # manuell gesetzte pcf-Readings nicht löschen
              readingsDelete ($hash, "pvCorrectionFactor_${n}");                      # V 1.37.0
          }
          else {
              readingsSingleUpdate ($hash, "pvCorrectionFactor_${n}", $pcf, 0);
          }
      }
  }

return;
}

#############################################################################
# zusätzliche Events erzeugen - PV Vorhersage bis Ende des kommenden Tages
#############################################################################
sub __createAdditionalEvents  {
  my $paref = shift;
  my $name  = $paref->{name};

  my $done  = 0;
  my $g2ev  = CurrentVal ($name, 'genPVforecastsToEvent', '');

  for my $idx (sort keys %{$data{$name}{nexthours}}) {
      my $nhts = NexthoursVal ($name, $idx, 'starttime', undef);
      my $nhfc = NexthoursVal ($name, $idx, 'pvfc',      undef);
      next if(!defined $nhts || !defined $nhfc);
      
      my ($dt, $h) = $nhts =~ /([\w-]+)\s(\d{2})/xs;
      
      if (!$nhfc && $g2ev eq 'adapt4fSteps') {                                         # für SVG 'fsteps'-Darstellung optimieren                                                     
           storeReading ('AllPVforecastsToEvent', "0 Wh", $dt." ".$h.":59:59");   
           next;  
      }
                                                                                       # https://forum.fhem.de/index.php?msg=1340607
      storeReading ('AllPVforecastsToEvent', "0 Wh", $dt." ".$h.":00:00") if(!$done);  # vor dem ersten Prognosewert immer einen Nullwert setzen

      $done = 1;

      if ($g2ev eq 'adapt4Steps') {                                                    # für SVG 'steps'-Darstellung optimieren
          storeReading ('AllPVforecastsToEvent', "0 Wh", $dt." ".$h.":00:00");         # jeden neuen Stundenwert mit 0 starten
          storeReading ('AllPVforecastsToEvent', "$nhfc Wh", $dt." ".$h.":00:01");
      }

      storeReading ('AllPVforecastsToEvent', "$nhfc Wh", $dt." ".$h.":59:59");
  }

  if (!$done) {
      Log3 ($name, 2, "$name - WARNING - Events of 'AllPVforecastsToEvent' were not created due to no data in 'nexthours'");
  }

return;
}

#############################################################################
#            solcastapi Hash veraltete Daten löschen
#############################################################################
sub __delObsoleteAPIData {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $date  = $paref->{date};                                                          # aktuelles Datum
  my $hash  = $defs{$name};

  my ($rapi, $wapi) = getStatusApiName ($hash);

  ## Wetter-API Daten löschen
  #############################
  if (keys %{$data{$name}{weatherapi}}) {
      if ($wapi ne 'OpenMeteo') {
          delete $data{$name}{weatherapi}{OpenMeteo};
      }
  }

  ## Status-API Daten löschen
  #############################
  if (keys %{$data{$name}{statusapi}}) {
      delete $data{$name}{statusapi}{OpenMeteo}     if($rapi ne 'OpenMeteo' && $wapi ne 'OpenMeteo');
      delete $data{$name}{statusapi}{ForecastSolar} if($rapi ne 'ForecastSolar');
      delete $data{$name}{statusapi}{SolCast}       if($rapi ne 'SolCast');
      delete $data{$name}{statusapi}{'?IdPair'}     if($rapi ne 'SolCast');
      delete $data{$name}{statusapi}{DWD}           if($rapi ne 'DWD');
      delete $data{$name}{statusapi}{VictronKi}     if($rapi ne 'VictronKi');
      delete $data{$name}{statusapi}{'?VRM'}        if($rapi ne 'VictronKi');
  }

  ## Solar-API Daten löschen
  #############################
  if (keys %{$data{$name}{solcastapi}}) {
      my $refts = timestringToTimestamp ($date.' 00:00:00');                               # Referenztimestring

      for my $idx (sort keys %{$data{$name}{solcastapi}}) {                                # alle Datumschlüssel kleiner aktueller Tag 00:00:00 selektieren
          if (!keys %{$data{$name}{solcastapi}{$idx}}) {                                   # leeren Schlüssel löschen
              delete $data{$name}{solcastapi}{$idx};
              next;
          }

          for my $scd (sort keys %{$data{$name}{solcastapi}{$idx}}) {
              my $ds = timestringToTimestamp ($scd);
              delete $data{$name}{solcastapi}{$idx}{$scd} if($ds && $ds < $refts);
          }
      }
  }

  ## veraltete Strings aus Strings-Hash löschen
  ################################################
  my @as = split ",", AttrVal ($name, 'setupInverterStrings', '');
  if (scalar @as) {
      for my $k (keys %{$data{$name}{strings}}) {
          next if($k =~ /\?All/);
          next if(grep /^$k$/, @as);

          delete $data{$name}{strings}{$k};

          Log3 ($name, 2, "$name - obsolete PV-String >$k< was deleted from Strings-Hash");
      }
  }

return;
}

################################################################
#    Wetter Werte aus dem angebenen Wetterdevice extrahieren
################################################################
sub _transferWeatherValues {
  my $paref = shift;
  my $name  = $paref->{name};
  my $chour = $paref->{chour};
  my $hash  = $defs{$name};

  my ($valid, $fcname, $apiu) = isWeatherDevValid ($hash, 'setupWeatherDev1');                 # Standard Weather Forecast Device
  return if(!$valid);

  delete $data{$name}{weatherdata};                                                            # Wetterdaten Hash löschen

  $paref->{apiu}   = $apiu;                                                                    # API wird verwendet
  $paref->{fcname} = $fcname;
  __sunRS ($paref);                                                                            # Sonnenauf- und untergang
  delete $paref->{fcname};
  delete $paref->{apiu};

  my ($fctime, $fctimets);                                                                     # Alter der DWD Daten

  if (!$apiu) {
      $fctime   = ReadingsVal ($fcname, 'fc_time', '-');
      $fctimets = timestringToTimestamp ($fctime);
  }
  else {
      my ($rapi, $wapi) = getStatusApiName ($hash);
      $fctime           = StatusAPIVal ($hash, $wapi, '?All', 'lastretrieval_time',      '-');
      $fctimets         = StatusAPIVal ($hash, $wapi, '?All', 'lastretrieval_timestamp', '-');
  }

  $data{$name}{current}{dwdWfchAge}   = $fctime;
  $data{$name}{current}{dwdWfchAgeTS} = $fctimets;

  for my $step (1..MAXWEATHERDEV) {
      $paref->{step} = $step;
      __readDataWeather ($paref);                                                           # Wetterdaten aus Device in Wetter-Hash einlesen
       delete $paref->{step};
  }

  __mergeDataWeather ($paref);                                                              # Wetterdaten zusammenfügen

  for my $num (0..MAXNEXTHOURS) {
      my ($fd, $fh) = calcDayHourMove ($chour, $num);
      last if($fd > MAXNEXTDAYS);

      my $wid   = $data{$name}{weatherdata}{"fc${fd}_${fh}"}{merge}{ww};                    # signifikantes Wetter = Wetter ID
      my $wwd   = $data{$name}{weatherdata}{"fc${fd}_${fh}"}{merge}{wwd};                   # Wetter Beschreibung
      my $wcc   = $data{$name}{weatherdata}{"fc${fd}_${fh}"}{merge}{neff};                  # Effektive Wolkendecke
      my $rr1c  = $data{$name}{weatherdata}{"fc${fd}_${fh}"}{merge}{rr1c};                  # Gesamtniederschlag (1-stündig) letzte 1 Stunde
      my $temp  = $data{$name}{weatherdata}{"fc${fd}_${fh}"}{merge}{ttt};                   # Außentemperatur
      my $don   = $data{$name}{weatherdata}{"fc${fd}_${fh}"}{merge}{don};                   # Tag/Nacht-Grenze

      if (defined $wid && (!$wid || $wid == 100)) {
          $wcc = 0;                                                                         # V 1.47.2
          debugLog ($paref, 'collectData_long', "Adjust cloud cover ratio (wcc) due to significant weather (ww) - ww: $wid -> wcc: $wcc");
      }

      my $nhtstr                                  = 'NextHour'.(sprintf "%02d", $num);
      $data{$name}{nexthours}{$nhtstr}{weatherid} = $wid;
      $data{$name}{nexthours}{$nhtstr}{wcc}       = $wcc;
      $data{$name}{nexthours}{$nhtstr}{rr1c}      = $rr1c;
      $data{$name}{nexthours}{$nhtstr}{rainrange} = $rr1c;
      $data{$name}{nexthours}{$nhtstr}{temp}      = $temp;
      $data{$name}{nexthours}{$nhtstr}{DoN}       = $don;

      my $fh1 = $fh + 1;                                                                       # = hod

      if ($num < 23 && $fh < 24) {                                                             # Ringspeicher Weather Forum: https://forum.fhem.de/index.php/topic,117864.msg1139251.html#msg1139251
          $data{$name}{circular}{sprintf("%02d",$fh1)}{weatherid}  = $wid;
          $data{$name}{circular}{sprintf("%02d",$fh1)}{weathertxt} = $wwd;
          $data{$name}{circular}{sprintf("%02d",$fh1)}{wcc}        = $wcc;
          $data{$name}{circular}{sprintf("%02d",$fh1)}{rr1c}       = $rr1c;
          $data{$name}{circular}{sprintf("%02d",$fh1)}{temp}       = $temp;

          if ($num == 0) {                                                                     # aktuelle Außentemperatur
              $data{$name}{current}{temp} = $temp;
          }
      }

      if ($fd == 0 && $fh1) {                                                                  # Weather in pvHistory speichern
          writeToHistory ( { paref => $paref, key => 'weatherid',         val => $wid,      hour => $fh1 } );
          writeToHistory ( { paref => $paref, key => 'weathercloudcover', val => $wcc // 0, hour => $fh1 } );
          writeToHistory ( { paref => $paref, key => 'rr1c',              val => $rr1c,     hour => $fh1 } );
          writeToHistory ( { paref => $paref, key => 'temperature',       val => $temp,     hour => $fh1 } );
          writeToHistory ( { paref => $paref, key => 'DoN',               val => $don,      hour => $fh1 } );
      }
  }

return;
}

################################################################
#   lese Wetterdaten aus Device im Attribut setupWeatherDevX
#   X = laufende Schleifenvariable $step
################################################################
sub __readDataWeather {
  my $paref = shift;
  my $name  = $paref->{name};
  my $chour = $paref->{chour};                                                                  # aktuelles Datum
  my $type  = $paref->{type};
  my $step  = $paref->{step};
  my $t     = $paref->{t};
  my $hash  = $defs{$name};

  my ($valid, $fcname, $apiu) = isWeatherDevValid ($hash, 'setupWeatherDev'.$step);             # Weather Forecast Device
  return if(!$valid);

  if ($apiu) {                                                                                  # eine API wird verwendet
      $paref->{fcname} = $fcname;
      ___readDataWeatherAPI ($paref);
      delete $paref->{fcname};
      return;
  }

  my ($err, $warnmsg) = checkdwdattr ($name, $fcname, \@dweattrmust);
  $paref->{state}     = $err if($err);
  
  my $fcdays = AttrVal ($fcname, 'forecastDays', 2);                                          # Anzahl Forecast Days in DWD Device
  my $end    = (24 + $fcdays * 24) - 1;                                                       # V 1.55.0 -> default 71
  
  debugLog ($paref, 'collectData_long', "collect Weather data step $step - device: $fcname =>");

  for my $n (0..$end) {
      my ($fd, $fh) = calcDayHourMove ($chour, $n);
      last if($fd > MAXNEXTDAYS);

      my $wid   = ReadingsNum ($fcname, "fc${fd}_${fh}_ww",   undef);                          # Signifikantes Wetter zum Vorhersagezeitpunkt
      my $wwd   = ReadingsVal ($fcname, "fc${fd}_${fh}_wwd",     '');                          # Wetter Beschreibung
      my $neff  = ReadingsNum ($fcname, "fc${fd}_${fh}_Neff", undef);                          # Effektiver Bedeckungsgrad zum Vorhersagezeitpunkt
      my $temp  = ReadingsNum ($fcname, "fc${fd}_${fh}_TTT",  undef);                          # 2m-Temperatur zum Vorhersagezeitpunkt
      my $sunup = ReadingsNum ($fcname, "fc${fd}_${fh}_SunUp",    0);                          # 1 - Tag

      if (!$n) {                                                                               # Hour 00 -> Werte des vorigen Tag / hour 24 verwenden
          my $dt  = timestringsFromOffset ($t, -86400);
          $wid  //= HistoryVal ($name, $dt->{day}, '24', 'weatherid', undef);
          $neff //= HistoryVal ($name, $dt->{day}, '24', 'wcc',       undef);
          $temp //= HistoryVal ($name, $dt->{day}, '24', 'temp',      undef);
      }

      if (!$sunup && defined $wid && defined $weather_ids{$wid}{icon} && $weather_ids{$wid}{icon} ne 'unknown') {        # Nacht-Icons
          $wid += 100;
      }

      my $fh1 = $fh + 1;
      my $fd1 = $fd;

      if ($fh1 == 24) {
          $fh1 = 0;
          $fd1++;
      }

      my $rr1c = ReadingsNum ($fcname, "fc${fd1}_${fh1}_RR1c", 0);                             # Gesamtniederschlag (1-stündig) letzte 1 Stunde -> wir schuen in die Zukunft

      debugLog ($paref, 'collectData_long', "Weather $step: fc${fd}_${fh}, don: $sunup, wid: ".(defined $wid ? $wid : '<undef>').", RR1c: $rr1c, TTT: ".(defined $temp ? $temp : '<undef>').", Neff: ".(defined $neff ? $neff : '<undef>'));

      $data{$name}{weatherdata}{"fc${fd}_${fh}"}{$step}{ww}   = $wid;
      $data{$name}{weatherdata}{"fc${fd}_${fh}"}{$step}{wwd}  = $wwd;
      $data{$name}{weatherdata}{"fc${fd}_${fh}"}{$step}{neff} = $neff;
      $data{$name}{weatherdata}{"fc${fd}_${fh}"}{$step}{rr1c} = $rr1c;
      $data{$name}{weatherdata}{"fc${fd}_${fh}"}{$step}{ttt}  = $temp;
      $data{$name}{weatherdata}{"fc${fd}_${fh}"}{$step}{don}  = $sunup;
  }

return;
}

################################################################
#   lese Wetterdaten aus API Speicher (solcastapi)
################################################################
sub ___readDataWeatherAPI {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $type   = $paref->{type};
  my $step   = $paref->{step};
  my $fcname = $paref->{fcname};
  my $hash   = $defs{$name};

  debugLog ($paref, 'collectData_long', "collect Weather data step $step - API: $fcname =>");

  my ($rapi, $wapi) = getStatusApiName ($hash);

  for my $idx (sort keys %{$data{$name}{weatherapi}{$wapi}}) {
      if ($idx =~ /^fc(?:[0-2])_(?:[0-9]|1[0-9]|2[0-3])$/xs) {                                                                    # valider Weather API Index
          my $rr1c = WeatherAPIVal ($hash, $wapi, $idx, 'rr1c', undef);
          my $wid  = WeatherAPIVal ($hash, $wapi, $idx, 'ww',   undef);
          my $neff = WeatherAPIVal ($hash, $wapi, $idx, 'neff', undef);
          my $don  = WeatherAPIVal ($hash, $wapi, $idx, 'don',      0);
          my $ttt  = WeatherAPIVal ($hash, $wapi, $idx, 'ttt',  undef);

          if ($idx eq 'fc0_0') {
              $wid  //= WeatherAPIVal ($hash, $wapi, 'fc0_1', 'ww',   undef);
              $neff //= WeatherAPIVal ($hash, $wapi, 'fc0_1', 'neff', undef);
              $ttt  //= WeatherAPIVal ($hash, $wapi, 'fc0_1', 'ttt',  undef);
          }

          if (!$don && defined $wid && defined $weather_ids{$wid}{icon} && $weather_ids{$wid}{icon} ne 'unknown') {        # Nacht-Icons
              $wid += 100;
          }

          $data{$name}{weatherdata}{$idx}{$step}{ww}   = $wid  if(defined $wid);
          $data{$name}{weatherdata}{$idx}{$step}{neff} = $neff if(defined $neff);
          $data{$name}{weatherdata}{$idx}{$step}{rr1c} = $rr1c if(defined $rr1c);
          $data{$name}{weatherdata}{$idx}{$step}{ttt}  = $ttt  if(defined $ttt);
          $data{$name}{weatherdata}{$idx}{$step}{don}  = $don  if(defined $don);

          debugLog ($paref, 'collectData_long', "Weather $step: $idx".
                                           ", don: ". (defined $don  ? $don  : '<undef>').
                                           ", wid: ". (defined $wid  ? $wid  : '<undef>').
                                           ", RR1c: ".(defined $rr1c ? $rr1c : '<undef>').
                                           ", TTT: ". (defined $ttt  ? $ttt  : '<undef>').
                                           ", Neff: ".(defined $neff ? $neff : '<undef>')
                                           );
      }
  }

return;
}

################################################################
#                     Wetterdaten mergen
################################################################
sub __mergeDataWeather {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $hash  = $defs{$name};

  debugLog ($paref, 'collectData_long', "merge Weather data =>");

  my $ds = 0;

  for my $wd (1..MAXWEATHERDEV) {
      my ($valid, $fcname, $apiu) = isWeatherDevValid ($hash, 'setupWeatherDev'.$wd);              # Weather Forecast Device
      $ds++ if($valid);
  }

  my ($q, $m) = (0,0);

  for my $key (sort keys %{$data{$name}{weatherdata}}) {
      my ($z, $neff, $rr1c, $temp) = (0,0,0,0);

      $data{$name}{weatherdata}{$key}{merge}{don}  = $data{$name}{weatherdata}{$key}{1}{don};
      $data{$name}{weatherdata}{$key}{merge}{ww}   = $data{$name}{weatherdata}{$key}{1}{ww};
      $data{$name}{weatherdata}{$key}{merge}{wwd}  = $data{$name}{weatherdata}{$key}{1}{wwd};
      $data{$name}{weatherdata}{$key}{merge}{neff} = $data{$name}{weatherdata}{$key}{1}{neff};
      $data{$name}{weatherdata}{$key}{merge}{rr1c} = $data{$name}{weatherdata}{$key}{1}{rr1c};
      $data{$name}{weatherdata}{$key}{merge}{ttt}  = $data{$name}{weatherdata}{$key}{1}{ttt};

      for my $step (1..$ds) {
          $q++;

          my $n = $data{$name}{weatherdata}{$key}{$step}{neff};
          my $r = $data{$name}{weatherdata}{$key}{$step}{rr1c};
          my $t = $data{$name}{weatherdata}{$key}{$step}{ttt};

          next if(!isNumeric ($n) || !isNumeric ($r) || !isNumeric ($t));

          $neff += $n;
          $rr1c += $r;
          $temp += $t;
          $z++;
          $m++;
      }

      next if(!$z);

      $data{$name}{weatherdata}{$key}{merge}{neff} = sprintf "%.0f", ($neff / $z);
      $data{$name}{weatherdata}{$key}{merge}{rr1c} = sprintf "%.2f", ($rr1c / $z);
      $data{$name}{weatherdata}{$key}{merge}{ttt}  = sprintf "%.2f", ($temp / $z);

      debugLog ($paref, 'collectData_long', "Weather merged: $key, ".
                                       "don: $data{$name}{weatherdata}{$key}{merge}{don}, ".
                                       "wid: ".(defined $data{$name}{weatherdata}{$key}{1}{ww} ? $data{$name}{weatherdata}{$key}{1}{ww} : '<undef>').", ".
                                       "RR1c: $data{$name}{weatherdata}{$key}{merge}{rr1c}, ".
                                       "TTT: $data{$name}{weatherdata}{$key}{merge}{ttt}, ".
                                       "Neff: $data{$name}{weatherdata}{$key}{merge}{neff}");
  }

  debugLog ($paref, 'collectData_long', "Number of Weather datasets mergers - delivered: $q, merged: $m, failures: ".($q - $m));

return;
}

################################################################
#   Sonnenauf- und untergang bei gesetzten global
#   latitude/longitude Koordinaten berechnen, sonst aus DWD
#   Device extrahieren
################################################################
sub __sunRS {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $t      = $paref->{t};                                                       # aktuelle Zeit
  my $fcname = $paref->{fcname};
  my $type   = $paref->{type};
  my $date   = $paref->{date};                                                    # aktuelles Datum
  my $apiu   = $paref->{apiu};
  my $hash   = $defs{$name};

  my ($fc0_sr, $fc0_ss, $fc1_sr, $fc1_ss);

  my ($cset, undef, undef, undef) = locCoordinates();

  debugLog ($paref, 'collectData_long', "collect sunrise/sunset times - device: $fcname =>");

  my ($rapi, $wapi) = getStatusApiName ($hash);

  if ($cset) {
      my $alt = 'HORIZON=-0.833';                                                 # default from https://metacpan.org/release/JFORGET/DateTime-Event-Sunrise-0.0505/view/lib/DateTime/Event/Sunrise.pm
      $fc0_sr = substr (sunrise_abs_dat ($t, $alt),         0, 5);                # SunRise heute
      $fc0_ss = substr (sunset_abs_dat  ($t, $alt),         0, 5);                # SunSet heute
      $fc1_sr = substr (sunrise_abs_dat ($t + 86400, $alt), 0, 5);                # SunRise morgen
      $fc1_ss = substr (sunset_abs_dat  ($t + 86400, $alt), 0, 5);                # SunSet morgen
  }
  else {
      if (!$apiu) {                                                               # Daten aus DWD Device holen
          $fc0_sr = ReadingsVal ($fcname, 'fc0_SunRise', '23:59');
          $fc0_ss = ReadingsVal ($fcname, 'fc0_SunSet',  '00:00');
          $fc1_sr = ReadingsVal ($fcname, 'fc1_SunRise', '23:59');
          $fc1_ss = ReadingsVal ($fcname, 'fc1_SunSet',  '00:00');
      }
      else {                                                                                          # Daten aus solcastapi (API) holen
          $fc0_sr = substr (WeatherAPIVal ($hash, $wapi, 'sunrise', 'today',    '23:59:59'), 0, 5);
          $fc0_ss = substr (WeatherAPIVal ($hash, $wapi, 'sunset',  'today',    '00:00:00'), 0, 5);
          $fc1_sr = substr (WeatherAPIVal ($hash, $wapi, 'sunrise', 'tomorrow', '23:59:59'), 0, 5);
          $fc1_ss = substr (WeatherAPIVal ($hash, $wapi, 'sunset',  'tomorrow', '00:00:00'), 0, 5);
      }
  }

  $data{$name}{current}{sunriseToday}      = $date.' '.$fc0_sr.':00';
  $data{$name}{current}{sunriseTodayTs}    = timestringToTimestamp ($date.' '.$fc0_sr.':00');
  $data{$name}{current}{sunriseTomorrowTs} = 86400 + timestringToTimestamp ($date.' '.$fc1_sr.':00');

  $data{$name}{current}{sunsetToday}      = $date.' '.$fc0_ss.':00';
  $data{$name}{current}{sunsetTodayTs}    = timestringToTimestamp ($date.' '.$fc0_ss.':00');
  $data{$name}{current}{sunsetTomorrowTs} = 86400 + timestringToTimestamp ($date.' '.$fc1_ss.':00');

  debugLog ($paref, 'collectData_long', "sunrise/sunset today: $fc0_sr / $fc0_ss, sunrise/sunset tomorrow: $fc1_sr / $fc1_ss");

  storeReading ('Today_SunRise',    $fc0_sr);
  storeReading ('Today_SunSet',     $fc0_ss);
  storeReading ('Tomorrow_SunRise', $fc1_sr);
  storeReading ('Tomorrow_SunSet',  $fc1_ss);

  my $fc0_sr_mm = sprintf "%02d", (split ":", $fc0_sr)[0];
  my $fc0_ss_mm = sprintf "%02d", (split ":", $fc0_ss)[0];
  my $fc1_sr_mm = sprintf "%02d", (split ":", $fc1_sr)[0];
  my $fc1_ss_mm = sprintf "%02d", (split ":", $fc1_ss)[0];

return ($fc0_sr_mm, $fc0_ss_mm, $fc1_sr_mm, $fc1_ss_mm);
}

################################################################
#    Werte Inverter Device ermitteln und übertragen
################################################################
sub _transferInverterValues {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $t     = $paref->{t};                                              # aktuelle Unix-Zeit
  my $chour = $paref->{chour};
  my $day   = $paref->{day};

  my $hash         = $defs{$name};
  my ($acu, $aln)  = isAutoCorrUsed ($name);
  my $hod          = sprintf "%02d", ($chour + 1);
  my $warn         = '';
  my $pvsum        = 0;                                                 # Summe aktuelle PV aller Inverter
  my $ethishoursum = 0;                                                 # Summe Erzeugung akt. Stunde aller Inverter

  for my $in (1..MAXINVERTER) {
      $in = sprintf "%02d", $in;

      my ($err, $indev, $h) = isDeviceValid ( { name => $name, obj => 'setupInverterDev'.$in, method => 'attr' } );
      next if($err);

      my $pac2dc = 0;
      my $pdc2ac = 0;
      my $pvin   = 0;
      my $pvout  = 0;
      my $etotal = 0;
      my $source = 'pv';

      my $strings;

      if (defined $h->{strings}) {                                             # Strings und Wechselrichtertyp feststellen
           $strings = $h->{strings};
           $source  = 'bat' if($h->{strings} eq 'none');
      }
      else {                                                                   # keine Strings explizit angegeben -> alles Strings zuordnen
          my @astrings;

          for my $str (sort keys %{$data{$name}{strings}}) {
              push @astrings, $str;
          }

          $strings = join ",", @astrings;
      }

      my ($itype, $feed) = exploreInverterType ($h);

      if (defined $h->{ac2dc}) {
          my ($a2dread, $a2dunit) = split ":", $h->{ac2dc};
          my $a2duf               = $a2dunit =~ /^kW$/xi ? 1000 : 1;
          $pac2dc                 = ReadingsNum ($indev, $a2dread, 0) * $a2duf;                        # Leistung AC->DC
          $pac2dc                 = $pac2dc <= 0 ? 0 : sprintf "%.0f", $pac2dc;
      }

      if (defined $h->{dc2ac}) {
          my ($d2aread, $d2aunit) = split ":", $h->{dc2ac};
          my $d2auf               = $d2aunit =~ /^kW$/xi ? 1000 : 1;
          $pdc2ac                 = ReadingsNum ($indev, $d2aread, 0) * $d2auf;                        # Leistung DC->AC
          $pdc2ac                 = $pdc2ac <= 0 ? 0 : sprintf "%.0f", $pdc2ac;
      }

      if ($source eq 'pv') {
          my ($edread, $etunit)   = split ":", $h->{etotal};                                           # Readingname/Unit für Energie total (PV Erzeugung)
          my $etuf                = $etunit =~ /^kWh$/xi ? 1000 : 1;
          $etotal                 = ReadingsNum ($indev, $edread, 0) * $etuf;                          # Erzeugung total (Wh)

          my ($pvoread, $pvounit) = split ":", $h->{pvOut};                                            # Readingname/Unit für aktuelle Leistung aus PV-Erzeugung
          my $pvouf               = $pvounit =~ /^kW$/xi ? 1000 : 1;
          $pvout                  = ReadingsNum ($indev, $pvoread, 0) * $pvouf;
          $pvout                  = $pvout <= 0 ? 0 : sprintf "%.0f", $pvout;                          # Forum: https://forum.fhem.de/index.php/topic,117864.msg1159718.html#msg1159718, https://forum.fhem.de/index.php/topic,117864.msg1166201.html#msg1166201

          if (defined $h->{pvIn}) {                                                                    # ist optional
              my ($pviread, $pviunit) = split ":", $h->{pvIn};                                         # Readingname/Unit für PV-DC-Eingangsleistung
              my $pviuf               = $pviunit =~ /^kW$/xi ? 1000 : 1;
              $pvin                   = ReadingsNum ($indev, $pviread, 0) * $pviuf;
              $pvin                   = $pvin <= 0 ? 0 : sprintf "%.0f", $pvin;
          }
      }

      my $histetot = HistoryVal ($name, $day, $hod, 'etotali'.$in, 0);                                 # etotal zu Beginn einer Stunde

      my ($ethishour, $etotsvd);

      if (!$histetot) {                                                                                # etotal der aktuelle Stunde gesetzt ?
          writeToHistory ( { paref => $paref, key => 'etotali'.$in, val => $etotal, hour => $hod } );

          $etotsvd   = InverterVal ($name, $in, 'ietotal', $etotal);
          $ethishour = int ($etotal - $etotsvd);
      }
      else {
          $ethishour = int ($etotal - $histetot);

          if (defined $h->{capacity} && $ethishour > 2 * $h->{capacity}) {                             # Schutz vor plötzlichem Anstieg von 0 auf mehr als doppelte WR-Kapazität
              Log3 ($name, 1, "$name - WARNING - The generated PV of Inverter '$indev' is much more higher than capacity set in inverter key 'capacity'. It seems to be a failure and Energy Total is reinitialized.");
              $warn = ' (WARNING: too much generated PV was registered - see log file)';

              writeToHistory ( { paref => $paref, key => 'etotali'.$in, val => $etotal, hour => $hod } );

              $etotsvd   = InverterVal ($name, $in, 'ietotal', $etotal);
              $ethishour = int ($etotal - $etotsvd);
          }
      }

      if ($ethishour < 0) {
          $ethishour = 0;
          my $vl     = 3;
          my $pre    = '- WARNING -';

          if ($paref->{debug} =~ /collectData/xs) {                                                 # V 1.23.0 Forum: https://forum.fhem.de/index.php?msg=1314453
              $vl  = 1;
              $pre = 'DEBUG> - WARNING -';
          }

          Log3 ($name, $vl, "$name $pre The Total Energy of Inverter '$indev' is lower than the value saved before. This situation is unexpected and the Energy generated of current hour of this inverter is set to '0'.");
          $warn = ' (WARNING invalid real PV occured - see Logfile)';
      }

      $data{$name}{inverters}{$in}{ipvin}       = $pvin;                                         # aktuelle DC PV-Eingangsleistung
      $data{$name}{inverters}{$in}{ipvout}      = $pvout;                                        # aktuelle Leistung aus PV-Erzeugung, Forum: https://forum.fhem.de/index.php/topic,117864.msg1139251.html#msg1139251
      $data{$name}{inverters}{$in}{ipac2dc}     = $pac2dc;                                       # aktuelle Leistung AC->DC
      $data{$name}{inverters}{$in}{ipdc2ac}     = $pdc2ac;                                       # aktuelle Leistung DC->AC
      $data{$name}{inverters}{$in}{ietotal}     = $etotal;                                       # aktuellen etotal des WR speichern
      $data{$name}{inverters}{$in}{iname}       = $indev;                                        # Name des Inverterdevices
      $data{$name}{inverters}{$in}{ialias}      = AttrVal ($indev, 'alias', $indev);             # Alias Inverter
      $data{$name}{inverters}{$in}{invertercap} = $h->{capacity}  if(defined $h->{capacity});    # optionale Angabe max. WR-Leistung
      $data{$name}{inverters}{$in}{ilimit}      = $h->{limit} // 100;                            # Wirkleistungsbegrenzung
      $data{$name}{inverters}{$in}{iicon}       = $h->{icon}      if($h->{icon});                # Icon des Inverters
      $data{$name}{inverters}{$in}{istrings}    = $strings;                                      # dem Inverter zugeordnete Strings | none
      $data{$name}{inverters}{$in}{itype}       = $itype;                                        # Inverter Arbeitsvariante
      $data{$name}{inverters}{$in}{iasynchron}  = $h->{asynchron} if($h->{asynchron});           # Inverter Mode
      $data{$name}{inverters}{$in}{ifeed}       = $feed;                                         # Eigenschaften der Energielieferung
      $data{$name}{inverters}{$in}{isource}     = $source;                                       # Eigenschaften des Energiebezugs, normal pv

      $pvsum        += $pvout if($source eq 'pv');
      $ethishoursum += $ethishour;

      writeToHistory ( { paref => $paref, key => 'pvrl'.$in, val => $ethishour, hour => $hod } );

      debugLog ($paref, 'collectData|collectData_long', "collect Inverter $in data - device: $indev, source: $source, delivery: $feed =>");
      debugLog ($paref, 'collectData|collectData_long', "pvOut: $pvout W, pvIn: $pvin W, AC->DC: $pac2dc W, DC->AC: $pdc2ac W, etotal: $etotal Wh");
  }

  storeReading ('Current_PV', $pvsum.' W');
  storeReading ('Today_Hour'.$hod.'_PVreal', $ethishoursum.' Wh'.$warn);

  $data{$name}{circular}{$hod}{pvrl} = $ethishoursum;                                                            # Ringspeicher PV real Forum: https://forum.fhem.de/index.php/topic,117864.msg1133350.html#msg1133350

  push @{$data{$name}{current}{genslidereg}}, $pvsum;                                                            # Schieberegister PV Erzeugung
  limitArray ($data{$name}{current}{genslidereg}, SLIDENUMMAX);
  
  debugLog ($paref, 'collectData|collectData_long', "summary data of all Inverters - pv: $pvsum W, this hour Generation: $ethishoursum Wh");
   
  ## PV real valid Status bestimmen
  ###################################  
  __handleReductionState ($paref);                                                             # Abregelungsstatus der Anlage ermitteln und speichern
  
  my $valid     = 1;
  my $percdev   = 100;
  my $pvapifc   = CircularVal ($name, $hod, 'pvapifc', 0);                                     # vorhergesagte PV Energie am Ende der vorherigen Stunde
  my $pvrlvdsav = HistoryVal  ($name, $day, $hod, 'pvrlvd',       1);
  my $plantdera = HistoryVal  ($name, $day, $hod, 'plantderated', 0); 
  $percdev      = sprintf "%.1f", abs (($pvapifc - $ethishoursum) / $ethishoursum * 100) if($ethishoursum);  # akt. prozentuale Abweicheichung zw. FC und real
  
  $valid = 0  if($aln == 0);
  $valid = 0  if(!$pvrlvdsav);
  $valid = 0  if($plantdera);
  $valid = 1  if(!$pvrlvdsav && $percdev <= 10);                                              # pvrl dennoch als valide ansehen wenn hinreichend kleine fc-real Differenz -> was nur kurze Abregelung / Lernunterbrechnung
  
  debugLog ($paref, 'collectData|collectData_long', "currently saved 'pvrlvd' value: $pvrlvdsav");
  debugLog ($paref, 'collectData|collectData_long', "current percentage pvrl/pvapifc deviation of hod $hod: $percdev % -> pvrlvd: $valid");
  
  writeToHistory ( { paref => $paref, key => 'pvrl', val => $ethishoursum, hour => $hod, valid => $valid } );    # valid=1: beim Learning berücksichtigen, 0: nicht

return;
}

################################################################
#    Ermittlung und Speicherung des Anlagenabregelungsstatus
################################################################
sub __handleReductionState {
  my $paref = shift;
  my $name  = $paref->{name};
  my $day   = $paref->{day};
  my $chour = $paref->{chour};
  my $t     = $paref->{t};                                         

  delete $data{$name}{current}{reductionPlantState};
  
  my ($rdcstate, $info, $err) = isReductionState ($name);
  
  if ($err) {
      Log3 ($name, 1, "$name - ERROR - $err");
      return;
  }

  debugLog ($paref, 'collectData|collectData_long', "State of Plant derating: $rdcstate, info: $info");
  
  if ($info ne 'reductionState not set') {
      my $hod = sprintf "%02d", ($chour + 1);
      my $pd  = HistoryVal ($name, $day, $hod, 'plantderated', 0);                                # evtl. schon gespeicherte Abregelungszeitpunkt
      
      if (!$pd && $rdcstate) {
          writeToHistory ( { paref => $paref, key => 'plantderated', val => $t, hour => $hod } ); 
      }  
      
      $data{$name}{current}{reductionPlantState} = $rdcstate;
  }

return;
}

################################################################
#  Strahlungsvorhersage Werte aus solcastapi-Hash
#  übertragen und PV Vorhersage berechnen / in Nexthours
#  speichern
################################################################
sub _transferAPIRadiationValues {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};                                                                     # Epoche Zeit
  my $lang  = $paref->{lang};
  my $chour = $paref->{chour};
  my $date  = $paref->{date};
  my $hash  = $defs{$name};

  return if(!keys %{$data{$name}{solcastapi}});

  my @strings = sort keys %{$data{$name}{strings}};
  return if(!@strings);

  my $invcapsum   = 0;
  my ($acu, $aln) = isAutoCorrUsed ($name);
  my $dbmsg       = '';

  for my $in (keys %{$data{$name}{inverters}}) {
      $invcapsum += InverterVal ($name, $in, 'invertercap', 0);                                            # Limit Leistungssumme aller Inverters
  }

  for my $num (0..MAXNEXTHOURS) {
      my ($fd, $fh)        = calcDayHourMove ($chour, $num);
      last if($fd > MAXNEXTDAYS);
      
      my $fh1              = $fh + 1;
      my $wantts           = (timestringToTimestamp ($date.' '.$chour.':00:00')) + ($num * 3600);
      my $wantdt           = (timestampToTimestring ($wantts, $lang))[1];
      my $nhtstr           = 'NextHour'.(sprintf "%02d", $num);
      my ($wtday, $wthour) = $wantdt =~ /(\d{2})\s(\d{2}):/xs;
      my $hod              = sprintf "%02d", int $wthour + 1;                                              # Stunde des Tages
      my $rad1h            = RadiationAPIVal ($name, '?All', $wantdt, 'Rad1h', undef);    
      
      $paref->{wantdt} = $wantdt;
      $paref->{wantts} = $wantts;
      $paref->{wtday}  = $wtday;
      $paref->{hod}    = $hod;
      $paref->{nhtstr} = $nhtstr;
      $paref->{num}    = $num;
      $paref->{fh1}    = $fh1;
      $paref->{fd}     = $fd;

      $data{$name}{nexthours}{$nhtstr}{starttime} = $wantdt;
      $data{$name}{nexthours}{$nhtstr}{day}       = $wtday;
      $data{$name}{nexthours}{$nhtstr}{hourofday} = $hod;
      $data{$name}{nexthours}{$nhtstr}{today}     = $fd == 0 ? 1 : 0;
      $data{$name}{nexthours}{$nhtstr}{rad1h}     = $rad1h;

      my ($sunalt, $sunaz);

      if ($fd == 0) {                                                                                      # V 1.49.4 für den aktuellen Tag
          $sunalt = HistoryVal ($name, $wtday, $hod, 'sunalt', undef);
          $sunaz  = HistoryVal ($name, $wtday, $hod, 'sunaz',  undef);

          if (!defined $sunalt || !defined $sunaz) {
              __calcSunPosition ($paref);
              $sunalt = HistoryVal ($name, $wtday, $hod, 'sunalt', undef);
              $sunaz  = HistoryVal ($name, $wtday, $hod, 'sunaz',  undef);
          }
      }

      if (defined $sunalt && defined $sunaz) {
          $data{$name}{nexthours}{$nhtstr}{sunalt} = $sunalt;
          $data{$name}{nexthours}{$nhtstr}{sunaz}  = $sunaz;
      }
      else {
          __calcSunPosition ($paref);
          $sunalt = NexthoursVal ($name, $nhtstr, 'sunalt', 0);
          $sunaz  = NexthoursVal ($name, $nhtstr, 'sunaz',  0);
      }

      $paref->{sabin}            = sunalt2bin ($sunalt);
      my ($pvapifc, $pvapifcraw) = __calcPVestimates ($paref);                         # API Wert mit Korrekturfaktor und ohne KF ermitteln
      my ($msg, $pvaifc)         = aiGetResult ($paref);                               # KI Entscheidungen abfragen

      delete $paref->{fd};
      delete $paref->{fh1};
      delete $paref->{num};
      delete $paref->{nhtstr};
      delete $paref->{hod};
      delete $paref->{wtday};
      delete $paref->{wantdt};
      delete $paref->{wantts};
      delete $paref->{sabin};

      my $useai = 0;
      my $pvfc;

      if ($msg eq 'accurate') {                                                                         # KI Treffer
          if ($invcapsum && $pvaifc > $invcapsum) {
              $pvaifc = $invcapsum;                                                                     # PV AI Vorhersage auf Summe aller WR Kapazität begrenzen

              debugLog ($paref, "radiationProcess", "PV AI forecast start time $wantdt limited to $invcapsum Wh due to inverter capacity summary");
          }

          my $airn  = CircularVal ($name, 99, 'aiRulesNumber', 0) / CurrentVal ($name, 'aiTreesPV', AINUMTREES);
          my $aivar = 0;
          $aivar    = sprintf "%.0f", (100 * $pvaifc / $pvapifc) if($pvapifc);                          # Übereinstimmungsgrad KI Forecast zu API Forecast in %

          if ($airn >= AIACCTRNMIN || ($aivar >= AIACCLOWLIM && $aivar <= AIACCUPLIM)) {
              $data{$name}{nexthours}{$nhtstr}{aihit} = 1;
              $useai = 1;

              if ($acu =~ /api_ai/xs) {
                  $pvfc  = $pvapifc ? (sprintf "%.0f", ($pvaifc + $pvapifc) / 2) : $pvaifc;             # Durchschnitt AI und API verwenden
                  $dbmsg = 'average of accurate AI & API result used';
              }
              else {
                  $pvfc  = $pvaifc;
                  $dbmsg = 'accurate result used';
              }

              debugLog ($paref, 'aiData', qq{AI Hit - $dbmsg -> aiRulesNum: $airn, variance: $aivar, hod: $hod, Rad1h: $rad1h, pvfc: $pvfc Wh});
          }

      }
      else {
          debugLog ($paref, 'aiData', $msg);
      }

      if ($useai) {
          $data{$name}{nexthours}{$nhtstr}{pvaifc} = $pvaifc;                                  # durch AI gelieferte PV Forecast
      }
      else {
          delete $data{$name}{nexthours}{$nhtstr}{pvaifc};
          $data{$name}{nexthours}{$nhtstr}{aihit} = 0;
          $pvfc = $pvapifc;

          debugLog ($paref, 'aiData', "use PV from API (no AI or AI result tolerance overflow) -> hod: $hod, Rad1h: ".(defined $rad1h ? $rad1h : '-').", pvfc: $pvfc Wh");
      }

      $data{$name}{nexthours}{$nhtstr}{pvapifc}    = $pvapifc;                                 # durch API gelieferte PV Forecast mit Korrekturfaktor
      $data{$name}{nexthours}{$nhtstr}{pvapifcraw} = $pvapifcraw;                              # durch API gelieferte PV Forecast Raw
      $data{$name}{nexthours}{$nhtstr}{pvfc}       = $pvfc;                                    # resultierende PV Forecast zuweisen

      my $hh1 = sprintf "%02d", $fh1;
      
      if ($num < 23 && $fh < 24) {                                                             # Ringspeicher PV forecast Forum: https://forum.fhem.de/index.php/topic,117864.msg1133350.html#msg1133350
          $data{$name}{circular}{$hh1}{pvapifc}    = NexthoursVal ($name, $nhtstr, 'pvapifc',    undef);
          $data{$name}{circular}{$hh1}{pvapifcraw} = NexthoursVal ($name, $nhtstr, 'pvapifcraw', undef);
          $data{$name}{circular}{$hh1}{pvaifc}     = NexthoursVal ($name, $nhtstr, 'pvaifc',     undef);
          $data{$name}{circular}{$hh1}{aihit}      = NexthoursVal ($name, $nhtstr, 'aihit',          0);
          $data{$name}{circular}{$hh1}{pvfc}       = $pvfc;
      }

      if ($fd == 0 && int $pvfc > 0) {                                                         # Vorhersagedaten des aktuellen Tages zum manuellen Vergleich in Reading speichern
          storeReading ('Today_Hour'.$hh1.'_PVforecast', "$pvfc Wh");
      }

      if ($fd == 0 && $fh1) {
          writeToHistory ( { paref => $paref, key => 'pvapifcraw', val => $pvapifcraw, hour => $fh1 } );
          writeToHistory ( { paref => $paref, key => 'pvfc',       val => $pvfc,       hour => $fh1 } );
          writeToHistory ( { paref => $paref, key => 'radiation',  val => $rad1h,      hour => $fh1 } );
      }
  }

  storeReading ('.lastupdateForecastValues', $t);                                              # Statusreading letzter update

return;
}

################################################################
#    Ermittlung der Sonnenpositionen
#    Az,Alt = Azimuth und Höhe (in Dezimalgrad) des Körpers
#             über dem Horizont
################################################################
sub __calcSunPosition {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $type   = $paref->{type};
  my $t      = $paref->{t};                                                                                # Epoche Zeit
  my $chour  = $paref->{chour};
  my $wtday  = $paref->{wtday};
  my $num    = $paref->{num};
  my $nhtstr = $paref->{nhtstr};
  my $hash   = $defs{$name};

  my ($fd, $fh)          = calcDayHourMove ($chour, $num);
  my $tstr               = (timestampToTimestring ($t + ($num * 3600)))[3];
  my ($date, $h, $m, $s) = split /[ :]/, $tstr;
  $tstr                  = $date.' '.$h.':30:00';

  my ($az, $alt);

  eval {
      $az  = sprintf "%.0f", FHEM::Astro::Get (undef, 'global', 'text', 'SunAz',  $tstr);             # statt Astro_Get geht auch FHEM::Astro::Get
      $alt = sprintf "%.0f", FHEM::Astro::Get (undef, 'global', 'text', 'SunAlt', $tstr);
  };

  if ($@) {
      Log3 ($name, 1, "$name - ERROR - $@");
      return;
  }

  my $hodn = sprintf "%02d", $h + 1;

  $data{$name}{nexthours}{$nhtstr}{sunaz}  = $az;
  $data{$name}{nexthours}{$nhtstr}{sunalt} = $alt;

  debugLog ($paref, 'collectData_long', "Sun position: day: $wtday, hod: $hodn, $tstr, azimuth: $az, altitude: $alt");

  if ($fd == 0 && $hodn) {                                                                            # Sun Position für aktuellen Tag in pvHistory speichern
      writeToHistory ( { paref => $paref, key => 'sunaz',  val => $az,  hour => $hodn } );
      writeToHistory ( { paref => $paref, key => 'sunalt', val => $alt, hour => $hodn } );
  }

return;
}

#########################################################################
#  API Erzeugungsprognose mit gewählter Autokorrekturmethode anpassen
#########################################################################
sub __calcPVestimates {
  my $paref   = shift;
  my $name    = $paref->{name};
  my $wantdt  = $paref->{wantdt};
  my $hod     = $paref->{hod};
  my $fd      = $paref->{fd};
  my $num     = $paref->{num};
  my $debug   = $paref->{debug};

  my $reld        = $fd == 0 ? "today" : $fd == 1 ? "tomorrow" : "unknown";
  my $rr1c        = NexthoursVal   ($name, "NextHour".sprintf ("%02d",$num), "rr1c",           0);    # Gesamtniederschlag während der letzten Stunde kg/m2
  my $wcc         = NexthoursVal   ($name, "NextHour".sprintf ("%02d",$num), "wcc",            0);    # effektive Wolkendecke nächste Stunde X
  my $temp        = NexthoursVal   ($name, "NextHour".sprintf ("%02d",$num), "temp", TEMPBASEDEF);    # vorhergesagte Temperatur Stunde X
  my ($acu, $aln) = isAutoCorrUsed ($name);

  $paref->{wcc}  = $wcc;
  my ($hc, $hq)  = ___readCandQ ($paref);                                                             # liest den anzuwendenden Korrekturfaktor
  delete $paref->{wcc};

  my ($lh,$sq,$peakloss, $modtemp);
  my $pvsum    = 0;
  my $peaksum  = 0;
  my $pvsumraw = 0;
  my %sum;

  for my $string (sort keys %{$data{$name}{strings}}) {
      my $peak = StringVal ($name, $string, 'peak', 0);                                               # String Peak (kWp)

      if ($acu =~ /on_complex/xs) {
          $paref->{peak} = $peak;
          $paref->{wcc}  = $wcc;
          $paref->{temp} = $temp;

          ($peakloss, $modtemp) = ___calcPeaklossByTemp ($paref);                                     # Reduktion Peakleistung durch Temperaturkoeffizienten der Module (vorzeichengehaftet)
          $peak                += $peakloss;

          delete $paref->{peak};
          delete $paref->{wcc};
          delete $paref->{temp};
      }

      $peak    *= 1000;
      my $pvest = RadiationAPIVal ($name, $string, $wantdt, 'pv_estimate50', 0);
      my $pv    = sprintf "%.1f", ($pvest * $hc);                                                     # Korrekturfaktor anwenden

      for my $in (keys %{$data{$name}{inverters}}) {
          my $istrings = InverterVal ($name, $in, 'istrings', 'all');                                 # dem Inverter zugeordnete Strings

          if ($istrings eq 'all' || grep /^$string$/, (split ',', $istrings)) {
              $sum{$in}{pvinvsum} += $pv;
              $sum{$in}{pvrawsum} += $pvest;                                                          # PV Prognose ohne Faktorenanwendung
              $sum{$in}{string}    = defined $sum{$in}{string} ? $sum{$in}{string}.','.$string : $string;
          }
      }

      if ($debug =~ /radiationProcess/xs) {
          $lh = {                                                                                     # Log-Hash zur Ausgabe
              "String Peak"                    => $peak. " W",
              "Estimated PV generation (raw)"  => $pvest." Wh",
              "Estimated PV generation (calc)" => $pv.   " Wh",
              "PV correction factor"           => $hc,
              "PV correction quality"          => $hq,
          };

          if ($acu =~ /on_complex/xs) {
              $lh->{"Module Temp (calculated)"}                 = $modtemp." C";
              $lh->{"Win(+)/Loss(-) String Peak Power by Temp"} = $peakloss." kWp";
          }

          $sq = q{};
          for my $idx (sort keys %{$lh}) {
              $sq .= $idx." => ".$lh->{$idx}."\n";
          }

          Log3 ($name, 1, "$name DEBUG> PV API estimate for $reld Hour ".sprintf ("%02d", $hod)." string $string ->\n$sq");
      }

      $peaksum += $peak;
  }

  for my $ins (keys %sum) {
      my $cap      = InverterVal ($name, $ins, 'invertercap', 0);                                   # Max. Leistung des Inverters
      my $pvinvsum = $sum{$ins}{pvinvsum};
      my $pvrawsum = $sum{$ins}{pvrawsum};
      
      if ($pvrawsum > $cap) {
          $pvrawsum = $cap;
      }

      if ($pvinvsum > $cap) {
          $pvinvsum = $cap;                                                                         # betreffende Strings auf WR Kapazität begrenzen

          debugLog ($paref, "radiationProcess", "String(s) ".$sum{$ins}{string}." in total limited to $cap Wh due to inverter $ins capacity");
      }

      $pvsum    += $pvinvsum;
      $pvsumraw += $pvrawsum;                                                                       # PV Prognose ohne Faktorenanwendung
  }

  $data{$name}{current}{allstringspeak} = $peaksum;                                                 # temperaturbedingte Korrektur der installierten Peakleistung in W
  $pvsum                                = $peaksum if($peaksum && $pvsum > $peaksum);               # Vorhersage nicht größer als die Summe aller PV-Strings Peak
  $pvsum                                = sprintf "%.0f", $pvsum;
  $pvsumraw                             = $peaksum if($peaksum && $pvsumraw > $peaksum);
  $pvsumraw                             = sprintf "%.0f", $pvsumraw;

  if ($debug =~ /radiationProcess/xs) {
      $lh = {                                                                                        # Log-Hash zur Ausgabe
          "Starttime"                => $wantdt,
          "Forecasted temperature"   => $temp." C",
          "Cloudcover"               => $wcc,
          "Total Rain last hour"     => $rr1c." kg/m2",
          "PV Correction mode"       => ($acu ? $acu : 'no'),
          "PV generation forecast"   => $pvsum." Wh",
      };

      $sq = q{};

      for my $idx (sort keys %{$lh}) {
          $sq .= $idx." => ".$lh->{$idx}."\n";
      }

      Log3 ($name, 1, "$name DEBUG> PV API estimate for $reld Hour ".sprintf ("%02d", $hod)." summary: \n$sq");
  }

return ($pvsum, $pvsumraw);
}

######################################################################
#  Complex:
#  Liest bewölkungsabhängige Korrekturfaktor/Qualität aus pvCircular
#  und speichert die Werte im Nexthours / pvHistory Hash
#
#  Simple:
#  Liest Korrekturfaktor/Qualität aus pvCircular simple und
#  speichert die Werte im Nexthours / pvHistory Hash
######################################################################
sub ___readCandQ {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $num   = $paref->{num};
  my $hod   = $paref->{hod};                                     # Stunde des Tages
  my $fd    = $paref->{fd};
  my $wcc   = $paref->{wcc};
  my $sabin = $paref->{sabin};
  my $hash  = $defs{$name};

  my ($acu, $aln) = isAutoCorrUsed ($name);                                                           # Autokorrekturmodus
  my $sunalt      = NexthoursVal ($hash, "NextHour".sprintf("%02d",$num), 'sunalt', undef);           # Sun Altitude
  my $hcraw       = ReadingsNum  ($name, 'pvCorrectionFactor_'.$hod, 1.00);                           # Voreinstellung RAW-Korrekturfaktor (evtl. manuell gesetzt)
  my $cpcf        = ReadingsVal  ($name, 'pvCorrectionFactor_'.$hod,   '');                           # aktuelles pcf-Reading
  my $hq          = '-';                                                                              # keine Qualität definiert
  my $crang       = 'simple';
  my $hc;

  delete $data{$name}{nexthours}{'NextHour'.sprintf("%02d",$num)}{cloudrange};

  if ($acu =~ /on_complex/xs) {                                                                       # Autokorrektur complex soll genutzt werden
      $crang     = cloud2bin ($wcc);                                                                  # Range errechnen
      ($hc, $hq) = CircularSunCloudkorrVal ($hash, $hod, $sabin, $crang, undef);                      # Korrekturfaktor/Qualität der Stunde des Tages (complex)
      my $daref  = $data{$name}{circular}{$hod}{'pvrl_'.$sabin}{"$crang"};

      if (ref $daref eq 'ARRAY') {
          $data{$name}{nexthours}{'NextHour'.sprintf("%02d",$num)}{DaysInRange} = scalar (@{$daref}); # Anzahl Tage im selben Wetterbereich  speichern
      }

      $data{$name}{nexthours}{'NextHour'.sprintf("%02d",$num)}{cloudrange}  = $crang;
  }
  elsif ($acu =~ /on_simple/xs) {
      ($hc, $hq) = CircularSunCloudkorrVal ($hash, $hod, $sabin, 'simple', undef);                    # Korrekturfaktor/Qualität der Stunde des Tages (simple)
  }
  else {                                                                                              # keine Autokorrektur
      ($hc, $hq) = CircularSunCloudkorrVal ($hash, $hod, $sabin, 'simple', undef);                    # Korrekturfaktor/Qualität der Stunde des Tages (simple)
      $hc        = 1;
  }

  $hq //= '-';                                                                                        # keine Qualität definiert
  $hq   = sprintf "%.2f", $hq if(isNumeric ($hq));
  $hc //= $hcraw;                                                                                     # Korrekturfaktor Voreinstellung
  $hc   = 1 if(1 * $hc == 0);                                                                         # 0.0-Werte ignorieren (Schleifengefahr)
  $hc   = sprintf "%.2f", $hc;

  if ($cpcf =~ /manual\sfix/xs) {                                                                     # Voreinstellung pcf-Reading verwenden wenn 'manual fix'
      $hc = $hcraw;
      debugLog ($paref, 'pvCorrectionRead', "use 'manual fix' - fd: $fd, hod: $hod, corrf: $hc, quality: $hq");
  }
  else {
      my $flex = $cpcf =~ /manual\sflex/xs ? "use 'manual flex'" : 'read parameters';
      debugLog ($paref, 'pvCorrectionRead', "$flex - fd: $fd, hod: $hod, Sun Altitude Bin: $sabin, Cloud range: $crang, corrf: $hc, quality: $hq");
  }

  $data{$name}{nexthours}{'NextHour'.sprintf("%02d",$num)}{pvcorrf} = $hc."/".$hq;

  if ($fd == 0 && $hod) {
      writeToHistory ( { paref => $paref, key => 'pvcorrfactor', val => $hc.'/'.$hq, hour => $hod } );
  }

return ($hc, $hq);
}

###################################################################
# Zellen Leistungskorrektur Einfluss durch Wärmekoeffizienten
# berechnen
#
# Die Nominalleistung der Module wird bei 25 Grad
# Umgebungstemperatur und bei 1.000 Watt Sonneneinstrahlung
# gemessen.
# Steigt die Temperatur um 1 Grad Celsius sinkt die Modulleistung
# typisch um 0,4 Prozent. Solartellen können im Sommer 70°C heiß
# werden.
#
# Das würde für eine 10 kWp Photovoltaikanlage folgenden
# Leistungsverlust bedeuten:
#
#       Leistungsverlust = -0,4%/K * 45K * 10 kWp = 1,8 kWp
#
# https://www.enerix.de/photovoltaiklexikon/temperaturkoeffizient/
#
###################################################################
sub ___calcPeaklossByTemp {
  my $paref = shift;
  my $name  = $paref->{name};
  my $peak  = $paref->{peak} // return (0,0);
  my $wcc   = $paref->{wcc}  // return (0,0);                                               # vorhergesagte Wolkendecke Stunde X
  my $temp  = $paref->{temp} // return (0,0);                                               # vorhergesagte Temperatur Stunde X

  my $modtemp  = $temp + (TEMPMODINC * (1 - ($wcc/100)));                                   # kalkulierte Modultemperatur
  my $peakloss = sprintf "%.2f", TEMPCOEFFDEF * ($modtemp - TEMPBASEDEF) * $peak / 100;

return ($peakloss, $modtemp);
}

################################################################
#    den Maximalwert PV Vorhersage für Heute ermitteln
################################################################
sub _calcMaxEstimateToday {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $date  = $paref->{date};

  my $maxest = 0;
  my $maxtim = '-';

  for my $h (1..23) {
      my $pvfc = ReadingsNum ($name, "Today_Hour".sprintf("%02d",$h)."_PVforecast", 0);
      next if($pvfc <= $maxest);

      $maxtim = $date.' '.sprintf("%02d",$h-1).':00:00';
      $maxest = $pvfc;
  }

  return if(!$maxest);

  storeReading ('Today_MaxPVforecast',     $maxest.' Wh');
  storeReading ('Today_MaxPVforecastTime', $maxtim);

return;
}

################################################################
#    Werte anderer Erzeuger ermitteln und übertragen
################################################################
sub _transferProducerValues {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};                                                                    # aktuelle Unix-Zeit
  my $chour = $paref->{chour};
  my $day   = $paref->{day};

  my $hash  = $defs{$name};

  for my $pn (1..MAXPRODUCER) {
      $pn = sprintf "%02d", $pn;
      my ($err, $prdev, $h) = isDeviceValid ( { name => $name, obj => 'setupOtherProducer'.$pn, method => 'attr' } );
      next if($err);

      my $type = $paref->{type};

      my ($pcread, $pcunit) = split ":", $h->{pcurr};                                                         # Readingname/Unit für aktuelle Erzeugung
      my ($edread, $etunit) = split ":", $h->{etotal};                                                        # Readingname/Unit für Energie total (Erzeugung)

      next if(!$pcread || !$edread);

      my $pu = $pcunit =~ /^kW$/xi ? 1000 : 1;
      my $p  = ReadingsNum ($prdev, $pcread, 0) * $pu;                                                        # aktuelle Erzeugung (W)
      $p     = $p < 0 ? 0 : $p;

      my $etu    = $etunit =~ /^kWh$/xi ? 1000 : 1;
      my $etotal = ReadingsNum ($prdev, $edread, 0) * $etu;                                                   # Erzeugung total (Wh)

      my $nhour    = $chour + 1;
      my $histetot = HistoryVal ($hash, $day, sprintf("%02d",$nhour), 'etotalp'.$pn, 0);                      # etotal zu Beginn einer Stunde
      my $warn     = '';

      my ($ethishour, $etotsvd);

      if (!$histetot) {                                                                                       # etotal der aktuelle Stunde gesetzt ?
          writeToHistory ( { paref => $paref, key => 'etotalp'.$pn, val => $etotal, hour => $nhour } );

          $etotsvd   = ProducerVal ($hash, $pn, 'petotal', $etotal);
          $ethishour = int ($etotal - $etotsvd);
      }
      else {
          $ethishour = int ($etotal - $histetot);
      }

      $data{$name}{producers}{$pn}{pgeneration} = $p;
      $data{$name}{producers}{$pn}{petotal}     = $etotal;                                                # aktuellen etotal des WR speichern
      $data{$name}{producers}{$pn}{pname}       = $prdev;                                                 # Name des Producerdevices
      $data{$name}{producers}{$pn}{palias}      = AttrVal ($prdev, 'alias', $prdev);                      # Alias Producer
      $data{$name}{producers}{$pn}{picon}       = $h->{icon} if($h->{icon});                              # Icon des Producers
      $data{$name}{producers}{$pn}{pfeed}       = 'default';                                              # Eigenschaften der Energielieferung

      if ($ethishour < 0) {
          $ethishour = 0;
          my $vl     = 3;
          my $pre    = '- WARNING -';

          if ($paref->{debug} =~ /collectData/xs) {
              $vl  = 1;
              $pre = 'DEBUG> - WARNING -';
          }

          Log3 ($name, $vl, "$name $pre The Total Energy of Producer$pn '$prdev' is lower than the value saved before. This situation is unexpected and the Energy generated of current hour is set to '0'.");
          $warn = ' (WARNING $prdev invalid real produced energy occured - see Logfile)';
      }

      storeReading ('Current_PP_'.$pn, sprintf("%.1f", $p).' W');
      storeReading ('Today_Hour'.sprintf("%02d",$nhour).'_PPreal_'.$pn, $ethishour.' Wh'.$warn);

      $data{$name}{circular}{sprintf("%02d",$nhour)}{'pprl'.$pn} = $ethishour;                        # Ringspeicher P real

      writeToHistory ( { paref => $paref, key => 'pprl'.$pn, val => $ethishour, hour => $nhour } );

      debugLog ($paref, 'collectData|collectData_long', "collect Producer $pn data - device: $prdev =>");
      debugLog ($paref, 'collectData|collectData_long', "pcurr: $p W, etotal: $etotal Wh");
  }

return;
}

################################################################
#    Werte Meter Device ermitteln und übertragen
################################################################
sub _transferMeterValues {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};
  my $chour = $paref->{chour};

  my $hash              = $defs{$name};
  my ($err, $medev, $h) = isDeviceValid ( { name => $name, obj => 'setupMeterDev', method => 'attr' } );
  return if($err);

  my $type = $paref->{type};

  my ($gc, $gcunit) = split ":", $h->{gcon};                                                   # Readingname/Unit für aktuellen Netzbezug
  my ($gf, $gfunit) = split ":", $h->{gfeedin};                                                # Readingname/Unit für aktuelle Netzeinspeisung
  my ($gt, $ctunit) = split ":", $h->{contotal};                                               # Readingname/Unit für Bezug total
  my ($ft, $ftunit) = split ":", $h->{feedtotal};                                              # Readingname/Unit für Einspeisung total

  return if(!$gc || !$gf || !$gt || !$ft);

  my $nhour = $chour + 1;

  if ($h->{conprice}) {                                                                        # Bezugspreis (Arbeitspreis) pro kWh
      my @acp = split ":", $h->{conprice};

      if (scalar(@acp) == 3) {
          $data{$name}{current}{ePurchasePrice}    = ReadingsNum ($acp[0], $acp[1], 0);
          $data{$name}{current}{ePurchasePriceCcy} = $acp[2];
      }
      elsif (scalar(@acp) == 2) {
          if (isNumeric($acp[0])) {
              $data{$name}{current}{ePurchasePrice}    = $acp[0];
              $data{$name}{current}{ePurchasePriceCcy} = $acp[1];
          }
          else {
              $data{$name}{current}{ePurchasePrice}    = ReadingsNum ($medev, $acp[0], 0);
              $data{$name}{current}{ePurchasePriceCcy} = $acp[1];
          }
      }

      writeToHistory ( { paref => $paref,                                                      # Bezugspreis in pvHistory speichern
                         key   => 'conprice',
                         val   => CurrentVal ($hash, 'ePurchasePrice', 0),
                         hour  => $nhour
                       }
                     );
  }

  if ($h->{feedprice}) {                                                                       # Einspeisevergütung pro kWh
      my @afp = split ":", $h->{feedprice};

      if (scalar(@afp) == 3) {
          $data{$name}{current}{eFeedInTariff}    = ReadingsNum ($afp[0], $afp[1], 0);
          $data{$name}{current}{eFeedInTariffCcy} = $afp[2];
      }
      elsif (scalar(@afp) == 2) {
          if (isNumeric($afp[0])) {
              $data{$name}{current}{eFeedInTariff}    = $afp[0];
              $data{$name}{current}{eFeedInTariffCcy} = $afp[1];
          }
          else {
              $data{$name}{current}{eFeedInTariff}    = ReadingsNum ($medev, $afp[0], 0);
              $data{$name}{current}{eFeedInTariffCcy} = $afp[1];
          }
      }

      writeToHistory ( { paref => $paref,                                                      # Einspeisevergütung in pvHistory speichern
                         key   => 'feedprice',
                         val   => CurrentVal ($hash, 'eFeedInTariff', 0),
                         hour  => $nhour
                       }
                     );
  }

  $gfunit //= $gcunit;
  $gcunit //= $gfunit;

  my ($gco,$gfin);

  my $gcuf = $gcunit =~ /^kW$/xi ? 1000 : 1;
  my $gfuf = $gfunit =~ /^kW$/xi ? 1000 : 1;

  $gco  = ReadingsNum ($medev, $gc, 0) * $gcuf;                                                      # aktueller Bezug (W)
  $gfin = ReadingsNum ($medev, $gf, 0) * $gfuf;                                                      # aktuelle Einspeisung (W)

  my $params;

  if ($gc eq '-gfeedin') {                                                                           # Spezialfall gcon bei neg. gfeedin                                                                                      # Spezialfall: bei negativen gfeedin -> $gco = abs($gf), $gf = 0
      $params = {
          dev  => $medev,
          rdg  => $gf,
          rdgf => $gfuf
      };

      ($gfin, $gco) = substSpecialCases ($params);
  }

  if ($gf eq '-gcon') {                                                                              # Spezialfall gfeedin bei neg. gcon
      $params = {
          dev  => $medev,
          rdg  => $gc,
          rdgf => $gcuf
      };

      ($gco, $gfin) = substSpecialCases ($params);
  }

  my $ctuf    = $ctunit =~ /^kWh$/xi ? 1000 : 1;
  my $gctotal = ReadingsNum ($medev, $gt, 0) * $ctuf;                                                # Bezug total (Wh)

  my $ftuf    = $ftunit =~ /^kWh$/xi ? 1000 : 1;
  my $fitotal = ReadingsNum ($medev, $ft, 0) * $ftuf;                                                # Einspeisung total (Wh)

  $data{$name}{circular}{99}{gridcontotal} = $gctotal;                                               # Total Netzbezug speichern
  $data{$name}{circular}{99}{feedintotal}  = $fitotal;                                               # Total Feedin speichern
  $data{$name}{current}{gridconsumption}   = int $gco;                                               # Current grid consumption Forum: https://forum.fhem.de/index.php/topic,117864.msg1139251.html#msg1139251
  $data{$name}{current}{gridfeedin}        = int $gfin;                                              # Wert current grid Feed in

  debugLog ($paref, 'collectData|collectData_long', "collect Meter data - device: $medev =>");
  debugLog ($paref, 'collectData|collectData_long', "gcon: $gco W, gfeedin: $gfin W, contotal: $gctotal Wh, feedtotal: $fitotal Wh");


  ## Management aus dem Netz bezogener Energie
  ##############################################
  my $gcdaypast = 0;
  my $gfdaypast = 0;
  my $docon     = 0;

  for my $hour (0..int $chour) {                                                                         # alle bisherigen Erzeugungen des Tages summieren
      $gcdaypast += ReadingsNum ($name, "Today_Hour".sprintf("%02d",$hour)."_GridConsumption", 0);
      $gfdaypast += ReadingsNum ($name, "Today_Hour".sprintf("%02d",$hour)."_GridFeedIn",      0);
  }

  my $idgcon = CircularVal ($hash, 99, 'initdaygcon', undef);

  if (!$gctotal) {                                                                                      # Meter Reset!
      $data{$name}{circular}{99}{initdaygcon} = 0;
      Log3 ($name, 3, "$name - WARNING - '$medev' - the total energy drawn from grid was reset and is registered with >0<. Check Reading '$gt'");
  }
  elsif (!defined $idgcon) {                                                                            # Initial für den Tag noch nicht angelegt
      $data{$name}{circular}{99}{initdaygcon} = $gctotal - $gcdaypast - ReadingsNum ($name, "Today_Hour".sprintf("%02d",$chour+1)."_GridConsumption", 0);
  }
  elsif ($idgcon > $gctotal) {                                                                          # Tageszähler Meter zu spät zurückgesetzt
      $data{$name}{circular}{99}{initdaygcon} = 0;
      Log3 ($name, 3, "$name - WARNING - '$medev' - total Grid consumption '$gctotal' is lower than the day Init value '$idgcon'. The initialization for the day was performed again.");
  }
  elsif ($gcdaypast == 0) {                                                                             # Stundenberechnung auf Basis Totalwerte GridConsumtion
      if (defined $idgcon) {
          $docon = 1;
      }
      else {
          $data{$name}{circular}{99}{initdaygcon} = $gctotal;
      }
  }
  else {
      $docon = 1;
  }

  if ($docon) {
      my $gctotthishour = int ($gctotal - ($gcdaypast + CircularVal ($hash, 99, 'initdaygcon', 0)));

      if ($gctotthishour < 0) {
          $gctotthishour = 0;
      }

      storeReading ('Today_Hour'.sprintf("%02d",$nhour).'_GridConsumption', $gctotthishour.' Wh');
      $data{$name}{circular}{sprintf("%02d",$nhour)}{gcons} = $gctotthishour;                               # Hilfshash Wert Bezug (Wh) Forum: https://forum.fhem.de/index.php/topic,117864.msg1133350.html#msg1133350

      writeToHistory ( { paref => $paref, key => 'gcons', val => $gctotthishour, hour => $nhour } );

      debugLog ($paref, "saveData2Cache|collectData", "write to pvHistory - day: $paref->{day}, hod: $nhour, GridConsumption (gcons): $gctotthishour Wh");
  }

  ## Management der in das Netz eingespeister (nur vom Meter gemessene) Energie
  ###############################################################################
  my $dofeed = 0;
  my $idfin  = CircularVal ($hash, 99, 'initdayfeedin', undef);

  if (!$fitotal) {
      $data{$name}{circular}{99}{initdayfeedin} = 0;
      Log3 ($name, 3, "$name - WARNING - '$medev' - the total energy feed in to grid was reset and is registered with >0<.");
  }
  elsif ($gfdaypast == 0) {                                                                                 # Management der Stundenberechnung auf Basis Totalwerte GridFeedIn
      if (defined $idfin) {
          $dofeed = 1;
      }
      else {
          $data{$name}{circular}{99}{initdayfeedin} = $fitotal;
      }
  }
  elsif (!defined $idfin) {
      $data{$name}{circular}{99}{initdayfeedin} = $fitotal - $gfdaypast - ReadingsNum ($name, 'Today_Hour'.sprintf("%02d",$chour+1).'_GridFeedIn', 0);
  }
  else {
      $dofeed = 1;
  }

  if ($dofeed) {
      my $gftotthishour = int ($fitotal - ($gfdaypast + CircularVal ($hash, 99, 'initdayfeedin', 0)));

      if ($gftotthishour < 0) {
          $gftotthishour = 0;
      }

      storeReading ('Today_Hour'.sprintf("%02d",$nhour).'_GridFeedIn', $gftotthishour.' Wh');
      $data{$name}{circular}{sprintf("%02d",$nhour)}{gfeedin} = $gftotthishour;

      writeToHistory ( { paref => $paref, key => 'gfeedin', val => $gftotthishour, hour => $nhour } );
  }

return;
}

################################################################
#                    Batteriewerte sammeln
################################################################
sub _transferBatteryValues {
  my $paref = shift;
  my $name  = $paref->{name};
  my $chour = $paref->{chour};
  my $day   = $paref->{day};
  my $debug = $paref->{debug};

  my $hash    = $defs{$name};
  my $num     = 0;
  my $pbisum  = 0;
  my $pbosum  = 0;
  my $bcapsum = 0;
  my $nhour   = $chour + 1;
  my $socsum;
  my $socwhsum;

  delete $data{$name}{current}{batpowerinsum};
  delete $data{$name}{current}{batpoweroutsum};
  delete $data{$name}{current}{batcapsum};
  delete $data{$name}{current}{batwhtotal};

  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;

      my ($err, $badev, $h) = isDeviceValid ( { name => $name, obj => 'setupBatteryDev'.$bn, method => 'attr' } );
      next if($err);

      my $warnin  = '';
      my $warnout = '';
      my ($pin,$piunit)    = split ":", $h->{pin};                                                # Readingname/Unit für aktuelle Batterieladung
      my ($pou,$pounit)    = split ":", $h->{pout};                                               # Readingname/Unit für aktuelle Batterieentladung
      my ($bin,$binunit)   = split ":", $h->{intotal}  // "-:-";                                  # Readingname/Unit der total in die Batterie eingespeisten Energie (Zähler)
      my ($bout,$boutunit) = split ":", $h->{outtotal} // "-:-";                                  # Readingname/Unit der total aus der Batterie entnommenen Energie (Zähler)
      my $batchr           = $h->{charge} // '';                                                  # Readingname Ladezustand Batterie
      my $instcap          = $h->{cap};                                                           # numerischer Wert (Wh) oder Readingname installierte Batteriekapazität
      my $pinmax           = $h->{pinmax}     // INFINITE;                                        # max. mögliche Ladeleistung
      my $pinreduced       = $h->{pinreduced} // $pinmax;                                         # reduzierte Ladeleistung (z.B. bei Ladung aus dem Grid)
      my $poutmax          = $h->{poutmax}    // INFINITE;                                        # max. mögliche Entladeleistung 

      next if(!$pin || !$pou);

      $pounit   //= $piunit;
      $piunit   //= $pounit;
      $boutunit //= $binunit;
      $binunit  //= $boutunit;

      my $piuf    = $piunit   =~ /^kW$/xi  ? 1000 : 1;
      my $pouf    = $pounit   =~ /^kW$/xi  ? 1000 : 1;
      my $binuf   = $binunit  =~ /^kWh$/xi ? 1000 : 1;
      my $boutuf  = $boutunit =~ /^kWh$/xi ? 1000 : 1;

      my $pbo     = int (ReadingsNum ($badev, $pou, 0) * $pouf);                                 # aktuelle Batterieentladung (W)
      my $pbi     = int (ReadingsNum ($badev, $pin, 0) * $piuf);                                 # aktueller Batterieladung (W)
      my $btotout = ReadingsNum ($badev, $bout,     0) * $boutuf;                                # totale Batterieentladung (Wh)
      my $btotin  = ReadingsNum ($badev, $bin,      0) * $binuf;                                 # totale Batterieladung (Wh)
      my $soc     = ReadingsNum ($badev, $batchr,   0);

      my $show    = $h->{show}  // 0;                                                            # Batterie in Balkengrafik anzeigen
      my $label   = $h->{label} // 'none';                                                       # Batterie SoC-Beschriftung in Balkengrafik
      my $pos     = 'top';

      if ($show =~ /:/xs) {
          ($show, $pos) = split ':', $show;
      }

      if ($instcap) {
          if (!isNumeric ($instcap)) {                                                           # wenn $instcap Reading Wert abfragen
              my ($bcapr,$bcapunit) = split ':', $instcap;
              $bcapunit           //= 'Wh';
              $instcap              = ReadingsNum ($badev, $bcapr, 0);
              $instcap              = $instcap * ($bcapunit =~ /^kWh$/xi ? 1000 : 1);
          }

          $bcapsum += $instcap;                                                                  # Summe installierte Bat Kapazität
          $data{$name}{batteries}{$bn}{binstcap} = $instcap;                                     # installierte Batterie Kapazität
      }
      else {
          delete $data{$name}{batteries}{$bn}{binstcap};
      }

      if ($debug =~ /collectData/x) {
          Log3 ($name, 1, "$name DEBUG> collect Battery Readings data: device=$badev =>");
          Log3 ($name, 1, "$name DEBUG> pin: $pbi W, pout: $pbo W, totalin: $btotin Wh, totalout: $btotout Wh, soc: $soc");
      }

      my $params;

      if ($pin eq "-pout") {                                                                       # Spezialfall pin bei neg. pout
          $params = {
              dev  => $badev,
              rdg  => $pou,
              rdgf => $pouf
          };

          ($pbo,$pbi) = substSpecialCases ($params);

          if ($debug =~ /collectData/x) {
              Log3 ($name, 1, "$name DEBUG> Battery Power data after resolving the special case 'pin eq -pout' =>");
              Log3 ($name, 1, "$name DEBUG> pin: $pbi W, pout: $pbo W");
          }
      }

      if ($pou eq "-pin") {                                                                        # Spezialfall pout bei neg. pin
          $params = {
              dev  => $badev,
              rdg  => $pin,
              rdgf => $piuf
          };

          ($pbi,$pbo) = substSpecialCases ($params);

          if ($debug =~ /collectData/x) {
              Log3 ($name, 1, "$name DEBUG> Battery Power data after resolving the special case 'pou eq -pin' =>");
              Log3 ($name, 1, "$name DEBUG> pin: $pbi W, pout: $pbo W");
          }
      }

      # Batterielade, -entladeenergie in Circular speichern
      #######################################################
      if (!defined CircularVal ($name, 99, 'initdaybatintot'.$bn, undef)) {
          $data{$name}{circular}{99}{'initdaybatintot'.$bn} = $btotin;                                          # total Batterieladung zu Tagbeginn (Wh)
      }

      if (!defined CircularVal ($name, 99, 'initdaybatouttot'.$bn, undef)) {                                    # total Batterieentladung zu Tagbeginn (Wh)
          $data{$name}{circular}{99}{'initdaybatouttot'.$bn} = $btotout;
      }

      $data{$name}{circular}{99}{'batintot'.$bn}  = $btotin;                                                    # aktuell total Batterieladung (Wh)
      $data{$name}{circular}{99}{'batouttot'.$bn} = $btotout;                                                   # aktuell total Batterieentladung (Wh)

      # Batterieladung aktuelle Stunde in pvHistory speichern
      #########################################################
      my $histbatintot = HistoryVal ($name, $day, sprintf("%02d",$nhour), 'batintotal'.$bn, undef);             # totale Batterieladung zu Beginn einer Stunde
      my $batinthishour;

      if (!defined $histbatintot) {                                                                             # totale Batterieladung der aktuelle Stunde gesetzt?
          writeToHistory ( { paref => $paref, key => 'batintotal'.$bn, val => $btotin, hour => $nhour } );
          $batinthishour = 0;
      }
      else {
          $batinthishour = int ($btotin - $histbatintot);
      }

      if ($batinthishour < 0) {
          $batinthishour = 0;
          my $vl         = 3;
          my $pre        = '- WARNING -';

          if ($debug =~ /collectData/xs) {
              $vl  = 1;
              $pre = 'DEBUG> - WARNING -';
          }

          Log3 ($name, $vl, "$name $pre The BatIn Energy of Battery '$badev' is lower than the value saved before. This situation is unexpected and the Energy generated of current hour of this Battery is set to '0'.");
          $warnin = ' (WARNING invalid BatIn Energy occured - see Logfile)';
      }

      $data{$name}{circular}{sprintf("%02d",$nhour)}{'batin'.$bn} = $batinthishour;                            # Ringspeicher Battery In Forum: https://forum.fhem.de/index.php/topic,117864.msg1133350.html#msg1133350

      writeToHistory ( { paref => $paref, key => 'batinthishour'.$bn, val => $batinthishour, hour => $nhour } );

      # Batterieentladung aktuelle Stunde in pvHistory speichern
      ############################################################
      my $histbatouttot = HistoryVal ($name, $day, sprintf("%02d",$nhour), 'batouttotal'.$bn, undef);          # totale Betterieladung zu Beginn einer Stunde
      my $batoutthishour;

      if (!defined $histbatouttot) {                                                                           # totale Betterieladung der aktuelle Stunde gesetzt?
          writeToHistory ( { paref => $paref, key => 'batouttotal'.$bn, val => $btotout, hour => $nhour } );
          $batoutthishour = 0;
      }
      else {
          $batoutthishour = int ($btotout - $histbatouttot);
      }

      if ($batoutthishour < 0) {
          $batoutthishour = 0;
          my $vl          = 3;
          my $pre         = '- WARNING -';

          if ($debug =~ /collectData/xs) {
              $vl  = 1;
              $pre = 'DEBUG> - WARNING -';
          }

          Log3 ($name, $vl, "$name $pre The BatOut Energy of Battery '$badev' is lower than the value saved before. This situation is unexpected and the Energy generated of current hour of this Battery is set to '0'.");
          $warnout = ' (WARNING invalid BatOut Energy occured - see Logfile)';
      }

      $data{$name}{circular}{sprintf("%02d",$nhour)}{'batout'.$bn} = $batoutthishour;                          # Ringspeicher Battery In Forum: https://forum.fhem.de/index.php/topic,117864.msg1133350.html#msg1133350

      writeToHistory ( { paref => $paref, key => 'batoutthishour'.$bn, val => $batoutthishour, hour => $nhour } );

      # täglichen maximalen SOC in pvHistory speichern
      ##################################################
      my $batmaxsoc = HistoryVal ($name, $day, 99, 'batmaxsoc'.$bn, 0);                                        # gespeicherter max. SOC des Tages

      if ($soc >= $batmaxsoc) {
          writeToHistory ( { paref => $paref, key => 'batmaxsoc'.$bn, val => $soc, hour => 99 } );
      }

      # aktuellen SOC in pvHistory speichern
      ########################################
      writeToHistory ( { paref => $paref, key => 'batsoc'.$bn, val => $soc, hour => $nhour } );

      storeReading ('Today_Hour'.sprintf("%02d",$nhour).'_BatIn_'. $bn, $batinthishour. ' Wh'.$warnin);
      storeReading ('Today_Hour'.sprintf("%02d",$nhour).'_BatOut_'.$bn, $batoutthishour.' Wh'.$warnout);
      storeReading ('Current_PowerBatIn_'. $bn, $pbi.' W');
      storeReading ('Current_PowerBatOut_'.$bn, $pbo.' W');
      storeReading ('Current_BatCharge_'.  $bn, $soc.' %');

      $data{$name}{batteries}{$bn}{bname}        = $badev;                                               # Batterie Devicename
      $data{$name}{batteries}{$bn}{balias}       = AttrVal ($badev, 'alias', $badev);                    # Alias Batterie Device
      $data{$name}{batteries}{$bn}{bpowerin}     = $pbi;                                                 # momentane Batterieladung
      $data{$name}{batteries}{$bn}{bpowerout}    = $pbo;                                                 # momentane Batterieentladung
      $data{$name}{batteries}{$bn}{bpinmax}      = $pinmax;                                              # max. mögliche Ladeleistung
      $data{$name}{batteries}{$bn}{bpinreduced}  = $pinreduced;                                          # # reduzierte Ladeleistung (z.B. bei Ladung aus dem Grid)
      $data{$name}{batteries}{$bn}{bpoutmax}     = $poutmax;                                             # max. mögliche Entladeleistung
      $data{$name}{batteries}{$bn}{bcharge}      = $soc;                                                 # Batterie SoC (%)
      $data{$name}{batteries}{$bn}{basynchron}   = $h->{asynchron} // 0;                                 # asynchroner Modus = X
      $data{$name}{batteries}{$bn}{bicon}        = $h->{icon} if($h->{icon});                            # Batterie Icon
      $data{$name}{batteries}{$bn}{bshowingraph} = $show;                                                # Batterie in Balkengrafik anzeigen    
      $data{$name}{batteries}{$bn}{bposingraph}  = $pos;                                                 # Anzeigeposition in Balkengrafik
      $data{$name}{batteries}{$bn}{blabel}       = $label;                                               # Batterie SoC-Beschriftung in Balkengrafik
      $data{$name}{batteries}{$bn}{bchargewh}    = BatteryVal ($name, $bn, 'binstcap', 0) * $soc / 100;  # Batterie SoC (Wh)
      $data{$name}{batteries}{$bn}{befficiency}  = $h->{efficiency};                                     # Speicherwirkungsgrad

      $num++;
      $socsum   += $soc;
      $socwhsum += BatteryVal ($name, $bn, 'binstcap', 0) * $soc / 100;                    # Batterie SoC in Wh

      $pbisum += $pbi;
      $pbosum += $pbo;
  }

  if ($num) {
      if ($bcapsum) {
          my $soctotal = sprintf "%.2f", ($socwhsum / $bcapsum * 100);                     # resultierender SoC (%) aller Batterien als "eine"
          $data{$name}{current}{batsoctotal} = $soctotal;
          push @{$data{$name}{current}{batsocslidereg}}, $soctotal;                        # Schieberegister average SOC aller Batterien
      }

      $socwhsum = sprintf "%.0f", $socwhsum;
      writeToHistory ( { paref => $paref, key => 'socwhsum', val => $socwhsum, hour => $nhour } );
      
      limitArray ($data{$name}{current}{batsocslidereg}, SLIDENUMMAX);

      $data{$name}{current}{batpowerinsum}   = $pbisum;                                    # summarische laufende Batterieladung
      $data{$name}{current}{batpoweroutsum}  = $pbosum;                                    # summarische laufende Batterieentladung
      $data{$name}{current}{batcapsum}       = $bcapsum;                                   # Summe installierte Batterie Kapazität in Wh
      $data{$name}{current}{batwhtotal}      = $socwhsum;                                  # Ladung in Wh über alle Batterien
      $data{$name}{current}{batwhdeficitsum} = $bcapsum - $socwhsum;                       # Fehlbetrag bis volle Ladung über alle Batterien 
  }

return;
}

################################################################
#          Batterie SOC optimalen Sollwert berechnen
################################################################
sub _batSocTarget {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};                                                                        # aktuelle Zeit
  my $debug = $paref->{debug};

  return if(!isBatteryUsed ($name));
  
  debugLog ($paref, 'batteryManagement', "######################### Start Battery Management DebugLog #########################");

  for my $bn (1..MAXBATTERIES) {
      $bn      = sprintf "%02d", $bn;
      my $cgbt = AttrVal ($name, 'ctrlBatSocManagement'.$bn, undef);
      next if(!$cgbt);

      my ($err, $badev, $h) = isDeviceValid ( { name => $name, obj => 'setupBatteryDev'.$bn, method => 'attr' } );
      next if($err);

      my $batinstcap = BatteryVal  ($name, $bn, 'binstcap', 0);                                   # installierte Batteriekapazität Wh
      
      if (!$batinstcap) {
          Log3 ($name, 1, "$name - WARNING - Attribute ctrlBatSocManagement${bn} is active, but required key 'cap' is not set. Go to Next...");
          next;
      }

      my $parsed    = __parseAttrBatSoc ($name, $cgbt);
      my $lowSoc    = $parsed->{lowSoc};
      my $upSoc     = $parsed->{upSoc};
      my $maxSoc    = $parsed->{maxSoc};
      my $stepSoc   = $parsed->{stepSoc};
      my $careCycle = $parsed->{careCycle};
      
      if (!$lowSoc || !$upSoc) {
          Log3 ($name, 1, "$name - WARNING - Attribute ctrlBatSocManagement${bn} is active, but required keys 'lowSoc' and 'upSoC' are not set. Go to Next...");
          next;          
      }
	  
	  if (!$stepSoc) {
		  debugLog ($paref, 'batteryManagement', "SoC Step1 Bat $bn - The SoC-Management is switched off. Battery_OptimumTargetSoC_$bn is set to lowSoC and Battery_ChargeRequest_$bn to '0'.");
		  
		  ## pvHistory/Readings schreiben
		  #################################
		  writeToHistory ( { paref => $paref, key => 'batsetsoc'.$bn, val => $lowSoc, hour => 99 } );
		  storeReading   ('Battery_OptimumTargetSoC_'.$bn, $lowSoc.' %');
		  storeReading   ('Battery_ChargeRequest_'.$bn, 0);

          next;		  
	  }
      
      my $oldd2care = CircularVal ($name, 99, 'days2care'.$bn,            0);
      my $ltsmsr    = CircularVal ($name, 99, 'lastTsMaxSocRchd'.$bn, undef);
      my $soc       = BatteryVal  ($name, $bn, 'bcharge',                 0);                   # aktuelle Ladung in %

      $paref->{batnmb}    = $bn;
      $paref->{careCycle} = $careCycle;

      __batSaveSocKeyFigures ($paref) if(!$ltsmsr || $soc >= $maxSoc || $soc >= MAXSOCDEF || $oldd2care < 0);
      
      delete $paref->{batnmb};
      delete $paref->{careCycle};

      my $chargereq  = 0;                                                                       # Ladeanforderung wenn SoC unter Minimum SoC gefallen ist
      my $target     = $lowSoc;
      my $yday       = strftime "%d", localtime($t - 86400);                                    # Vortag  (range 01 to 31)
      my $tdconsset  = CurrentVal ($name, 'tdConFcTillSunset',              0);                 # Verbrauch bis Sonnenuntergang Wh
      my $batymaxsoc = HistoryVal ($name, $yday, 99, 'batmaxsoc'.$bn,       0);                 # gespeicherter max. SOC des Vortages
      my $batysetsoc = HistoryVal ($name, $yday, 99, 'batsetsoc'.$bn, $lowSoc);                 # gespeicherter SOC Sollwert des Vortages

      $target = $batymaxsoc <  $maxSoc ? $batysetsoc + $stepSoc :
                $batymaxsoc >= $maxSoc ? $batysetsoc - $stepSoc :
                $batysetsoc;                                                                    # neuer Min SOC für den laufenden Tag

      ## erwartete PV ermitteln & Anteilsfaktor Bat anwenden
      ########################################################
      my $pvfctm   = ReadingsNum ($name, 'Tomorrow_PVforecast',            0);                  # PV Prognose morgen
      my $pvfctd   = ReadingsNum ($name, 'RestOfDayPVforecast',            0);                  # PV Prognose Rest heute
      my $pvexpraw = $pvfctm > $pvfctd ? $pvfctm : $pvfctd - $tdconsset;                        # erwartete (Rest) PV-Leistung des Tages
      $pvexpraw    = $pvexpraw > 0 ? $pvexpraw : 0;                                             # erwartete PV-Leistung inkl. Verbrauchsprognose bis Sonnenuntergang

      #my $sf       = __batCapShareFactor ($name, $bn);                                         # Anteilsfaktor der Batterie XX Kapazität an Gesamtkapazität
      my $sf       = __batDeficitShareFactor ($name, $bn);                                      # V 1.59.5 Anteilsfaktor der Batterie XX Ladebedarf an Gesamtladebedarf
	  my $pvexpect = $sf * $pvexpraw;

      if ($debug =~ /batteryManagement/xs) {
          Log3 ($name, 1, "$name DEBUG> SoC Step1 Bat $bn - basics -> Battery share factor of total required load: $sf");
          Log3 ($name, 1, "$name DEBUG> SoC Step1 Bat $bn - basics -> Expected energy for charging raw: $pvexpraw Wh");
          Log3 ($name, 1, "$name DEBUG> SoC Step1 Bat $bn - basics -> Expected energy for charging after application Share factor: $pvexpect Wh");
          Log3 ($name, 1, "$name DEBUG> SoC Step1 Bat $bn - compare with SoC history -> preliminary new Target: $target %");
      }

      ## Pflege-SoC (Soll SoC MAXSOCDEF bei $stepSoc % Steigerung p. Tag)
      #####################################################################
      my $sunset  = CurrentVal ($name, 'sunsetTodayTs',  $t);
      my $sunrise = CurrentVal ($name, 'sunriseTodayTs', $t); 
	  #my $delayts = $sunset - 5400;                                                            # Pflege-SoC/Erhöhung SoC erst ab 1,5h vor Sonnenuntergang berechnen/anwenden
      my $delayts = $sunrise + (($sunset - $sunrise) / 2);                                      # V 1.59.5 neues SoC-Ziel ab ca. Mittag berechnen/anwenden
	  my $nt      = (timestampToTimestring ($delayts, $paref->{lang}))[0];
	  my $la      = '';
      my $careSoc = $target;

      my $ntsmsc    = CircularVal ($name, 99, 'nextTsMaxSocChge'.$bn, $t);
      my $days2care = floor       (($ntsmsc - $t) / 86400);                                    # verbleibende Tage bis der Batterie Pflege-SoC (default 95%) erreicht sein soll
      my $docare    = 0;                                                                       # keine Zwangsanwendung care SoC

      my $whneed    = ($maxSoc / 100 * $batinstcap) - ($soc / 100 * $batinstcap);              # benötigte Ladeenergie in Wh bis $maxSoc
      $whneed       = sprintf "%.0f", max (0, $whneed);

      if ($t > $delayts || $pvexpect < $whneed || !$days2care) {
          $paref->{batnmb}    = $bn;
          $paref->{days2care} = $days2care;
          
          __batSaveSocKeyFigures ($paref);
          
          delete $paref->{days2care};
          delete $paref->{batnmb};

          $careSoc = $maxSoc - ($days2care * $stepSoc);                                        # Pflege-SoC um rechtzeitig den $maxsoc zu erreichen bei $stepSoc % Steigerung pro Tag
          $careSoc = $careSoc < $lowSoc ? $lowSoc : $careSoc;

          if ($careSoc >= $target) {
              $target = $careSoc;                                                              # resultierender Target-SoC unter Berücksichtigung $caresoc
              $docare = 1;                                                                     # Zwangsanwendung care SoC
          }

          $la = "calc care SoC -> docare: $docare, care SoC: $careSoc %, Remaining days until care SoC: $days2care, Target: $target %";
      }
      else {
          $la = "calc care SoC -> docare: $docare, care SoC: $careSoc %, use preliminary Target: $target % (new care SoC calc & act postponed to after $nt)";
      }

      debugLog ($paref, 'batteryManagement', "SoC Step2 Bat $bn - basics -> Energy expected for charging: $pvexpect Wh, need until maxsoc: $whneed Wh");
      debugLog ($paref, 'batteryManagement', "SoC Step2 Bat $bn - $la");

      ## Aufladewahrscheinlichkeit beachten
      #######################################
      my $csopt     = ReadingsNum ($name, 'Battery_OptimumTargetSoC_'.$bn, $lowSoc);           # aktuelles SoC Optimum
      my $cantarget = sprintf "%.0f", (100 - (100 / $batinstcap) * $pvexpect);                 # berechneter max. möglicher Minimum-SOC nach Berücksichtigung Ladewahrscheinlichkeit
      my $newtarget = sprintf "%.0f", ($cantarget < $target ? $cantarget : $target);           # Abgleich möglicher Minimum-SOC gg. berechneten Minimum-SOC

      debugLog ($paref, 'batteryManagement', "SoC Step3 Bat $bn - basics -> cantarget: $cantarget %, newtarget: $newtarget %");

      if ($newtarget > $careSoc) {
          $docare = 0;                                                                         # keine Zwangsanwendung care SoC
      }
      else {
          $newtarget = $careSoc;
      }

      my $logadd = '';

      if ($newtarget > $csopt && $t > $delayts) {                                              # Erhöhung des SoC (wird ab delayts angewendet)
          $target = $newtarget;
          $logadd = "(new target > $csopt % and Sunset has passed)";
      }
      elsif ($newtarget > $csopt && $t <= $delayts && !$docare) {                              # bisheriges Optimum bleibt vorerst
          $target = $csopt;
          $logadd = "(new target SoC is calculated & activated after $nt)";
      }
      elsif ($newtarget < $csopt) {                                                            # Targetminderung sofort umsetzen -> Freiplatz für Ladeprognose
          $target = $newtarget;
          $logadd = "(new target < current Target SoC $csopt)";
      }
      else {                                                                                   # bisheriges Optimum bleibt
          $target = $newtarget;
          $logadd = "(no change)";
      }

      debugLog ($paref, 'batteryManagement', "SoC Step3 Bat $bn - charging probability -> docare: $docare, Target: $target % ".$logadd);

      ## low/up-Grenzen beachten
      ############################
      $target = $docare           ? $target :
                $target > $upSoc  ? $upSoc  :
                $target < $lowSoc ? $lowSoc :
                $target;

      debugLog ($paref, 'batteryManagement', "SoC Step4 Bat $bn - basics -> docare: $docare, lowSoc: $lowSoc %, upSoc: $upSoc %");
      debugLog ($paref, 'batteryManagement', "SoC Step4 Bat $bn - observe low/up limits -> Target: $target %");

      ## auf $stepSoc Schritte anpassen (40,45,50,...)
      ##################################################
      my $flo = floor ($target / $stepSoc);
      my $rmn = $target - ($flo * $stepSoc);
      my $add = $rmn <= 2.5 ? 0 : $stepSoc;
      $target = ($flo * $stepSoc) + $add;

      debugLog ($paref, 'batteryManagement', "SoC Step5 Bat $bn - rounding the SoC to steps of ".$stepSoc." % -> Target: $target %");

      ## Ladeanforderung
      ####################
      if ($soc < $target) {
          $chargereq = 1;
      }

      debugLog ($paref, 'batteryManagement', "SoC Step6 Bat $bn - force charging request: ".
                        ($chargereq ? 'yes (battery charge is below minimum SoC)' : 'no (Battery is sufficiently charged)'));

      ## pvHistory/Readings schreiben
      #################################
      writeToHistory ( { paref => $paref, key => 'batsetsoc'.$bn, val => $target, hour => 99 } );
      storeReading   ('Battery_OptimumTargetSoC_'.$bn, $target.' %');
      storeReading   ('Battery_ChargeRequest_'.$bn,      $chargereq);
  }

return;
}

################################################################
#                Parse ctrlBatSocManagementXX
################################################################
sub __parseAttrBatSoc {
  my $name = shift;
  my $cgbt = shift // return;

  my ($lrMargin, $otpMargin);
  my ($pa, $ph)           = parseParams ($cgbt);
  ($lrMargin, $otpMargin) = split ':', $ph->{safetyMargin} if(defined $ph->{safetyMargin});

  my $parsed = {
      lowSoc       => $ph->{lowSoc},                                               
      upSoc        => $ph->{upSoC}, 
      maxSoc       => $ph->{maxSoC}    // MAXSOCDEF,                                      # optional (default: MAXSOCDEF)
      stepSoc      => $ph->{stepSoC}   // BATSOCCHGDAY,                                   # mögliche SoC-Änderung pro Tag
      careCycle    => $ph->{careCycle} // CARECYCLEDEF,                                   # Ladungszyklus (Maintenance) für maxSoC in Tagen     
      lcslot       => $ph->{lcSlot}, 
      loadAbort    => $ph->{loadAbort},
      loadStrategy => $ph->{loadStrategy},
      loadTarget   => $ph->{loadTarget},
      weightOwnUse => $ph->{weightOwnUse},      
      lrMargin     => $lrMargin,       
      otpMargin    => $otpMargin,
  };
  
return $parsed;
}

################################################################
#          Batterie Kennzahlen speichern
################################################################
sub __batSaveSocKeyFigures {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $bn        = $paref->{batnmb};                                                       # Batterienummer (01, 02, ...)
  my $t         = $paref->{t};                                                            # aktuelle Zeit
  my $careCycle = $paref->{careCycle};

  if (defined $paref->{days2care}) {
      $data{$name}{circular}{99}{'days2care'.$bn} = $paref->{days2care};                  # verbleibende Tage bis zum Pflege-SoC erreicht werden soll
      return;
  }

  $data{$name}{circular}{99}{'lastTsMaxSocRchd'.$bn} = $t;                                # Timestamp des letzten Erreichens von >= maxSoC
  $data{$name}{circular}{99}{'nextTsMaxSocChge'.$bn} = $t + (86400 * $careCycle);         # Timestamp bis zu dem die Batterie mindestens einmal maxSoC erreichen soll

return;
}

################################################################
#  Anteilsfaktor der Batterie XX Defizit an Gesamtdefizit
################################################################
sub __batDeficitShareFactor {
  my $name = shift;
  my $bn   = shift;                                                                           # Batterienummer

  my $csocwh          = BatteryVal ($name, $bn, 'bchargewh', 0);                              # aktuelle Ladung in Wh
  my $binstcap        = BatteryVal ($name, $bn, 'binstcap',  0);                              # installierte Batteriekapazität Wh
  my $bdeficit        = $binstcap - $csocwh;
  my $batwhdeficitsum = CurrentVal ($name, 'batwhdeficitsum', $binstcap);                     # Summe Ladungsdefizit

  my $sf = 0;
  $sf    = (100 * $bdeficit / $batwhdeficitsum) / 100 if($batwhdeficitsum);                   # Anteilsfaktor Defizit Batt XX an Gesamtdefizit

return sprintf "%.2f", $sf;
}

################################################################
#  Anteilsfaktor der Batterie XX Ladung an Gesamtladung
################################################################
sub __batLoadShareFactor {
  my $name = shift;
  my $bn   = shift;                                                                           # Batterienummer

  my $csocwh          = BatteryVal ($name, $bn, 'bchargewh',  0);                             # aktuelle Ladung in Wh
  my $batcapsum       = CurrentVal ($name, 'batcapsum',       1);                             # Summe installierte Batterie Kapazität
  my $batwhdeficitsum = CurrentVal ($name, 'batwhdeficitsum', 0);                             # Summe Ladungsdefizit
  my $loadsum         = max (1, $batcapsum - $batwhdeficitsum);

  my $sf = (100 * $csocwh / $loadsum) / 100;                                                  # Anteilsfaktor Ladung Batt XX an Gesamtladung

return sprintf "%.2f", $sf;
}

################################################################
#  Anteilsfaktor der Batterie XX Kapazität an Gesamtkapazität
################################################################
sub __batCapShareFactor {
  my $name = shift;
  my $bn   = shift;                                                          # Batterienummer

  my $binstcap  = BatteryVal ($name, $bn, 'binstcap', 1);                    # Kapazität der Batterie XX
  my $batcapsum = CurrentVal ($name, 'batcapsum', $binstcap);                # Summe installierte Batterie Kapazität

  my $sf = (100 * $binstcap / $batcapsum) / 100;                             # Anteilsfaktor der Batt XX Kapazität an Gesamtkapazität

return sprintf "%.2f", $sf;
}

################################################################
#       Erstellung Batterie Ladefreigabe + SoC Prognose
################################################################
sub _batChargeMgmt {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $chour  = $paref->{chour};
  my $minute = $paref->{minute};                                                                 # aktuelle Minute (00-59)
  my $t      = $paref->{t};

  return if(!isBatteryUsed ($name));

  my $hash      = $defs{$name};
  my $pvCu      = ReadingsNum ($name, 'Current_PV',               0);                            # aktuelle PV Erzeugung
  my $curcon    = ReadingsNum ($name, 'Current_Consumption',      0);                            # aktueller Verbrauch
  my $feedinlim = CurrentVal  ($name, 'feedinPowerLimit',  INFINITE);                            # Einspeiselimit in W
  my $bpin      = CurrentVal  ($name, 'batpowerinsum',            0);                            # aktuelle Batterie Ladeleistung (Summe über alle Batterien)
  my $gfeedin   = CurrentVal  ($name, 'gridfeedin',               0);                            # aktuelle Netzeinspeisung
  my $inplim    = 0;
  
  my $tdaysset  = CurrentVal ($name, 'sunsetTodayTs', $t);                                       # Timestamp Sonneuntergang am aktuellen Tag
  my $hs2sunset = sprintf "%.2f", (($tdaysset - $t) / 3600);                                     # Rest-Stunden bis Sonnenuntergang 
  
  my $hsurp  = {};                                                                               # Hashreferenz Überschuß
  my $hsoc   = {};                                                                               # Hashreferenz Prognose-SOC über alle Batterien
  my $trans  = {};                                                                               # Referenz Übertrags-Hash 
  my $values = {};                                                                               # Hashreferenz
  my $progsoc;
  
  ## Inverter Limits ermitteln
  ##############################
  for my $in (1..MAXINVERTER) {
      $in       = sprintf "%02d", $in;
      my $iname = InverterVal ($name, $in, 'iname', '');
      next if(!$iname);

      my $feed = InverterVal ($name, $in, 'ifeed', 'default');
      next if($feed eq 'grid');                                                                  # Inverter 'Grid' ausschließen

      my $icap  = InverterVal ($name, $in, 'invertercap',   0);
      my $limit = InverterVal ($name, $in, 'ilimit',      100);                                  # Wirkleistungsbegrenzung  (default keine Begrenzung)
      my $aplim = $icap * $limit / 100;
      $inplim  += $aplim;                                                                        # max. Leistung aller WR mit Berücksichtigung Wirkleistungsbegrenzung

      debugLog ($paref, 'batteryManagement', "ChargeMgmt - Inverter '$iname' cap: $icap W, Power limit: $limit % -> Pmax eff: $aplim W");
  }

  debugLog ($paref, 'batteryManagement', "ChargeMgmt - Summary Power limit of all Inverter (except feed 'grid'): $inplim W");
  debugLog ($paref, 'batteryManagement', "ChargeMgmt - The limit for grid feed-in is: $feedinlim W");

  ## Schleife über alle Batterien
  #################################  
  for my $bn (1..MAXBATTERIES) {                                                                 # für jede Batterie
      $bn = sprintf "%02d", $bn;
      
      my ($err, $badev, $h) = isDeviceValid ( { name => $name, obj => 'setupBatteryDev'.$bn, method => 'attr' } );
      next if($err);

      my $batinstcap = BatteryVal ($name, $bn, 'binstcap', 0);                                   # installierte Batteriekapazität Wh

      if (!$inplim || !$batinstcap) {
          debugLog ($paref, 'batteryManagement', "WARNING - The requirements for dynamic battery charge recommendation for Bat '$bn' are not met. Check key 'cap'. Go to Next.");
          next;
      }

      my $maxfctim    = timestringToTimestamp (ReadingsVal ($name, 'Today_MaxPVforecastTime', '')) // $t;
      my $rodpvfc     = ReadingsNum ($name, 'RestOfDayPVforecast',           0);                   # PV Prognose Rest des Tages
      my $tompvfc     = ReadingsNum ($name, 'Tomorrow_PVforecast',           0);                   # PV Prognose nächster Tag
      my $tomconfc    = ReadingsNum ($name, 'Tomorrow_ConsumptionForecast',  0);                   # Verbrauchsprognose nächster Tag
      my $batoptsoc   = ReadingsNum ($name, 'Battery_OptimumTargetSoC_'.$bn, 0);                   # aktueller optimierter SoC in %
      my $confcss     = CurrentVal  ($name, 'tdConFcTillSunset',             0);                   # Verbrauchsprognose bis Sonnenuntergang
      my $csoc        = BatteryVal  ($name, $bn, 'bcharge',                  0);                   # aktuelle Ladung in %
      my $csocwh      = BatteryVal  ($name, $bn, 'bchargewh',                0);                   # aktuelle Ladung in Wh
      my $bpinmax     = BatteryVal  ($name, $bn, 'bpinmax',           INFINITE);                   # max. mögliche Ladeleistung W
      my $bpoutmax    = BatteryVal  ($name, $bn, 'bpoutmax',          INFINITE);                   # max. mögliche Entladeleistung W
      my $bpowerin    = BatteryVal  ($name, $bn, 'bpowerin',          INFINITE);                   # aktuelle Ladeleistung W
      my $bpinreduced = BatteryVal  ($name, $bn, 'bpinreduced',              0);                   # Standardwert bei <=lowSoC -> Anforderungsladung vom Grid 
      my $befficiency = BatteryVal  ($name, $bn, 'befficiency', STOREFFDEF) / 100;                 # Speicherwirkungsgrad
      my $cgbt        = AttrVal     ($name, 'ctrlBatSocManagement'.$bn,  undef);
      #my $sf          = __batCapShareFactor     ($name, $bn);                                      # Anteilsfaktor der Batterie XX Kapazität an Gesamtkapazität
      my $sf          = __batDeficitShareFactor ($name, $bn);                                      # V 1.59.5 Anteilsfaktor Ladungsdefizit
      my $strategy    = 'loadRelease';                                                             # 'loadRelease', 'optPower', 'smartPower'
      my $wou         = 0;                                                                         # Gewichtung Prognose-Verbrauch als Anteil "Eigennutzung" (https://forum.fhem.de/index.php?msg=1348429)     
      my $lowSoc      = 0;
      my $loadAbort   = '';
      my $goalwh      = $batinstcap;                                                               # initiales Ladeziel (Wh)
      my $lrMargin    = SFTYMARGIN_50;
      my $otpMargin   = SFTYMARGIN_20;                                                               
      my $lcslot;
            
      if ($cgbt) {
          my $parsed = __parseAttrBatSoc ($name, $cgbt);
          $lowSoc    = $parsed->{lowSoc}       // 0;
          $lcslot    = $parsed->{lcslot};
          $loadAbort = $parsed->{loadAbort};
          $lrMargin  = $parsed->{lrMargin}     // $lrMargin;                                       # Sicherheitszuschlag LR (%)
          $otpMargin = $parsed->{otpMargin}    // $otpMargin;                                      # Sicherheitszuschlag OTP (%)
          $strategy  = $parsed->{loadStrategy} // $strategy;
          $wou       = $parsed->{weightOwnUse} // $wou;
          my $tgt    = $parsed->{loadTarget};                                                      # Ladeziel-SoC in %
          $tgt       = $batoptsoc if(defined $tgt && $tgt < $batoptsoc);                           # Wert Battery_OptimumTargetSoC_XX beachten
          $goalwh    = defined $tgt 
                       ? sprintf "%.0f", ___batSocPercentToWh ($batinstcap, $tgt) 
                       : $goalwh;                                                                  # Ladeziel-SoC in Wh
      }
      
      my $goalpercent = sprintf "%.0f", ___batSocWhToPercent ($batinstcap, $goalwh);               # Ladeziel in %

      ## generelle Ladeabbruchbedingung evaluieren
      ##############################################
      if ($loadAbort) {
          my ($abortSoc, $abortpin, $releaseSoC) = split ':', $loadAbort;                          # Ladeabbruch Forum: https://forum.fhem.de/index.php?msg=1342556      
          
          $releaseSoC //= $abortSoc;
          
          if ($csoc >= $abortSoc && $bpowerin <= $abortpin) {
              $data{$name}{batteries}{$bn}{bloadAbortCond} = 1;
          }
          elsif ($csoc < $releaseSoC) {
              $data{$name}{batteries}{$bn}{bloadAbortCond} = 0;
          }
      }
      else {
          delete $data{$name}{batteries}{$bn}{bloadAbortCond};
          readingsDelete ($hash, 'Battery_ChargeAbort_'.$bn);
      }
      
      my $labortCond  = BatteryVal ($name, $bn, 'bloadAbortCond', 0);                             # Ladeabbruchbedingung gesetzt 1 oder nicht 0                
      my $batoptsocwh = ___batSocPercentToWh ($batinstcap, $batoptsoc);                           # optimaler SoC in Wh
      my $lowSocwh    = ___batSocPercentToWh ($batinstcap, $lowSoc);                              # lowSoC in Wh
      my $socwh       = sprintf "%.0f", ___batSocPercentToWh ($batinstcap, $csoc);                # aktueller SoC in Wh
      
      my $whneed      = $goalwh - $socwh;
      
      ## Zeitfenster für aktives Lademanagement ermitteln
      #####################################################
      $lcslot             //= '00:00-23:59';
      my ($lcstart, $lcend) = split "-", $lcslot;
      
      # Debuglog
      ############
      if ($paref->{debug} =~ /batteryManagement/) {
		  Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - selected charging strategy: $strategy");
          Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - General load termination condition: $labortCond");
          Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - control time Slot - Slot start: $lcstart, Slot end: $lcend");
          Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - Battery efficiency used: ".($befficiency * 100)." %");
          Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - charging target: $goalpercent % / $goalwh Wh");
          #Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - Installed Battery capacity: $batinstcap Wh, Percentage of total capacity: ".(sprintf "%.1f", $sf*100)." %");
          Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - Percentage of the total amount of charging energy required: ".(sprintf "%.1f", $sf*100)." %");
		  Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - The PV generation, consumption and surplus listed below are based on the battery's share of the total amount of charging energy required!");
          Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - used safety margin: $lrMargin %");
          Log3 ($name, 1, "$name DEBUG> ChargeMgmt Bat $bn - weighted self-consumption: $wou %");
      }
      
      ## Auswertung für jede kommende Stunde
      ########################################
      for my $num (0..MAXNEXTHOURS) {
          my ($fd, $fh) = calcDayHourMove ($chour, $num);
          next if($fd > 2);

          my $nhr   = sprintf "%02d", $num;
          my $hod   = NexthoursVal ($name, 'NextHour'.$nhr, 'hourofday', undef);
          my $nhstt = NexthoursVal ($name, 'NextHour'.$nhr, 'starttime', undef);
          my $stt   = (split /[-:]/, $nhstt)[2];
          $stt      =~ s/\s/\//;
          
          next if(!defined ($hod) || !defined ($nhstt));
          
          my $today = NexthoursVal ($name, 'NextHour'.$nhr, 'today', 0);
          my $confc = NexthoursVal ($name, 'NextHour'.$nhr, 'confc', 0);
          my $pvfc  = NexthoursVal ($name, 'NextHour'.$nhr, 'pvfc',  0);
          
          if ($fd == 2 && $fh == 0) {
              $tompvfc  = CurrentVal ($name, 'dayAfterTomorrowPVfc',  0);                        # PV Prognose übernächster Tag
              $tomconfc = CurrentVal ($name, 'dayAfterTomorrowConfc', 0);                        # Verbrauchsprognose übernächster Tag
          }          
          
          ## Zeitfenster für aktives Lademanagement anwenden
          #####################################################
          my $lcintime = 1;
          
          my ($date)    = (split " ", $nhstt)[0];
          my $sttts     = timestringToTimestamp ($nhstt);
          my $lcstartts = timestringToTimestamp ("$date ${lcstart}:00");
          my $lcendts   = timestringToTimestamp ("$date ${lcend}:59");
          $lcintime     = $sttts >= $lcstartts && $sttts <= $lcendts ? 1 : 0;                    # 1 wenn innerhalb Time Slot -> Lademanagement freigegeben, sonst Batterie Ladung immer freigeben
          
          my $crel  = 0;                                                                         # Ladefreigabe 0 Ausgangswert
          my $spday = 0;

          ## Aufteilung Energie auf Batterie XX im Verhältnis aller Bat
          ###############################################################
          $pvfc     = sprintf "%.0f", ($sf * $pvfc);
          $confcss  = sprintf "%.0f", ($sf * $confcss);
          $confc    = sprintf "%.0f", ($sf * $confc);
          $rodpvfc  = sprintf "%.0f", ($sf * $rodpvfc);
          $tomconfc = sprintf "%.0f", ($sf * $tomconfc);
          $tompvfc  = sprintf "%.0f", ($sf * $tompvfc);

          ## PV-Überschuß und (Rest)Tagesüberschuß heute/morgen
          #######################################################    
          if ($today) {                                                                          # heutiger Tag
              $confcss  -= $confc;                                                               # Verbrauch bis Sonnenuntergang - Verbrauch Fc aktuelle Stunde
              $confcss   = 0 if($confcss < 0);
              $rodpvfc  -= $pvfc;
              $rodpvfc   = 0 if($rodpvfc < 0);
              $spday     = $rodpvfc - $confcss;                                                  # PV-Überschußprognose (Rest) heutiger Tag
          }
          else {                                                                                 # nächster Tag
              $tomconfc -= $confc;
              $tomconfc  = 0 if($tomconfc < 0);
              $tompvfc  -= $pvfc;
              $spday     = $tompvfc - $tomconfc;
          }

          $spday     = 0 if($spday < 0);                                                         # PV Überschuß Prognose bis Sonnenuntergang
          $confc    *= (100 - $wou) / 100 if($pvfc > 0);                                         # Gewichtung Prognose-Verbrauch als Anteil "Eigennutzung" (https://forum.fhem.de/index.php?msg=1348429)
          my $surpls = $pvfc - $confc;                                              
          
          ## Steuerung nach Ladefreigabe
          ################################
          if ( $whneed * (1 + ($lrMargin / 100)) >= $spday ) {$crel = 1}                         # Ladefreigabe wenn benötigte Ladeenergie >= Restüberschuß des Tages zzgl. Sicherheitsaufschlag
          if ( !$num && ($pvCu - $curcon) >= $inplim )       {$crel = 1}                         # Ladefreigabe wenn akt. PV Leistung - Abschläge >= WR-Leistungsbegrenzung
          if ( !$bpin && $gfeedin > $feedinlim )             {$crel = 1}                         # V 1.49.6 Ladefreigabe wenn akt. keine Bat-Ladung UND akt. Einspeisung > Einspeiselimit der Anlage
          if ( $bpin && ($gfeedin - $bpin) > $feedinlim )    {$crel = 1}                         # V 1.49.6 Ladefreigabe wenn akt. Bat-Ladung UND Eispeisung - Bat-Ladung > Einspeiselimit der Anlage
          if ( !$cgbt )                                      {$crel = 1}                         # Ladefreigabe wenn kein BatSoc-Management
          if ( !$lcintime )                                  {$crel = 1}                         # Ladefreigabe wenn nicht innerhalb Zeitslot für Ladesteuerung
          if ( $labortCond )                                 {$crel = 0}                         # keine Ladefreigabe bei genereller Abbruchbedingung 
          
          # Steuerhash für optimimierte Ladeleistung erstellen
          ######################################################
          my $surplswh = max (0, (sprintf "%.0f", $surpls));                                     # wichtig keine Nachkommastellen!
          
          if ($strategy =~ /(?:opt|smart)Power/xs || $strategy eq 'loadRelease' && $today) {     # bei loadRelease' nur den aktuellen Tag betrachten
              $hsurp->{$fd}{$hod}{nhr}               = $nhr;
              $hsurp->{$fd}{$hod}{speff}             = $surpls;                                  # effektiver PV Überschuß bzw. effektiver Verbrauch wenn < 0  
              $hsurp->{$fd}{$hod}{surplswh}          = $surplswh.'.'.$hod;                       # absoluter Überschuß in Wh der Stunde mit Sortierhilfe 
              $hsurp->{$fd}{$hod}{$bn}{spday}        = $spday;                                   # (Rest)PV-Überschuß am laufenden Tag
              $hsurp->{$fd}{$hod}{$bn}{initsocwh}    = $socwh;                                   # durch LR fortgeschriebener SoC
              $hsurp->{$fd}{$hod}{$bn}{batinstcap}   = $batinstcap;                              # installierte Batteriekapazität (Wh)
              $hsurp->{$fd}{$hod}{$bn}{goalwh}       = $goalwh;                                  # Ladeziel
              $hsurp->{$fd}{$hod}{$bn}{bpinmax}      = $bpinmax;                                 # max. mögliche Ladeleistung
              $hsurp->{$fd}{$hod}{$bn}{bpinreduced}  = $bpinreduced;                             # Standardwert bei <=lowSoC -> Anforderungsladung vom Grid
              $hsurp->{$fd}{$hod}{$bn}{bpoutmax}     = $bpoutmax;                                # max. mögliche Entladeleistung
              $hsurp->{$fd}{$hod}{$bn}{lowSocwh}     = $lowSocwh;                                # eingestellter lowSoC in Wh
              $hsurp->{$fd}{$hod}{$bn}{batoptsocwh}  = $batoptsocwh;                             # optimaler SoC in Wh
              $hsurp->{$fd}{$hod}{$bn}{csocwh}       = $csocwh;                                  # aktueller SoC in Wh
              $hsurp->{$fd}{$hod}{$bn}{otpMargin}    = $otpMargin;                               # Sicherheitszuschlag für Berechnungen
              $hsurp->{$fd}{$hod}{$bn}{lcintime}     = $lcintime;                                # Ladesteuerung "In Time" oder "nicht In Time"
              $hsurp->{$fd}{$hod}{$bn}{stt}          = $stt;                                     # Day/Time für Debuglog 
              $hsurp->{$fd}{$hod}{$bn}{strategy}     = $strategy;                                # Ladestrategie
              $hsurp->{$fd}{$hod}{$bn}{weightOwnUse} = $wou;                                     # Gewichtung Prognose-Verbrauch als Anteil "Eigennutzung" (https://forum.fhem.de/index.php?msg=1348429)
              $hsurp->{$fd}{$hod}{$bn}{befficiency}  = $befficiency;                             # Speicherwirkungsgrad
          }
          
          $surpls = $surpls / 60 * (60 - int $minute) if(!$num);                                 # aktuelle (Rest)-Stunde -> zeitgewichteter PV-Überschuß
          $surpls = sprintf "%.0f", $surpls;                                                     # wichtig keine Nachkommastellen!
          
          ## SOC-Prognose LR
          ####################                                                                      
          my $speff = $surpls;                                                                   # effektiver PV Überschuß bzw. effektiver Verbrauch wenn < 0                                                             
          
          $speff    = $speff > 0 ? ($speff >= $bpinmax   ? $bpinmax   : $speff) :
                      $speff < 0 ? ($speff <= -$bpoutmax ? -$bpoutmax : $speff) :
                      $speff;                                
        
          my $delta = $speff > 0 ? ($crel ? $speff * $befficiency : 0) :                         # PV Überschuß (d.h. Aufladung) nur einbeziehen wenn Ladefreigabe
                      $speff < 0 ? $speff / $befficiency               :                         # Verbrauch einbeziehen
                      0;

          $socwh += $delta;         
          $socwh  = ___batClampValue ($socwh, $lowSocwh, $batoptsocwh, $batinstcap);             # SoC begrenzen

          $socwh   = sprintf "%.0f", $socwh;                                                     # SoC Prognose in Wh
          $progsoc = sprintf "%.1f", ___batSocWhToPercent ($batinstcap, $socwh);                 # Prognose SoC in %
          
          ## Debuglog LR
          ################
          my $msg = "CurrSoc: $csoc %, SoCfc: $socwh Wh, whneed: $whneed, pvfc: $pvfc, rodpvfc: $rodpvfc, confcss: $confcss, SurpDay: $spday Wh, CurrPV: $pvCu W, CurrCons: $curcon W, Limit: $inplim W, inTime: ".($cgbt ? $lcintime : '-');

          if ($num) {
              $msg = "SoCfc: $progsoc % / $socwh Wh, whneed: $whneed, pvfc: $pvfc, rodpvfc: $rodpvfc, confcss: $confcss, SurpDay: $spday Wh, inTime: ".($cgbt ? $lcintime : '-');

              if (!$today) {
                  $msg = "SoCfc: $progsoc % / $socwh Wh, whneed: $whneed, pvfc: $pvfc, roTomPV: $tompvfc, roTomCON: $tomconfc, SurpDay: $spday Wh, inTime: ".($cgbt ? $lcintime : '-');
              }
          }
          
          debugLog ($paref, 'batteryManagement', "ChargeLR Bat $bn $stt - lr: $crel, $msg");

          ## Fortschreibung
          ###################
          $whneed = $goalwh - $socwh;
          
          ## Speicherung und Readings erstellen LR
          ##########################################
          $values = { hsoc       => $hsoc,
                      bn         => $bn,
                      nhr        => $nhr,
                      progsoc    => $progsoc,
                      socwh      => $socwh,
                      today      => $today,
                      hod        => $hod,
                      loopid     => 'LR',
                      strategy   => $strategy, 
                      crel       => $crel,
                      labortCond => $labortCond,
                      loadAbort  => $loadAbort,
                      cgbt       => $cgbt,
                      lcintime   => $lcintime,
                   };

          ___batChargeSaveResults ($paref, $values);
          
          $values = {};
      }
  }
  
  ## leistungsoptimierte (optPower/smartPower) Beladungssteuerung
  ################################################################# 
  for my $lfd (0..max (0, keys %{$hsurp})) {
      $paref->{hsurp} = $hsurp->{$lfd}; 
      
      my ($hopt, $otp) = __batChargeOptTargetPower ($paref, $lfd, $minute, $trans, $hs2sunset);
      
      delete $paref->{hsurp};
      
      ## Debuglog OTP
      #################
      if ($paref->{debug} =~ /batteryManagement/ && !$lfd) {
          Log3 ($name, 1, "$name DEBUG> ChargeOTP - The limit for grid feed-in is $feedinlim W");
      }
      
      ## Speicherung und Readings erstellen OTP
      ###########################################
      for my $shod (sort { $a <=> $b } keys %{$hopt}) {
          my $nhr       = $hopt->{$shod}{nhr};
          my @batteries = grep { !/^(?:fd|speff|surplswh|nhr)$/xs } keys %{$hopt->{24}};
          
          for my $bat (sort @batteries) {
              next if(!defined $hopt->{$shod}{$bat}{batinstcap});			  
              my $ssocwh = $hopt->{$shod}{$bat}{runwh} // '-';
              
              ## SOC-Prognose OTP
              #####################
              my $fcendwh = $hopt->{$shod}{$bat}{fcendwh} // 0;  
              $progsoc    = sprintf "%.1f", ___batSocWhToPercent ($hopt->{$shod}{$bat}{batinstcap}, $fcendwh);        # Prognose SoC in %
                        
              ## Speicherung und Readings erstellen OTP
              ##########################################
              $values = { hsoc     => $hsoc,
                          otp      => $otp,
                          bn       => $bat,
                          nhr      => $nhr,
                          progsoc  => $progsoc,
                          socwh    => $fcendwh,
                          hod      => $shod,
                          loopid   => 'OTP',
                          strategy => $hopt->{$shod}{$bat}{strategy},
                          crel     => $hopt->{$shod}{$bat}{loadrel},                                                  
                       };

              ___batChargeSaveResults ($paref, $values);
              
              ## Debuglog OTP
              #################
              if ($paref->{debug} =~ /batteryManagement/) {              
                  my $lcintime = $hopt->{$shod}{$bat}{lcintime};             
                  my $spls     = int $hopt->{$shod}{surplswh};
                  my $pneedmin = $hopt->{$shod}{$bat}{pneedmin};
                  my $ttt      = $hopt->{$shod}{$bat}{stt};
                  my $crel     = $hopt->{$shod}{$bat}{loadrel};           
                  
                  if ($nhr eq '00') {
                      $pneedmin        = $otp->{$bat}{target} // 0;
                      my $achievelog   = $hopt->{$shod}{$bat}{achievelog};
                      my $otpMargin    = $hopt->{$shod}{$bat}{otpMargin};
                      my $weightOwnUse = $hopt->{$shod}{$bat}{weightOwnUse};
                      Log3 ($name, 1, "$name DEBUG> ChargeOTP Bat $bat - used safety margin: $otpMargin %");
                      Log3 ($name, 1, "$name DEBUG> ChargeOTP Bat $bat - weighted self-consumption: $weightOwnUse %");
                      Log3 ($name, 1, "$name DEBUG> ChargeOTP Bat $bat - $achievelog");
                  }              
                  
                  Log3 ($name, 1, "$name DEBUG> ChargeOTP Bat $bat $ttt - hod: $shod / $nhr, lr/lc: $crel/$lcintime, SoC S/E: $ssocwh / $fcendwh Wh, Surplus: $spls Wh, OTP: $pneedmin W");
              }
          }
      }
  }

  # prognostizierten SOC über alle Batterien speichern
  ######################################################
  for my $nhr (keys %{$hsoc}) {
      if (defined $hsoc->{$nhr}{socprogwhsum}) {
          $data{$name}{nexthours}{'NextHour'.$nhr}{socprogwhsum} = $hsoc->{$nhr}{socprogwhsum};

          my $today = NexthoursVal ($name, 'NextHour'.$nhr, 'today',      0);
          my $hod   = NexthoursVal ($name, 'NextHour'.$nhr, 'hourofday', '');

          if ($today && $hod) {                                                                                  # heutiger Tag
              writeToHistory ( { paref => $paref, key => 'socprogwhsum', val => $hsoc->{$nhr}{socprogwhsum}, hour => $hod } );
          }
      }
  }

return;
}

################################################################
#      zusätzliche Readings NextHourXX_Bat_XX_ChargeForecast
#      erstellen
################################################################
sub __createNextHoursSFCReadings {
  my $paref   = shift;
  my $name    = $paref->{name};
  my $nhr     = $paref->{nhr};                # nächste Stunde
  my $bn      = $paref->{bn};                 # Batterienummer
  my $progsoc = $paref->{progsoc};            # prognostizierter SoC

  my $hods = AttrVal ($name, 'ctrlNextHoursSoCForecastReadings', '');

  return if(!$hods);

  if (grep { /$nhr/x } split ',', $hods) {
      storeReading ('Battery_NextHour'.$nhr.'_SoCforecast_'.$bn, $progsoc.' %');
  }

return;
}

################################################################
#   Erstellung Optimum Ladeleistung für jede Batterie
#   (Erreichung des max. möglichen SoC mit möglichst geringer 
#   Ladeleistung verteilt über die Tagstunden mit PV-Überschuß)
################################################################       
sub __batChargeOptTargetPower {
  my $paref     = shift;
  my $lfd       = shift;                                                                                         # laufender Tag (1..X)
  my $minute    = shift;
  my $trans     = shift;                                                                                         # Übertrags-Hash Referenz
  my $hs2sunset = shift;
  
  my $name  = $paref->{name};
  my $hsurp = $paref->{hsurp};                                                                                   # Hashref Überschußhash

  my $fipl       = CurrentVal ($name, 'feedinPowerLimit', INFINITE);
  my @sortedhods = sort { $hsurp->{$a}{surplswh} <=> $hsurp->{$b}{surplswh} } keys %{$hsurp};                    # Stunden aufsteigend nach PV-Überschuß sortiert
  my @batteries  = grep { !/^(?:fd|speff|surplswh|nhr)$/xs } keys %{$hsurp->{24}};
  
  my ($fcendwh, $diff);
  my $otp;

  for my $hod (sort { $a <=> $b } keys %{$hsurp}) {
	  my $nhr     = $hsurp->{$hod}{nhr};
      my $spls    = int ($hsurp->{$hod}{surplswh} // 0);	  
	  my $nexthod = sprintf "%02d", (int $hod + 1);
	  my $nextnhr = $hsurp->{$nexthod}{nhr};
      
      my @remaining_hods = grep { int $_ >= int $hod } @sortedhods;
	  my $total          = 0;                                               
	  $total            += $hsurp->{$_}{surplswh} for @remaining_hods;                                           # Gesamtkapazität aller Stunden mit PV-Überschuß ermitteln

      for my $sbn (sort { $a <=> $b } @batteries) {                                                              # jede Batterie		  
		  my $bpinmax     = $hsurp->{$hod}{$sbn}{bpinmax};                                                       # Bat max. mögliche Ladelesitung
          my $batinstcap  = $hsurp->{$hod}{$sbn}{batinstcap};                                                    # Kapa dieser Batterie 
          my $lowSocwh    = $hsurp->{$hod}{$sbn}{lowSocwh};                                                      # eingestellter lowSoc in Wh
          my $batoptsocwh = $hsurp->{$hod}{$sbn}{batoptsocwh};                                                   # optimaler SoC in Wh
          my $csocwh      = $hsurp->{$hod}{$sbn}{csocwh};                                                        # aktueller SoC in Wh
          my $bpinreduced = $hsurp->{$hod}{$sbn}{bpinreduced};                                                   # Standardwert bei <=lowSoC -> Anforderungsladung vom Grid
          my $befficiency = $hsurp->{$hod}{$sbn}{befficiency};                                                   # Speicherwirkungsgrad
		  my $strategy    = $hsurp->{$hod}{$sbn}{strategy};                                                      # Ladestrategie
          
          # Initialisierung / Fortschreibung Prognose-SOC (Wh)
          ######################################################
          my $fc_next_wh  = $hsurp->{$hod}{$sbn}{fcnextwh};
          my $init_soc_wh = $hsurp->{$hod}{$sbn}{initsocwh};
          my $transfer    = $trans->{$sbn}{$lfd}{transfer};
          
          my $runwh = do {
              if (defined $fc_next_wh)   { $fc_next_wh }
              elsif ($nhr eq '00')       { $csocwh }
              elsif (defined $transfer)  { delete $trans->{$sbn}{$lfd}{transfer} }
              else                       { $init_soc_wh }
          };
          
          $runwh                      = min ($runwh, $batinstcap);                            
          $hsurp->{$hod}{$sbn}{runwh} = sprintf "%.0f", $runwh;                                                  # Startwert für DebugLog

          ## Ziel und dessen Erreichbarkeit
          ###################################
          my $goalwh     = $hsurp->{$hod}{$sbn}{goalwh};                                                         # Ladeziel 
          my $runwhneed  = $goalwh - $runwh; 
          my $achievable = 1;
            
          if ($runwhneed > 0 && $total * $befficiency < $runwhneed) {                                            # Erreichbarkeit des Ziels (benötigte Ladeenergie total) prüfen
              $achievable = 0;                                                      
          }
          
          storeReading ('Battery_TargetAchievable_'.$sbn, $achievable) if($nhr eq '00');
          
          $hsurp->{$hod}{$sbn}{loadrel}    = $runwhneed > 0 ? 1 : 0;                                             # Ladefreigabe abhängig von Ziel-SoC Erfüllung
          $hsurp->{$hod}{$sbn}{achievelog} = "charging target: $goalwh Wh, remaining: ".(sprintf "%.0f", $runwhneed).' Wh -> target likely achievable? '.($achievable ? 'yes' : 'no'); 
          
          ## kein Überschuß
          ###################
          if (!$spls) {                                                                                         
              $hsurp->{$hod}{$sbn}{pneedmin} = $runwhneed > 0 ? $bpinmax : 0;                                    # Ladeleistung abhängig von Ziel-SoC Erfüllung
              
              $diff = $hsurp->{$hod}{speff};                                                                     # Verbrauch
              
              if ($nhr eq '00') {
                  $diff                = $diff / 60 * (60 - int $minute);                                        # aktuelle (Rest)-Stunde -> zeitgewichteter Ladungsabfluß
                  $otp->{$sbn}{target} = $csocwh <= $lowSocwh ? $bpinreduced : $bpinmax;
              }
              
              $runwh += $diff / $befficiency;                                                                    # um Verbrauch reduzieren
              $runwh  = ___batClampValue ($runwh, $lowSocwh, $batoptsocwh, $batinstcap);                         # runwh begrenzen                  
              
              $hsurp->{$hod}{$sbn}{fcendwh}      = sprintf "%.0f", $runwh;                	  
			  $hsurp->{$nexthod}{$sbn}{fcnextwh} = $hsurp->{$hod}{$sbn}{fcendwh} if(defined $nextnhr);           # Startwert kommende Stunde 			            
              
              next;
          }                                   
          
          ## weiter mit Überschuß (Prognose)
          ####################################
          my $otpMargin = $hsurp->{$hod}{$sbn}{otpMargin};                              
          my $fref      = ___batFindMinPhWh ($hsurp, \@remaining_hods, $runwhneed);
          my $needraw   = min ($fref->{ph}, $spls);                                                              # Ladeleistung auf Surplus begrenzen
          
          $needraw      = $bpinmax if(!$hsurp->{$hod}{$sbn}{lcintime});            
          $needraw      = max ($needraw, $bpinreduced);                                                          # Mindestladeleistung bpinreduced sicherstellen                  
          
          my $pneedmin  = $needraw * (1 + $otpMargin / 100);                                                     # optPower: initialer Sicherheitsaufschlag
          
          if ($strategy eq 'smartPower') {
              $pneedmin = ___batAdjustPowerByMargin ($name, $needraw, $bpinmax, $runwhneed, $otpMargin);         # Sicherheitsaufschlag abfallend proportional zum linearen Überschuss
          }
          
          $pneedmin = sprintf "%.0f", $pneedmin;
          $pneedmin = min ($pneedmin, $bpinmax);                                                                 # Begrenzung auf max. mögliche Batterieladeleistung
          
          $hsurp->{$hod}{$sbn}{pneedmin} = $pneedmin > 0 ? $pneedmin : 0;                                        # Ladeleistung abhängig von Ziel-SoC Erfüllung        
               
          ## NextHour 00 bearbeiten
          ###########################
          if ($nhr eq '00') {
              my $target = $needraw > 0 ? $needraw / $befficiency : 0;                                           # Zielleistung mit Batterie Effizienzgrad erhöhen

              if ($achievable) {                                                                                 # Tagesziel erreichbar: Basisziel um otpMargin% erhöhen
                  $target *= 1 + ($otpMargin / 100);
                    
                  if ($strategy eq 'smartPower') {                                                               # smartPower: Sicherheitsaufschlag linear absenkend
                      $target = ___batAdjustPowerByMargin ($name, $target, $bpinmax, $runwhneed, $otpMargin);
                  }
              }
              else {                                                                                             # Tagesziel nicht erreichbar: Aufschlag potenziert (zweifach wirksam)                 
                  $hs2sunset -= 1;
				  $target     = $runwhneed > 0 && $hs2sunset > 0 ? $runwhneed / $hs2sunset : $target;  
                  $target    *= (1 + $otpMargin / 100) ** 2;                
                                    
                  if ($strategy eq 'smartPower') {                                                               # smartPower: maximale Ladeleistung erzwingen
                      $target = $bpinmax;
                  }
              }

              my $gfeedin = CurrentVal ($name, 'gridfeedin',    0);                                              # aktuelle Netzeinspeisung
              my $bpin    = CurrentVal ($name, 'batpowerinsum', 0);                                              # aktuelle Batterie Ladeleistung (Summe über alle Batterien)
              my $inc     = 0;
              
              if ( !$bpin && $gfeedin > $fipl )           {$inc = $gfeedin - $fipl}                              # Ladeleistung wenn akt. keine Bat-Ladung UND akt. Einspeisung > Einspeiselimit der Anlage
              if (  $bpin && ($gfeedin - $bpin) > $fipl ) {$inc = $bpin + (($gfeedin - $bpin) - $fipl)}          # Ladeleistung wenn akt. Bat-Ladung UND Einspeisung - Bat-Ladung > Einspeiselimit der Anlage
                       
              $target              = sprintf "%.0f", max ($target, $inc);                                        # Einspeiselimit berücksichtigen
              $target              = min (($csocwh <= $lowSocwh ? $bpinreduced : $bpinmax), $target);            # 2. Begrenzung auf max. mögliche Batterieleistung bzw. bpinreduced bei Unterschreitung lowSoc
              $otp->{$sbn}{target} = $target;
          }

          $diff = min ($spls, $hsurp->{$hod}{$sbn}{pneedmin});                                                   # kleinster Wert aus PV-Überschuß oder Ladeleistungsbegrenzung
          
          if ($nhr eq '00') {                                                                                    # aktuelle (Rest)-Stunde -> zeitgewichteter Ladungszufluß
              $diff = $spls / 60 * (60 - int $minute);                                                  
          }
          
          $runwh = min ($goalwh, $runwh + $diff * $befficiency);                                                 # Endwert Prognose        
          $runwh = ___batClampValue ($runwh, $lowSocwh, $batoptsocwh, $batinstcap);                              # runwh begrenzen
		  
          $hsurp->{$hod}{$sbn}{fcendwh}      = sprintf "%.0f", $runwh;
          $hsurp->{$nexthod}{$sbn}{fcnextwh} = $hsurp->{$hod}{$sbn}{fcendwh} if(defined $nextnhr);               # Startwert kommende Stunde  
      }
  }
  
  for my $bat (sort { $a <=> $b } @batteries) {
      $trans->{$bat}{$lfd + 1}{transfer} = $hsurp->{24}{$bat}{fcendwh};                                          # Übertrag SoC-Prognose für kommenden Tag                              
  }
  
return ($hsurp, $otp);
}

################################################################
#  Zielleistung mit Sicherheitszuschlag behandeln  
#  abfallend proportional zum linearen Rest-Überschuss des Tages
################################################################       
sub ___batAdjustPowerByMargin {
  my ($name, $target, $pinmax, $runwhneed, $otpMargin) = @_;

  my $ratio   = 0;
  my $rodpvfc = ReadingsNum ($name, 'RestOfDayPVforecast', 0);                     # PV Prognose Rest des Tages
  $ratio      = $rodpvfc * 100 / $runwhneed if($runwhneed);
  
  return $pinmax if($target == $pinmax || $ratio <= 100);
  return $target * (1 + $otpMargin / 100) if($target == 0 || !$otpMargin || $ratio >= 100 + $otpMargin); 
  
  my $pow = $pinmax - ($pinmax - $target) * ($ratio - 100) / $otpMargin;

return $pow;
}

################################################################
#          Umrechnung Batterie SoC % in Wh
################################################################            
sub ___batSocPercentToWh {
  my $base = shift;                                                      # Batteriekapazität in Wh
  my $soc  = shift;                                                      # SoC in %

return  $base / 100 * $soc;
}

################################################################
#          Umrechnung Batterie Wh in SoC %
################################################################         
sub ___batSocWhToPercent {
  my $base  = shift;                                                      # Batteriekapazität in Wh
  my $socwh = shift;                                                      # SoC in Wh

return  100 / $base * $socwh ;
}

################################################################
#   Begrenzungen einhalten zwischen low, opt und high Grenze 
#
#   $x = ___batClampValue ($value, $low, $opt, $high);
################################################################
sub ___batClampValue {
  my ($value, $low, $opt, $high) = @_;

  $value = $value < $low  ? $low  :                                                  
           $value < $opt  ? $opt  :                                       
           $value > $high ? $high :
           $value; 

return $value;
}

###############################################################################################
#   Binärsuche für konstante Ladeleistung: $ph Wh via Binärsuche Iteration
#   
# - Wenn die Summe aller surplswh geringer ist als der Bedarf, wird Ereq automatisch auf 
#   diesen Maximalwert gesetzt und liefert so die tatsächlich erreichbare Energie.
# - gewichtete Stundenkapazität @hods enthält die Stunden-Keys sortiert von der niedrigsten 
#   bis zur höchsten Leistung. In jeder Binärsuche-Iteration addiert das Skript 
#   min(ph, surplswh) für jede Stunde, wodurch die konstant gewählte Leistung ph gemäß der 
#   verfügbaren Kapazität gewichtet wird.
# - Rückgabe Nach X Iterationen steht $high als kleinstmöglicher Wert für ph bereit. Er 
#   garantiert entweder das Erreichen von Ereq Wh oder – falls das Ziel unerreichbar war – 
#   die vollständige Ausnutzung der vorhandenen Kapazität.
###############################################################################################
sub ___batFindMinPhWh {
    my ($hsurp, $aref, $Ereq) = @_;
    
    my @hods     = @$aref;
    my $low      = 0;                                                 
    my $high     = max map { $hsurp->{$_}{surplswh} } @hods;
    my $eps      = 0.5;                                               # minimale Genauigkeit in Wh  (1e-3)
    my $max_iter = 100;                                               # Zwangsabbruch nach X Durchläufen
    my $loop     = 0;
    
    while (($high - $low) > $eps) {
        last if ++$loop > $max_iter;
        
        my $mid     = ($low + $high) / 2;
        my $charged = 0;
        
        for my $hod (@hods) {
            my $cap   = $hsurp->{$hod}{surplswh};
            $charged += $mid < $cap ? $mid : $cap;
        }
        
        $charged >= $Ereq ? ($high = $mid) : ($low = $mid);
    } 
    
    $high = max (0, $high);
    
return { ph => (sprintf "%.0f", $high), iterations => $loop, blur => (sprintf "%.4f", ($high - $low)) };
}

################################################################
#   Speicherung Ergebnisse aus Batterie Lademanagement
################################################################       
sub ___batChargeSaveResults {
  my $paref  = shift;
  my $values = shift;
  
  my $name       = $paref->{name};
  my $hsoc       = $values->{hsoc};                                          # Referenz SoC-Hash
  my $otp        = $values->{otp};                                           # Referenz OTP-Hash
  my $bn         = $values->{bn};                                            # Batterie Nummer 
  my $nhr        = $values->{nhr};                                           # zweistellige lfd. Nexthour
  my $progsoc    = $values->{progsoc};                                       # Prognose-SoC in % 
  my $socwh      = $values->{socwh};                                         # Prognose-SoC in Wh                                    
  my $today      = $values->{today};                                         # Statusbit aktueller Tag
  my $hod        = $values->{hod};                                           # Stunde des Tages
  my $loopid     = $values->{loopid};                                        # in welcher Loop ist sub aufgerufen?
  my $strategy   = $values->{strategy};                                      # welche Lade-Strategie wird verwendet
  
  my $crel       = $values->{crel};                                          # nur in Schleife 'loadRelease' mitgeben
  my $labortCond = $values->{labortCond};                                    # nur in Schleife 'loadRelease' mitgeben
  my $loadAbort  = $values->{loadAbort};                                     # nur in Schleife 'loadRelease' mitgeben
  my $cgbt       = $values->{cgbt};                                          # nur in Schleife 'loadRelease' mitgeben
  my $lcintime   = $values->{lcintime};                                      # nur in Schleife 'loadRelease' mitgeben

  ## in Schleife 'loadRelease' setzen
  #####################################  
  if ($loopid eq 'LR') {                                                                                              
      $data{$name}{nexthours}{'NextHour'.$nhr}{'lcintimebat'.$bn} = $lcintime if($cgbt);                               # nur einmal bei 'loadRelease' setzen  -> Ladesteuerung "In Time", "nicht In Time" oder nicht verwendet
      $data{$name}{nexthours}{'NextHour'.$nhr}{'strategybat'.$bn} = $strategy;                                        
      
      if ($nhr eq '00') { 
          storeReading ('Battery_ChargeUnrestricted_'.$bn, $crel);                
          storeReading ('Battery_ChargeAbort_'.$bn,  $labortCond) if ($loadAbort);                                     # Ladeabbruchbedingung
      }
      
      if ($today && $hod) {                                                                                      
          writeToHistory ( { paref => $paref, key => 'lcintimebat'.$bn, val => $lcintime, hour => $hod } ) if($cgbt); 
          writeToHistory ( { paref => $paref, key => 'strategybat'.$bn, val => $strategy, hour => $hod } );            
      }
  }
  
  ## in Schleife 'optPower/smartPower' setzen
  #############################################
  if ($loopid eq 'OTP') {
      if ($nhr eq '00') {                                                                            # Target für aktuelle Stunde
          my $needmin = $otp->{$bn}{target} // 0;
          storeReading ('Battery_ChargeOptTargetPower_'.$bn, $needmin.' W');
      }
  }
  
  ## abhängig von Strategie in entsprechender Schleife setzen 
  #############################################################
  if (($loopid eq 'LR' && $strategy eq 'loadRelease') || ($loopid eq 'OTP' && $strategy =~ /(?:opt|smart)Power/xs)) {
	  $data{$name}{nexthours}{'NextHour'.$nhr}{'rcdchargebat'.$bn} = $crel;
	  
      if ($today && $hod) {                                                                                      
          writeToHistory ( { paref => $paref, key => 'batprogsoc'.$bn,  val => $progsoc,  hour => $hod } );
      }
      
      __createNextHoursSFCReadings ( {name    => $name,
                                      nhr     => $nhr,
                                      bn      => $bn,
                                      progsoc => $progsoc
                                     }
                                   );                                                                                  # Readings NextHourXX_Bat_XX_ChargeForecast erstellen

      $data{$name}{nexthours}{'NextHour'.$nhr}{'soc'.$bn} = $progsoc;
      
      $hsoc->{$nhr}{socprogwhsum} += $socwh;                                                                           # Hilfshash Aufsummierung SoC-Prognose (Wh) über alle Batterien
  }
  
return;
}

################################################################
#               Zusammenfassungen erstellen
################################################################
sub _createSummaries {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $t      = $paref->{t};
  my $day    = $paref->{day};                                                                         # aktueller Tag
  my $chour  = $paref->{chour};                                                                       # aktuelle Stunde
  my $minute = $paref->{minute};                                                                      # aktuelle Minute
  my $debug  = $paref->{debug};

  $minute = int ($minute) + 1;                                                                        # Minute Range umsetzen auf 1 bis 60

  my $dt     = timestringsFromOffset ($t, 86400);
  my $tmoday = $dt->{day};                                                                            # Tomorrow Day (01..31)
  
  $dt          = timestringsFromOffset ($t, 172800);
  my $datmoday = $dt->{day};                                                                          # Übermorgen Day (01..31)

  ## Initialisierung
  ####################
  my $next1HoursSum = { "PV" => 0, "Consumption" => 0 };
  my $next2HoursSum = { "PV" => 0, "Consumption" => 0 };
  my $next3HoursSum = { "PV" => 0, "Consumption" => 0 };
  my $next4HoursSum = { "PV" => 0, "Consumption" => 0 };
  my $restOfDaySum  = { "PV" => 0, "Consumption" => 0 };
  my $tomorrowSum   = { "PV" => 0, "Consumption" => 0 };
  my $daftertomSum  = { "PV" => 0, "Consumption" => 0 };                                               # Werte für Übermorgen 
  my $todaySumFc    = { "PV" => 0, "Consumption" => 0 };
  my $todaySumRe    = { "PV" => 0, "Consumption" => 0 };
  
  my $tdaysset = CurrentVal ($name, 'sunsetTodayTs', 0);                                               # Timestamp Sonneuntergang am aktuellen Tag
  my $dtsset   = timestringsFromOffset ($tdaysset,   0);

  my $tdConFcTillSunset = 0;
  my $remainminutes     = 60 - $minute;                                                                # verbleibende Minuten der aktuellen Stunde

  my $hour00pvfc  = NexthoursVal ($name, "NextHour00", 'pvfc',  0) / 60 * $remainminutes;
  my $hour00confc = NexthoursVal ($name, "NextHour00", 'confc', 0);
  my $hod00       = NexthoursVal ($name, "NextHour00", 'hourofday', 0);
  
  $hour00pvfc     = max (0, $hour00pvfc);                                                              # PV Prognose darf nicht negativ sein
  $hour00confc    = max (0, $hour00confc);                                                             # Verbrauchsprognose darf nicht negativ sein
  
  my $hour00confcremain = $hour00confc / 60 * $remainminutes;
  
  if ($paref->{t} < $tdaysset) {
      if (int ($hod00) != int ($dtsset->{hour}) + 1) {
          $tdConFcTillSunset += $hour00confcremain;                                                    # aktuelle Minute bis volle Stunde
      }
      else {
          $tdConFcTillSunset += $hour00confc / 60 * (int ($dtsset->{minute}) + 1 - $minute);           # aktuelle Minute bis Sunset
      }
  }

  $next1HoursSum->{PV}          = $hour00pvfc;
  $next2HoursSum->{PV}          = $hour00pvfc;
  $next3HoursSum->{PV}          = $hour00pvfc;
  $next4HoursSum->{PV}          = $hour00pvfc;
  $restOfDaySum->{PV}           = $hour00pvfc;

  $next1HoursSum->{Consumption} = $hour00confcremain;
  $next2HoursSum->{Consumption} = $hour00confcremain;
  $next3HoursSum->{Consumption} = $hour00confcremain;
  $next4HoursSum->{Consumption} = $hour00confcremain;
  $restOfDaySum->{Consumption}  = $hour00confcremain;

  for my $h (1..MAXNEXTHOURS) {
      my $idx   = sprintf "%02d", $h;
      my $pvfc  = NexthoursVal ($name, "NextHour".$idx, 'pvfc',      0);
      my $confc = NexthoursVal ($name, "NextHour".$idx, 'confc',     0);
      my $istdy = NexthoursVal ($name, "NextHour".$idx, 'today',     0);
      my $don   = NexthoursVal ($name, "NextHour".$idx, 'DoN',       0);
      my $hod   = NexthoursVal ($name, "NextHour".$idx, 'hourofday', 0);
      my $nhday = NexthoursVal ($name, "NextHour".$idx, 'day',       0);
      
      $pvfc     = max (0, $pvfc);                                                           # PV Prognose darf nicht negativ sein
      $confc    = max (0, $confc);                                                          # Verbrauchsprognose darf nicht negativ sein
      
      if ($h == 1) {
          $next1HoursSum->{PV}          += $pvfc  / 60 * $minute;
          $next1HoursSum->{Consumption} += $confc / 60 * $minute;
      }

      if ($h <= 2) {
          $next2HoursSum->{PV}          += $pvfc                 if($h <  2);
          $next2HoursSum->{PV}          += $pvfc  / 60 * $minute if($h == 2);
          $next2HoursSum->{Consumption} += $confc                if($h <  2);
          $next2HoursSum->{Consumption} += $confc / 60 * $minute if($h == 2);
      }

      if ($h <= 3) {
          $next3HoursSum->{PV}          += $pvfc                 if($h <  3);
          $next3HoursSum->{PV}          += $pvfc  / 60 * $minute if($h == 3);
          $next3HoursSum->{Consumption} += $confc                if($h <  3);
          $next3HoursSum->{Consumption} += $confc / 60 * $minute if($h == 3);
      }

      if ($h <= 4) {
          $next4HoursSum->{PV}          += $pvfc                 if($h <  4);
          $next4HoursSum->{PV}          += $pvfc  / 60 * $minute if($h == 4);
          $next4HoursSum->{Consumption} += $confc                if($h <  4);
          $next4HoursSum->{Consumption} += $confc / 60 * $minute if($h == 4);
      }

      if ($istdy) {
          $restOfDaySum->{PV}          += $pvfc;
          $restOfDaySum->{Consumption} += $confc;
          $tdConFcTillSunset           += $confc if($don);
          
          if (int ($hod) == int ($dtsset->{hour}) + 1) {                              # wenn die berücksichtigte Stunde die Stunde des Sonnenuntergangs ist
              my $diflasth        = 60 - int ($dtsset->{minute}) + 1;                 # fehlende Minuten zur vollen Stunde in der Stunde des Sunset 
              $tdConFcTillSunset -= ($confc / 60) * $diflasth;
          }
      }
      elsif ($nhday eq $tmoday) {
          $tomorrowSum->{PV} += $pvfc;
      }
      elsif ($nhday eq $datmoday) {
          $daftertomSum->{PV}          += $pvfc;
          $daftertomSum->{Consumption} += $confc;          
      }
  }

  for my $th (1..24) {
      $todaySumFc->{PV} += HistoryVal ($name, $day, sprintf("%02d", $th), 'pvfc', 0);
      $todaySumRe->{PV} += HistoryVal ($name, $day, sprintf("%02d", $th), 'pvrl', 0);
  }

  my $pvre = int $todaySumRe->{PV};

  push @{$data{$name}{current}{h4fcslidereg}}, int $next4HoursSum->{PV};                                # Schieberegister 4h Summe Forecast
  limitArray ($data{$name}{current}{h4fcslidereg}, SLIDENUMMAX);

  my $gcon    = CurrentVal ($name, 'gridconsumption',         0);                                       # aktueller Netzbezug
  my $tconsum = CurrentVal ($name, 'tomorrowconsumption', undef);                                       # Verbrauchsprognose für folgenden Tag
  my $gfeedin = CurrentVal ($name, 'gridfeedin',              0);

  my $batin  = 0;
  my $batout = 0;

  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;
      $batin  += BatteryVal ($name, $bn, 'bpowerin',  0);                                               # Summe momentane Batterieladung
      $batout += BatteryVal ($name, $bn, 'bpowerout', 0);                                               # Summe momentane Batterieentladung
  }

  my $pv2node     = 0;
  my $pv2bat      = 0;
  my $dc2inv2node = 0;
  my $node2inv2dc = 0;
  my $pv2grid     = 0;                                                                                   # PV-Erzeugung zu Grid-only
  
  for my $in (1..MAXINVERTER) {
      $in       = sprintf "%02d", $in;
      my ($err) = isDeviceValid ( { name => $name, obj => 'setupInverterDev'.$in, method => 'attr' } );
      next if($err);

      my $pvout    = InverterVal ($name, $in, 'ipvout',  0);                                            # Erzeugung aus PV
      my $pdc2ac   = InverterVal ($name, $in, 'ipdc2ac', 0);                                            # Wandlung DC->AC (Batterie-Wechselrichter)
      my $pac2dc   = InverterVal ($name, $in, 'ipac2dc', 0);                                            # Rückwandlung AC->DC (Batterie-Wechselrichter)
      my $ifeed    = InverterVal ($name, $in, 'ifeed',   'default');
      my $isource  = InverterVal ($name, $in, 'isource',      'pv');

      $pv2node     += $pvout  if($ifeed eq 'default' && $isource eq 'pv');                              # PV-Erzeugung Inverter für das Hausnetz
      $pv2grid     += $pvout  if($ifeed eq 'grid'    && $isource eq 'pv');                              # PV nur für das öffentliche Netz
      $pv2bat      += $pvout  if($ifeed eq 'bat'     && $isource eq 'pv');                              # Direktladen PV nur in die Batterie
      $dc2inv2node += $pdc2ac if($ifeed eq 'hybrid' || ($ifeed eq 'default' && $isource eq 'bat'));     # DC->AC / Speisung Inverter aus Batterie / Solar-Ladegerät statt PV
      $node2inv2dc += $pac2dc if($ifeed eq 'hybrid' || ($ifeed eq 'default' && $isource eq 'bat'));     # AC->DC (Batterie- oder Hybrid-Wechselrichter)
  }

  my $ppall = 0;                                                                                        # Summe Otherproducer

  for my $pn (1..MAXPRODUCER) {                                                                         # Erzeugung sonstiger Producer hinzufügen
      $pn     = sprintf "%02d", $pn;
      $ppall += ProducerVal ($name, $pn, 'pgeneration', 0);
  } 
  
  my $vector = __calcVectorConsumption ( { name        => $name,
                                           batout      => $batout,
                                           batin       => $batin,
                                           pv2bat      => $pv2bat,
                                           pv2node     => $pv2node,
                                           dc2inv2node => $dc2inv2node,
                                           node2inv2dc => $node2inv2dc,
                                           ppall       => $ppall,
                                           gfeedin     => $gfeedin,
                                           gcon        => $gcon
                                         }
                                       );
                                            
  my $consumption     = $vector->{vectorconsumption};
  my $selfconsumption = sprintf "%.0f", ($pv2node + $pv2bat - $gfeedin - $batin);
  $selfconsumption    = $selfconsumption < 0 ? 0 : $selfconsumption;

  my $surplus         = sprintf "%.0f", ($pv2node + $pv2bat + $ppall - $pv2grid - $consumption);        # aktueller Überschuß - fix V1.57.3
  $surplus            = 0 if($surplus < 0);                                                             # wegen Vergleich nompower vs. surplus

  if ($debug =~ /collectData/xs) {
      Log3 ($name, 1, "$name DEBUG> current Power values -> PV2Node: $pv2node W, PV2Bat: $pv2bat, PV2Grid: $pv2grid W, Other: $ppall W, GridIn: $gfeedin W, GridCon: $gcon W");
      Log3 ($name, 1, "$name DEBUG> current Power Battery -> BatIn: $batin W (Node2Inv2DC: $node2inv2dc W), BatOut: $batout W (DC2Inv2Node: $dc2inv2node W)");
      Log3 ($name, 1, "$name DEBUG> current Consumption result -> $consumption W");
  }

  my $selfconsumptionrate = 0;
  my $autarkyrate         = 0;
  my $divi                = $selfconsumption + $batout + $gcon;
  $selfconsumptionrate    = sprintf "%.0f", ($selfconsumption / $pv2node * 100)        if($pv2node * 1 > 0);
  $autarkyrate            = sprintf "%.0f", ($selfconsumption + $batout) / $divi * 100 if($divi);       # vermeide Illegal division by zero

  $data{$name}{current}{consumption}           = $consumption;
  $data{$name}{current}{selfconsumption}       = $selfconsumption;
  $data{$name}{current}{selfconsumptionrate}   = $selfconsumptionrate;
  $data{$name}{current}{autarkyrate}           = $autarkyrate;
  $data{$name}{current}{tdConFcTillSunset}     = sprintf "%.0f", $tdConFcTillSunset;
  $data{$name}{current}{surplus}               = $surplus;
  $data{$name}{current}{dayAfterTomorrowPVfc}  = $daftertomSum->{PV};
  $data{$name}{current}{dayAfterTomorrowConfc} = $daftertomSum->{Consumption};

  push @{$data{$name}{current}{surplusslidereg}}, $surplus;                                             # Schieberegister PV Überschuß
  limitArray ($data{$name}{current}{surplusslidereg}, SPLSLIDEMAX);

  storeReading ('Current_GridFeedIn',           (sprintf "%.0f", $gfeedin). ' W');                           
  storeReading ('Current_GridConsumption',      (sprintf "%.0f", $gcon).    ' W');                            
  storeReading ('Current_Consumption',          $consumption.         ' W');
  storeReading ('Current_SelfConsumption',      $selfconsumption.     ' W');
  storeReading ('Current_SelfConsumptionRate',  $selfconsumptionrate. ' %');
  storeReading ('Current_Surplus',              $surplus.             ' W');
  storeReading ('Current_AutarkyRate',          $autarkyrate.         ' %');
  storeReading ('Today_PVreal',                 $pvre.               ' Wh');
  storeReading ('Tomorrow_ConsumptionForecast', $tconsum.            ' Wh') if(defined $tconsum);

  storeReading ('NextHours_Sum01_PVforecast',          (sprintf "%.0f", $next1HoursSum->{PV}).         ' Wh');
  storeReading ('NextHours_Sum02_PVforecast',          (sprintf "%.0f", $next2HoursSum->{PV}).         ' Wh');
  storeReading ('NextHours_Sum03_PVforecast',          (sprintf "%.0f", $next3HoursSum->{PV}).         ' Wh');
  storeReading ('NextHours_Sum04_PVforecast',          (sprintf "%.0f", $next4HoursSum->{PV}).         ' Wh');
  storeReading ('RestOfDayPVforecast',                 (sprintf "%.0f", $restOfDaySum->{PV}).          ' Wh');
  storeReading ('Tomorrow_PVforecast',                 (sprintf "%.0f", $tomorrowSum->{PV}).           ' Wh');
  storeReading ('Today_PVforecast',                    (sprintf "%.0f", $todaySumFc->{PV}).            ' Wh');
  storeReading ('NextHours_Sum04_ConsumptionForecast', (sprintf "%.0f", $next4HoursSum->{Consumption}).' Wh');
  storeReading ('RestOfDayConsumptionForecast',        (sprintf "%.0f", $restOfDaySum->{Consumption}). ' Wh');

return;
}

################################################################
# Hausverbrauch aus dem Leistungsfluß in/aus Knoten ermitteln
# (erfasst auch Verlustleistung in den Batteriewechselrichtern)
# und alternativ linear
# alles ohne PV2Grid
################################################################
sub __calcVectorConsumption {
  my $paref       = shift;
  my $name        = $paref->{name};
  my $batout      = $paref->{batout};
  my $batin       = $paref->{batin};
  my $pv2bat      = $paref->{pv2bat};
  my $pv2node     = $paref->{pv2node};
  my $dc2inv2node = $paref->{dc2inv2node};
  my $node2inv2dc = $paref->{node2inv2dc};
  my $ppall       = $paref->{ppall};
  my $gfeedin     = $paref->{gfeedin};
  my $gcon        = $paref->{gcon};
  
  my $vector; 
  $vector->{batDischarge2HomeNode} = 0;  
  my $node2bat = 0;                                                                       # Verbindung Inv.Knoten <-> Batterie ((-) Bat -> Knoten, (+) Knoten -> Bat)
  my $bat2home = 0;
  
  ## Vectorverbrauch
  ####################
  if ($batout || $batin) {                                                                # Batterie wird geladen oder entladen
      $node2bat = ($batin - $batout) - $pv2bat + $dc2inv2node - $node2inv2dc;             # positiv: Richtung Inverter Knoten -> Bat, negativ: Richtung Bat -> Inverter Knoten
      $node2bat = 0 if(($dc2inv2node || $node2inv2dc) && $node2bat != 0);

      if ($node2bat < 0 && !$dc2inv2node && !$pv2bat) {                                   # Batterieentladung direkt ins Hausnetz wenn kein Batterie- / Hybridwechselrichter und kein Batterieladegerät aktiv
          $bat2home = abs $node2bat;
          $node2bat = 0;
          $vector->{batDischarge2HomeNode} = 1;
      }
  }
  else {
      $node2bat  = $dc2inv2node - $pv2bat;                                                # falls Batterie Idle und Smartloader arbeitet
      $node2bat  = 0 if($dc2inv2node && $node2bat > 0);                                   # muß negativ (0) sein: Richtung Bat -> Inv.Knoten,  wichtig zur Festlegung Richtung und Inv. Knoten Summierung
  }
  
  my $pnodesum  = $ppall + $pv2node + $dc2inv2node - $node2inv2dc;                        # Erzeugung Summe im Inverter-Knoten
  $pnodesum    += $node2bat < 0 ? abs $node2bat : 0;                                      # z.B. Batterie ist voll und SolarLader liefert an Knoten
  $pnodesum     = __normDecPlaces ($pnodesum);

  my $node2home = $pnodesum - $gfeedin - ($node2bat > 0 ? $node2bat : 0);                 # Energiefluß vom Knoten zum Haus
  $node2home    = __normDecPlaces ($node2home);
  
  $vector->{vectorconsumption} = sprintf "%.0f", ($gcon + $node2home + $bat2home);        # V 1.52.0 Anpassung Consumption wegen Verlustleistungsdifferenzen

  ## Linearverbrauch
  ####################
  $vector->{linearconsumption} = sprintf "%.0f", ($pv2node + $pv2bat + $ppall - $gfeedin + $gcon - $batin + $batout);  

  $vector->{bat2home}  = $bat2home;
  $vector->{pnodesum}  = $pnodesum;
  $vector->{node2home} = $node2home;
  $vector->{node2bat}  = $node2bat;

return $vector;
}

################################################################
#     Consumer - Energieverbrauch aufnehmen
#              - Masterdata ergänzen
#              - Schaltzeiten planen
################################################################
sub _manageConsumerData {
  my $paref   = shift;
  my $name    = $paref->{name};
  my $t       = $paref->{t};                                                 # aktuelle Zeit
  my $chour   = $paref->{chour};
  my $day     = $paref->{day};

  my $hash        = $defs{$name};
  my $nhour       = $chour + 1;
  $paref->{nhour} = sprintf "%02d", $nhour;
  
  my $pcurrsum = 0;

  for my $c (sort{$a<=>$b} keys %{$data{$name}{consumers}}) {
      $paref->{consumer} = $c;
      my $consumer       = ConsumerVal ($hash, $c, 'name',  '');
      my $alias          = ConsumerVal ($hash, $c, 'alias', '');

      ## aktuelle Leistung auslesen
      ##############################
      my $paread = ConsumerVal ($hash, $c, "rpcurr", "");
      my $up     = ConsumerVal ($hash, $c, "upcurr", "");
      my $pcurr  = 0;

      if ($paread) {
          my $eup = $up =~ /^kW$/xi ? 1000 : 1;
          $pcurr  = ReadingsNum ($consumer, $paread, 0) * $eup;
      }

      ## Verbrauch auslesen + speichern
      ###################################
      my $ethreshold = 0;
      my $etotread   = ConsumerVal ($hash, $c, "retotal", "");
      my $u          = ConsumerVal ($hash, $c, "uetotal", "");

      if ($etotread) {
          my $eu      = $u =~ /^kWh$/xi ? 1000 : 1;
          my $etot    = ReadingsNum ($consumer, $etotread, 0) * $eu;                               # Summe Energieverbrauch des Verbrauchers
          my $ehist   = HistoryVal  ($hash, $day, sprintf("%02d",$nhour), "csmt${c}", undef);      # gespeicherter Totalverbrauch
          $ethreshold = ConsumerVal ($hash, $c, "energythreshold", 0);                             # Schwellenwert (Wh pro Stunde) ab der ein Verbraucher als aktiv gewertet wird

          ## aktuelle Leistung ermitteln wenn kein Reading d. aktuellen Leistung verfügbar
          ##################################################################################
          if (!$paread){
              my $timespan = $t    - ConsumerVal ($hash, $c, "old_etottime",  $t);
              my $delta    = $etot - ConsumerVal ($hash, $c, "old_etotal", $etot);
              $pcurr       = sprintf "%.6f", $delta / (3600 * $timespan) if($delta);               # Einheitenformel beachten !!: W = Wh / (3600 * s)

              $data{$name}{consumers}{$c}{old_etotal}   = $etot;
              $data{$name}{consumers}{$c}{old_etottime} = $t;
          }

          if (defined $ehist && $etot >= $ehist && ($etot - $ehist) >= $ethreshold) {
              my $consumerco  = $etot - $ehist;
              $consumerco    += HistoryVal ($hash, $day, sprintf("%02d",$nhour), "csme${c}", 0);

              if ($consumerco < 0) {                                                              # V1.32.0
                  $consumerco = 0;
                  my $vl      = 3;
                  my $pre     = '- WARNING -';

                  if ($paref->{debug} =~ /consumption/xs) {
                      $vl  = 1;
                      $pre = 'DEBUG> - WARNING -';
                  }

                  Log3 ($name, $vl, "$name $pre The calculated Energy consumption of >$consumer< is negative. This appears to be an error and the energy consumption of the consumer for the current hour is set to '0'.");
              }

              $paref->{val}      = $consumerco;                                                   # Verbrauch des Consumers aktuelle Stunde
              $paref->{histname} = "csme${c}";

              setPVhistory ($paref);

              delete $paref->{histname};
              delete $paref->{val};
          }

          $paref->{val}      = $etot;                                                             # Totalverbrauch des Verbrauchers
          $paref->{histname} = "csmt${c}";

          setPVhistory ($paref);

          delete $paref->{histname};
          delete $paref->{val};
      }

      if (!$etotread && !$paread) {
          delete $data{$name}{consumers}{$c}{currpower};
          readingsDelete ($hash, "consumer${c}_currentPower");
      }
      else {
          $data{$name}{consumers}{$c}{currpower} = $pcurr;
          storeReading ("consumer${c}_currentPower", $pcurr.' W');
      }
      
      $pcurrsum      += $pcurr;
      $paref->{pcurr} = $pcurr;

      __getAutomaticState     ($paref);                                                                        # Automatic Status des Consumers abfragen
      __calcEnergyPieces      ($paref);                                                                        # Energieverbrauch auf einzelne Stunden für Planungsgrundlage aufteilen
      __planInitialSwitchTime ($paref);                                                                        # Consumer Switch Zeiten planen
      __setTimeframeState     ($paref);                                                                        # Timeframe Status ermitteln
      __setConsRcmdState      ($paref);                                                                        # Consumption Recommended Status setzen
      __switchConsumer        ($paref);                                                                        # Consumer schalten
      __getCyclesAndRuntime   ($paref);                                                                        # Verbraucher - Laufzeit, Tagesstarts und Aktivminuten pro Stunde ermitteln
      __reviewSwitchTime      ($paref);                                                                        # Planungsdaten überprüfen und ggf. neu planen
      __remainConsumerTime    ($paref);                                                                        # Restlaufzeit Verbraucher ermitteln

      delete $paref->{pcurr};

      ## Durchschnittsverbrauch / Betriebszeit ermitteln + speichern
      ################################################################
      my $consumerco = 0;
      my $runhours   = 0;
      my $dnum       = 0;

      for my $n (sort{$a<=>$b} keys %{$data{$name}{pvhist}}) {                                                 # Betriebszeit und gemessenen Verbrauch ermitteln
          my $csme  = HistoryVal ($hash, $n, 99, "csme${c}", 0);
          my $hours = HistoryVal ($hash, $n, 99, "hourscsme${c}", 0);
          next if(!$hours);

          $consumerco += $csme;
          $runhours   += $hours;
          $dnum++;
      }

      if ($dnum) {
          if ($consumerco && $runhours) {
              $data{$name}{consumers}{$c}{avgenergy} = sprintf "%.2f", ($consumerco / $runhours);              # Durchschnittsverbrauch pro Stunde in Wh
          }
          else {
              delete $data{$name}{consumers}{$c}{avgenergy};
          }

          $data{$name}{consumers}{$c}{runtimeAvgDay} = sprintf "%.2f", (($runhours / $dnum) * 60);             # Durchschnittslaufzeit am Tag in Minuten
      }

      ## Consumer Schaltstatus und Schaltzeit für Readings ermitteln
      ################################################################
      my $costate = isConsumerPhysOn  ($hash, $c) ? 'on'  :
                    isConsumerPhysOff ($hash, $c) ? 'off' :
                    "unknown";

      $data{$name}{consumers}{$c}{state}   = $costate;
      my ($pstate,$starttime,$stoptime,$supplmnt) = __getPlanningStateAndTimes ($paref);
      my ($iilt,$rlt) = isInLocktime ($paref);                                                                    # Sperrzeit Status ermitteln
      my $mode        = getConsumerPlanningMode ($hash, $c);                                                      # Planungsmode 'can' oder 'must'
      my $constate    = "name='$alias' state='$costate'";
      $constate      .= " mode='$mode' planningstate='$pstate'";
      $constate      .= " remainLockTime='$rlt'" if($rlt);
      $constate      .= " info='$supplmnt'"      if($supplmnt);

      storeReading ("consumer${c}",                $constate);                                                    # Consumer Infos
      storeReading ("consumer${c}_planned_start", $starttime) if($starttime);                                     # Consumer Start geplant
      storeReading ("consumer${c}_planned_stop",   $stoptime) if($stoptime);                                      # Consumer Stop geplant
  }
  
  $data{$name}{current}{dummyConsumption} = CurrentVal ($name, 'consumption', 0) - $pcurrsum;                     # aktueller Verbrauch - Summe aller ConsumerPower

  delete $paref->{consumer};
  delete $paref->{nhour};

return;
}

################################################################
#   Consumer Status Automatic Modus abfragen und im
#   Hash consumers aktualisieren
################################################################
sub __getAutomaticState {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};

  my $hash     = $defs{$name};
  my $consumer = ConsumerVal ($hash, $c, 'name', '');                                  # Name Consumer Device
  my ($err)    = isDeviceValid ( { name   => $name,
                                   obj    => $consumer,
                                   method => 'string',
                                 }
                               );
  return if($err);

  my $dswitch = ConsumerVal ($hash, $c, 'dswitch', '');                                # alternatives Schaltdevice

  if ($dswitch) {
      ($err) = isDeviceValid ( { name => $name, obj => $dswitch, method => 'string'  } );
      return if($err);
  }
  else {
      $dswitch = $consumer;
  }

  my $autord = ConsumerVal ($hash, $c, 'autoreading', '');                             # Readingname f. Automatiksteuerung
  my $auto   = 1;
  $auto      = ReadingsVal ($dswitch, $autord, 1) if($autord);                         # Reading für Ready-Bit -> Einschalten möglich ?

  $data{$name}{consumers}{$c}{auto} = $auto;                                    # Automaticsteuerung: 1 - Automatic ein, 0 - Automatic aus

return;
}

###################################################################
#    Energieverbrauch auf einzelne Stunden für Planungsgrundlage
#    aufteilen
#    Consumer specific epieces ermitteln + speichern
#    (in Wh)
###################################################################
sub __calcEnergyPieces {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};

  my $hash = $defs{$name};
  my $etot = HistoryVal ($hash, $paref->{day}, sprintf("%02d",$paref->{nhour}), "csmt${c}", 0);

  if ($etot) {
      $paref->{etot} = $etot;
      ___csmSpecificEpieces ($paref);
      delete $paref->{etot};
  }
  else {
      delete $data{$name}{consumers}{$c}{epiecAVG};
      delete $data{$name}{consumers}{$c}{epiecAVG_hours};
      delete $data{$name}{consumers}{$c}{epiecStartEtotal};
      delete $data{$name}{consumers}{$c}{epiecHist};
      delete $data{$name}{consumers}{$c}{epiecHour};

      for my $h (1..EPIECMAXCYCLES) {
          delete $data{$name}{consumers}{$c}{"epiecHist_".$h};
          delete $data{$name}{consumers}{$c}{"epiecHist_".$h."_hours"};
      }
  }

  delete $data{$name}{consumers}{$c}{epieces};

  my $cotype          = ConsumerVal ($hash, $c, "type",      DEFCTYPE);
  my ($err, $mintime) = getConsumerMintime ( { name    => $name,
                                               c       => $c,
                                               nolog   => 1,
                                               lang    => $paref->{lang},
                                               debug   => $paref->{debug}
                                             }
                                           );

  if ($err) {
      Log3 ($name, 1, "$name - ERROR in consumer $c config: $err");
      return;
  }

  my $hours   = ceil ($mintime / 60);                                                          # Einplanungsdauer in h
  my $ctote   = ConsumerVal ($hash, $c, "avgenergy", undef);                                   # gemessener durchschnittlicher Energieverbrauch pro Stunde (Wh)
  $ctote      = $ctote ? $ctote :
                ConsumerVal ($hash, $c, "power", 0);                                           # alternativer nominaler Energieverbrauch in W (bzw. Wh bezogen auf 1 h)

  if (int($hef{$cotype}{f}) == 1) {                                                            # bei linearen Verbrauchertypen die nominale Leistungsangabe verwenden statt Durchschnitt
      $ctote = ConsumerVal ($hash, $c, "power", 0);
  }

  my $epiecef = $ctote * $hef{$cotype}{f};                                                     # Gewichtung erste Laufstunde
  my $epiecel = $ctote * $hef{$cotype}{l};                                                     # Gewichtung letzte Laufstunde

  my $epiecem = $ctote * $hef{$cotype}{m};

  for my $h (1..$hours) {
      my $he;
      $he = $epiecef    if($h == 1               );                                            # kalk. Energieverbrauch Startstunde
      $he = $epiecem    if($h >  1 && $h < $hours);                                            # kalk. Energieverbrauch Folgestunde(n)
      $he = $epiecel    if($h == $hours          );                                            # kalk. Energieverbrauch letzte Stunde

      $data{$name}{consumers}{$c}{epieces}{${h}} = sprintf('%.2f', $he);
  }

return;
}

####################################################################################
#  Verbraucherspezifische Energiestück Ermittlung
#
#  epiecMaxCycles    => gibt an wie viele Zyklen betrachtet werden
#                       sollen
#  epiecHist         => ist die Nummer des Zyklus der aktuell
#                       benutzt wird.
#
#  epiecHist_x       => 1=.. 2=.. 3=.. 4=.. epieces eines Zyklus
#  epiecHist_x_hours => Stunden des Durchlauf bzw. wie viele
#                       Einträge epiecHist_x hat
#  epiecAVG          => 1=.. 2=.. durchschnittlicher Verbrauch pro Betriebsstunde
#                       1, 2, .. usw.
#                       wäre ein KPI um eine angepasste Einschaltung zu
#                       realisieren
#  epiecAVG_hours    => durchschnittliche Betriebsstunden für einen Ein/Aus-Zyklus
#
####################################################################################
sub ___csmSpecificEpieces {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};
  my $etot  = $paref->{etot};
  my $t     = $paref->{t};

  my $hash  = $defs{$name};

  if (ConsumerVal ($hash, $c, "onoff", "off") eq "on") {                                                # Status "Aus" verzögern um Pausen im Waschprogramm zu überbrücken
      $data{$name}{consumers}{$c}{lastOnTime} = $t;
  }

  my $tsloff = defined $data{$name}{consumers}{$c}{lastOnTime} ?
               $t - $data{$name}{consumers}{$c}{lastOnTime}    :
               99;

  debugLog ($paref, "epiecesCalc", qq{specificEpieces -> consumer "$c" - time since last Switch Off (tsloff): $tsloff seconds});

  if ($tsloff < 300) {                                                                                  # erst nach Auszeit >= X Sekunden wird ein neuer epiec-Zyklus gestartet
      my $ecycle          = "";
      my $epiecHist_hours = "";

      if (ConsumerVal ($hash, $c, "epiecHour", -1) < 0) {                                               # neue Aufzeichnung
          $data{$name}{consumers}{$c}{epiecStartTime} = $t;
          $data{$name}{consumers}{$c}{epiecHist}     += 1;
          $data{$name}{consumers}{$c}{epiecHist}      = 1 if(ConsumerVal ($hash, $c, "epiecHist", 0) > EPIECMAXCYCLES);

          $ecycle = "epiecHist_".ConsumerVal ($hash, $c, "epiecHist", 0);

          delete $data{$name}{consumers}{$c}{$ecycle};                                           # Löschen, wird neu erfasst
      }

      $ecycle          = "epiecHist_".ConsumerVal ($hash, $c, "epiecHist", 0);                          # Zyklusnummer für Namen
      $epiecHist_hours = "epiecHist_".ConsumerVal ($hash, $c, "epiecHist", 0)."_hours";
      my $epiecHour    = floor (($t - ConsumerVal ($hash, $c, "epiecStartTime", $t)) / 60 / 60) + 1;    # aktuelle Betriebsstunde ermitteln, ( / 60min) mögliche wäre auch durch 15min /Minute /Stunde

      debugLog ($paref, "epiecesCalc", qq{specificEpieces -> consumer "$c" - current cycle number (ecycle): $ecycle});
      debugLog ($paref, "epiecesCalc", qq{specificEpieces -> consumer "$c" - Operating hour after switch on (epiecHour): $epiecHour});

      if (ConsumerVal ($hash, $c, "epiecHour", 0) != $epiecHour) {                                      # Betriebsstundenwechsel ? Differenz von etot noch auf die vorherige Betriebsstunde anrechnen
          my $epiecHour_last = $epiecHour - 1;

          $data{$name}{consumers}{$c}{$ecycle}{$epiecHour_last} = sprintf '%.2f', ($etot - ConsumerVal ($hash, $c, "epiecStartEtotal", 0)) if($epiecHour > 1);
          $data{$name}{consumers}{$c}{epiecStartEtotal}         = $etot;

          debugLog ($paref, "epiecesCalc", qq{specificEpieces -> consumer "$c" - Operating hours change - new etotal (epiecStartEtotal): $etot});
      }

      my $ediff                                               = $etot - ConsumerVal ($hash, $c, "epiecStartEtotal", 0);
      $data{$name}{consumers}{$c}{$ecycle}{$epiecHour} = sprintf '%.2f', $ediff;
      $data{$name}{consumers}{$c}{epiecHour}           = $epiecHour;
      $data{$name}{consumers}{$c}{$epiecHist_hours}    = $ediff ? $epiecHour : $epiecHour - 1;           # wenn mehr als 1 Wh verbraucht wird die Stunde gezählt

      debugLog ($paref, "epiecesCalc", qq{specificEpieces -> consumer "$c" - energy consumption in operating hour $epiecHour (ediff): $ediff});
  }
  else {                                                                                                 # Durchschnitt ermitteln
      if (ConsumerVal ($hash, $c, "epiecHour", 0) > 0) {
          my $hours = 0;

          for my $h (1..EPIECMAXCYCLES) {                                                                # durchschnittliche Betriebsstunden über alle epieces ermitteln und aufrunden
              $hours += ConsumerVal ($hash, $c, "epiecHist_".$h."_hours", 0);
          }

          my $avghours                                   = ceil ($hours / EPIECMAXCYCLES);
          $data{$name}{consumers}{$c}{epiecAVG_hours} = $avghours;                                       # durchschnittliche Betriebsstunden pro Zyklus

          debugLog ($paref, "epiecesCalc", qq{specificEpieces -> consumer "$c" - Average operating hours per cycle (epiecAVG_hours): $avghours});

          delete $data{$name}{consumers}{$c}{epiecAVG};                                                  # Durchschnitt für epics ermitteln

          for my $hour (1..$avghours) {                                                                  # jede Stunde durchlaufen
              my $hoursE = 1;

              for my $h (1..EPIECMAXCYCLES) {                                                            # jedes epiec durchlaufen
                  my $ecycle = "epiecHist_".$h;

                  if (defined $data{$name}{consumers}{$c}{$ecycle}{$hour}) {
                      if ($data{$name}{consumers}{$c}{$ecycle}{$hour} > 5) {
                          $data{$name}{consumers}{$c}{epiecAVG}{$hour} += $data{$name}{consumers}{$c}{$ecycle}{$hour};
                          $hoursE += 1;
                      }
                  }

              }

              my $eavg  = defined $data{$name}{consumers}{$c}{epiecAVG}{$hour} ?
                          $data{$name}{consumers}{$c}{epiecAVG}{$hour}         :
                          0;

              my $ahval = sprintf '%.2f', $eavg / $hoursE;                                               # Durchschnitt ermittelt und speichern
              $data{$name}{consumers}{$c}{epiecAVG}{$hour} = $ahval;

              debugLog ($paref, "epiecesCalc", qq{specificEpieces -> consumer "$c" - Average epiece of operating hour $hour: $ahval});
          }
      }

      $data{$name}{consumers}{$c}{epiecHour} = -1;                                                       # epiecHour auf initialwert setzen für nächsten durchlauf
  }

return;
}

###################################################################
#    Consumer Schaltzeiten planen
###################################################################
sub __planInitialSwitchTime {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};
  my $debug = $paref->{debug};

  my $hash = $defs{$name};
  my $dnp  = ___noPlanRelease ($paref);

  if ($dnp) {
      if ($debug =~ /consumerPlanning/x) {
          Log3 ($name, 4, qq{$name DEBUG> Planning consumer "$c" - name: }.ConsumerVal ($hash, $c, 'name', '').
                          qq{ alias: }.ConsumerVal ($hash, $c, 'alias', ''));
          Log3 ($name, 4, qq{$name DEBUG> Planning consumer "$c" - $dnp});
      }

      return;
  }

  if ($debug =~ /consumerPlanning/x) {
      Log3 ($name, 1, qq{$name DEBUG> ############### consumerPlanning consumer "$c" ############### });
      Log3 ($name, 1, qq{$name DEBUG> Planning consumer "$c" - name: }.ConsumerVal ($hash, $c, 'name', '').
                      qq{ alias: }.ConsumerVal ($hash, $c, 'alias', ''));
  }

  if (ConsumerVal ($hash, $c, 'type', DEFCTYPE) eq 'noSchedule') {
      debugLog ($paref, "consumerPlanning", qq{consumer "$c" - }.$hqtxt{scnp}{EN});

      $paref->{ps} = 'noSchedule';

      ___setConsumerPlanningState ($paref);

      delete $paref->{ps};
      return;
  }

  ___doPlanning ($paref);

return;
}

###################################################################
#    Entscheidung ob die Planung für den Consumer
#    vorgenommen werden soll oder nicht
###################################################################
sub ___noPlanRelease {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};                                                                 # aktuelle Zeit
  my $c     = $paref->{consumer};

  my $hash = $defs{$name};
  my $dnp  = 0;                                                                            # 0 -> Planung, 1 -> keine Planung

  if (ConsumerVal ($hash, $c, 'planstate', undef)) {                                       # Verbraucher ist schon geplant/gestartet/fertig
      $dnp = qq{consumer is already planned};
  }
  elsif (isSolCastUsed ($hash) || isForecastSolarUsed ($hash)) {
      my ($rapi, $wapi) = getStatusApiName ($hash);
      my $tdc           = StatusAPIVal ($hash, $rapi, '?All', 'todayDoneAPIcalls', 0);

      if ($tdc < 1) {                                                                      # Planung erst nach dem zweiten API Abruf freigeben
           $dnp = qq{do not plan because off "todayDoneAPIcalls" is not set};
      }
  }
  else {                                                                                   # Planung erst ab "LEADTIME" vor Sonnenaufgang freigeben
      my $sunrise = CurrentVal ($hash, 'sunriseTodayTs', 32529945600);

      if ($t < $sunrise - LEADTIME) {
          $dnp = "do not plan because off current time is less than sunrise minus ".(LEADTIME / 3600)." hour";
      }
  }

return $dnp;
}

###################################################################
#    Consumer Review Schaltzeiten und neu planen wenn der
#    Consumer noch nicht in Operation oder finished ist
#    (nach Consumer Schaltung)
###################################################################
sub __reviewSwitchTime {
  my $paref = shift;
  my $name      = $paref->{name};
  my $c         = $paref->{consumer};

  my $hash      = $defs{$name};
  my $pstate    = ConsumerVal    ($hash, $c, 'planstate',   '');
  my $plswon    = ConsumerVal    ($hash, $c, 'planswitchon', 0);                      # bisher geplante Switch on Zeit
  my $simpCstat = simplifyCstate ($pstate);
  my $t         = $paref->{t};

  if ($simpCstat =~ /planned|suspended/xs) {
      if ($t < $plswon || $t > $plswon + 300) {                                       # geplante Switch-On Zeit ist 5 Min überschritten und immer noch "planned"
          my $minute = $paref->{minute};

          for my $m (qw(15 45)) {
              if (int $minute >= $m) {
                  if (!defined $hash->{HELPER}{$c.'M'.$m.'DONE'}) {
                      my $name                          = $paref->{name};
                      $hash->{HELPER}{$c.'M'.$m.'DONE'} = 1;

                      debugLog ($paref, "consumerPlanning", qq{consumer "$c" - Review switch time planning name: }.ConsumerVal ($hash, $c, 'name', '').
                                                            qq{ alias: }.ConsumerVal ($hash, $c, 'alias', ''));

                      $paref->{replan} = 1;                                           # V 1.35.0
                      ___doPlanning ($paref);
                      delete $paref->{replan};
                  }
              }
              else {
                  delete $hash->{HELPER}{$c.'M'.$m.'DONE'};
              }
          }
      }
  }
  else {
      delete $hash->{HELPER}{$c.'M15DONE'};
      delete $hash->{HELPER}{$c.'M45DONE'};
  }

return;
}

###################################################################
#    Consumer Planung ausführen
###################################################################
sub ___doPlanning {
  my $paref = shift;
  my $name   = $paref->{name};
  my $c      = $paref->{consumer};
  my $debug  = $paref->{debug};
  my $lang   = $paref->{lang};
  my $nh     = $data{$name}{nexthours};
  my $cicfip = CurrentVal ($name, 'consForecastInPlanning', 0);                            # soll Consumption Vorhersage in die Überschußermittlung eingehen ?

  my $hash   = $defs{$name};

  debugLog ($paref, "consumerPlanning", qq{consumer "$c" - consider consumption forecast in consumer planning (attr 'plantControl'): }.($cicfip ? 'yes' : 'no'));

  my %max;
  my %mtimes;

  ## max. PV-Forecast bzw. Überschuß (bei gesetzen consForecastInPlanning) ermitteln
  ####################################################################################
  for my $idx (sort keys %{$nh}) {
      my $pvfc    = NexthoursVal ($hash, $idx, 'pvfc',    0);
      my $confcex = NexthoursVal ($hash, $idx, 'confcEx', 0);                              # prognostizierter Verbrauch ohne registrierte Consumer mit gesetzten Schlüssel exconfc

      my $spexp   = $pvfc - ($cicfip ? $confcex : 0);                                      # prognostizierter Energieüberschuß (kann negativ sein)

      my ($hour)              = $idx =~ /NextHour(\d+)/xs;
      $max{$spexp}{starttime} = NexthoursVal ($hash, $idx, 'starttime', '');
      $max{$spexp}{today}     = NexthoursVal ($hash, $idx, 'today',      0);
      $max{$spexp}{nexthour}  = int ($hour);
  }

  my $order = 1;
  
  for my $k (reverse sort{$a<=>$b} keys %max) {
      my $ts                  = timestringToTimestamp ($max{$k}{starttime});

      $max{$order}{spexp}     = $k;
      $max{$order}{ts}        = $ts;
      $max{$order}{starttime} = $max{$k}{starttime};
      $max{$order}{nexthour}  = $max{$k}{nexthour};
      $max{$order}{today}     = $max{$k}{today};

      $mtimes{$ts}{spexp}     = $k;
      $mtimes{$ts}{starttime} = $max{$k}{starttime};
      $mtimes{$ts}{nexthour}  = $max{$k}{nexthour};
      $mtimes{$ts}{today}     = $max{$k}{today};

      delete $max{$k};

      $order++;
  }

  my $epiece1 = (~0 >> 1);
  my $epieces = ConsumerVal ($hash, $c, "epieces", "");

  if (ref $epieces eq "HASH") {
      $epiece1 = $data{$name}{consumers}{$c}{epieces}{1};
  }
  else {
      return;
  }

  debugLog ($paref, "consumerPlanning", qq{consumer "$c" - epiece1: $epiece1});

  my $mode            = getConsumerPlanningMode ($hash, $c);                                           # Planungsmode 'can' oder 'must'
  my $calias          = ConsumerVal ($hash, $c, 'alias',     '');
  my $oldplanstate    = ConsumerVal ($hash, $c, 'planstate', '');                                      # V. 1.35.0

  my ($err, $mintime) = getConsumerMintime ( { name    => $name,                                       # Einplanungsdauer
                                               c       => $c,
                                               lang    => $lang,
                                               debug   => $debug
                                             }
                                           );

  if ($err) {
      Log3 ($name, 1, "$name - ERROR in consumer $c config: $err");
      return;
  }

  debugLog ($paref, "consumerPlanning", qq{consumer "$c" - mode: $mode, mintime: $mintime, relevant method: surplus});

  my $stopdiff       = $mintime * 60;
  $paref->{maxref}   = \%max;
  $paref->{mintime}  = $mintime;
  $paref->{stopdiff} = $stopdiff;

  if ($mode eq 'can') {                                                                                # Verbraucher kann geplant werden
      if ($debug =~ /consumerPlanning/x) {
          for my $m (sort{$a<=>$b} keys %mtimes) {
              Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - surplus expected: $mtimes{$m}{spexp}, }.
                              qq{starttime: }.$mtimes{$m}{starttime}.", ".
                              qq{nexthour: $mtimes{$m}{nexthour}, today: $mtimes{$m}{today}});
          }
      }

      for my $ts (sort{$a<=>$b} keys %mtimes) {
          if ($mtimes{$ts}{spexp} >= $epiece1) {                                                       # die früheste Startzeit sofern Überschuß größer als Bedarf
              my $starttime       = $mtimes{$ts}{starttime};
              $paref->{starttime} = $starttime;
              $starttime          = ___switchonTimelimits ($paref);
              
              delete $paref->{starttime};

              my $startts       = timestringToTimestamp ($starttime);                                  # Unix Timestamp für geplanten Switch on
              $paref->{ps}      = $paref->{replan} ? 'replanned:' : 'planned:';                        # V 1.35.0
              $paref->{startts} = $startts;
              $paref->{stopts}  = $startts + $stopdiff;

              ___setConsumerPlanningState ($paref);
              ___saveEhodpieces           ($paref);

              delete $paref->{ps};
              delete $paref->{startts};
              delete $paref->{stopts};

              last;
          }
          else {
              $paref->{supplement} = encode('utf8', $hqtxt{emsple}{$lang});                          # 'erwarteter max Überschuss weniger als'
              $paref->{ps}         = 'suspended:';

              ___setConsumerPlanningState ($paref);

              delete $paref->{ps};
              delete $paref->{supplement};
          }
      }
  }
  else {                                                                                               # Verbraucher _muß_ geplant werden
      if ($debug =~ /consumerPlanning/x) {
          for my $o (sort{$a<=>$b} keys %max) {
              Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - surplus: $max{$o}{spexp}, }.
                              qq{starttime: }.$max{$o}{starttime}.", ".
                              qq{nexthour: $max{$o}{nexthour}, today: $max{$o}{today}});
          }
      }

      my $done;

      for my $o (sort{$a<=>$b} keys %max) {
          next if(!$max{$o}{today});                                                                   # der max-Wert von heute ist auszuwählen

          $paref->{elem} = $o;
          ___planMust ($paref);
          delete $paref->{elem};

          $done = 1;

          last;
      }

      if (!$done) {
          $paref->{supplement} = encode('utf8', $hqtxt{nmspld}{$lang});                              # 'kein max Überschuss für den aktuellen Tag gefunden'
          $paref->{ps}         = 'suspended:';

          ___setConsumerPlanningState ($paref);

          delete $paref->{ps};
          delete $paref->{supplement};
      }
  }

  my $planstate = ConsumerVal ($hash, $c, 'planstate',      '');
  my $planspmlt = ConsumerVal ($hash, $c, 'planSupplement', '');

  if ($planstate && ($planstate ne $oldplanstate)) {                                                   # V 1.35.0
      Log3 ($name, 3, qq{$name - Consumer "$calias" $planstate $planspmlt});
  }

  writeCacheToFile ($hash, 'consumers', $csmcache.$name);                                              # Cache File Consumer schreiben

  ___setPlanningDeleteMeth ($paref);

return;
}

################################################################
#   die geplanten EIN-Stunden des Tages mit den dazu gehörigen
#   Consumer spezifischen epieces im Consumer-Hash speichern
################################################################
sub ___saveEhodpieces {
  my $paref   = shift;
  my $name    = $paref->{name};
  my $c       = $paref->{consumer};
  my $startts = $paref->{startts};                                           # Unix Timestamp für geplanten Switch on
  my $stopts  = $paref->{stopts};                                            # Unix Timestamp für geplanten Switch off

  my $hash = $defs{$name};
  my $p    = 1;
  delete $data{$name}{consumers}{$c}{ehodpieces};

  for (my $i = $startts; $i <= $stopts; $i+=3600) {
      my $chod    = (strftime "%H", localtime($i)) + 1;
      my $epieces = ConsumerVal ($hash, $c, 'epieces', '');

      my $ep = 0;
      if (ref $epieces eq "HASH") {
          $ep = defined $data{$name}{consumers}{$c}{epieces}{$p} ?
                        $data{$name}{consumers}{$c}{epieces}{$p} :
                        0;
      }
      else {
          last;
      }

      $chod                                          = sprintf '%02d', $chod;
      $data{$name}{consumers}{$c}{ehodpieces}{$chod} = sprintf '%.2f', $ep if($ep);

      $p++;
  }

return;
}

################################################################
#     Planungsdaten bzw. aktuelle Planungszustände setzen
################################################################
sub ___setConsumerPlanningState {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $type      = $paref->{type};
  my $c         = $paref->{consumer};
  my $ps        = $paref->{ps};                    # Planstatus
  my $supplmnt  = $paref->{supplement} // '';
  my $startts   = $paref->{startts};               # Unix Timestamp für geplanten Switch on
  my $stopts    = $paref->{stopts};                # Unix Timestamp für geplanten Switch off
  my $lonts     = $paref->{lastAutoOnTs};          # Timestamp des letzten On-Schaltens bzw. letzter Fortsetzung im Automatikmodus
  my $loffts    = $paref->{lastAutoOffTs};         # Timestamp des letzten Off-Schaltens bzw. letzter Unterbrechnung im Automatikmodus
  my $lang      = $paref->{lang};

  $data{$name}{consumers}{$c}{planSupplement} = $supplmnt;

  return if(!$ps);

  my ($starttime,$stoptime);

  if (defined $lonts) {
      $data{$name}{consumers}{$c}{lastAutoOnTs} = $lonts;
  }

  if (defined $loffts) {
      $data{$name}{consumers}{$c}{lastAutoOffTs} = $loffts;
  }

  if ($startts) {
      $starttime                                       = (timestampToTimestring ($startts, $lang))[3];
      $data{$name}{consumers}{$c}{planswitchon} = $startts;
  }

  if ($stopts) {
      $stoptime                                         = (timestampToTimestring ($stopts, $lang))[3];
      $data{$name}{consumers}{$c}{planswitchoff} = $stopts;
  }

  $ps .= " "              if($starttime || $stoptime);
  $ps .= $starttime       if($starttime);
  $ps .= $stoptime        if(!$starttime && $stoptime);
  $ps .= " - ".$stoptime  if($starttime  && $stoptime);

  $data{$name}{consumers}{$c}{planstate} = $ps;

return;
}

################################################################
#          Consumer Zeiten MUST planen
################################################################
sub ___planMust {
  my $paref    = shift;
  my $name     = $paref->{name};
  my $type     = $paref->{type};
  my $c        = $paref->{consumer};
  my $maxref   = $paref->{maxref};
  my $elem     = $paref->{elem};
  my $mintime  = $paref->{mintime};
  my $stopdiff = $paref->{stopdiff};
  my $lang     = $paref->{lang};

  my $maxts     = timestringToTimestamp ($maxref->{$elem}{starttime});                 # Unix Timestamp des max. Überschusses heute
  my $half      = floor ($mintime / 2 / 60);                                           # die halbe Gesamtplanungsdauer in h als Vorlaufzeit einkalkulieren
  my $startts   = $maxts - ($half * 3600);
  my $starttime = (timestampToTimestring ($startts, $lang))[3];

  $paref->{starttime} = $starttime;
  $starttime          = ___switchonTimelimits ($paref);
  delete $paref->{starttime};

  $startts   = timestringToTimestamp ($starttime);
  my $stopts = $startts + $stopdiff;

  $paref->{ps}      = 'planned:';
  $paref->{startts} = $startts;                                                        # Unix Timestamp für geplanten Switch on
  $paref->{stopts}  = $stopts;                                                         # Unix Timestamp für geplanten Switch off

  ___setConsumerPlanningState ($paref);
  ___saveEhodpieces           ($paref);

  delete $paref->{ps};
  delete $paref->{startts};
  delete $paref->{stopts};

return;
}

################################################################
#   Einschaltgrenzen berücksichtigen und Korrektur
#   zurück liefern
#   notbefore, notafter muß in der Form "hh[:mm]" vorliegen
################################################################
sub ___switchonTimelimits {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $c         = $paref->{consumer};
  my $date      = $paref->{date};
  my $starttime = $paref->{starttime};
  my $lang      = $paref->{lang};
  my $t         = $paref->{t};

  my $hash = $defs{$name};
  my $startts;

  if (isSunPath ($hash, $c)) {                                                          # SunPath ist in mintime gesetzt
      my ($riseshift, $setshift) = sunShift   ($hash, $c);
      $startts                   = CurrentVal ($hash, 'sunriseTodayTs', 0) + $riseshift;
      $starttime                 = (timestampToTimestring ($startts, $lang))[3];

      debugLog ($paref, "consumerPlanning", qq{consumer "$c" - starttime is set to >$starttime< due to >SunPath< is used});
  }

  my $origtime  = $starttime;
  my $notbefore = ConsumerVal ($hash, $c, 'notbefore', 0);
  my $notafter  = ConsumerVal ($hash, $c, 'notafter',  0);

  my ($err, $vala, $valb);

  if ($notbefore =~ m/^\s*\{.*\}\s*$/xs) {                                             # notbefore als Perl-Code definiert
      ($err, $valb) = checkCode ($name, $notbefore, 'cc1');
      if (!$err && checkhhmm ($valb)) {
          $notbefore = $valb;
          debugLog ($paref, "consumerPlanning", qq{consumer "$c" - got 'notbefore' function result: $valb});
      }
      else {
          Log3 ($name, 1, "$name - ERROR - the result of the Perl code in 'notbefore' is incorrect: $valb");
          $notbefore = 0;
      }
  }

  if ($notafter =~ m/^\s*(\{.*\})\s*$/xs) {                                           # notafter als Perl-Code definiert
      ($err, $vala) = checkCode ($name, $notafter, 'cc1');
      if (!$err && checkhhmm ($vala)) {
          $notafter = $vala;
          debugLog ($paref, "consumerPlanning", qq{consumer "$c" - got 'notafter' function result: $vala})
      }
      else {
          Log3 ($name, 1, "$name - ERROR - the result of the Perl code in the 'notafter' key is incorrect: $vala");
          $notafter = 0;
      }
  }

  my ($nbfhh, $nbfmm, $nafhh, $nafmm);

  if ($notbefore) {
      ($nbfhh, $nbfmm) = split ":", $notbefore;
      $nbfmm         //= '00';
      $notbefore       = (int $nbfhh) . $nbfmm;
  }

  if ($notafter) {
      ($nafhh, $nafmm) = split ":", $notafter;
      $nafmm         //= '00';
      $notafter        = (int $nafhh) . $nafmm;
  }

  debugLog ($paref, "consumerPlanning", qq{consumer "$c" - used 'notbefore' term: }.(defined $notbefore ? $notbefore : ''));
  debugLog ($paref, "consumerPlanning", qq{consumer "$c" - used 'notafter' term: } .(defined $notafter  ? $notafter  : ''));

  my $change = q{};

  if ($t > timestringToTimestamp ($starttime)) {
      $starttime   = (timestampToTimestring ($t, $lang))[3];
      $change      = 'current time';
  }

  my ($starthour, $startminute) = $starttime =~ /\s(\d{2}):(\d{2}):/xs;
  my $start = (int $starthour) . $startminute;

  if ($notbefore && $start < $notbefore) {
      $nbfhh     = sprintf "%02d", $nbfhh;
      $starttime =~ s/\s(\d{2}):(\d{2}):/ $nbfhh:$nbfmm:/x;
      $change    = 'notbefore';
  }

  if ($notafter && $start > $notafter) {
      $nafhh     = sprintf "%02d", $nafhh;
      $starttime =~ s/\s(\d{2}):(\d{2}):/ $nafhh:$nafmm:/x;
      $change    = 'notafter';
  }

  if ($change) {
      my $cname = ConsumerVal ($hash, $c, 'name', '');
      debugLog ($paref, "consumerPlanning", qq{consumer "$c" - Planned starttime of "$cname" changed from "$origtime" to "$starttime" due to $change condition});
  }

return $starttime;
}

################################################################
#   Löschmethode der Planungsdaten setzen
################################################################
sub ___setPlanningDeleteMeth {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};

  my $hash    = $defs{$name};
  my $sonkey  = ConsumerVal ($hash, $c, "planswitchon",  "");
  my $soffkey = ConsumerVal ($hash, $c, "planswitchoff", "");

  if($sonkey && $soffkey) {
      my $onday  = strftime "%d", localtime($sonkey);
      my $offday = strftime "%d", localtime($soffkey);

      if ($offday ne $onday) {                                                          # Planungsdaten spezifische Löschmethode
          $data{$name}{consumers}{$c}{plandelete} = "specific";
      }
      else {                                                                            # Planungsdaten Löschmethode jeden Tag in Stunde 0 (_specialActivities)
          $data{$name}{consumers}{$c}{plandelete} = "regular";
      }
  }

return;
}

################################################################
#   Timeframe Status ermitteln
################################################################
sub __setTimeframeState {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};
  my $t     = $paref->{t};                                                            # aktueller Unixtimestamp

  my $hash    = $defs{$name};
  my $startts = ConsumerVal ($hash, $c, "planswitchon",  undef);                      # geplante Unix Startzeit
  my $stopts  = ConsumerVal ($hash, $c, "planswitchoff", undef);                      # geplante Unix Stopzeit

  if ($startts && $t >= $startts && $stopts && $t <= $stopts) {                       # ist Zeit innerhalb der Planzeit ein/aus ?
      $data{$name}{consumers}{$c}{isIntimeframe} = 1;
  }
  else {
      $data{$name}{consumers}{$c}{isIntimeframe} = 0;
  }

return;
}

################################################################
#   Consumption Recommended Status setzen
################################################################
sub __setConsRcmdState {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};
  my $debug = $paref->{debug};

  my $hash       = $defs{$name};
  my $nompower   = ConsumerVal      ($name, $c, 'power',                  0);             # Consumer nominale Leistungsaufnahme (W)
  my $ccr        = AttrVal          ($name, 'ctrlConsRecommendReadings', '');             # Liste der Consumer für die ConsumptionRecommended-Readings erstellt werden sollen
  my $rescons    = isConsumerPhysOn ($hash, $c) ? 0 : $nompower;                          # resultierender Verbauch nach Einschaltung Consumer

  my ($method, $surplus) = determSurplus ($name, $c);                                     # Consumer spezifische Ermittlung des Energieüberschußes

  $data{$name}{consumers}{$c}{surpmethResult} = sprintf "%.0f", $surplus;                 # Ergebnis der Surplus Ermittlung im Consumerstammsatz speichern, Forum: https://forum.fhem.de/index.php?msg=1345058

  if ($debug =~ /consumerSwitching${c}/x) {
      my $splref = CurrentVal ($name, 'surplusslidereg', '.');
      my $spser  = ref $splref eq 'ARRAY' ? join ' ', @{$splref} : undef;
      
      Log3 ($name, 1, qq{$name DEBUG> ############### consumerSwitching consumer "$c" ###############});
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - ConsumptionRecommended calc method: $method, surplus: }.
                         (defined $surplus ? $surplus : 'undef'));
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - method base: $spser}) if($method =~ /average|median/xs);
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - additional consumption after switching on (if currently 'off'): $rescons W});
  }

  my ($spignore, $info, $err) = isSurplusIgnoCond ($hash, $c, $debug);                    # PV Überschuß ignorieren?

  Log3 ($name, 1, "$name - $err") if($err);
  
  if ($debug =~ /consumerSwitching${c}/x && $info) {
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - IgnoreCondition - $info});
  }

  if (!defined $surplus) {                                                                # $surplus kann undef sein! -> dann bisherigen isConsumptionRecommended verwenden
      $data{$name}{consumers}{$c}{isConsumptionRecommended} = ReadingsVal ($name, "consumer${c}_ConsumptionRecommended", 0);
  }
  elsif (!$nompower || $surplus - $rescons > 0 || $spignore) {
      $data{$name}{consumers}{$c}{isConsumptionRecommended} = 1;                          # Einschalten des Consumers günstig bzw. Freigabe für "on" von Überschußseite erteilt
  }
  else {
      $data{$name}{consumers}{$c}{isConsumptionRecommended} = 0;
  }

  if ($ccr =~ /$c/xs) {
      storeReading ("consumer${c}_ConsumptionRecommended", ConsumerVal ($hash, $c, 'isConsumptionRecommended', 0));
  }

return;
}

################################################################
#   Planungsdaten Consumer prüfen und ggf. starten/stoppen
################################################################
sub __switchConsumer {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};
  my $debug = $paref->{debug};
  my $state = $paref->{state};

  $paref->{fscss} = 1;                                                            # erster Subaufruf Consumer Schaltzustände ermitteln & setzen
  $state = ___setConsumerSwitchingState ($paref);
  delete $paref->{fscss};

  $paref->{befsw} = 1;                                                            # Status vor Switching
  __setPhysLogSwState ($paref);                                                   # physischen / logischen Schaltzustand festhalten

  $state = ___switchConsumerOn          ($paref);                                 # Verbraucher Einschaltbedingung prüfen + auslösen
  $state = ___switchConsumerOff         ($paref);                                 # Verbraucher Ausschaltbedingung prüfen + auslösen
  $state = ___setConsumerSwitchingState ($paref);                                 # Consumer Schaltzustände nach Switching ermitteln & setzen

  $paref->{befsw} = 0;                                                            # Status nach Switching
  __setPhysLogSwState ($paref);                                                   # physischen / logischen Schaltzustand festhalten
  delete $paref->{befsw};

  $paref->{state} = $state;

return;
}

################################################################
#  Verbraucher einschalten
################################################################
sub ___switchConsumerOn {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};
  my $t     = $paref->{t};                                                                        # aktueller Unixtimestamp
  my $state = $paref->{state};
  my $debug = $paref->{debug};
  my $lang  = $paref->{lang};

  my $hash                    = $defs{$name};
  my ($err, $cname, $dswname) = getCDnames ($hash, $c);                                           # Consumer und Switch Device Name

  if ($err) {
      $state = 'ERROR - '.$err;
      Log3 ($name, 1, "$name - $state");
      return $state;
  }

  my $pstate    = ConsumerVal ($hash, $c, 'planstate',        '');
  my $startts   = ConsumerVal ($hash, $c, 'planswitchon',  undef);                                # geplante Unix Startzeit
  my $oncom     = ConsumerVal ($hash, $c, 'oncom',            '');                                # Set Command für "on"
  my $auto      = ConsumerVal ($hash, $c, 'auto',              1);
  my $calias    = ConsumerVal ($hash, $c, 'alias',        $cname);                                # Consumer Device Alias
  my $simpCstat = simplifyCstate ($pstate);
  my $isInTime  = isInTimeframe  ($hash, $c);

  my ($swoncond, $swoffcond, $infon, $infoff);

  ($swoncond, $infon, $err) = isAddSwitchOnCond ($name, $c);                                      # zusätzliche Switch on Bedingung
  Log3 ($name, 1, "$name - $err") if($err);

  ($swoffcond, $infoff, $err) = isAddSwitchOffCond ($hash, $c);                                   # zusätzliche Switch off Bedingung
  Log3 ($name, 1, "$name - $err") if($err);

  my ($iilt,$rlt) = isInLocktime ($paref);                                                        # Sperrzeit Status ermitteln

  if ($debug =~ /consumerSwitching${c}/x) {                                                       # nur für Debugging
      my $cons   = CurrentVal  ($hash, 'consumption',  0);
      my $nompow = ConsumerVal ($hash, $c, 'power',  '-');
      my $sp     = CurrentVal  ($hash, 'surplus',      0);

      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - general switching parameters => }.
                      qq{auto mode: $auto, Current household consumption: $cons W, nompower: $nompow, surplus: $sp W, }.
                      qq{planstate: $pstate, starttime: }.($startts ? (timestampToTimestring ($startts, $lang))[0] : "undef")
           );
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - isInLocktime: $iilt}.($rlt ? ", remainLockTime: $rlt seconds" : ''));
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - Check Context 'switch on' => }.
                      qq{swoncond: $swoncond, on-command: $oncom }
           );
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - isAddSwitchOnCond Info: $infon})   if($infon);
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - isAddSwitchOffCond Info: $infoff}) if($infoff);
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - device '$dswname' is used as switching device});

      if ($simpCstat =~ /planned|priority|starting|continuing/xs && $isInTime && $iilt) {
          Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - switching on postponed by >isInLocktime<});
      }
  }

  my $isintable = isInterruptable ($hash, $c, 0, 1);                                              # mit Ausgabe Interruptable Info im Debug

  if ($debug =~ /consumerSwitching${c}/x) {
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - Interrupt Characteristic value: $isintable -> $intrptcatic{$isintable}});
  }

  my $isConsRcmd = isConsRcmd ($hash, $c);

  my $supplmnt         = ConsumerVal ($hash, $c, 'planSupplement', '');
  $paref->{supplement} = '' if($supplmnt =~ /swoncond\snot|swoncond\snicht/xs && $swoncond);
  $paref->{supplement} = encode('utf8', $hqtxt{swonnm}{$lang}) if(!$swoncond);                   # 'swoncond not met'
  $paref->{supplement} = encode('utf8', $hqtxt{swofmt}{$lang}) if($swoffcond);                   # 'swoffcond met'

  if (defined $paref->{supplement}) {
      ___setConsumerPlanningState ($paref);
      delete $paref->{supplement};
  }

  if ($auto 
      && $oncom 
      && $swoncond 
      && !$swoffcond                                                                              # kein Einschalten wenn zusätzliche Switch off Bedingung oder Sperrzeit zutrifft
      && !$iilt 
      && $simpCstat =~ /planned|priority|starting/xs 
      && $isInTime) {                                                                             # Verbraucher Start ist geplant && Startzeit überschritten
      my $mode   = getConsumerPlanningMode        ($hash, $c);                                    # Planungsmode 'can' oder 'must'
      my $enable = ___enableSwitchByBatPrioCharge ($paref);                                       # Vorrangladung Batterie ?

      debugLog ($paref, "consumerSwitching${c}", qq{Consumer switch enable by battery state: $enable});

      if ($mode eq 'can' && !$enable) {                                                           # Batterieladung - keine Verbraucher "Einschalten" Freigabe
          $paref->{ps} = "priority charging battery";

          ___setConsumerPlanningState ($paref);

          delete $paref->{ps};
      }
      elsif ($mode eq "must" || $isConsRcmd) {                                                    # "Muss"-Planung oder Überschuß > Leistungsaufnahme (can)
          $state = qq{switching Consumer '$calias' to '$oncom', command: "set $dswname $oncom"};

          if ($debug =~ /consumerSwitching${c}/x) {
              Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - send switch command now: "set $dswname $oncom"});
          }
          else {
              Log3 ($name, 3, "$name - $state (Automatic = $auto)");
          }

          CommandSet (undef, "$dswname $oncom");

          $paref->{ps} = "switching on:";
          ___setConsumerPlanningState ($paref);
          delete $paref->{ps};

          writeCacheToFile ($hash, 'consumers', $csmcache.$name);                                  # Cache File Consumer schreiben
      }
  }                                                                                              
  elsif ($isConsRcmd                                                                               # unterbrochenen Consumer fortsetzen  
         && ($isintable == 0 || $isintable == 1 || $isintable == 3)                                # $isintable == 0 -> Consumer auch einschalten wenn sie nicht unterbrechbar sind
         && $isInTime
         && $auto
         && $oncom
         && !$iilt
         && $simpCstat =~ /interrupted|interrupting|continuing/xs) {
      my $cause = $isintable == 3 ? 'interrupt condition no longer present' : 'existing surplus';
      $state    = qq{switching Consumer '$calias' to '$oncom', command: "set $dswname $oncom", cause: $cause};

      if ($debug =~ /consumerSwitching${c}/x) {
          Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - send switch command now: "set $dswname $oncom"});
      }
      else {
          Log3 ($name, 3, "$name - $state");
      }

      CommandSet (undef, "$dswname $oncom");

      $paref->{ps} = "continuing:";
      ___setConsumerPlanningState ($paref);
      delete $paref->{ps};

      writeCacheToFile ($hash, 'consumers', $csmcache.$name);                                     # Cache File Consumer schreiben
  }

return $state;
}

################################################################
#  Verbraucher ausschalten
################################################################
sub ___switchConsumerOff {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};
  my $t     = $paref->{t};                                                                        # aktueller Unixtimestamp
  my $state = $paref->{state};
  my $debug = $paref->{debug};

  my $hash  = $defs{$name};

  my $pstate  = ConsumerVal ($hash, $c, "planstate",        "");
  my $stopts  = ConsumerVal ($hash, $c, "planswitchoff", undef);                                  # geplante Unix Stopzeit
  my $auto    = ConsumerVal ($hash, $c, "auto",              1);
  my $calias  = ConsumerVal ($hash, $c, "alias",            "");                                  # Consumer Device Alias
  my $hyst    = ConsumerVal ($hash, $c, "hysteresis",  DEFHYST);                                  # Hysterese

  my $mode                     = getConsumerPlanningMode ($hash, $c);                             # Planungsmode 'can' oder 'must'
  my $offcom                   = ConsumerVal             ($hash, $c, 'offcom', '');               # Set Command für "off"
  my ($swoffcond,$infoff,$err) = isAddSwitchOffCond      ($hash, $c);                             # zusätzliche Switch off Bedingung
  my $simpCstat                = simplifyCstate          ($pstate);
  my (undef, $cname, $dswname) = getCDnames              ($hash, $c);                             # Consumer und Switch Device Name
  my $isConsRcmd               = isConsRcmd              ($hash, $c);                             # Consumptionempfehlung
  my $cause;

  Log3 ($name, 1, "$name - $err") if($err);

  my ($iilt,$rlt) = isInLocktime ($paref);                                                        # Sperrzeit Status ermitteln

  if ($debug =~ /consumerSwitching${c}/x) {                                                       # nur für Debugging
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - Check Context 'switch off' => }.
                      qq{swoffcond: $swoffcond, off-command: $offcom}
           );
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - is Consumption recommended: $isConsRcmd});
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - isAddSwitchOffCond Info: $infoff}) if($infoff);

      if ($stopts && $t >= $stopts && $iilt) {
          Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - switching off postponed by >isInLocktime<});
      }
  }

  my $isintable = isInterruptable ($hash, $c, $hyst, 1);                                          # mit Ausgabe Interruptable Info im Debug

  if (($swoffcond || ($stopts && $t >= $stopts)) && !$iilt &&
     ($auto && $offcom && $simpCstat =~ /started|starting|stopping|interrupt|continu/xs)) {
      $cause = $swoffcond ? "switch-off condition (key swoffcond) is true" : "planned switch-off time reached/exceeded";
      $state = qq{switching Consumer '$calias' to '$offcom', command: "set $dswname $offcom", cause: $cause};

      if ($debug =~ /consumerSwitching${c}/x) {
          Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - send switch command now: "set $dswname $offcom"});
      }
      else {
          Log3 ($name, 3, "$name - $state (Automatic = $auto)");
      }

      CommandSet (undef,"$dswname $offcom");

      $paref->{ps} = "switching off:";
      ___setConsumerPlanningState ($paref);
      delete $paref->{ps};

      writeCacheToFile ($hash, 'consumers', $csmcache.$name);                                     # Cache File Consumer schreiben
  }
  elsif ((($isintable && !$isConsRcmd) || $isintable == 2)       &&                               # Consumer unterbrechen
         isInTimeframe ($hash, $c) && $auto && $offcom && !$iilt &&
         $simpCstat =~ /started|continued|interrupting/xs) {
      $cause = $isintable == 2 ? 'interrupt condition' : 'surplus shortage';
      $state = qq{switching Consumer '$calias' to '$offcom', command: "set $dswname $offcom", cause: $cause};

      if ($debug =~ /consumerSwitching${c}/x) {
          Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - send switch command now: "set $dswname $offcom"});
      }
      else {
          Log3 ($name, 3, "$name - $state (Automatic = $auto)");
      }

      CommandSet (undef,"$dswname $offcom");

      $paref->{ps} = "interrupting:";
      ___setConsumerPlanningState ($paref);
      delete $paref->{ps};

      writeCacheToFile ($hash, 'consumers', $csmcache.$name);                                     # Cache File Consumer schreiben
  }

return $state;
}

################################################################
#     Consumer aktuelle Schaltzustände ermitteln &
#     logische Zustände ableiten/setzen
################################################################
sub ___setConsumerSwitchingState {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};
  my $t     = $paref->{t};
  my $state = $paref->{state};
  my $fscss = $paref->{fscss};                                                                     # erster Subaufruf: 1

  my $hash      = $defs{$name};
  my $simpCstat = simplifyCstate (ConsumerVal ($hash, $c, 'planstate', ''));
  my $calias    = ConsumerVal    ($hash, $c, 'alias',                   '');                       # Consumer Device Alias
  my $auto      = ConsumerVal    ($hash, $c, 'auto',                     1);
  my $oldpsw    = ConsumerVal    ($hash, $c, 'physoffon',            'off');                       # gespeicherter physischer Schaltzustand
  my $dowri     = 0;

  debugLog ($paref, "consumerSwitching${c}", qq{consumer "$c" - current planning state: $simpCstat});

  if (isConsumerPhysOn ($hash, $c) && $simpCstat eq 'starting') {
      my ($err, $mintime) = getConsumerMintime ( { name    => $name,
                                                   startts => $t,
                                                   c       => $c,
                                                   nolog   => 1,
                                                   lang    => $paref->{lang},
                                                   debug   => $paref->{debug}
                                                 }
                                               );

      if ($err) {
          $state = qq{Consumer '$calias' ERROR in config: $err};
          Log3 ($name, 1, "$name - $state");
          return $state;
      }

      my $stopdiff           = $mintime * 60;
      $paref->{ps}           = "switched on:";
      $paref->{startts}      = $t;
      $paref->{lastAutoOnTs} = $t;
      $paref->{stopts}       = $t + $stopdiff;

      ___setConsumerPlanningState ($paref);

      delete $paref->{ps};
      delete $paref->{startts};
      delete $paref->{lastAutoOnTs};
      delete $paref->{stopts};

      $state = qq{Consumer '$calias' switched on};
      $dowri = 1;
  }
  elsif (isConsumerPhysOff ($hash, $c) && $simpCstat eq 'stopping') {
      $paref->{ps}            = "switched off:";
      $paref->{stopts}        = $t;
      $paref->{lastAutoOffTs} = $t;

      ___setConsumerPlanningState ($paref);

      delete $paref->{ps};
      delete $paref->{stopts};
      delete $paref->{lastAutoOffTs};

      $state = qq{Consumer '$calias' switched off};
      $dowri = 1;
  }
  elsif (isConsumerPhysOn ($hash, $c) && $simpCstat eq 'continuing') {
      $paref->{ps} = "continued:";
      $paref->{lastAutoOnTs} = $t;

      ___setConsumerPlanningState ($paref);

      delete $paref->{ps};
      delete $paref->{lastAutoOnTs};

      $state = qq{Consumer '$calias' switched on (continued)};
      $dowri = 1;
  }
  elsif (isConsumerPhysOff ($hash, $c) && $simpCstat eq 'interrupting') {
      $paref->{ps}            = "interrupted:";
      $paref->{lastAutoOffTs} = $t;

      ___setConsumerPlanningState ($paref);

      delete $paref->{ps};
      delete $paref->{lastAutoOffTs};

      $state = qq{Consumer '$calias' switched off (interrupted)};
      $dowri = 1;
  }
  elsif ($oldpsw eq 'off' && isConsumerPhysOn ($hash, $c)){
      $paref->{supplement} = "$hqtxt{wexso}{$paref->{lang}}";

      ___setConsumerPlanningState ($paref);

      delete $paref->{supplement};

      $state = qq{Consumer '$calias' was external switched on};
      $dowri = 1;
  }
  elsif ($oldpsw eq 'on' && isConsumerPhysOff ($hash, $c)) {
      $paref->{supplement} = "$hqtxt{wexso}{$paref->{lang}}";

      ___setConsumerPlanningState ($paref);

      delete $paref->{supplement};

      $state = qq{Consumer '$calias' was external switched off};
      $dowri = 1;
  }

  if ($dowri) {
      if (!$fscss) {
          writeCacheToFile ($hash, 'consumers', $csmcache.$name);                           # Cache File Consumer schreiben
      }

      Log3 ($name, 3, "$name - $state");
  }

return $state;
}

################################################################
# Verbraucher - Laufzeit, Tagesstarts und Aktivminuten pro
# Stunde ermitteln
# Stundenwechsel + Tageswechsel Management
#
# startTime - wichtig für Wechselmanagement!!
################################################################
sub __getCyclesAndRuntime {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $t     = $paref->{t};
  my $chour = $paref->{chour};
  my $day   = $paref->{day};                                               # aktueller Tag  (range 01 to 31)
  my $date  = $paref->{date};                                              # aktuelles Datum
  my $pcurr = $paref->{pcurr};
  my $c     = $paref->{consumer};
  my $debug = $paref->{debug};

  my $hash  = $defs{$name};

  my ($starthour, $startday);

  if (isConsumerLogOn ($hash, $c, $pcurr)) {                                                                                             # Verbraucher ist logisch "an"
        if (ConsumerVal ($hash, $c, 'onoff', 'off') eq 'off') {                                                                          # Status im letzen Zyklus war "off"
            $data{$name}{consumers}{$c}{onoff}          = 'on';
            $data{$name}{consumers}{$c}{startTime}      = $t;                                                                            # startTime ist nicht von "Automatic" abhängig -> nicht identisch mit planswitchon !!!
            $data{$name}{consumers}{$c}{cycleStarttime} = $t;
            $data{$name}{consumers}{$c}{cycleTime}      = 0;
            $data{$name}{consumers}{$c}{lastMinutesOn}  = ConsumerVal ($hash, $c, 'minutesOn', 0);

            $data{$name}{consumers}{$c}{cycleDayNum}++;                                                                                  # Anzahl der On-Schaltungen am Tag
        }
        else {
            $data{$name}{consumers}{$c}{cycleTime} = (($t - ConsumerVal ($hash, $c, 'cycleStarttime', $t)) / 60);                        # Minuten
        }

        $starthour = strftime "%H", localtime(ConsumerVal ($hash, $c, 'startTime', $t));
        $startday  = strftime "%d", localtime(ConsumerVal ($hash, $c, 'startTime', $t));                                                 # aktueller Tag  (range 01 to 31)

        if ($chour eq $starthour) {
            my $runtime                            = (($t - ConsumerVal ($hash, $c, 'startTime', $t)) / 60);                             # in Minuten ! (gettimeofday sind ms !)
            $data{$name}{consumers}{$c}{minutesOn} = ConsumerVal ($hash, $c, 'lastMinutesOn', 0) + $runtime;
        }
        else {                                                                                                                           # Stundenwechsel
            if (ConsumerVal ($hash, $c, 'onoff', 'off') eq 'on') {                                                                       # Status im letzen Zyklus war "on"
                my $newst                                  = timestringToTimestamp ($date.' '.sprintf("%02d",  $chour).':00:00');
                $data{$name}{consumers}{$c}{startTime}     = $newst;
                $data{$name}{consumers}{$c}{minutesOn}     = ($t - ConsumerVal ($hash, $c, 'startTime', $newst)) / 60;                   # in Minuten ! (gettimeofday sind ms !)
                $data{$name}{consumers}{$c}{lastMinutesOn} = 0;

                if ($day ne $startday) {                                                                                                 # Tageswechsel
                    $data{$name}{consumers}{$c}{cycleDayNum} = 1;
                }
            }
        }
  }
  else {                                                                                                                                 # Verbraucher soll nicht aktiv sein
      $starthour = strftime "%H", localtime(ConsumerVal ($hash, $c, 'startTime', 1));
      $startday  = strftime "%d", localtime(ConsumerVal ($hash, $c, 'startTime', 1));                                                    # aktueller Tag  (range 01 to 31)

      if ($chour ne $starthour) {                                                                                                        # Stundenwechsel
          $data{$name}{consumers}{$c}{minutesOn} = 0;
      }

      if ($day ne $startday) {                                                                                                           # Tageswechsel
          $data{$name}{consumers}{$c}{cycleDayNum} = 0;
      }

      $data{$name}{consumers}{$c}{onoff} = 'off';
  }

  if ($debug =~ /consumerSwitching${c}/xs) {
      my $sr  = 'still running';
      my $son = isConsumerLogOn ($hash, $c, $pcurr) ? $sr : ConsumerVal ($hash, $c, 'cycleTime', 0) * 60;                                # letzte Cycle-Zeitdauer in Sekunden
      my $cst = ConsumerVal     ($hash, $c, 'cycleStarttime', 0);
      $son    = $son && $son ne $sr ? timestampToTimestring ($cst + $son, $paref->{lang}) :
                $son eq $sr         ? $sr                                                 :
                '-';
      $cst    = $cst ? timestampToTimestring ($cst, $paref->{lang}) : '-';

      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - cycleDayNum: }.ConsumerVal ($hash, $c, 'cycleDayNum', 0));
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - last cycle start time: $cst});
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - last cycle end time: $son \n});
  }

  ## History schreiben
  ######################
  $paref->{val}      = ConsumerVal ($hash, $c, "cycleDayNum", 0);                         # Anzahl Tageszyklen des Verbrauchers speichern
  $paref->{histname} = "cyclescsm${c}";
  setPVhistory ($paref);

  $paref->{val}      = ceil ConsumerVal ($hash, $c, "minutesOn", 0);                      # Verbrauchsminuten akt. Stunde des Consumers speichern
  $paref->{histname} = "minutescsm${c}";
  setPVhistory ($paref);

  delete $paref->{histname};
  delete $paref->{val};

return;
}

################################################################
#   Restlaufzeit Verbraucher ermitteln
################################################################
sub __remainConsumerTime {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};
  my $t     = $paref->{t};                                                                   # aktueller Unixtimestamp

  my $hash                            = $defs{$name};
  my ($planstate,$startstr,$stoptstr) = __getPlanningStateAndTimes ($paref);
  my $stopts                          = ConsumerVal ($hash, $c, 'planswitchoff', undef);     # geplante Unix Stopzeit

  $data{$name}{consumers}{$c}{remainTime} = 0;

  if (isInTimeframe($hash, $c) && (($planstate =~ /started/xs && isConsumerPhysOn($hash, $c)) | $planstate =~ /interrupt|continu/xs)) {
      my $remainTime                                 = $stopts - $t ;
      $data{$name}{consumers}{$c}{remainTime} = sprintf "%.0f", ($remainTime / 60) if($remainTime > 0);
  }

return;
}

################################################################
#   Consumer physischen & logischen Schaltstatus setzen
################################################################
sub  __setPhysLogSwState {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $c     = $paref->{consumer};
  my $pcurr = $paref->{pcurr};
  my $befsw = $paref->{befsw};                      # Status vor Switching:1, danach 0 | undef
  my $debug = $paref->{debug};

  my $hash = $defs{$name};
  my $cpo  = isConsumerPhysOn ($hash, $c)         ? 'on' : 'off';
  my $clo  = isConsumerLogOn  ($hash, $c, $pcurr) ? 'on' : 'off';

  $data{$name}{consumers}{$c}{physoffon} = $cpo;
  $data{$name}{consumers}{$c}{logoffon}  = $clo;

  if ($debug =~ /consumerSwitching${c}/xs) {
      my $ao = $befsw ? 'before switching' : 'after switching';
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - physical Switchstate $ao: $cpo});
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - logical Switchstate $ao: $clo});
  }

return;
}

################################################################
# Freigabe Einschalten Verbraucher durch Batterie Vorrangladung
#    return 0 -> keine Einschaltfreigabe Verbraucher
#    return 1 -> Einschaltfreigabe Verbraucher
################################################################
sub ___enableSwitchByBatPrioCharge {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};

  my $ena     = 1;
  my $pcb     = CurrentVal ($name, 'batteryPreferredCharge', 0);             # Vorrangladung Batterie zu X%
  my ($badev) = isBatteryUsed ($name);

  return $ena if(!$pcb || !$badev);                                          # Freigabe Schalten Consumer wenn kein Prefered Battery/Soll-Ladung 0 oder keine Batterie installiert

  my $bcharge = CurrentVal ($name, 'batsoctotal', 0);                        # resultierender SoC (%) aller Batterien als Cluster
  $ena        = 0 if($bcharge < $pcb);                                       # keine Freigabe wenn Batterieladung kleiner Soll-Ladung

return $ena;
}

###################################################################
#    Consumer Planstatus und Planzeit ermitteln
###################################################################
sub __getPlanningStateAndTimes {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};
  my $lang  = $paref->{lang};

  my $hash      = $defs{$name};
  my $simpCstat = simplifyCstate (ConsumerVal ($hash, $c, 'planstate', ''));
  my $supplmnt  = ConsumerVal ($hash, $c, 'planSupplement', '');
  my $startts   = ConsumerVal ($hash, $c, 'planswitchon',   '');
  my $stopts    = ConsumerVal ($hash, $c, 'planswitchoff',  '');

  my $starttime = '';
  my $stoptime  = '';
  $starttime    = (timestampToTimestring ($startts, $lang))[0] if($startts);
  $stoptime     = (timestampToTimestring ($stopts, $lang))[0]  if($stopts);

return ($simpCstat, $starttime, $stoptime, $supplmnt);
}

################################################################
#     Energieverbrauch Vorhersage kalkulieren (Median)
################################################################
sub _calcConsForecast_circular {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $chour     = $paref->{chour};
  my $t         = $paref->{t};
  my $date      = $paref->{date};                                                                       # aktuelles Datum
  my $day       = $paref->{day};                                                                        # aktuelles Tagdatum (01...31)
  my $todayname = $paref->{dayname};                                                                    # aktueller Tagname

  my $hash    = $defs{$name};
  my $acref   = $data{$name}{consumers};
  my $swdfcfc = CurrentVal ($name, 'consForecastIdentWeekdays',         0);                             # nutze nur gleiche Wochentage (Mo...So) für Verbrauchsvorhersage
  my $acld    = CurrentVal ($name, 'consForecastLastDays',    CONSFCLDAYS);                             # Beachtung Stundenwerte der letzten X Tage falls gesetzt

  my $dt         = timestringsFromOffset ($t, 86400);
  my $tomdayname = $dt->{dayname};                                                                      # Wochentagsname kommender Tag
  my $lct        = LOCALE_TIME =~ /^de_/xs ? 'DE' : 'EN';
  my $st         = timestringToTimestamp ("$date 00:00:00");                                            # Startzeit 00:00 am aktuellen Tag
  my $ncds       = $swdfcfc ? $acld * 7 : $acld;                                                        # notwendige Anzahl Vergleichstage die vorhanden sein sollen
  my $nhist      = scalar keys %{$data{$name}{pvhist}};

  my (@cona, $exconfc, $csme, %usage);
  $usage{tom}{con} = 0;
  
  debugLog ($paref, 'consumption|consumption_long', "################### Start Consumption forecast ###################");
  debugLog ($paref, 'consumption_long', "Basics - installed locale: ".LOCALE_TIME.", used scheme: $lct"); 
  debugLog ($paref, 'consumption_long', "Need number of stored days: $ncds, Number of days in History: $nhist => can calculate excludes/includes: ".($ncds <= $nhist ? 'yes' : 'no'));


  ## Verbrauch der hod-Stunden 01..24 u. gesamten Tag ermitteln
  ###############################################################
  for my $h (1..24) {                                                                                   # Median für jede Stunde / Tag berechnen
      $dt         = timestringsFromOffset ($st, $h * 3559);                                             # eine Sek. weniger als 1 Stunde
      my $dayname = $dt->{dayname};
      my $hh      = sprintf "%02d", $h;

      debugLog ($paref, 'consumption_long', "process Today dayname: $dayname, Tomorrow dayname: $tomdayname") if($h == 1);

      my (@conh, @conhtom);
      my $mix = 0;

      if ($swdfcfc) {                                                                                   # nur bestimmten Tag (Mo...So) einbeziehen der Stunde
          push @conh,    @{$data{$name}{circular}{$hh}{con_all}{"$dayname"}}    if(defined ${$data{$name}{circular}{$hh}{con_all}{"$dayname"}}[0]);
          push @conhtom, @{$data{$name}{circular}{$hh}{con_all}{"$tomdayname"}} if(defined ${$data{$name}{circular}{$hh}{con_all}{"$tomdayname"}}[0]);          # für den nächsten Tag
      }
      else {                                                                                            # alle aufgezeichneten Wochentage in der Stunde berücksichtigen
          for my $dy (keys %{$data{$name}{circular}{$hh}{con_all}}) {                                   # den max Index aller Tagesarrays ermitteln
              my $ai = $#{$data{$name}{circular}{$hh}{con_all}{$dy}};
              $mix   = $ai if($ai > $mix);
          }

          for my $i (0..$mix) {                                                                         # Werte sortiert nach Alter aufsteigend in Array einfügen
              for my $dy (sort keys %habwdn) {
                  push @conh,    ${$data{$name}{circular}{$hh}{con_all}{$habwdn{$dy}{$lct}}}[$i] if(defined ${$data{$name}{circular}{$hh}{con_all}{$habwdn{$dy}{$lct}}}[$i]);
                  push @conhtom, @conh;
              }
          }
      }

      my $hnum    = scalar @conh;
      my $hnumtom = scalar @conhtom;

      if ($hnum) {
          if ($hnum > $acld) {
              @conh = splice (@conh, $acld * -1);
              $hnum = scalar @conh;
          }
                                    
          my $hcon         = $ncds <= $nhist ? (sprintf "%.0f", avgArray (\@conh, $hnum)) : 
                                               (sprintf "%.0f", medianArray (\@conh));                  # V 1.52.8
          $usage{$hh}{con} = $hcon;                                                                     # prognostizierter Verbrauch (Median) der Stunde hh (Hour of Day)
          $usage{$hh}{num} = $hnum;
      }

      if ($hnumtom) {
          if ($hnumtom > $acld) {
              @conhtom = splice (@conhtom, $acld * -1);
              $hnumtom = scalar @conhtom;
          }

          my $hcontom       = $ncds <= $nhist ? (sprintf "%.0f", avgArray (\@conhtom, $hnumtom)) :        
                                                (sprintf "%.0f", medianArray (\@conhtom));              # V 1.52.8
          $usage{tom}{con} += $hcontom;                                                                 # Summe prognostizierter Verbrauch (Median) des Tages
          $usage{tom}{num} += $hnumtom;
      }
  }

  ## Excludes / Includes vorbereiten
  ####################################
  my $exnum = 0;
  my $ex    = 0;
  my $lap   = 1;
  
  if ($ncds <= $nhist) {                                                                               # V 1.52.7
      for my $n (sort{$a<=>$b} keys %{$data{$name}{pvhist}}) {
          next if ($n eq $day);                                                                        # aktuellen (unvollständigen) Tag nicht berücksichtigen
          my $do = 1;

          for my $c (sort{$a<=>$b} keys %{$acref}) {                                                   # historischer Verbrauch aller registrierten Verbraucher aufaddieren
              $exconfc = ConsumerVal ($hash, $c, 'exconfc', 0);

              if ($exconfc) {
                  ## Tageswert Excludes finden und summieren
                  ############################################
                  if ($do && $exconfc == 1) {                                                          # 1 -> Consumer Verbrauch von Erstelleung der Verbrauchsprognose ausschließen
                      if ($swdfcfc) {                                                                  # nur gleiche Tage (Mo...So) einbeziehen
                          my $hdn = HistoryVal ($hash, $n, 99, 'dayname', undef);
                          $do     = 0 if(!$hdn || $hdn ne $tomdayname);
                      }

                      if ($do) {
                          $csme = HistoryVal ($hash, $n, 99, "csme${c}", 0);

                          if ($csme > 0) {
                              $ex   += $csme;
                              $exnum++;

                              debugLog ($paref, 'consumption_long', "Consumer '$c' hist cons registered by 'exconfc' for excl. - day: $n, csme: $csme");
                          }
                      }
                  }

                  ## Stundenweise exkludes und inkludes aufnehmen
                  #################################################
                  $do = 1;
                  if ($swdfcfc) {                                                                  # nur gleiche Tage (Mo...So) einbeziehen
                      my $hdn = HistoryVal ($hash, $n, 99, 'dayname', undef);
                      $do     = 0 if(!$hdn || $hdn ne $todayname);
                  }

                  if ($do) {
                      my $epiecelem = 1;

                      for my $h (1..24) {                                                                   # excludieren ob exconfc 1 oder 2
                          my $hh = sprintf "%02d", $h;
                          $csme  = HistoryVal ($hash, $n, $hh, "csme${c}", 0);

                          if ($csme) {
                              $csme                 = sprintf "%.2f", $csme;
                              $usage{$hh}{histcon} += $csme;
                              $usage{$hh}{histnum}++;

                              debugLog ($paref, 'consumption_long', "consumer '$c' register for exclude day $n, hod: $hh - ".$csme." Wh");
                          }

                          if ($exconfc == 2 && $lap == 1) {                                                 # AVG-Daten des Consumers inkludieren
                              my $rt     = $st + (3600 * ($h - 1));                                         # Schleifenlaufzeit
                              my $plson  = ConsumerVal ($name, $c, 'planswitchon',  $st + 86400);           # geplante Switch-on Zeit des Consumers
                              my $plsoff = ConsumerVal ($name, $c, 'planswitchoff',           0);           # geplante Switch-off Zeit des Consumers

                              if ($rt >= $plson && $rt <= $plsoff) {
                                  if (defined $data{$name}{consumers}{$c}{epiecAVG}{$epiecelem}) {
                                      $usage{$hh}{plancon} += $data{$name}{consumers}{$c}{epiecAVG}{$epiecelem};
                                      $usage{$hh}{plannum}++;

                                      debugLog ($paref, 'consumption_long', "consumer '$c' register epiecAVG: ".$data{$name}{consumers}{$c}{epiecAVG}{$epiecelem}." Wh for include in Hour $hh");

                                      $epiecelem++;
                                  }
                              }
                          }
                      }
                  }
              }
          }

          $lap++;
      }
  }

  ## effektiven StundenForecast berechnen
  #########################################
  debugLog ($paref, 'consumption|consumption_long', "################### Consumption forecast for the next Hours (new median) ###################");

  for my $h (1..24) {
      my $hh = sprintf "%02d", $h;

      if (defined $usage{$hh}{histnum}) {                                                             # historische Stundenverbräuche exkludieren
          my $exhcon        = sprintf "%.0f", ($usage{$hh}{histcon} / $usage{$hh}{histnum});          # durchschnittlichen Verbrauchswert
          $usage{$hh}{con} -= $exhcon if($usage{$hh}{con} > $exhcon);

          debugLog ($paref, 'consumption_long', "excl. hist $exhcon Wh for Hour $hh, Considered value numbers: ".$usage{$hh}{histnum});
      }

      $usage{$hh}{conex} = $usage{$hh}{con};

      if (defined $usage{$hh}{plannum}) {                                                             # geplante Stundenverbräuche inkludieren
          my $inhcon        = sprintf "%.0f", ($usage{$hh}{plancon} / $usage{$hh}{plannum});
          $usage{$hh}{con} += $inhcon;

          debugLog ($paref, 'consumption_long', "incl. planned $inhcon Wh for Hour $hh, Considered value numbers: ".$usage{$hh}{plannum});
      }

      if (defined $usage{$hh}{num}) {                                                                 # V 1.47.0
          debugLog ($paref, 'consumption|consumption_long', "estimated cons of Hour $hh: ".$usage{$hh}{con}." Wh, Considered value numbers: ".$usage{$hh}{num});
      }
  }

  ## nächsten Tageswert Excludes berücksichtigen
  ################################################
  my $tomnum = $usage{tom}{num} // 0;

  debugLog ($paref, 'consumption|consumption_long', "################### Consumption forecast for the next day (new median) ###################");

  if ($tomnum) {
      if ($exnum) {
          $ex               = sprintf "%.0f", ($ex / $exnum);                                        # Ex Tageswert Durchschnitt bilden
          $usage{tom}{con} -= $ex;
      }

      $data{$name}{current}{tomorrowconsumption} = $usage{tom}{con};
      debugLog ($paref, 'consumption|consumption_long', "estimated cons Tomorrow: ".$usage{tom}{con}." Wh, Individual hourly values considered: $tomnum, exclude: $ex Wh (avg of $exnum entities)");
  }
  else {
      my $lang                                   = $paref->{lang};
      $data{$name}{current}{tomorrowconsumption} = $hqtxt{wfmdcf}{$lang};
      debugLog ($paref, 'consumption|consumption_long', "no estimated cons for Tomorrow: ".$hqtxt{wfmdcf}{$lang});
  }

  ## Ergebnisse speichern
  ########################
  debugLog ($paref, 'saveData2Cache|consumption_long', "################### Store Consumption forecast values (new median) ###################");

  for my $k (sort keys %{$data{$name}{nexthours}}) {
      my $nhst = NexthoursVal ($hash, $k, "starttime", undef);                                         # Startzeit
      next if(!$nhst);

      my $utime = timestringToTimestamp ($nhst);
      my $nhday = strftime "%a", localtime($utime);                                                    # Wochentagsname des NextHours Key
      my $nhhr  = sprintf "%02d", int (strftime "%H", localtime($utime)) + 1;                          # Stunde des Tages vom NextHours Key (01,02,...24)

      next if(!defined $usage{$nhhr}{con});                                                            # V 1.47.0

      $data{$name}{nexthours}{$k}{confcEx} = $usage{$nhhr}{conex};
      $data{$name}{nexthours}{$k}{confc}   = $usage{$nhhr}{con};                                       # prognostizierter Verbrauch (Median)

      debugLog ($paref, 'saveData2Cache|consumption_long', "store '$k' hod '$nhhr' confc: $usage{$nhhr}{con}, confcEx: $usage{$nhhr}{conex}");

      if (NexthoursVal ($name, $k, 'today', 0)) {                                                      # nur Werte des aktuellen Tags speichern
          $data{$name}{circular}{$nhhr}{confc} = $usage{$nhhr}{con};
          writeToHistory ( { paref => $paref, key => 'confc', val => $usage{$nhhr}{con}, hour => $nhhr } );

          debugLog ($paref, 'saveData2Cache|consumption_long', "store circular/history hod '$nhhr' confc: $usage{$nhhr}{con}");
      }
  }

return;
}

################################################################
#     Schwellenwerte auswerten und signalisieren
################################################################
sub _evaluateThresholds {
  my $paref = shift;
  my $name  = $paref->{name};

  my $bt    = ReadingsVal($name, 'batteryTrigger',  '');
  my $pt    = ReadingsVal($name, 'powerTrigger',    '');
  my $eh4t  = ReadingsVal($name, 'energyH4Trigger', '');

  if ($bt) {
      $paref->{cobj}   = 'batsocslidereg';
      $paref->{tname}  = 'batteryTrigger';
      $paref->{tholds} = $bt;

      __evaluateArray ($paref);
  }

  if ($pt) {
      $paref->{cobj}   = 'genslidereg';
      $paref->{tname}  = 'powerTrigger';
      $paref->{tholds} = $pt;

      __evaluateArray ($paref);
  }

  if ($eh4t) {
      $paref->{cobj}   = 'h4fcslidereg';
      $paref->{tname}  = 'energyH4Trigger';
      $paref->{tholds} = $eh4t;

      __evaluateArray ($paref);
  }

  delete $paref->{cobj};
  delete $paref->{tname};
  delete $paref->{tholds};

return;
}

################################################################
#     Threshold-Array auswerten und Readings vorbereiten
################################################################
sub __evaluateArray {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $cobj   = $paref->{cobj};           # das CurrentVal Objekt, z.B. genslidereg
  my $tname  = $paref->{tname};          # Thresholdname, z.B. powerTrigger
  my $tholds = $paref->{tholds};         # Triggervorgaben, z.B. aus Reading powerTrigger

  my $aaref = CurrentVal ($name, $cobj, '');
  my @aa    = ();
  @aa       = @{$aaref} if (ref $aaref eq 'ARRAY');

  return if(scalar @aa < SLIDENUMMAX);

  my $gen1   = $aa[0];
  my $gen2   = $aa[1];
  my $gen3   = $aa[2];

  my ($a, $h) = parseParams ($tholds);

  for my $key (keys %{$h}) {
      my ($knum,$cond) = $key =~ /^([0-9]+)(on|off)$/x;

      if ($cond eq "on" && $gen1 > $h->{$key}) {
          next if($gen2 < $h->{$key});
          next if($gen3 < $h->{$key});
          storeReading ("${tname}_${knum}", 'on') if(ReadingsVal($name, "${tname}_${knum}", "off") eq "off");
      }

      if ($cond eq "off" && $gen1 < $h->{$key}) {
          next if($gen2 > $h->{$key});
          next if($gen3 > $h->{$key});
          storeReading ("${tname}_${knum}", 'off') if(ReadingsVal($name, "${tname}_${knum}", "on") eq "on");
      }
  }

return;
}

################################################################
#      zusätzliche Readings Tomorrow_HourXX_PVforecast
#      erstellen
################################################################
sub _calcReadingsTomorrowPVFc {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};

  my $hash = $defs{$name};
  my $hods = AttrVal ($name, 'ctrlNextDayForecastReadings', '');

  return if(!$hods || !keys %{$data{$name}{nexthours}});
  
  my $dt     = timestringsFromOffset ($t, 86400);
  my $tmoday = $dt->{day};                                                                            # Tomorrow Day (01..31)

  for my $idx (sort keys %{$data{$name}{nexthours}}) {
      my $day = NexthoursVal ($hash, $idx, 'day', 'dd');
      next if($day ne $tmoday);                                                                       # aktueller Tag wird nicht benötigt

      my $hod = NexthoursVal ($hash, $idx, 'hourofday', '');
      next if(!$hod || $hods !~ /$hod/xs);                                                            # diese Stunde des Tages soll nicht erzeugt werden

      my $pvfc = NexthoursVal ($hash, $idx, 'pvfc', 0);

      storeReading ('Tomorrow_Hour'.$hod.'_PVforecast', $pvfc.' Wh');
  }

return;
}

################################################################
#  Korrektur von Today_PVreal +
#  berechnet die prozentuale Abweichung von Today_PVforecast
#  und Today_PVreal
################################################################
sub _calcTodayPVdeviation {
  my $paref = shift;
  my $name  = $paref->{name};
  my $t     = $paref->{t};
  my $date  = $paref->{date};
  my $day   = $paref->{day};

  my $hash = $defs{$name};
  my $pvfc = ReadingsNum ($name, 'Today_PVforecast', 0);
  my $pvre = ReadingsNum ($name, 'Today_PVreal',     0);

  return if(!$pvre || !$pvfc);                                                # Illegal division by zero verhindern

  my $dp;
  my ($manner, $perspective) = split ':', CurrentVal ($name, 'genPVdeviation', 'daily');
  $perspective //= 'default';

  if ($manner eq 'daily') {
      my $sstime = timestringToTimestamp ($date.' '.ReadingsVal ($name, "Today_SunSet", '22:00').':00');
      return if($t < $sstime);

      $dp = sprintf "%.2f", (100 - (100 * $pvre / $pvfc));                    # V 1.23.0
  }
  else {
      my $pvfcd = ReadingsNum ($name, 'RestOfDayPVforecast', 0) - $pvfc;      # PV Prognose bis jetzt
      return if(!$pvfcd);                                                     # Illegal division by zero verhindern

      $dp = sprintf "%.2f", (100 - (100 * $pvre / abs $pvfcd));               # V 1.25.0
  }

  $dp *= -1 if ($perspective eq 'reverse');                                   # Perspektivänderung: Abweichung = Real - Vorhersage statt Abweichung = Vorhersage - Real
  
  $data{$name}{circular}{99}{tdayDvtn} = $dp;

  storeReading ('Today_PVdeviation', $dp.' %');

return;
}

################################################################
#  Werte berechnen und speichern die nach jeder vollen Stunde
#  nur einmal ermittelt werden:
#  - PV-Prognosekorrekturfaktoren und deren Qualität
#  - AI Quellendaten hinzufügen
#  - Verbrauchswerte für Medianauswertung
################################################################
sub _calcDataEveryFullHour {
  my $paref = shift;
  my $name  = $paref->{name};
  my $chour = $paref->{chour};
  my $day   = $paref->{day};                                                          # aktueller Tag (range 01 to 31)
  my $t     = $paref->{t};                                                            # aktuelle Unix-Zeit

  my $hash        = $defs{$name};
  my ($acu, $aln) = isAutoCorrUsed ($name);

  if ($acu) {
      readingsSingleUpdate ($hash, '.pvCorrectionFactor_Auto_Soll', ($aln ? $acu : $acu.' noLearning'), 0) if($acu =~ /on/xs);

      my $idts = CircularVal ($hash, 99, "attrInvChangedTs", '');                         # Definitionstimestamp des Attr setupInverterDev01

      if (!$idts) {                                                                       # V 1.47.3
          $data{$name}{circular}{99}{attrInvChangedTs} = int $t;
          return;
      }

      if ($t - $idts < 7200) {
          my $rmh = sprintf "%.2f", ((7200 - ($t - $idts)) / 3600);
          readingsSingleUpdate ($hash, 'pvCorrectionFactor_Auto', "standby (remains in standby for $rmh hours)", 0);

          Log3 ($name, 4, "$name - Correction usage is in standby. It starts in $rmh hours.");

          return;
      }
      else {
          my $acuset = ReadingsVal ($name, '.pvCorrectionFactor_Auto_Soll', 'on_simple');
          readingsSingleUpdate     ($hash, 'pvCorrectionFactor_Auto', $acuset, 0);
      }
  }
  else {
      readingsSingleUpdate ($hash, '.pvCorrectionFactor_Auto_Soll', 'off', 0);
  }

  $paref->{acu} = $acu;

  for my $h (0..23) {
      next if($h > $chour);

      if (int $chour == 0) {                                                                      # 00:XX -> Stunde 24 des Vortages speichern
          my $dt             = timestringsFromOffset ($t, -3600);
          $paref->{yt}       = $t - 3600;                                                         # Timestamp Vortag
          $paref->{yday}     = $dt->{day};                                                        # vorheriger Tag (range 01 .. 31)
          $paref->{ydayname} = $dt->{dayname};
          $h                 = 24;                                                                # Stunde 24 am Vortag!
      }

      next if(!$h);

      my $hh          = sprintf "%02d", $h;
      $paref->{cpcf}  = ReadingsVal ($name, 'pvCorrectionFactor_'.$hh, '');                       # aktuelles pvCorf-Reading
      $paref->{aihit} = CircularVal ($name, $hh, 'aihit',  0);                                    # AI verwendet?
      $paref->{h}     = $h;

      next if(ReadingsVal ($name, '.signaldone_'.$hh, '') eq "done");
      
      $paref->{pvrlvd} = HistoryVal ($name, ($paref->{yday} ? $paref->{yday} : $day), $hh, 'pvrlvd', 1);   

      _calcCaQsimple    ($paref);                                                                 # einfache Korrekturberechnung duchführen/speichern
      _calcCaQcomplex   ($paref);                                                                 # Korrekturberechnung mit Bewölkung duchführen/speichern
      _addHourAiRawdata ($paref);                                                                 # AI Raw Data hinzufügen
      _addCon2CircArray ($paref);                                                                 # Hausverbrauch / Netzbezug der vergangenen Stunde zum con-Array im Circular Speicher hinzufügen

      storeReading ('.signaldone_'.$hh, 'done');                                                  # Sperrsignal (erledigt) setzen

      delete $paref->{h};
      delete $paref->{cpcf};
      delete $paref->{aihit};
      delete $paref->{yday};
      delete $paref->{ydayname};
      delete $paref->{yt};
      delete $paref->{pvrlvd};
  }

  delete $paref->{acu};

return;
}

################################################################
# PV Ist/Forecast ermitteln und Korrekturfaktoren, Qualität
# ohne Nebenfaktoren errechnen und speichern (simple)
################################################################
sub _calcCaQsimple {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $date   = $paref->{date};
  my $acu    = $paref->{acu};
  my $pvrlvd = $paref->{pvrlvd};                                                     # PV-Wert valide 1/0
  my $h      = $paref->{h};
  my $day    = $paref->{day};                                                        # aktueller Tag
  my $yday   = $paref->{yday};                                                       # vorheriger Tag (falls gesetzt)
  my $aihit  = $paref->{aihit};

  if (!$pvrlvd) {
      debugLog ($paref, 'pvCorrectionWrite', "real PV generation is marked as invalid for hour: $h -> skip the recalculation of the simple correction factor");
      return;
  }

  my $hh         = sprintf "%02d", $h;
  my $pvrl       = CircularVal ($name, $hh, 'pvrl',       0);
  my $pvapifc    = CircularVal ($name, $hh, 'pvapifc',    0);                         # vorhergesagte PV Energie incl. Korrekturfaktoren am Ende der vorherigen Stunde
  my $pvapifcraw = CircularVal ($name, $hh, 'pvapifcraw', 0);                         # vorhergesagte PV Energie (raw) am Ende der vorherigen Stunde

  if (!$pvrl || !$pvapifcraw) {
      return;
  }

  my $sunalt = HistoryVal ($name, $day, $hh, 'sunalt', 0);                            # Sonne Altitude
  my $sabin  = sunalt2bin ($sunalt);

  $paref->{pvrl}       = $pvrl;
  $paref->{pvapifc}    = $pvapifc;
  $paref->{pvapifcraw} = $pvapifcraw;
  $paref->{sabin}      = $sabin;
  $paref->{crang}      = 'simple';
  $paref->{calc}       = 'Simple';

  my ($oldfac, $factor, $dnum) = __calcNewFactor_migrated ($paref);                   # migrierte Daten verwenden

  delete $paref->{pvrl};
  delete $paref->{pvapifc};
  delete $paref->{pvapifcraw};
  delete $paref->{sabin};
  delete $paref->{crang};
  delete $paref->{calc};

  $aihit = $aihit ? ' AI result used,' : '';

  if ($acu =~ /on_simple/xs) {
      if ($paref->{cpcf} !~ /manual/xs) {                                                            # pcf-Reading nur überschreiben wenn nicht 'manual xxx' gesetzt
          storeReading ('pvCorrectionFactor_'.$hh, $factor." (automatic - old factor: $oldfac,$aihit Days in range: $dnum)");
      }
      else {
          storeReading ('pvCorrectionFactor_'.$hh, $paref->{cpcf}." / flexmatic result $factor,$aihit Days in range: $dnum");
      }
  }

return;
}

################################################################
# PV Ist/Forecast ermitteln und Korrekturfaktoren, Qualität
# in Abhängigkeit Bewölkung errechnen und speichern (komplex)
################################################################
sub _calcCaQcomplex {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $debug  = $paref->{debug};
  my $acu    = $paref->{acu};
  my $pvrlvd = $paref->{pvrlvd};                                                                       # PV-Wert valide 1/0
  my $h      = $paref->{h};
  my $day    = $paref->{day};                                                                          # aktueller Tag
  my $yday   = $paref->{yday};                                                                         # vorheriger Tag (falls gesetzt)
  my $aihit  = $paref->{aihit};

  if (!$pvrlvd) {
      debugLog ($paref, 'pvCorrectionWrite', "real PV generation is marked as invalid for hour: $h -> skip the recalculation of the complex correction factor");
      return;
  }

  my $hh         = sprintf "%02d", $h;
  my $pvrl       = CircularVal ($name, $hh, 'pvrl',       0);                         # real erzeugte PV Energie am Ende der vorherigen Stunde
  my $pvapifc    = CircularVal ($name, $hh, 'pvapifc',    0);                         # vorhergesagte PV Energie incl. Korrekturfaktoren am Ende der vorherigen Stunde
  my $pvapifcraw = CircularVal ($name, $hh, 'pvapifcraw', 0);                         # vorhergesagte PV Energie (raw) am Ende der vorherigen Stunde
 
  if (!$pvrl || !$pvapifcraw) {
      return;
  }

  my $chwcc  = HistoryVal ($name, $day, $hh, 'wcc',    0);                            # Wolkenbedeckung heute & abgefragte Stunde
  my $sunalt = HistoryVal ($name, $day, $hh, 'sunalt', 0);                            # Sonne Altitude
  my $crang  = cloud2bin  ($chwcc);
  my $sabin  = sunalt2bin ($sunalt);

  ## Speicherarrays schreiben
  #############################
  push @{$data{$name}{circular}{$hh}{'pvrl_'.$sabin}{"$crang"}}, $pvrl;
  push @{$data{$name}{circular}{$hh}{'pvfc_'.$sabin}{"$crang"}}, $pvapifcraw;

  removeMinMaxArray ($data{$name}{circular}{$hh}{'pvrl_'.$sabin}{"$crang"}, SPLSLIDEMAX);
  removeMinMaxArray ($data{$name}{circular}{$hh}{'pvfc_'.$sabin}{"$crang"}, SPLSLIDEMAX);

  ## neuen Korrekturfaktor berechnen
  ####################################
  $paref->{pvrl}       = $pvrl;
  $paref->{pvapifc}    = $pvapifc;
  $paref->{pvapifcraw} = $pvapifcraw;
  $paref->{crang}      = $crang;
  $paref->{sabin}      = $sabin;
  $paref->{calc}       = 'Complex';

  my ($oldfac, $factor, $dnum) = __calcNewFactor_migrated ($paref);                  # migrierte Daten verwenden

  delete $paref->{pvrl};
  delete $paref->{pvapifc};
  delete $paref->{pvapifcraw};
  delete $paref->{crang};
  delete $paref->{sabin};
  delete $paref->{calc};

  $aihit = $aihit ? ' AI result used,' : '';

  if ($acu =~ /on_complex/xs) {
      if ($paref->{cpcf} !~ /manual/xs) {                                                            # pcf-Reading nur überschreiben wenn nicht 'manual xxx' gesetzt
          storeReading ('pvCorrectionFactor_'.$hh, $factor." (automatic - old factor: $oldfac,$aihit Sun Alt range: $sabin, Cloud range: $crang, Days in range: $dnum)");
      }
      else {
          storeReading ('pvCorrectionFactor_'.$hh, $paref->{cpcf}." / flexmatic result $factor for Sun Alt range: $sabin,$aihit Cloud range: $crang, Days in range: $dnum");
      }
  }

return;
}

################################################################
#  den Hausverbrauch der vergangenen Stunde zum con-Array
#  im Circular Speicher hinzufügen
################################################################
sub _addCon2CircArray {
  my $paref    = shift;
  my $name     = $paref->{name};
  my $h        = $paref->{h};
  my $yday     = $paref->{yday};                                                      # vorheriger Tag (falls gesetzt)
  my $day      = $paref->{day};                                                       # aktueller Tag (range 01 to 31)
  my $dayname  = $paref->{dayname};
  my $ydayname = $paref->{ydayname};

  $day      = $yday     if(defined $yday);                                            # der vergangene Tag soll verarbeitet werden
  $dayname  = $ydayname if(defined $ydayname);                                        # Name des Vortages
  my $hh    = sprintf "%02d", $h;
  my $con   = HistoryVal ($name, $day, $hh, 'con',   0);                              # Consumption der abgefragten Stunde
  my $gcons = HistoryVal ($name, $day, $hh, 'gcons', 0);                              # Netzbezug der abgefragten Stunde

  push @{$data{$name}{circular}{$hh}{con_all}{"$dayname"}}, $con   if($con   >= 0);   # Consumption zum Speicherarray hinzufügen
  push @{$data{$name}{circular}{$hh}{gcons_a}{"$dayname"}}, $gcons if($gcons >= 0);   # Consumption zum Speicherarray hinzufügen

  limitArray ($data{$name}{circular}{$hh}{con_all}{"$dayname"}, CONDAYSLIDEMAX);
  limitArray ($data{$name}{circular}{$hh}{gcons_a}{"$dayname"}, CONDAYSLIDEMAX);

  debugLog ($paref, 'saveData2Cache', "add consumption into Array (con_all) in Circular - day: $day, hod: $hh, con: $con");
  debugLog ($paref, 'saveData2Cache', "add consumption into Array (gcons_a) in Circular - day: $day, hod: $hh, gcons: $gcons");

return;
}

################################################################
#   den neuen Korrekturfaktur berechnen (neue Median Funktion)
################################################################
sub __calcNewFactor_migrated {
  my $paref    = shift;
  my $name     = $paref->{name};
  my $pvrl     = $paref->{pvrl};
  my $pvapifc  = $paref->{pvapifc};
  my $pvfcraw  = $paref->{pvapifcraw};
  my $crang    = $paref->{crang};
  my $sabin    = $paref->{sabin};
  my $h        = $paref->{h};
  my $calc     = $paref->{calc};

  my $hash = $defs{$name};
  my ($factor, $pvcirc, $fccirc, $pvrlsum, $pvfcsum, $dnum);

  my $hh                = sprintf "%02d", $h;
  my ($oldfac, $oldqal) = CircularSunCloudkorrVal ($hash, $hh, $sabin, $crang, 0);                        # bisher definierter Korrekturfaktor / Qualität
  $oldfac               = 1 if(1 * $oldfac == 0);

  debugLog ($paref, 'pvCorrectionWrite', "$calc Corrf -> Start calculation correction factor for hour: $hh (migrated data structure)");

  if ($calc eq 'Simple') {
      ($pvcirc, $fccirc, $dnum) = CircularSumVal ($hash, $hh, $sabin, 'simple', 0);

      debugLog ($paref, 'pvCorrectionWrite', "$calc Corrf -> read stored values: PVreal sum: $pvcirc, PVforecast sum: $fccirc, days: $dnum");

      if ($dnum) {                                                                                        # Werte in History vorhanden -> haben Prio !
          $dnum++;
          $pvrlsum = $pvrl + $pvcirc;
          $pvfcsum = $pvfcraw + $fccirc;
          $pvrl    = $pvrlsum / $dnum;
          $pvfcraw = $pvfcsum / $dnum;
          $factor  = sprintf "%.2f", ($pvrl / $pvfcraw);                                                  # Faktorberechnung: reale PV / Prognose
      }
      elsif ($oldfac && (!$pvcirc || !$fccirc)) {                                                         # Circular Hash liefert einen vorhandenen Korrekturfaktor aber keine gespeicherten PV-Werte
          $dnum   = 1;
          $factor = sprintf "%.2f", ($pvrl / $pvfcraw);
          $factor = sprintf "%.2f", ($factor + $oldfac) / 2;
      }
      else {                                                                                              # ganz neuer Wert
          $dnum   = 1;
          $factor = sprintf "%.2f", ($pvrl / $pvfcraw);
      }
  }
  else {
     $pvrl    = medianArray (\@{$data{$name}{circular}{$hh}{'pvrl_'.$sabin}{"$crang"}});                  # neuen Median berechnen
     $pvfcraw = medianArray (\@{$data{$name}{circular}{$hh}{'pvfc_'.$sabin}{"$crang"}});                  # neuen Median berechnen

     $factor = 0;
     $dnum   = scalar (@{$data{$name}{circular}{$hh}{'pvrl_'.$sabin}{"$crang"}});
     $factor = sprintf "%.2f", ($pvrl / $pvfcraw) if($pvrl && $pvfcraw);                                  # devision by zero Forum: https://forum.fhem.de/index.php?msg=1341884

     debugLog ($paref, 'pvCorrectionWrite', "$calc Corrf -> read stored values: PVreal median: $pvrl, PVforecast median: $pvfcraw, days: $dnum");
  }

  $factor = 1.00 if(1 * $factor == 0);                                                                    # 0.00-Werte ignorieren (Schleifengefahr)

  ## max. Faktorsteigerung berücksichtigen
  ##########################################
  if (abs($factor - $oldfac) > DEFMAXVAR) {
      $factor = sprintf "%.2f", ($factor > $oldfac ? $oldfac + DEFMAXVAR : $oldfac - DEFMAXVAR);
      Log3 ($name, 3, "$name - new $calc correction factor calculated (limited by maximum Day Variance): $factor (old: $oldfac) for hour: $hh");
  }
  else {
      Log3 ($name, 3, "$name - new $calc correction factor for hour $hh calculated: $factor (old: $oldfac)");
  }

  ## Qualität berechnen
  #######################
  $oldfac  = sprintf "%.2f", $oldfac;
  my $qual = __calcFcQuality ($pvapifc, $pvrl);                                                          # Qualität der Vorhersage für die vergangene Stunde

  debugLog ($paref, 'pvCorrectionWrite',                "$calc Corrf -> determined values - hour: $hh, Sun Altitude range: $sabin, Cloud range: $crang, old factor: $oldfac, new factor: $factor, days: $dnum");
  debugLog ($paref, 'pvCorrectionWrite|saveData2Cache', "$calc Corrf -> write correction values into Circular - hour: $hh, Sun Altitude range: $sabin, Cloud range: $crang, factor: $factor, quality: $qual, days: $dnum");

  ## neue Werte speichern
  #########################
  if ($calc eq 'Simple') {
      $data{$name}{circular}{$hh}{pvrlsum}{'simple'} = $pvrlsum;
      $data{$name}{circular}{$hh}{pvfcsum}{'simple'} = $pvfcsum;
      $data{$name}{circular}{$hh}{dnumsum}{'simple'} = $dnum;
      $data{$name}{circular}{$hh}{pvcorrf}{'simple'} = $factor;
      $data{$name}{circular}{$hh}{quality}{'simple'} = $qual;
  }
  else {
      my $idx                                    = $sabin.'.'.$crang;
      $data{$name}{circular}{$hh}{pvcorrf}{$idx} = $factor;
      $data{$name}{circular}{$hh}{quality}{$idx} = $qual;
  }

return ($oldfac, $factor, $dnum);
}

################################################################
#            Qualität der Vorhersage berechnen
################################################################
sub __calcFcQuality {
  my $pvapifc = shift;                                                     # PV Vorhersagewert
  my $pvrl    = shift;                                                     # PV reale Erzeugung

  return if(!$pvapifc || !$pvrl);

  my $diff = $pvapifc - $pvrl;
  my $hdv  = 1 - abs ($diff / $pvrl);                                      # Abweichung der Stunde, 1 = bestmöglicher Wert

  $hdv = $hdv < 0 ? 0 : $hdv;
  $hdv = sprintf "%.2f", $hdv;

return $hdv;
}

################################################################
#     Energieverbrauch des Hauses in History speichern
################################################################
sub _saveEnergyConsumption {
  my $paref = shift;
  my $name  = $paref->{name};
  my $day   = $paref->{day};
  my $chour = $paref->{chour};
  my $debug = $paref->{debug};

  my $hod     = sprintf "%02d", ($chour + 1);
  my $pvrl    = ReadingsNum ($name, 'Today_Hour'.$hod.'_PVreal',          0);   # Reading enthält die Summe aller Inverterdevices
  my $gfeedin = ReadingsNum ($name, 'Today_Hour'.$hod.'_GridFeedIn',      0);
  my $gcon    = ReadingsNum ($name, 'Today_Hour'.$hod.'_GridConsumption', 0);

  my $batin  = 0;
  my $batout = 0;

  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;
      $batin  += ReadingsNum ($name, 'Today_Hour'.$hod.'_BatIn_'.$bn,  0);
      $batout += ReadingsNum ($name, 'Today_Hour'.$hod.'_BatOut_'.$bn, 0);
  }

  my $ppreal = 0;

  for my $prn (1..MAXPRODUCER) {                                               # V1.32.0 : Erzeugung sonstiger Producer (01..03) hinzufügen
      $prn     = sprintf "%02d", $prn;
      $ppreal += ReadingsNum ($name, 'Today_Hour'.$hod.'_PPreal_'.$prn, 0);
  }

  my $con     = $pvrl + $ppreal - $gfeedin + $gcon - $batin + $batout;
  my $dowrite = 1;

  if (int $paref->{minute} > 30 && $con < 0) {                                  # V1.32.0 : erst den "eingeschwungenen" Zustand mit mehreren Meßwerten auswerten
      $dowrite = 0;
      my $vl   = 3;
      my $pre  = '- WARNING -';

      if ($debug =~ /consumption/xs) {
          $vl  = 1;
          $pre = 'DEBUG> - WARNING -';
      }

      Log3 ($name, $vl, "$name $pre The calculated Energy consumption of the house is negative. This appears to be an error and is not saved. Check Readings _PVreal, _GridFeedIn, _GridConsumption, _BatIn_XX, _BatOut_XX of hour >$hod<");
  }

  if ($debug =~ /collectData/xs) {
      Log3 ($name, 1, "$name DEBUG> EnergyConsumption input -> PV: $pvrl Wh, PP: $ppreal Wh, GridIn: $gfeedin Wh, GridCon: $gcon Wh, BatIn: $batin Wh, BatOut: $batout Wh");
      Log3 ($name, 1, "$name DEBUG> EnergyConsumption result -> $con Wh");
  }

  if ($dowrite) {
      writeToHistory ( { paref => $paref, key => 'con', val => $con, hour => $hod } );
      $data{$name}{circular}{99}{todayConsumption} = HistoryVal ($name, $day, '99', 'con', undef);

      debugLog ($paref, 'consumption', "consumption calculated - day: $day, hod: $hod, con: $con Wh");
      debugLog ($paref, 'saveData2Cache|consumption', "write pvCircular consumption - hod: 99, todayConsumption: ".HistoryVal ($name, $day, '99', 'con', 'undef')." Wh");
  }

return;
}

################################################################
#    optionale "special" Readings erstellen
################################################################
sub _genSpecialReadings {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $date   = $paref->{date};           # aktuelles Datum
  my $day    = $paref->{day};
  my $minute = $paref->{minute},         # aktuelle Minute (00-59)
  my $t      = $paref->{t};              # aktueller UNIX Timestamp

  my $hash = $defs{$name};
  my @srd  = sort keys (%hcsr);
  my @csr  = split ',', AttrVal ($name, 'ctrlSpecialReadings', '');
  my $prpo = 'special';

  for my $item (@srd) {
      next if(grep /^$item$/, @csr);
      readingsDelete    ($hash, $prpo.'_'.$item);
      deleteReadingspec ($hash, $prpo.'_'.$item.'_.*') if($item eq 'todayConsumptionForecast');
      deleteReadingspec ($hash, $prpo.'_'.$item.'_.*') if($item eq 'tomorrowConsumptionForecast');
  }

  return if(!@csr);

  my ($rapi, $wapi) = getStatusApiName ($hash);

  for my $kpi (@csr) {
      my $def = $hcsr{$kpi}{def};
      my $par = $hcsr{$kpi}{par};

      if (!defined $def || !defined $par) {
          Log3 ($name, 1, "$name - ERROR in Application - attribute ctrlSpecialReadings KPI '$kpi' has no Parameter or default value set. Set the attribute again or inform Maintainer.");
          next;
      }

      if ($def eq 'apimaxreq') {
          $def = isSolCastUsed   ($hash) ? (AttrVal ($name, 'ctrlSolCastAPImaxReq', SOLCMAXREQDEF)) :
                 isOpenMeteoUsed ($hash) ? OMETMAXREQ                                               :
                 'n.a.';
      }

      if ($hcsr{$kpi}{fnr} == 1) {
          storeReading ($prpo.'_'.$kpi, &{$hcsr{$kpi}{fn}} ($hash, $rapi, '?All', $kpi, $def));
      }
      elsif ($hcsr{$kpi}{fnr} == 2) {
          $par = $kpi if(!$par);
          storeReading ($prpo.'_'.$kpi, &{$hcsr{$kpi}{fn}} ($hash, $par, $def).$hcsr{$kpi}{unit});
      }
      elsif ($hcsr{$kpi}{fnr} == 3) {
          storeReading ($prpo.'_'.$kpi, &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, $kpi, $def).$hcsr{$kpi}{unit});
      }
      elsif ($hcsr{$kpi}{fnr} == 4) {
          storeReading ($prpo.'_'.$kpi, &{$hcsr{$kpi}{fn}} ($hash, $day, $hcsr{$kpi}{par}, $hcsr{$kpi}{par1}, $def).$hcsr{$kpi}{unit});
      }
      elsif ($hcsr{$kpi}{fnr} == 5) {
          if ($kpi eq 'SunHours_Remain') {
              my $ss  = &{$hcsr{$kpi}{fn}} ($hash, 'sunsetTodayTs',  $def);
              my $shr = ($ss - $t) / 3600;
              $shr    = $shr < 0 ? 0 : $shr;

              storeReading ($prpo.'_'.$kpi, sprintf "%.2f", $shr);
          }
          elsif ($kpi eq 'SunMinutes_Remain') {
              my $ss  = &{$hcsr{$kpi}{fn}} ($hash, 'sunsetTodayTs',  $def);
              my $smr = ($ss - $t) / 60;
              $smr    = $smr < 0 ? 0 : $smr;

              storeReading ($prpo.'_'.$kpi, sprintf "%.0f", $smr);
          }
          elsif ($kpi =~ /BatPower(In|Out)_Sum/xs) {
              my $bsum = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, $def);
              $bsum   .= $bsum eq $def ? '' : $hcsr{$kpi}{unit};

              storeReading ($prpo.'_'.$kpi, $bsum);
          }
          elsif ($kpi =~ /daysUntilBatteryCare_/xs) {
              my $bn = (split "_", $kpi)[1];                                                          # Batterienummer extrahieren
              my $d2c = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'days2care'.$bn, $def);

              storeReading ($prpo.'_'.$kpi, $d2c);
          }
          elsif ($kpi =~ /remainingHrsWoChargeRcmdBat_/xs) {
              my $bn = (split "_", $kpi)[1];
              my $n  = 0;

              for my $idx (sort keys %{$data{$name}{nexthours}}) {
                  my $istoday = &{$hcsr{$kpi}{fn}} ($name, $idx, 'today', 0);
                  last if(!$istoday);

                  my $rcdcharge = &{$hcsr{$kpi}{fn}} ($name, $idx, $hcsr{$kpi}{par}, $def);
                 
                  if (!$rcdcharge) {
                      $n++;
                  }
              }
             
              storeReading ($prpo.'_'.$kpi, $n);
          }
          elsif ($kpi =~ /remainingSurplsHrsMinPwrBat_/xs) {
              my $bn        = (split "_", $kpi)[1];
              my $parsed    = __parseAttrBatSoc ($name, AttrVal ($name, 'ctrlBatSocManagement'.$bn, undef));
              my $loadAbort = $parsed->{loadAbort}; 
              my $n         = 0;
              my $lasthod;
              
              if ($loadAbort) {
                  my (undef, $minpwr) = split ':', $loadAbort;                      
                  $minpwr            *= 1;                                                            # MinPower auf 1h normiert -> Wh 

                  for my $idx (sort keys %{$data{$name}{nexthours}}) {
                      my $istoday = &{$hcsr{$kpi}{fn}} ($name, $idx, 'today', 0);
                      last if(!$istoday);

                      my $pvfc  = &{$hcsr{$kpi}{fn}} ($name, $idx, $hcsr{$kpi}{par},  $def);
                      my $confc = &{$hcsr{$kpi}{fn}} ($name, $idx, $hcsr{$kpi}{par1}, $def);
                     
                      if (($pvfc - $confc) >= $minpwr) {
                          $lasthod = &{$hcsr{$kpi}{fn}} ($name, $idx, 'hourofday', 0);
                          $n++;
                      }
                  }
                  
                  if ($n) {                                                                           
                      my $mintotal = $n * 60;
                      $mintotal   -= int ($minute);                                                   # von den volle Stunden die aktuell schon vergangenen Minuten abziehen 
                      
                      my $tdaysset = CurrentVal ($name, 'sunsetTodayTs', 0);                          # Timestamp Sonnenuntergang aktueller Tag
                      my $dtsset   = timestringsFromOffset ($tdaysset,   0);
                      
                      if (int ($lasthod) == int ($dtsset->{hour}) + 1) {                              # wenn die letzte berücksichtigte Stunde die Stunde des Sonnenuntergangs ist
                          my $diflasth = 60 - $dtsset->{minute};                                      # fehlende Minuten zur vollen Stunde in der Stunde des Sunset 
                          $mintotal   -= int ($diflasth);
                      }
                      
                      $n = sprintf "%.2f", ($mintotal / 60);
                  }
                 
                  storeReading ($prpo.'_'.$kpi, $n);
              }
              else {
                  storeReading ($prpo.'_'.$kpi, $n. " (attribute ctrlBatSocManagement${bn}->loadAbort seems to be not set)");
              }
          }
          elsif ($kpi eq 'todayGridFeedIn') {
              my $idfi = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'initdayfeedin', $def);         # initialer Tagesstartwert
              my $cfi  = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'feedintotal',   $def);         # aktuelles total Feed In

              my $dfi  = $cfi - $idfi;

              storeReading ($prpo.'_'.$kpi, (sprintf "%.1f", $dfi).' Wh');
          }
          elsif ($kpi eq 'todayGridConsumption') {
              my $idgcon = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'initdaygcon',  $def);         # initialer Tagesstartwert
              my $cgcon  = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'gridcontotal', $def);         # aktuelles total Netzbezug

              my $dgcon  = $cgcon - $idgcon;

              storeReading ($prpo.'_'.$kpi, (sprintf "%.0f", $dgcon).' Wh');
          }
          elsif ($kpi eq 'todayBatInSum') {                                                                    # Summe tägl. Ladeenergie (alle Batterien)
              my $tdbisum = 0;

              for my $bn (1..MAXBATTERIES) {
                  $bn = sprintf "%02d", $bn;

                  my $idbitot = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'initdaybatintot'.$bn, $def);     # initialer Tagesstartwert Batterie In total
                  my $cbitot  = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'batintot'.$bn,        $def);     # aktuell total Batterieladung (Wh)

                  $tdbisum += ($cbitot - $idbitot);
              }

              storeReading ($prpo.'_'.$kpi, (sprintf "%.1f", $tdbisum).' '.$hcsr{$kpi}{unit});
          }
          elsif ($kpi eq 'todayBatOutSum') {                                                                   # Summe tägl. Entadeenergie (alle Batterien)
              my $tdbosum = 0;

              for my $bn (1..MAXBATTERIES) {
                  $bn = sprintf "%02d", $bn;

                  my $idbotot = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'initdaybatouttot'.$bn, $def);    # initialer Tagesstartwert Batterie Out total
                  my $cbotot  = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'batouttot'.$bn,        $def);    # aktuelles total Batterie Out

                  $tdbosum += ($cbotot - $idbotot);
              }

              storeReading ($prpo.'_'.$kpi, (sprintf "%.1f", $tdbosum).' '.$hcsr{$kpi}{unit});
          }
          elsif ($kpi =~ /todayBatIn_/xs) {
              my $bn = (split "_", $kpi)[1];                                                               # Batterienummer extrahieren
              my $idbitot = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'initdaybatintot'.$bn, $def);     # initialer Tagesstartwert Batterie In total
              my $cbitot  = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'batintot'.$bn,        $def);     # aktuell total Batterieladung (Wh)

              my $dbi = $cbitot - $idbitot;

              storeReading ($prpo.'_'.$kpi, (sprintf "%.1f", $dbi).' '.$hcsr{$kpi}{unit});
          }
          elsif ($kpi =~ /todayBatOut_/xs) {
              my $bn = (split "_", $kpi)[1];                                                               # Batterienummer extrahieren
              my $idbotot = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'initdaybatouttot'.$bn, $def);    # initialer Tagesstartwert Batterie Out total
              my $cbotot  = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, 'batouttot'.$bn,        $def);    # aktuelles total Batterie Out

              my $dbo = $cbotot - $idbotot;

              storeReading ($prpo.'_'.$kpi, (sprintf "%.1f", $dbo).' '.$hcsr{$kpi}{unit});
          }
          elsif ($kpi eq 'dayAfterTomorrowPVforecast') {                                                   # PV Vorhersage Summe für Übermorgen (falls Werte vorhanden), Forum:#134226        
              my $datpvfc = &{$hcsr{$kpi}{fn}} ($name, 'dayAfterTomorrowPVfc', $def);

              if ($datpvfc) {
                  storeReading ($prpo.'_'.$kpi, (sprintf "%.0f", $datpvfc).$hcsr{$kpi}{unit});
              }
              else {
                  storeReading ($prpo.'_'.$kpi, $datpvfc. ' (no data available)');
              }
          }
          elsif ($kpi =~ /currentRunMtsConsumer_/xs) {
              my $c = (split "_", $kpi)[1];                                                          # Consumer Nummer extrahieren

              if (!AttrVal ($name, 'consumer'.$c, '')) {
                  readingsDelete ($hash, $prpo.'_currentRunMtsConsumer_'.$c);
                  next;
              }

              my $mion = &{$hcsr{$kpi}{fn}} ($hash, $c, $hcsr{$kpi}{par}, $def);

              storeReading ($prpo.'_'.$kpi, (sprintf "%.0f", $mion).$hcsr{$kpi}{unit});
          }
          elsif ($kpi =~ /runTimeAvgDayConsumer_/xs) {
              my $c = (split "_", $kpi)[1];                                                          # Consumer Nummer extrahieren

              if (!AttrVal ($name, 'consumer'.$c, '')) {
                  readingsDelete ($hash, $prpo.'_runTimeAvgDayConsumer_'.$c);
                  next;
              }

              my $radc = &{$hcsr{$kpi}{fn}} ($hash, $c, $hcsr{$kpi}{par}, $def);

              storeReading ($prpo.'_'.$kpi, $radc.$hcsr{$kpi}{unit});
          }
          elsif ($kpi eq 'todayNotOwnerConsumption') {                                                         # Summe Verbrauch, der nicht Consumern zugeordnet werden kann
              my $csme = 0;
              
              my $contoday = &{$hcsr{$kpi}{fn}} ($hash, $hcsr{$kpi}{par}, $hcsr{$kpi}{par1}, $def);            # Tagesverbrauch Summe (Wh)
              
              for my $c (1..MAXCONSUMER) {                                                                     # Verbrauch alle Consumer
                  $c     = sprintf "%02d", $c;
                  $csme += HistoryVal ($name, $day, '99', "csme${c}", 0); 
                  
              }
              
              my $nowncon = $contoday - $csme;
              $nowncon    = max (0, $nowncon);

              storeReading ($prpo.'_'.$kpi, (sprintf "%.1f", $nowncon).' '.$hcsr{$kpi}{unit});
          }
          elsif ($kpi eq 'todayConsumptionForecast') {
             for my $hod (sort keys %{$data{$name}{pvhist}{$day}}) {
                 next if(!$hod || $hod == 99);

                 my $confc = &{$hcsr{$kpi}{fn}} ($hash, $day, $hod, $hcsr{$kpi}{par1}, $def);

                 storeReading ($prpo.'_'.$kpi.'_'.$hod, $confc.$hcsr{$kpi}{unit});
             }
          }
          elsif ($kpi eq 'tomorrowConsumptionForecast') {
              my $dt     = timestringsFromOffset ($t, 86400);
              my $tmoday = $dt->{day}; 
             
              for my $idx (sort keys %{$data{$name}{nexthours}}) {
                  my $nhday = NexthoursVal ($hash, $idx, 'day', 0);
                  next if(int ($nhday) != int ($tmoday));

                  my $hod   = NexthoursVal ($hash, $idx, 'hourofday', '01');
                  my $confc = &{$hcsr{$kpi}{fn}} ($hash, $idx, $hcsr{$kpi}{par}, $def);

                  storeReading ($prpo.'_'.$kpi.'_'.$hod, $confc.$hcsr{$kpi}{unit});
              }
          }
          elsif ($kpi eq 'conForecastTillNextSunrise') {
             my ($confc, $confcs, $confcsr) = (0, 0, 0);
             my $donl  = 1;
             my $lap   = 1;

             for my $idx (sort keys %{$data{$name}{nexthours}}) {
                 my $don = NexthoursVal ($hash, $idx, 'DoN', 2);                                      # Wechsel von 0 -> 1 für Abbruch relevant
                 last if($don == 2);

                 if ($donl == 0 && $don == 1) {
                     last;
                 }
                 
                 $confc  += &{$hcsr{$kpi}{fn}} ($hash, $idx, $hcsr{$kpi}{par}, $def);
                 $confcs  = &{$hcsr{$kpi}{fn}} ($hash, $idx, $hcsr{$kpi}{par}, $def) if($lap == 1);   # Verbrauchsprognosewert in der aktuellen Stunde
                 $confcsr = &{$hcsr{$kpi}{fn}} ($hash, $idx, $hcsr{$kpi}{par}, $def);                 # letzter Verbrauchsprognosewert -> in der Stunde des Sonnenaufgang
                 $donl    = $don;
                 
                 $lap++;
             }

             $confcs  = max (0, $confcs);
             $confcsr = max (0, $confcsr);
             $confc   = max (0, $confc);
             
             my $tdaysrise = CurrentVal ($name, 'sunriseTodayTs',    0);
             my $tmorsrise = CurrentVal ($name, 'sunriseTomorrowTs', 0);
             my $sunrise   = $t < $tdaysrise ? $tdaysrise : $tmorsrise;

             if ($confc && $sunrise) { 
                 my $dt;
                 $confc -= $confcs;
                 
                 $dt           = timestringsFromOffset ($t, 0);
                 my $curmts    = int ($dt->{minute}) + 1;                                            # vergangene Minuten in der aktuellen Stunde            
                 my $cfcscurh  = ($confcs / 60) * (60 - $curmts);                                    # anteiler Verbrauch (Schätzung) aktuelle Zeit bis volle Stunde
                 $confc       += $cfcscurh;
                 
                 $confc       -= $confcsr;
                 my $dtrise    = timestringsFromOffset ($sunrise, 0);
                 my $srisemts  = int ($dtrise->{minute}) + 1;                                        # vergangene Minuten in der Stunde des Sunrise     
                 my $cfcsrish  = ($confcsr / 60) * $srisemts;                                        # anteiler Verbrauch (Schätzung) volle Stunde bis Sunrise
                 $confc       += $cfcsrish;
                 
                 storeReading ($prpo.'_'.$kpi, (sprintf "%.0f", $confc).$hcsr{$kpi}{unit});
             }
             else {
                 storeReading ($prpo.'_'.$kpi, $confc.$hcsr{$kpi}{unit});
             }
          }
          elsif ($kpi eq 'conForecastComingNight') {
             my ($confc, $confcss, $confcsr) = (0, 0, 0);
             my $donl  = 1;
             my $lap   = 1;
             
             my $tdaysset  = CurrentVal ($name, 'sunsetTodayTs',  0);
             my $tdaysrise = CurrentVal ($name, 'sunriseTodayTs', 0);
             my $dtsset    = timestringsFromOffset ($tdaysset,  0);
             my $dtsrise   = timestringsFromOffset ($tdaysrise, 0);

             for my $idx (sort keys %{$data{$name}{nexthours}}) {
                 my $don = NexthoursVal ($hash, $idx, 'DoN', 2);                                      # Wechsel von 0 -> 1 für Abbruch relevant
                 last if($don == 2);               
                 
                 if ($donl == 0 && $don == 1) {
                     last;
                 }
                 
                 my $hod = NexthoursVal ($hash, $idx, 'hourofday', '01');  
                 
                 next if(int ($hod) > int ($dtsrise->{hour}) + 1 && int ($hod) < int ($dtsset->{hour}) + 1); 

                 $confc  += &{$hcsr{$kpi}{fn}} ($hash, $idx, $hcsr{$kpi}{par}, $def);
                 $confcss = &{$hcsr{$kpi}{fn}} ($hash, $idx, $hcsr{$kpi}{par}, $def) if($lap == 1);   # Verbrauchsprognosewert in der Stunde des Sonnenuntergangs
                 $confcsr = &{$hcsr{$kpi}{fn}} ($hash, $idx, $hcsr{$kpi}{par}, $def);                 # letzter Verbrauchsprognosewert -> in der Stunde des Sonnenaufgang
                 $donl    = $don;
                 
                 $lap++;
             }

             $confcss = max (0, $confcss);
             $confcsr = max (0, $confcsr);
             $confc   = max (0, $confc);
             
             my $tmorsrise = CurrentVal ($name, 'sunriseTomorrowTs', 0);
             my $sunrise   = $t < $tdaysrise ? $tdaysrise : $tmorsrise; 

             if ($confc && $tdaysset && $sunrise) { 
                 my $dt;
                 $confc -= $confcss;
                 
                 if ($t < $tdaysset) {                                                               # Auswertung noch vor Sonnenuntergang
                     $dt = timestringsFromOffset ($tdaysset, 0);
                 }
                 else {
                     $dt = timestringsFromOffset ($t, 0);
                 }
                 
                 my $ssetmts   = int ($dt->{minute}) + 1;                                            # vergangene Minuten in der Stunde des Sunset bzw. in der aktuellen Stunde            
                 my $cfcsseth  = ($confcss / 60) * (60 - $ssetmts);                                  # anteiler Verbrauch (Schätzung) Sunset bis volle Stunde bzw. aktuelle Zeit bis volle Stunde
                 $confc       += $cfcsseth;
                 
                 $confc       -= $confcsr;
                 my $dtrise    = timestringsFromOffset ($sunrise, 0);
                 my $srisemts  = int ($dtrise->{minute}) + 1;                                        # vergangene Minuten in der Stunde des Sunrise     
                 my $cfcsrish  = ($confcsr / 60) * $srisemts;                                        # anteiler Verbrauch (Schätzung) volle Stunde bis Sunrise
                 $confc       += $cfcsrish;
                 
                 storeReading ($prpo.'_'.$kpi, (sprintf "%.0f", $confc).$hcsr{$kpi}{unit});
             }
             else {
                 storeReading ($prpo.'_'.$kpi, $confc.$hcsr{$kpi}{unit});
             }
          }
      }
  }

return;
}

###################################################################################
#      Erstellen System-Messages für Notification System
#  Struktur:
#  0|SV|1
#  0|DE|Mitteilung ....
#  0|EN|Message...
#  $data{$name}{preparedmessages}{999500}{TS}: Timestamp Stand prepared Messages
#
# if (<Bedingung>) {
#    $midx++;
#    $data{$name}{preparedmessages}{$midx}{SV}  = 1;
#    $data{$name}{preparedmessages}{$midx}{DE}  = 'Mitteilung deutsch <br>';
#    $data{$name}{preparedmessages}{$midx}{DE} .= 'weiter Mittelung deusch';
#    $data{$name}{preparedmessages}{$midx}{EN}  = 'message english <br>';
#    $data{$name}{preparedmessages}{$midx}{EN} .= 'continue message english';
# }
###################################################################################
sub _readSystemMessages {
  my $paref = shift;
  my $name  = $paref->{name};

  delete $data{$name}{preparedmessages};

  my $midx = 0;
  
  my ($cset, $lat, $lon, $alt) = locCoordinates();
  my $noloc = '';
  my @nlc; 
  
  push @nlc, 'altitude'  if(!$alt);
  push @nlc, 'latitude'  if(!$lat);
  push @nlc, 'longitude' if(!$lon);
  
  $noloc = join ',', @nlc if(@nlc);

  if ($noloc) {
      $midx++;
      $data{$name}{preparedmessages}{$midx}{SV}  = 3;
      $data{$name}{preparedmessages}{$midx}{DE}  = "<span style='color: red;'><b>ACHTUNG:</b></span> Im global Device sind diese wichtigen Parameter nicht vorhanden: $noloc <br>";
      $data{$name}{preparedmessages}{$midx}{DE} .= 'Bitte unbedingt diese Attribute im global Device setzen!';
      $data{$name}{preparedmessages}{$midx}{EN}  = "<span style='color: red;'><b>CAUTION:</b></span> These important parameters are not available in the global device: $noloc <br>";
      $data{$name}{preparedmessages}{$midx}{EN} .= 'Please be sure to set these attributes in the global device!';
  }

  $data{$name}{preparedmessages}{999500}{TS} = time;

return;
}

################################################################
#              FHEMWEB Fn
################################################################
sub FwFn {
  my ($FW_wname, $name, $room, $pageHash) = @_;                                  # pageHash is set for summaryFn.
  my $hash = $defs{$name};

  $hash->{HELPER}{FW} = $FW_wname;

  my $ret = "<html>";
  $ret   .= entryGraphic ($name);
  $ret   .= "</html>";

return $ret;
}

################################################################
#    Grafik als HTML zurück liefern    (z.B. für Widget)
################################################################
sub pageAsHtml {
  my $name = shift;
  my $ftui = shift // '';
  my $gsel = shift // '';                                                                  # direkte Auswahl welche Grafik zurück gegeben werden soll (both, flow, forecast)

  my $ret = "<html>";
  $ret   .= entryGraphic ($name, $ftui, $gsel, 1);
  $ret   .= "</html>";

return $ret;
}

################################################################
#                  Einstieg Grafikanzeige
################################################################
sub entryGraphic {
  my $name = shift;
  my $ftui = shift // '';
  my $gsel = shift // '';                                                                  # direkte Auswahl welche Grafik zurück gegeben werden soll (both, flow, forecast)
  my $pah  = shift // 0;                                                                   # 1 wenn durch pageAsHtml aufgerufen

  return if(!$init_done);

  my $hash = $defs{$name};

  # Setup Vollständigkeit/disabled prüfen
  #########################################
  my $incomplete = _checkSetupNotComplete ($hash);
  return $incomplete if($incomplete);

  # Kontext des SolarForecast-Devices speichern für Refresh
  ##########################################################
  $hash->{HELPER}{SPGDEV}    = $name;                                                      # Name des aufrufenden SolarForecastSPG-Devices
  $hash->{HELPER}{SPGROOM}   = $FW_room   ? $FW_room   : "";                               # Raum aus dem das SolarForecastSPG-Device die Funktion aufrief
  $hash->{HELPER}{SPGDETAIL} = $FW_detail ? $FW_detail : "";                               # Name des SolarForecastSPG-Devices (wenn Detailansicht)

  # Parameter f. Anzeige extrahieren
  ###################################
  my $width      = CurrentVal ($name, 'beamWidth', BEAMWIDTH);                             # zu klein ist nicht problematisch
  my $maxhours   = CurrentVal ($name, 'hourCount', HOURCOUNT);
  my $alias      = AttrVal    ($name, 'alias',            $name);                          # Linktext als Aliasname oder Devicename setzen

  AttrVal ($name, 'graphicShowNight', 0) =~ /(.)(.)?/xs;
  my $show_night = $1 // 0;
  my $layersync  = $2 // 0;

  my $w          = $width * $maxhours;                                                     # gesammte Breite der Ausgabe , WetterIcon braucht ca. 34px
  my $offset     = -1 * AttrNum ($name, 'graphicHistoryHour', HISTHOURDEF);
  my $dlink      = qq{<a href="$::FW_ME$::FW_subdir?detail=$name">$alias</a>};

  if (!$gsel) {
      $gsel = AttrVal ($name, 'graphicSelect', 'both');                                    # Auswahl der anzuzeigenden Grafiken
  }

  my $paref = {
      name           => $name,
      hash           => $hash,
      type           => $hash->{TYPE},
      ftui           => $ftui,
      pah            => $pah,
      maxhours       => $maxhours,
      t              => time,
      modulo         => 1,
      dstyle         => qq{style='padding-left: 10px; padding-right: 10px; padding-top: 3px; padding-bottom: 3px; white-space:nowrap;'},     # TD-Style
      offset         => $offset,
      colorb1        => AttrVal    ($name, 'graphicBeam1Color',           B1COLDEF),
      colorb2        => AttrVal    ($name, 'graphicBeam2Color',           B2COLDEF),
      fcolor1        => AttrVal    ($name, 'graphicBeam1FontColor',   B1FONTCOLDEF),
      fcolor2        => AttrVal    ($name, 'graphicBeam2FontColor',   B2FONTCOLDEF),
      beam1cont      => AttrVal    ($name, 'graphicBeam1Content',         'pvReal'),
      beam2cont      => AttrVal    ($name, 'graphicBeam2Content',     'pvForecast'),
      beam3cont      => AttrVal    ($name, 'graphicBeam3Content',               ''),
      beam4cont      => AttrVal    ($name, 'graphicBeam4Content',               ''),
      beam5cont      => AttrVal    ($name, 'graphicBeam5Content',               ''),
      beam6cont      => AttrVal    ($name, 'graphicBeam6Content',               ''),
      weather        => AttrNum    ($name, 'graphicShowWeather',                 1),                # Wetter Icons anzeigen
      colorw         => AttrVal    ($name, 'graphicWeatherColor',       WTHCOLDDEF),                # Wetter Icon Farbe Tag
      colorwn        => AttrVal    ($name, 'graphicWeatherColorNight',  WTHCOLNDEF),                # Wetter Icon Farbe Nacht
      wlalias        => AttrVal    ($name, 'alias',                          $name),
      lotype         => CurrentVal ($name, 'layoutType',                  'double'),
      hourstyle      => CurrentVal ($name, 'hourStyle',                         ''),
      hdrDetail      => CurrentVal ($name, 'headerDetail',                   'all'),                # ermöglicht den Inhalt zu begrenzen, um bspw. passgenau in ftui einzubetten
      spacesz        => CurrentVal ($name, 'spaceSize',                  SPACESIZE),
      kw             => CurrentVal ($name, 'energyUnit',                      'Wh'),
      clegendpos     => CurrentVal ($name, 'showLegend',                'icon_top'),                # Lage und Art Cunsumer Legende
      clink          => CurrentVal ($name, 'detailLink',                         1),                # Link zur Detailansicht des Verbrauchers
      caicon         => CurrentVal ($name, 'adviceIcon',                 CAICONDEF),                # Consumer AdviceIcon
      flowgsize      => CurrentVal ($name, 'size',                    FLOWGSIZEDEF),                # Größe Energieflußgrafik
      flowgani       => CurrentVal ($name, 'animate',                            1),                # Animation Energieflußgrafik
      flowgxshift    => CurrentVal ($name, 'shiftx',                             0),                # X-Verschiebung der Flußgrafikbox (muß negiert werden)
      flowgyshift    => CurrentVal ($name, 'shifty',                             0),                # Y-Verschiebung der Flußgrafikbox (muß negiert werden)
      flowgconsumer  => CurrentVal ($name, 'showconsumer',                       1),                # Verbraucher in der Energieflußgrafik anzeigen
      flowgconX      => CurrentVal ($name, 'showconsumerdummy',                  1),                # Dummyverbraucher in der Energieflußgrafik anzeigen
      flowgconsPower => CurrentVal ($name, 'showconsumerpower',                  1),                # Verbraucher Leistung in der Energieflußgrafik anzeigen
      flowgconsTime  => CurrentVal ($name, 'showconsumerremaintime',             1),                # Verbraucher Restlaufeit in der Energieflußgrafik anzeigen
      flowgconsDist  => CurrentVal ($name, 'consumerdist',                 FGCDDEF),                # Abstand Verbrauchericons zueinander
      flowgh2cDist   => CurrentVal ($name, 'h2consumerdist',                     0),                # Erweiterung des vertikalen Abstandes Haus -> Consumer
      genpvdva       => CurrentVal ($name, 'genPVdeviation',               'daily'),                # Methode der Abweichungsberechnung
      lang           => getLang    ($hash),
      debug          => getDebug   ($hash),                                                         # Debug Module
      width          => $width,
      layersync      => $layersync,                                                                 # Zeitsynchronisation zwischen Ebene 1 und den folgenden Balkengrafikebenen
      show_night     => $show_night,                                                                # alle Balken (Spalten) anzeigen ?
      graphicselect  => $gsel,                                                                      # Optionen der Grafikselektion
  };

  my $colspan = $maxhours + 2;
  my $ret     = q{};

  $ret .= "<span>$dlink </span><br>"  if(CurrentVal ($name, 'showLink', 0));
  $ret .= '<style>';
  $ret .= 'TD.solarfc {text-align: center; padding-left:5px; padding-right:5px; margin:0px;}';
  $ret .= '.batcontainer_below {position: relative;}';                                                                  # Batterie mit Beschriftung untereinander
  $ret .= '.batsoc_below {position: relative;}';                                                                        # Batterie mit Beschriftung untereinander
  $ret .= '.batcontainer_beside {position: relative; left: 20%;}';                                                      # Batterie mit Beschriftung nebeneiander
  $ret .= '.batsoc_beside {position: absolute; top: 50%; left: 5%; transform: translate(-50%, -50%) rotate(-90deg);}';  # Batterie mit Beschriftung nebeneiander     # Bsp: z-index: '.batsoc { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-90deg); color:#000; z-index: 2; }';
  $ret .= '</style>';
  $ret .= "<table class='roomoverview' width='$w' style='width:".$w."px'><tr class='devTypeTr'></tr>";
  $ret .= "<tr><td class='solarfc'>";

  # Kopfbereich inkl. Benutzerbereich generieren
  ################################################
  my $header = _graphicHeader ($paref);

  # Verbraucherlegende und Steuerung generieren
  ###############################################
  my $cnmlegend = _graphicConsumerLegend ($paref);

  my $m = $paref->{modulo} % 2;
  $ret .= "\n<table class='block'>";                                                                        # das \n erleichtert das Lesen der debug Quelltextausgabe

  if ($header) {                                                                                            # Header ausgeben
      $ret .= "<tr class='$htr{$m}{cl}'>";
      $ret .= "<td colspan='$colspan' align='center' style='word-break: normal'>$header</td>";
      $ret .= "</tr>";

      $paref->{modulo}++;
  }

  $m = $paref->{modulo} % 2;

  # Verbraucherlegende oben
  ###################################################################################
  if ($cnmlegend && $paref->{clegendpos} =~ /_top$/xs) {
      $ret .= "<tr class='$htr{$m}{cl}'>";
      $ret .= "<td colspan='$colspan' align='center' style='padding-left: 10px; padding-top: 5px; padding-bottom: 5px; word-break: normal'>";
      $ret .= $cnmlegend;
      $ret .= "</td>";
      $ret .= "</tr>";

      $paref->{modulo}++;
  }

  $m = $paref->{modulo} % 2;

  # Flußgrafik oberhalb Balkengrafik
  ###################################################################################
  if ($gsel =~ /swap/xs) {
      $ret  .= "<tr class='$htr{$m}{cl}'>";
      $ret  .= "<td colspan='$colspan' align='center' style='word-break: normal'>";
      $ret  .= _flowGraphic ($paref);
      $ret  .= "</td>";
      $ret  .= "</tr>";
      $ret  .= _levelSeparator ($paref);

      $paref->{modulo}++;
  }

  $m = $paref->{modulo} % 2;

  ## Balkengrafiken
  ###################################################################################
  my $scm = _parseScaleModes    ($name);                                                                   # Scale Modes auflösen
  my $bhl = _parseHeightLevels  ($name);                                                                   # beamHeightLevel auflösen
  my $sdf = _parseShowdiffModes ($name);
  
  ## Balkengrafik Ebene 1
  #########################
  if ($gsel =~ /both|swap|forecast/xs) {
      my %hfcg1;
      $paref->{chartlvl} = 1;                                                                              # Balkengrafik Ebene 1
      $paref->{scm}      = $scm->{1};                                                                      # Scale Mode Level 1
      $paref->{height}   = $bhl->{1};                                                                      # beamHeightLevel 1
      $paref->{showdiff} = $sdf->{1};                                                                      # show Diff Mode Level 1
      $paref->{hfcg}     = \%hfcg1;                                                                        # hfcg = hash forecast graphic

      ## Werte aktuelle Stunde
      ##########################
      $paref->{thishour} = _beamGraphicFirstHour ($paref);

      ## get consumer list and display it in Graphics
      #################################################
      #_showConsumerInGraphicBeam ($paref);                                                                # keine Verwendung zur Zeit

      ## Werte restliche Stunden
      ############################
      my $back           = _beamGraphicRemainingHours ($paref);
      $paref->{maxVal}   = $back->{maxVal};                                                                # Startwert
      $paref->{maxStVal} = $back->{maxStVal};                                                              # Start Staplewert
      $paref->{maxDif}   = $back->{maxDif};                                                                # für Typ diff
      $paref->{minDif}   = $back->{minDif};                                                                # für Typ diff

      ## Batteriewerte füllen
      #########################
      _beamFillupBatValues ($paref);

      # Balkengrafik Ausgabe
      ########################
      $ret .= _beamGraphic    ($paref);
      $ret .= _levelSeparator ($paref);

      delete $paref->{maxVal};                                                                             # bereinigen vor nächster Ebene
      delete $paref->{maxStVal};
      delete $paref->{maxDif};
      delete $paref->{minDif};
      delete $paref->{hfcg};

      ## Balkengrafik Ebene 2
      #########################
      if ($paref->{beam3cont} || $paref->{beam4cont}) {                                                    # Balkengrafik Ebene 2
          my %hfcg2;

          $paref->{chartlvl}  = 2;
          $paref->{scm}       = $scm->{2};                                                                 # Scale Mode Level 2
          $paref->{height}    = $bhl->{2};                                                                 # beamHeightLevel 2
          $paref->{showdiff}  = $sdf->{2};                                                                 # show Diff Mode Level 2
          $paref->{beam1cont} = $paref->{beam3cont};
          $paref->{beam2cont} = $paref->{beam4cont};
          $paref->{colorb1}   = AttrVal ($name, 'graphicBeam3Color',       B3COLDEF);
          $paref->{colorb2}   = AttrVal ($name, 'graphicBeam4Color',       B4COLDEF);
          $paref->{fcolor1}   = AttrVal ($name, 'graphicBeam3FontColor',   B3FONTCOLDEF);
          $paref->{fcolor2}   = AttrVal ($name, 'graphicBeam4FontColor',   B4FONTCOLDEF);
          $paref->{weather}   = 0;
          $paref->{hfcg}      = \%hfcg2;

          # Werte aktuelle Stunde
          ##########################
          $paref->{thishour} = _beamGraphicFirstHour ($paref);

          # Werte restliche Stunden
          ###########################
          my $back           = _beamGraphicRemainingHours ($paref);
          $paref->{maxVal}   = $back->{maxVal};                                                           # Startwert wenn kein Wert bereits via attr vorgegeben ist
          $paref->{maxStVal} = $back->{maxStVal};                                                         # Start Staplewert
          $paref->{maxDif}   = $back->{maxDif};                                                           # für Typ diff
          $paref->{minDif}   = $back->{minDif};                                                           # für Typ diff

          ## Batteriewerte füllen
          #########################
          _beamFillupBatValues ($paref);

          # Balkengrafik Ausgabe
          ########################
          $ret .= _beamGraphic    ($paref);
          $ret .= _levelSeparator ($paref);

          delete $paref->{maxVal};                                                                        # bereinigen vor nächster Ebene
          delete $paref->{maxStVal};
          delete $paref->{maxDif};
          delete $paref->{minDif};
          delete $paref->{hfcg};
      }

      ## Balkengrafik Ebene 3
      #########################
      if ($paref->{beam5cont} || $paref->{beam6cont}) {                                                    # Balkengrafik Ebene 3
          my %hfcg3;

          $paref->{chartlvl}  = 3;
          $paref->{scm}       = $scm->{3};                                                                 # Scale Mode Level 3
          $paref->{height}    = $bhl->{3};                                                                 # beamHeightLevel 3
          $paref->{showdiff}  = $sdf->{3};                                                                 # show Diff Mode Level 3
          $paref->{beam1cont} = $paref->{beam5cont};
          $paref->{beam2cont} = $paref->{beam6cont};
          $paref->{colorb1}   = AttrVal ($name, 'graphicBeam5Color',       B5COLDEF);
          $paref->{colorb2}   = AttrVal ($name, 'graphicBeam6Color',       B6COLDEF);
          $paref->{fcolor1}   = AttrVal ($name, 'graphicBeam5FontColor',   B5FONTCOLDEF);
          $paref->{fcolor2}   = AttrVal ($name, 'graphicBeam6FontColor',   B6FONTCOLDEF);
          $paref->{weather}   = 0;
          $paref->{hfcg}      = \%hfcg3;

          # Werte aktuelle Stunde
          ##########################
          $paref->{thishour} = _beamGraphicFirstHour ($paref);

          # Werte restliche Stunden
          ###########################
          my $back           = _beamGraphicRemainingHours ($paref);
          $paref->{maxVal}   = $back->{maxVal};                                                           # Startwert wenn kein Wert bereits via attr vorgegeben ist
          $paref->{maxStVal} = $back->{maxStVal};                                                         # Start Staplewert
          $paref->{maxDif}   = $back->{maxDif};                                                           # für Typ diff
          $paref->{minDif}   = $back->{minDif};                                                           # für Typ diff

          ## Batteriewerte füllen
          #########################
          _beamFillupBatValues ($paref);

          # Balkengrafik Ausgabe
          ########################
          $ret .= _beamGraphic    ($paref);
          $ret .= _levelSeparator ($paref);

          delete $paref->{maxVal};                                                                        # bereinigen vor nächster Ebene
          delete $paref->{maxStVal};
          delete $paref->{maxDif};
          delete $paref->{minDif};
          delete $paref->{hfcg};
      }

      $paref->{modulo}++;
  }

  $m = $paref->{modulo} % 2;

  # Flußgrafik unterhalb Balkengrafik
  ###################################################################################
  if ($gsel =~ /both|flow/xs) {
      $ret  .= "<tr class='$htr{$m}{cl}'>";
      $ret  .= "<td colspan='$colspan' align='center' style='word-break: normal'>";
      $ret  .= _flowGraphic ($paref);
      $ret  .= "</td>";
      $ret  .= "</tr>";

      $paref->{modulo}++;
  }

  $m = $paref->{modulo} % 2;

  # Verbraucherlegende unten
  ###################################################################################
  if ($cnmlegend && $paref->{clegendpos} =~ /_bottom$/xs) {
      $ret .= "<tr class='$htr{$m}{cl}'>";
      $ret .= "<td colspan='$colspan' align='center' style='padding-left: 10px; padding-top: 5px; padding-bottom: 5px; word-break: normal'>";
      $ret .= "$cnmlegend</td>";
      $ret .= "</tr>";
  }
  
  undef $paref;

  $ret .= "</table>";

  $ret .= "</td></tr>";
  $ret .= "</table>";

return $ret;
}

################################################################
#       Vollständigkeit Setup prüfen
################################################################
sub _checkSetupNotComplete {
  my $hash = shift;
  my $ret  = q{};

  my $name = $hash->{NAME};

  my $strings = AttrVal ($name, 'setupInverterStrings',   undef);                           # String Konfig
  my $wedev   = AttrVal ($name, 'setupWeatherDev1',       undef);                           # Device Vorhersage Wetterdaten (Bewölkung etc.)
  my $radev   = AttrVal ($name, 'setupRadiationAPI',      undef);                           # Device Strahlungsdaten Vorhersage
  my $indev   = AttrVal ($name, 'setupInverterDev01',     undef);                           # Inverter Device
  my $medev   = AttrVal ($name, 'setupMeterDev',          undef);                           # Meter Device
  my $peaks   = AttrVal ($name, 'setupStringPeak',        undef);                           # String Peak
  my $maz     = AttrVal ($name, 'setupStringAzimuth',     undef);                           # Modulausrichtung Konfig (Azimut)
  my $mdec    = AttrVal ($name, 'setupStringDeclination', undef);                           # Modul Neigungswinkel Konfig
  my $mrt     = AttrVal ($name, 'setupRoofTops',          undef);                           # RoofTop Konfiguration (SolCast API)

  my $vrmcr   = StatusAPIVal ($hash, '?VRM', '?API', 'credentials', '');                    # Victron VRM Credentials gesetzt

  my ($coset, $lat, $lon) = locCoordinates();                                               # Koordinaten im global device
  my $rip;
  $rip    = 1 if(exists $data{$name}{statusapi}{'?IdPair'});                                # es existiert mindestens ein Paar RoofTop-ID / API-Key
  my $pv0 = NexthoursVal ($hash, 'NextHour00', 'pvfc', undef);                              # der erste PV ForeCast Wert

  my $link = qq{<a href="$::FW_ME$::FW_subdir?detail=$name">$name</a>};
  my $lang = getLang ($hash);

  my (undef, $disabled, $inactive) = controller ($name);

  if ($disabled || $inactive) {
      $ret .= "<table class='roomoverview'>";
      $ret .= "<tr style='height:".BHEIGHTLEVEL."px'>";
      $ret .= "<td>";
      $ret .= qq{SolarForecast device $link is disabled or inactive};
      $ret .= "</td>";
      $ret .= "</tr>";
      $ret .= "</table>";

      return $ret;
  }

  ## Anlagen Check-Icon
  #######################
  my $cmdplchk = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=get $name plantConfigCheck', function(data){FW_okDialog(data)})"};
  my $img      = FW_makeImage('edit_settings@grey');
  my $chkicon  = "<a onClick=$cmdplchk>$img</a>";
  my $chktitle = $htitles{plchk}{$lang};

  if (!$strings || !$wedev || !$radev || !$indev || !$medev || !$peaks                                   ||
     (isSolCastUsed ($hash) ? (!$rip || !$mrt) : isVictronKiUsed ($hash) ? !$vrmcr : (!$maz || !$mdec )) ||
     (isForecastSolarUsed ($hash) ? !$coset : '')                                                        ||
     (isOpenMeteoUsed ($hash)     ? !$coset : '')                                                        ||
     !defined $pv0) {
      $ret .= "<table class='roomoverview'>";
      $ret .= "<tr style='height:".BHEIGHTLEVEL."px'>";
      $ret .= "<td>";
      $ret .= $hqtxt{entry}{$lang};                                                         # Entry Text

      if (!$strings) {                                                                      ## no critic 'Cascading'
          $ret .= $hqtxt{ist}{$lang};
      }
      elsif (!$peaks) {
          $ret .= $hqtxt{mps}{$lang};
      }
      elsif (!$radev) {
          $ret .= $hqtxt{crd}{$lang};
      }
      elsif (!$indev) {
          $ret .= $hqtxt{cid}{$lang};
      }
      elsif (!$medev) {
          $ret .= $hqtxt{mid}{$lang};
      }
      elsif (!$rip && isSolCastUsed ($hash)) {
          $ret .= $hqtxt{rip}{$lang};
      }
      elsif (!$mrt && isSolCastUsed ($hash)) {
          $ret .= $hqtxt{mrt}{$lang};
      }
      elsif (!$maz && !isSolCastUsed ($hash) && !isVictronKiUsed ($hash)) {
          $ret .= $hqtxt{mdr}{$lang};
      }
      elsif (!$mdec && !isSolCastUsed ($hash) && !isVictronKiUsed ($hash)) {
          $ret .= $hqtxt{mta}{$lang};
      }
      elsif (!$wedev) {
          $ret .= $hqtxt{cfd}{$lang};
      }
      elsif (!$vrmcr && isVictronKiUsed ($hash)) {
          $ret .= $hqtxt{vrmcr}{$lang};
      }
      elsif (!$coset && isForecastSolarUsed ($hash)) {
          $ret .= $hqtxt{coord}{$lang};
      }
      elsif (!$coset && isOpenMeteoUsed ($hash)) {
          $ret .= $hqtxt{coord}{$lang};
      }
      elsif (!defined $pv0) {
          $ret .= $hqtxt{awd}{$lang};
          $ret .= "</td>";
          $ret .= "</tr>";
          $ret .= "<tr>";
          $ret .= qq{<td align="left" title="$chktitle"> $chkicon};
      }

      $ret .= "</td>";
      $ret .= "</tr>";
      $ret .= "</table>";
      $ret  =~ s/LINK/$link/gxs;

      delete $data{$name}{current}{setupcomplete};

      return $ret;
  }

  $data{$name}{current}{setupcomplete} = 1;

return;
}

################################################################
#  Parse den Scale Mode für jede Balkengrafik Ebene
#  z.B. scaleMode=1:log,2:lin,3:lin
################################################################
sub _parseScaleModes {                         
  my $name = shift;
  my $scm;
  
  for my $bl (1..MAXBEAMLEVEL) {                      # Hashref Scale Modes initial mit Standard füllen 
      $scm->{"$bl"} = 'lin'; 
  }    
  
  my $mo = CurrentVal ($name, 'scaleMode', '');
  
  if ($mo) {
      my @moa = split ',', $mo;
      
      for my $elem (@moa) {
          my ($lvl, $mode) = split ':', $elem;
          $scm->{"$lvl"} = $mode; 
      }
  }

return $scm;
}

################################################################
#  Parse den Heightlevel für jede Balkengrafik Ebene
#  z.B. beamHeightlevel=1:300,2:400,3:250
################################################################
sub _parseHeightLevels {                         
  my $name = shift;
  my $bhl;
  
  for my $bl (1..MAXBEAMLEVEL) {                      # Hashref beamHeightlevel initial mit Standard füllen 
      $bhl->{"$bl"} = BHEIGHTLEVEL; 
  }    
  
  my $lv = CurrentVal ($name, 'beamHeightlevel', '');
  
  if ($lv) {
      my @lva = split ',', $lv;
      
      for my $elem (@lva) {
          my ($lvl, $val) = split ':', $elem;
          $bhl->{"$lvl"} = $val; 
      }
  }

return $bhl;
}

################################################################
#  Parse den Diff Mode für jede Balkengrafik Ebene
#  z.B. showDiff=1:top,2:bottom,3:bottom
################################################################
sub _parseShowdiffModes {                          
  my $name = shift;
  my $sdf;
  
  for my $bl (1..MAXBEAMLEVEL) {                      # Hashref Diff Modes initial mit Standard füllen 
      $sdf->{"$bl"} = ''; 
  }    
  
  my $mo = CurrentVal ($name, 'showDiff', '');
  
  ### nicht mehr benötigte Daten verarbeiten - Bereich kann später wieder raus !!    03.07.
  ###########################################################################################
  if ($mo) {
      $mo = $mo eq 'no'     ? qq{1:'',2:'',3:''} :
            $mo eq 'top'    ? qq{1:top,2:top,3:top} :
            $mo eq 'bottom' ? qq{1:bottom,2:bottom,3:bottom} :
            $mo;
  }
  ##########################################################################################
  
  if ($mo) {
      my @moa = split ',', $mo;
      
      for my $elem (@moa) {
          my ($lvl, $mode) = split ':', $elem;
          $sdf->{"$lvl"} = $mode; 
      }
      
  }

return $sdf;
}

################################################################
#         forecastGraphic Headerzeile generieren
################################################################
sub _graphicHeader {
  my $paref = shift;

  return q{} if($paref->{graphicselect} =~ /_noHead/xs);

  my $hdrDetail = $paref->{hdrDetail};                     # ermöglicht den Inhalt zu begrenzen, um bspw. passgenau in ftui einzubetten
  my $ftui      = $paref->{ftui};
  my $lang      = $paref->{lang};
  my $name      = $paref->{name};
  my $kw        = $paref->{kw};
  my $dstyle    = $paref->{dstyle};                        # TD-Style

  my $hash      = $defs{$name};
  my $lup       = ReadingsTimestamp ($name, ".lastupdateForecastValues", "0000-00-00 00:00:00");   # letzter Forecast Update

  my $co4h      = ReadingsNum ($name, "NextHours_Sum04_ConsumptionForecast", 0);
  my $coRe      = ReadingsNum ($name, "RestOfDayConsumptionForecast",        0);
  my $coTo      = ReadingsNum ($name, "Tomorrow_ConsumptionForecast",        0);
  my $coCu      = CurrentVal  ($hash, 'consumption',                         0);
  my $pv4h      = ReadingsNum ($name, "NextHours_Sum04_PVforecast",          0);
  my $pvRe      = ReadingsNum ($name, "RestOfDayPVforecast",                 0);
  my $pvTo      = ReadingsNum ($name, "Tomorrow_PVforecast",                 0);
  my $pvCu      = ReadingsNum ($name, "Current_PV",                          0);

  my ($rapi, $wapi) = getStatusApiName ($hash);                                                    # Status-API Name

  if ($kw eq 'kWh') {
      $co4h = sprintf ("%.1f", $co4h/1000)."&nbsp;kWh";
      $coRe = sprintf ("%.1f", $coRe/1000)."&nbsp;kWh";
      $coTo = sprintf ("%.1f", $coTo/1000)."&nbsp;kWh";
      $coCu = sprintf ("%.1f", $coCu/1000)."&nbsp;kW";
      $pv4h = sprintf ("%.1f", $pv4h/1000)."&nbsp;kWh";
      $pvRe = sprintf ("%.1f", $pvRe/1000)."&nbsp;kWh";
      $pvTo = sprintf ("%.1f", $pvTo/1000)."&nbsp;kWh";
      $pvCu = sprintf ("%.1f", $pvCu/1000)."&nbsp;kW";
  }
  else {
      $co4h .= "&nbsp;Wh";
      $coRe .= "&nbsp;Wh";
      $coTo .= "&nbsp;Wh";
      $coCu .= "&nbsp;W";
      $pv4h .= "&nbsp;Wh";
      $pvRe .= "&nbsp;Wh";
      $pvTo .= "&nbsp;Wh";
      $pvCu .= "&nbsp;W";
  }

  my $lupt    = $hqtxt{lupt}{$lang};
  my $autoct  = $hqtxt{autoct}{$lang};
  my $aihtxt  = $hqtxt{aihtxt}{$lang};
  my $prdctxt = $hqtxt{plrdct}{$lang};
  my $lbpcq   = $hqtxt{lbpcq}{$lang};
  my $lblPv4h = $hqtxt{lblPvh}{$lang};
  my $lblPvRe = $hqtxt{lblPRe}{$lang};
  my $lblPvTo = $hqtxt{lblPTo}{$lang};
  my $lblPvCu = $hqtxt{lblPCu}{$lang};

  ## Header Start
  #################
  my $header = qq{<table width='100%'>};

  # Header Link + Status + Update Button
  #########################################
  if ($hdrDetail =~ /all|status/xs) {
      my ($scicon,$img);

      my ($year, $month, $day, $time) = $lup =~ /(\d{4})-(\d{2})-(\d{2})\s+(.*)/x;
      $lup                            = "$year-$month-$day&nbsp;$time";

      if($lang eq "DE") {
         $lup = "$day.$month.$year&nbsp;$time";
      }

      my $cmdplchk  = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=get $name plantConfigCheck', function(data){FW_okDialog(data)})"};          # Plant Check Kommando generieren
      my $cmdoutmsg = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=get $name outputMessages', function(data){FW_okDialog(data)})"};            # Message Ausgabe Kommando generieren

      if ($ftui eq 'ftui') {
          $cmdplchk  = qq{"ftui.setFhemStatus('get $name plantConfigCheck')"};
          $cmdoutmsg = qq{"ftui.setFhemStatus('get $name outputMessages')"};
      }

      ## Anlagen Check-Icon
      #######################
      $img         = FW_makeImage('edit_settings@grey');
      my $chkicon  = "<a onClick=$cmdplchk>$img</a>";
      my $chktitle = $htitles{plchk}{$lang};

      ## Forum Thread-Icon
      ######################
      $img         = FW_makeImage('time_note@grey');
      my $fthicon  = "<a href='https://forum.fhem.de/index.php?topic=137058.0' target='_blank'>$img</a>";
      my $fthtitle = $htitles{jtsfft}{$lang};

      ## Wiki-Icon
      ##############
      $img         = FW_makeImage ('edit_copy@grey');
      my $wikicon  = "<a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung' target='_blank'>$img</a>";
      my $wiktitle = $htitles{opwiki}{$lang};

      ## Message-Icon
      #################
      my $tfl            = $data{$name}{messages}{999000}{TS}                                     ?
                           (timestampToTimestring ($data{$name}{messages}{999000}{TS}, $lang))[0] :
                           'n.a.';
      my $tfn            = $data{$name}{messages}{999000}{TSNEXT}                                     ?
                           (timestampToTimestring ($data{$name}{messages}{999000}{TSNEXT}, $lang))[0] :
                           'n.a.';
      my ($micon, $midx) = fillupMessageSystem ($paref);
      $img               = FW_makeImage ($micon);
      my $msgicon        = $midx ? "<a onClick=$cmdoutmsg>$img</a>" : $img;
      my $msgtitle       = $midx ? $htitles{outpmsg}{$lang} : $htitles{nomsgfo}{$lang}."\n\n$htitles{lstmsgc}{$lang}: $tfl \n$htitles{nxtmsgc}{$lang}: $tfn";

      ## Update-Icon
      ################
      my $upicon =  __createUpdateIcon ($paref);

      ## Sonnenauf- und untergang / Wetterdaten Aktualität
      ######################################################
      my $sriseimg = FW_makeImage('weather_sunrise@darkorange');
      my $ssetimg  = FW_makeImage('weather_sunset@LightCoral');
      my $srisetxt = ReadingsVal ($name, 'Today_SunRise', '-');
      my $ssettxt  = ReadingsVal ($name, 'Today_SunSet',  '-');

      my ($err, $resh) = isWeatherAgeExceeded ($paref);
      $img = FW_makeImage ('10px-kreis-gruen.png', $htitles{dwfcrsu}{$lang}.' '.$resh->{mosmix}.' &#10;'.$htitles{dwdtime}{$lang}.': '.$resh->{fctime});

      if (!$err && $resh->{exceed}) {
          my $agewfc = $htitles{aswfc2o}{$lang};
          $agewfc    =~ s/<NAME>/$name/xs;
          $img = FW_makeImage ('10px-kreis-gelb.png', $agewfc.' &#10;'.$htitles{dwdtime}{$lang}.': '.$resh->{fctime});
      }

      my $waicon = "<a>$img</a>";                                                                       # Icon Wetterdaten Alter

      ## Autokorrektur-Icon
      ######################
      my $acicon = __createAutokorrIcon ($paref);

      ## Solare API Sektion
      ########################
      my $api = isSolCastUsed       ($hash) ? '<a href="https://solcast.com/live-and-forecast" style="color: inherit !important;" target="_blank">SolCast</a>:'                                                      :
                isForecastSolarUsed ($hash) ? '<a href="https://forecast.solar" style="color: inherit !important;" target="_blank">Forecast.Solar</a>:'                                                              :
                isVictronKiUsed     ($hash) ? '<a href="https://www.victronenergy.com/blog/2023/07/05/new-vrm-solar-production-forecast-feature" style="color: inherit !important;" target="_blank">VictronVRM</a>:' :
                isDWDUsed           ($hash) ? '<a href="https://www.dwd.de/DE/leistungen/met_verfahren_mosmix/met_verfahren_mosmix.html" style="color: inherit !important;" target="_blank">DWD</a>:'                :
                isOpenMeteoUsed     ($hash) ? '<a href="https://open-meteo.com/" style="color: inherit !important;" target="_blank">OpenMeteo</a>:'                                                                        :
                q{};

      my $nscc = ReadingsVal  ($name, 'nextRadiationAPICall', '?');
      my $lrt  = StatusAPIVal ($hash, $rapi, '?All', 'lastretrieval_time', '-');
      my $scrm = StatusAPIVal ($hash, $rapi, '?All', 'response_message',   '-');

      if ($lrt =~ /(\d{4})-(\d{2})-(\d{2})\s+(.*)/x) {
          my ($sly, $slmo, $sld, $slt) = $lrt =~ /(\d{4})-(\d{2})-(\d{2})\s+(.*)/x;
          $lrt                         = "$sly-$slmo-$sld&nbsp;$slt";

          if($lang eq "DE") {
             $lrt = "$sld.$slmo.$sly&nbsp;$slt";
          }
      }

      if ($api =~ /SolCast/xs) {
          $api .= '&nbsp;'.$lrt;

          if ($scrm eq 'success') {
              $img = FW_makeImage ('10px-kreis-gruen.png', $htitles{scaresps}{$lang}.'&#10;'.$htitles{natc}{$lang}.' '.$nscc);
          }
          elsif ($scrm =~ /Rate limit for API calls reached/i) {
              $img = FW_makeImage ('10px-kreis-rot.png', $htitles{scarespf}{$lang}.':&#10;'. $htitles{yheyfdl}{$lang});
          }
          elsif ($scrm =~ /ApiKey does not exist/i) {
              $img = FW_makeImage ('10px-kreis-rot.png', $htitles{scarespf}{$lang}.':&#10;'. $htitles{scakdne}{$lang});
          }
          elsif ($scrm =~ /Rooftop site does not exist or is not accessible/i) {
              $img = FW_makeImage ('10px-kreis-rot.png', $htitles{scarespf}{$lang}.':&#10;'. $htitles{scrsdne}{$lang});
          }
          else {
              $img = FW_makeImage('10px-kreis-rot.png', $htitles{scarespf}{$lang}.': '. $scrm);
          }

          $scicon = "<a>$img</a>";

          $api .= '&nbsp;&nbsp;'.$scicon;
          $api .= '<span title="'.$htitles{dapic}{$lang}.' / '.$htitles{rapic}{$lang}.'">';
          $api .= '&nbsp;&nbsp;(';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'todayDoneAPIrequests', 0);
          $api .= '/';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'todayRemainingAPIrequests', SOLCMAXREQDEF);
          $api .= ')';
          $api .= '</span>';
      }
      elsif ($api =~ /Forecast.Solar/xs) {
          $api .= '&nbsp;'.$lrt;

          if ($scrm eq 'success') {
              $img = FW_makeImage('10px-kreis-gruen.png', $htitles{scaresps}{$lang}.'&#10;'.$htitles{natc}{$lang}.' '.$nscc);
          }
          elsif ($scrm =~ /You have exceeded your free daily limit/i) {
              $img = FW_makeImage('10px-kreis-rot.png', $htitles{scarespf}{$lang}.':&#10;'. $htitles{rlfaccpr}{$lang});
          }
          else {
              $img = FW_makeImage('10px-kreis-rot.png', $htitles{scarespf}{$lang}.': '. $scrm);
          }

          $scicon = "<a>$img</a>";

          $api .= '&nbsp;&nbsp;'.$scicon;
          $api .= '<span title="'.$htitles{dapic}{$lang}.' / '.$htitles{raricp}{$lang}.'">';
          $api .= '&nbsp;&nbsp;(';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'todayDoneAPIrequests', 0);
          $api .= '/';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'requests_remaining', '-');
          $api .= ')';
          $api .= '</span>';
      }
      elsif ($api =~ /VictronVRM/xs) {
          $api .= '&nbsp;'.$lrt;

          if ($scrm eq 'success') {
              $img = FW_makeImage('10px-kreis-gruen.png', $htitles{scaresps}{$lang}.'&#10;'.$htitles{natc}{$lang}.' '.$nscc);
          }
          else {
              $img = FW_makeImage('10px-kreis-rot.png', $htitles{scarespf}{$lang}.': '. $scrm);
          }

          $scicon = "<a>$img</a>";

          $api .= '&nbsp;&nbsp;'.$scicon;
          $api .= '<span title="'.$htitles{dapic}{$lang}.'">';
          $api .= '&nbsp;&nbsp;(';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'todayDoneAPIrequests', 0);
          $api .= ')';
          $api .= '</span>';
      }
      elsif ($api =~ /DWD/xs) {
          $nscc = ReadingsVal ($name, 'nextCycletime', '?');
          $api .= '&nbsp;'.$lrt;

          if ($scrm eq 'success') {
              ($err, $resh) = isRad1hAgeExceeded ($paref);
              $img          = FW_makeImage ('10px-kreis-gruen.png', $htitles{scaresps}{$lang}.' &#10;'.$htitles{dwfcrsu}{$lang}.' '.$resh->{mosmix}.' &#10;'.$htitles{predtime}{$lang}.' '.$resh->{fctime});

              if (!$err && $resh->{exceed}) {
                  my $agetit = $htitles{arsrad2o}{$lang};
                  $agetit    =~ s/<NAME>/$name/xs;
                  $img = FW_makeImage ('10px-kreis-gelb.png', $agetit.' &#10;'.$htitles{predtime}{$lang}.' '.$resh->{fctime});
              }
          }
          else {
              $img = FW_makeImage('10px-kreis-rot.png', $htitles{scarespf}{$lang}.': '. $scrm);
          }

          $scicon = "<a>$img</a>";

          $api .= '&nbsp;&nbsp;'.$scicon;
          $api .= '<span title="'.$htitles{dapic}{$lang}.'">';
          $api .= '&nbsp;&nbsp;(';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'todayDoneAPIrequests', 0);
          $api .= ')';
          $api .= '</span>';
      }
      elsif ($api =~ /OpenMeteo/xs) {
          $api .= '&nbsp;'.$lrt;

          if ($scrm eq 'success') {
              $img = FW_makeImage ('10px-kreis-gruen.png', $htitles{scaresps}{$lang}.' &#10;'.$htitles{natc}{$lang}.' '.$nscc);
          }
          else {
              $img = FW_makeImage('10px-kreis-rot.png', $htitles{scarespf}{$lang}.': '. $scrm);
          }

          $scicon = "<a>$img</a>";

          $api .= '&nbsp;&nbsp;'.$scicon;
          $api .= '<span title="'.$htitles{dapic}{$lang}.' / '.$htitles{rapic}{$lang}.'">';
          $api .= '&nbsp;&nbsp;(';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'todayDoneAPIrequests', 0);
          $api .= '/';
          $api .= StatusAPIVal ($hash, $rapi, '?All', 'todayRemainingAPIrequests', OMETMAXREQ);
          $api .= ')';
          $api .= '</span>';
      }

      ## Qualitäts-Icon
      ######################
      my $pcqicon = __createQuaIcon ($paref);

      ## KI Status
      ##############
      my $aiicon = __createAIicon ($paref);
      
      ## Abregelungsstatus
      ######################
      my $rdcicon = __createReduceIcon ($paref);

      ## Abweichung PV Prognose/Erzeugung
      #####################################
      my $tdayDvtn = CircularVal ($hash, 99, 'tdayDvtn', '-');
      my $ydayDvtn = CircularVal ($hash, 99, 'ydayDvtn', '-');
      $tdayDvtn    = sprintf "%.1f %%", $tdayDvtn if(isNumeric($tdayDvtn));
      $ydayDvtn    = sprintf "%.1f %%", $ydayDvtn if(isNumeric($ydayDvtn));
      $tdayDvtn    =~ s/\./,/;
      $tdayDvtn    =~ s/\,0//;
      $ydayDvtn    =~ s/\./,/;
      $ydayDvtn    =~ s/,0//;

      my $genpvdva = $paref->{genpvdva};
      my ($manner, $perspective) = split ':', $genpvdva;
      $perspective //= 'default';

      my $dvtntxt  = $hqtxt{dvtn}{$lang}.'&nbsp;';
      my $tdaytxt  = ($manner eq 'daily' ? $hqtxt{tday}{$lang} : $hqtxt{ctnsly}{$lang}).':&nbsp;'."<b>".$tdayDvtn."</b>";
      my $ydaytxt  = $hqtxt{yday}{$lang}.':&nbsp;'."<b>".$ydayDvtn."</b>";

      my $text_tdayDvtn = $tdayDvtn =~ /^-[1-9]/? ($perspective eq 'default' ? $hqtxt{pmtp}{$lang} : $hqtxt{pltp}{$lang}) :
                          $tdayDvtn =~ /^-?0,/  ? $hqtxt{petp}{$lang} :
                          $tdayDvtn =~ /^[1-9]/ ? ($perspective eq 'default' ? $hqtxt{pltp}{$lang} : $hqtxt{pmtp}{$lang}) :
                          $hqtxt{wusond}{$lang};

      my $text_ydayDvtn = $ydayDvtn =~ /^-[1-9]/? ($perspective eq 'default' ? $hqtxt{pmtp}{$lang} : $hqtxt{pltp}{$lang}) :
                          $ydayDvtn =~ /^-?0,/  ? $hqtxt{petp}{$lang} :
                          $ydayDvtn =~ /^[1-9]/ ? ($perspective eq 'default' ? $hqtxt{pltp}{$lang} : $hqtxt{pmtp}{$lang}) :
                          $hqtxt{snbefb}{$lang};
                          
      $text_tdayDvtn = encode ('utf8', $text_tdayDvtn);
      $text_ydayDvtn = encode ('utf8', $text_ydayDvtn);

      ## erste Header-Zeilen
      #######################
      my $alias = AttrVal ($name, "alias", $name );                                               # Linktext als Aliasname
      my $dlink = qq{<a href="$::FW_ME$::FW_subdir?detail=$name">$alias</a>};
      my $space = '&nbsp;&nbsp;&nbsp;';
      my $spc3  = '&nbsp;' x 3;
      my $disti = qq{<span title="$chktitle"> $chkicon </span> $space <span title="$fthtitle"> $fthicon </span> $space <span title="$wiktitle"> $wikicon </span> $space <span title="$msgtitle"> $msgicon </span>};

      my @parts1 = (
          [ $sriseimg, 1 ],
          [ $srisetxt, 3 ],
          [ $ssetimg,  1 ],
          [ $ssettxt,  3 ],
          [ $waicon,   0 ],  # am Ende kein zusätzlicher Abstand
      );
      
      my @parts2 = (
          [ $autoct,  2 ],
          [ $acicon,  5 ],
          [ $lbpcq,   2 ],
          [ $pcqicon, 5 ],
          [ $aihtxt,  2 ],
          [ $aiicon,  5 ],
          [ $prdctxt, 2 ],
          [ $rdcicon, 0 ],  # am Ende kein zusätzlicher Abstand
      );
      
      my $cont1 = join '', map { $_->[0] . ('&nbsp;' x $_->[1]) } @parts1;
      my $cont2 = join '', map { $_->[0] . ('&nbsp;' x $_->[1]) } @parts2;

      $header  .= qq{<tr>};
      $header  .= qq{<td colspan="1" align="left"   $dstyle> <b>$dlink</b>              </td>};
      $header  .= qq{<td colspan="2" align="center" $dstyle> $disti                     </td>};
      $header  .= qq{<td colspan="3" align="left"   $dstyle> $lupt $lup &nbsp; $upicon  </td>};
      $header  .= qq{<td colspan="3" align="right"  $dstyle> $api                       </td>};
      $header  .= qq{</tr>};
      $header  .= qq{<tr>};
      $header  .= qq{<td colspan="3" align="left"  $dstyle> $cont1 </td>};
      $header  .= qq{<td colspan="3" align="left"  $dstyle> $cont2 </td>};
      $header  .= qq{<td colspan="3" align="right" $dstyle> $dvtntxt};
      $header  .= qq{<span title="$text_tdayDvtn">};
      $header  .= qq{$tdaytxt};
      $header  .= qq{</span>};
      $header  .= qq{,&nbsp;};
      $header  .= qq{<span title="$text_ydayDvtn">};
      $header  .= qq{$ydaytxt};
      $header  .= qq{</span>};
      $header  .= qq{</td>};
      $header  .= qq{</tr>};
      $header  .= qq{<tr>};
      $header  .= qq{<td colspan="9" align="left" $dstyle><hr></td>};
      $header  .= qq{</tr>};
  }

  # Header Information pv
  ########################
  if ($hdrDetail =~ /all|pv/xs) {
      $header .= "<tr>";
      $header .= "<td $dstyle><b>".$hqtxt{pvgen}{$lang}."&nbsp;</b></td>";
      $header .= "<td $dstyle><b>$lblPvCu</b></td> <td align=right $dstyle>$pvCu</td>";
      $header .= "<td $dstyle><b>$lblPv4h</b></td> <td align=right $dstyle>$pv4h</td>";
      $header .= "<td $dstyle><b>$lblPvRe</b></td> <td align=right $dstyle>$pvRe</td>";
      $header .= "<td $dstyle><b>$lblPvTo</b></td> <td align=right $dstyle>$pvTo</td>";
      $header .= "</tr>";
  }


  # Header Information co
  #########################
  if ($hdrDetail =~ /all|co/xs) {
      $header .= "<tr>";
      $header .= "<td $dstyle><b>".$hqtxt{conspt}{$lang}."&nbsp;</b></td>";
      $header .= "<td $dstyle><b>$lblPvCu</b></td><td align=right $dstyle>$coCu</td>";
      $header .= "<td $dstyle><b>$lblPv4h</b></td><td align=right $dstyle>$co4h</td>";
      $header .= "<td $dstyle><b>$lblPvRe</b></td><td align=right $dstyle>$coRe</td>";
      $header .= "<td $dstyle><b>$lblPvTo</b></td><td align=right $dstyle>$coTo</td>";
      $header .= "</tr>";
  }

  if ($hdrDetail =~ /all|pv|co/xs) {
      $header .= qq{<tr>};
      $header .= qq{<td colspan="9" align="left" $dstyle><hr></td>};
      $header .= qq{</tr>};
  }

  # Header User Spezifikation
  #############################
  my $ownv = __createOwnSpec ($paref);
  $header .= $ownv if($ownv);

  $header .= qq{</table>};

return $header;
}

################################################################
#    erstelle Update-Icon
################################################################
sub __createUpdateIcon {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};
  my $ftui  = $paref->{ftui};

  my $upstate = ReadingsVal ($name, 'state',         '');
  my $naup    = ReadingsVal ($name, 'nextCycletime', '');

  my $cmdupdate = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=set $name clientAction - 0 get $name data')"};                               # Update Button generieren

  if ($ftui eq 'ftui') {
      $cmdupdate = qq{"ftui.setFhemStatus('set $name clientAction - 0 get $name data')"};
  }

  my ($img, $upicon);

  if ($upstate =~ /updated|successfully|switched/ix) {
      $img    = FW_makeImage('10px-kreis-gruen.png', $htitles{upd}{$lang}.'&#10;'.$htitles{natc}{$lang}.' '.$naup.'');
      $upicon = "<a onClick=$cmdupdate>$img</a>";
  }
  elsif ($upstate =~ /running/ix) {
      $img    = FW_makeImage('10px-kreis-gelb.png', 'running');
      $upicon = "<a>$img</a>";
  }
  elsif ($upstate =~ /initialized/ix) {
      $img    = FW_makeImage('1px-spacer.png', 'initialized');
      $upicon = "<a>$img</a>";
  }
  else {
      $img    = FW_makeImage('10px-kreis-rot.png', $htitles{upd}{$lang}.' ('.$htitles{natc}{$lang}.' '.$naup.')');
      $upicon = "<a onClick=$cmdupdate>$img</a>";
  }

return $upicon;
}

################################################################
#    erstelle Autokorrektur-Icon
################################################################
sub __createAutokorrIcon {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};

  my $aciimg;
  my $acitit      = q{};
  my ($acu, $aln) = isAutoCorrUsed ($name);

  if ($acu =~ /on/xs) {
      $aciimg = FW_makeImage ('10px-kreis-gruen.png', $htitles{on}{$lang}." ($acu)");
  }
  elsif ($acu =~ /standby/ixs) {
      my $pcfa    = ReadingsVal ($name, 'pvCorrectionFactor_Auto', 'off');
      my ($rtime) = $pcfa =~ /for (.*?) hours/x;
      my $img     = FW_makeImage ('10px-kreis-gelb.png', $htitles{dela}{$lang});
      $aciimg     = "$img&nbsp;(Start in ".$rtime." h)";
  }
  else {
      $acitit = $htitles{akorron}{$lang};
      $acitit =~ s/<NAME>/$name/xs;
      $aciimg = '-';
  }

  my $acicon = qq{<a title="$acitit">$aciimg</a>};

return $acicon;
}

################################################################
#    erstelle Qualitäts-Icon
################################################################
sub __createQuaIcon {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};
  my $ftui  = $paref->{ftui};

  my $hash       = $defs{$name};
  my $pvfc00     = NexthoursVal ($hash, 'NextHour00', 'pvfc',    undef);
  my $pvcorrf00  = NexthoursVal ($hash, 'NextHour00', 'pvcorrf', '-/-');
  my ($pcf,$pcq) = split "/", $pvcorrf00;
  my $pvcanz     = qq{factor: $pcf / quality: $pcq};

  my $cmdfcqal = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=get $name forecastQualities imgget', function(data){FW_okDialog(data)})"};

  if ($ftui eq 'ftui') {
      $cmdfcqal = qq{"ftui.setFhemStatus('get $name forecastQualities imgget')"};
  }

  $pcq       =~ s/-/-1/xs;
  my $pcqimg = $pcq < 0.00 ? FW_makeImage ('15px-blank',          $pvcanz) :
               $pcq < 0.60 ? FW_makeImage ('10px-kreis-rot.png',  $pvcanz) :
               $pcq < 0.80 ? FW_makeImage ('10px-kreis-gelb.png', $pvcanz) :
               FW_makeImage ('10px-kreis-gruen.png', $pvcanz);

  my $pcqtit = q();

  if(!$pvfc00 || $pcq == -1) {
      $pcqimg = "-";
      $pcqtit = $htitles{norate}{$lang};
  }

  my $pcqicon = qq{<a title="$pcqtit", onClick=$cmdfcqal>$pcqimg</a>};

return $pcqicon;
}

################################################################
#    erstelle KI Icon
################################################################
sub __createAIicon {
  my $paref    = shift;
  my $name     = $paref->{name};
  my $lang     = $paref->{lang};

  my $hash     = $defs{$name};
  my $aiprep   = isPrepared4AI ($hash, 'full');                      # isPrepared4AI full vor Abfrage 'aicanuse' ausführen !
  my $aicanuse = CurrentVal    ($hash, 'aicanuse',           '');
  my $aitst    = CurrentVal    ($hash, 'aitrainstate',     'ok');
  my $aihit    = NexthoursVal  ($hash, 'NextHour00', 'aihit', 0);

  my $aitit = $aidtabs          ? $htitles{aimstt}{$lang} :
              $aicanuse ne 'ok' ? $htitles{ainuse}{$lang} :
              q{};
  $aitit   =~ s/<NAME>/$name/xs;

  my $atf = CircularVal ($hash, 99, 'aitrainLastFinishTs', 0);
  my $art = CurrentVal  ($hash, 'aiLastGetResultTime', ''),
  $atf    = $hqtxt{ailatr}{$lang}.' '.($atf ? (timestampToTimestring ($atf, $lang))[0] : '-');
  $art    = $hqtxt{ailgrt}{$lang}.' '.($art ? ($art * 1000).' ms' : '-');

  my $aiimg  = $aidtabs          ? '--' :
               $aicanuse ne 'ok' ? '-'  :
               $aitst ne 'ok'    ? FW_makeImage ('10px-kreis-rot.png', $aitst) :
               $aihit            ? FW_makeImage ('10px-kreis-gruen.png', $hqtxt{aiwhit}{$lang}.' &#10;'.$atf.' &#10;'.$art) :
               FW_makeImage ('10px-kreis-gelb.png', $hqtxt{aiwook}{$lang}.' &#10;'.$atf);

  my $aiicon = qq{<a title="$aitit">$aiimg</a>};

return $aiicon;
}

################################################################
#    erstelle Abregelungs-Icon
################################################################
sub __createReduceIcon {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};

  my $rps   = CurrentVal ($name, 'reductionPlantState', undef);
  my $title = q{};
  my $img;

  if (!defined $rps) {
      $title = encode ('utf8', $htitles{rdcstat}{$lang});
      $title =~ s/<NAME>/$name/xs;
      $img   = '-';
  }
  elsif ($rps) {
      $title = encode ('utf8', $htitles{rdcactiv}{$lang});
      $title =~ s/<NAME>/$name/xs;
      $img = FW_makeImage ('10px-kreis-gelb.png', $title);
  }
  else {
      $title = encode ('utf8', $htitles{rdcnoact}{$lang});
      $title =~ s/<NAME>/$name/xs;    
      $img = FW_makeImage ('10px-kreis-gruen.png', $title);
  }
  
  my $rpsicon = qq{<a title="$title">$img</a>};

return $rpsicon;
}

################################################################
#    erstelle Übersicht eigener Readings
################################################################
sub __createOwnSpec {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $dstyle    = $paref->{dstyle};                                                    # TD-Style
  my $hdrDetail = $paref->{hdrDetail};
  my $pah       = $paref->{pah};                                                       # 1 wenn durch pageAsHtml abgerufen

  my $vinr = 4;                                                                        # Spezifikationen in einer Zeile
  my $spec = AttrVal    ($name, 'graphicHeaderOwnspec', '');
  my $uatr = CurrentVal ($name, 'energyUnit', 'Wh');
  my $show = $hdrDetail =~ /all|own/xs ? 1 : 0;

  return if(!$spec || !$show);

  my $allsets  = ' '.FW_widgetOverride ($name, getAllSets ($name),  'set').' ';
  my $allattrs = ' '.FW_widgetOverride ($name, getAllAttr ($name), 'attr').' ';        # Leerzeichen wichtig für Regexvergleich

  my @fields = split (/\s+/sx, $spec);

  my (@cats, @vals);

  for my $f (@fields) {
      if ($f =~ /^\#(.*)/xs) {
          push @cats, $1;
          next;
      }

      push @vals, $f;
  }

  my $ownv;
  my $cakey;
  my $rows = ceil (scalar(@vals) / $vinr);
  my $col  = 0;

  for (my $i = 1 ; $i <= $rows; $i++) {
      my ($h, $v, $u);

      for (my $k = 0 ; $k < $vinr; $k++) {
          ($h->{$k}{label}, $h->{$k}{elm}) = $vals[$col] =~ /^(.*):(.*)$/ if($vals[$col]);   # Label und darzustellendes Element am LETZTEN : trennen
          
          $h->{$k}{elm}   //= '';
          my ($elm, $dev)   = split "@", $h->{$k}{elm};                                      # evtl. anderes Devices
          $dev            //= $name;
          
          ($elm, $cakey)    = split "->", $elm;                                              # zusammengesetztes Attribut: gewünschtes Schlüssel identifizieren

          $col++;

          if (!$h->{$k}{label}) {
              undef $h->{$k}{label};
              next;
          }

          ## Set-Kommandos identifizieren
          #################################
          my $setcmd = ___ownSpecGetFWwidget ($name, $dev, $elm, $allsets, 'set', $cakey);           

          if ($setcmd) {
              if ($pah) {                                                                    # bei get pageAsHtml setter/attr nicht anzeigen (js Fehler)
                  undef $h->{$k}{label};
                  $setcmd = '<hidden by pageAsHtml>';
              }

              $v->{$k} = $setcmd;
              $u->{$k} = q{};

              debugLog ($paref, 'graphic', "graphicHeaderOwnspec - set-command genereated:\n$setcmd");
              next;
          }

          ## Attr-Kommandos identifizieren
          ##################################
          my $attrcmd = ___ownSpecGetFWwidget ($name, $dev, $elm, $allattrs, 'attr', $cakey);        

          if ($attrcmd) {
              if ($pah) {                                                                    # bei get pageAsHtml setter/attr nicht anzeigen (js Fehler)
                  undef $h->{$k}{label};
                  $attrcmd = '<hidden by pageAsHtml>';
              }

              $v->{$k} = $attrcmd;
              $u->{$k} = q{};

              debugLog ($paref, 'graphic', "graphicHeaderOwnspec - attr-command genereated:\n$attrcmd");
              next;
          }

          ## Reading identifizieren
          ###########################
          $v->{$k} = ReadingsVal ($dev, $elm, undef);

          if (defined $v->{$k} && $v->{$k} =~ /^\s*(-?\d+(\.\d+)?)/xs) {
              ($v->{$k}, $u->{$k}) = split /\s+/, ReadingsVal ($dev, $elm, '');              # Value und Unit trennen wenn Value numerisch
          }

          $u->{$k} //= q{};

          $paref->{dev}  = $dev;
          $paref->{rdg}  = $elm;
          $paref->{val}  = $v->{$k};
          $paref->{unit} = $u->{$k};

          ($v->{$k}, $u->{$k}) = ___ghoValForm ($paref);
          
          $v->{$k} //= q{};          

          delete $paref->{dev};
          delete $paref->{rdg};
          delete $paref->{val};
          delete $paref->{unit};

          next if(!$u->{$k});

          if ($uatr eq 'kWh') {
              if ($u->{$k} =~ /^Wh/xs) {
                  $v->{$k} = sprintf "%.1f",($v->{$k} / 1000);
                  $u->{$k} = 'kWh';
              }
          }

          if ($uatr eq 'Wh') {
              if ($u->{$k} =~ /^kWh/xs) {
                  $v->{$k} = sprintf "%.0f",($v->{$k} * 1000);
                  $u->{$k} = 'Wh';
              }
          }
      }

      $ownv .= "<tr>";
      $ownv .= "<td $dstyle>".($cats[$i-1] ? '<b>'.$cats[$i-1].'</b>' : '')."</td>";
      $ownv .= "<td $dstyle><b>".$h->{0}{label}.":</b></td> <td align=right $dstyle>".$v->{0}." ".$u->{0}."</td>" if(defined $h->{0}{label});
      $ownv .= "<td $dstyle><b>".$h->{1}{label}.":</b></td> <td align=right $dstyle>".$v->{1}." ".$u->{1}."</td>" if(defined $h->{1}{label});
      $ownv .= "<td $dstyle><b>".$h->{2}{label}.":</b></td> <td align=right $dstyle>".$v->{2}." ".$u->{2}."</td>" if(defined $h->{2}{label});
      $ownv .= "<td $dstyle><b>".$h->{3}{label}.":</b></td> <td align=right $dstyle>".$v->{3}." ".$u->{3}."</td>" if(defined $h->{3}{label});
      $ownv .= "</tr>";
  }

  $ownv .= qq{<tr>};
  $ownv .= qq{<td colspan="9" align="left" $dstyle><hr></td>};
  $ownv .= qq{</tr>};

return $ownv;
}

################################################################
#  liefert ein FHEMWEB set/attr Widget zurück
################################################################
sub ___ownSpecGetFWwidget {
  my $name  = shift;
  my $dev   = shift;                         # Device des Elements, default=$name
  my $elm   = shift;                         # zu prüfendes Element (Setter / Attribut)
  my $allc  = shift;                         # Kommandovorrat -> ist Element enthalten?
  my $ctyp  = shift;                         # Kommandotyp: set/attr
  my $cakey = shift;                         # ein einzelner Schlüssel zur Selektion aus einem zusammengesetzten Attribut
  my $isize = shift // INPUTSIZE;            # Breite eines Text-Eingabefeldes 

  return if(!$elm || $elm eq 'state');

  my $widget = '';
  my ($current, $reading);

  if ($dev ne $name) {                                                                   # Element eines anderen Devices verarbeiten
      if ($ctyp eq 'set') {
          $allc = ' '.FW_widgetOverride ($dev, getAllSets($dev), 'set').' ';             # Leerzeichen wichtig für Regexvergleich
      }
      elsif ($ctyp eq 'attr') {
          $allc = ' '.FW_widgetOverride ($dev, getAllAttr($dev), 'attr').' ';
      }
  }

  if ($allc =~ /\s$elm:?(.*?)\s/xs) {                                                    # Element in allen Sets oder Attr enthalten
      my $arg = $1 // '';

      if ($arg =~ /textField-long/xs) {                                                  # Label (Reading) ausblenden -> siehe fhemweb.js function FW_createTextField Zeile 1657
          $arg = 'textFieldNL-long,,'.$isize;
      }
      elsif (!$arg || $arg =~ /textField/xs) {                                           # Label (Reading) ausblenden -> siehe fhemweb.js function FW_createTextField Zeile 1657
          $arg = 'textFieldNL,,'.$isize;
      }

      if ($arg !~ /^\#/xs && $arg !~ /^$allwidgets/xs) {
          $arg = '#,'.$arg;
      }

      if ($arg =~ 'slider') {                                                            # Widget slider in selectnumbers für Kopfgrafik umsetzen
          my ($wid, $min, $step, $max, $float) = split ",", $arg;
          $arg = "selectnumbers,$min,$step,$max,0,lin";
      }

      if ($ctyp eq 'attr') {                                                             # Attributwerte als verstecktes Reading abbilden
          $current = AttrVal ($dev, $elm, '');
          $current =~ s/(?<! )\R(?! )/ /g;                                               # V 1.59.6: ersetzt alle Zeilenumbrüche, die weder links noch rechts ein Leerzeichen haben, durch ein Leerzeichen
          $reading = '.'.$dev.'_'.$elm;
      }
      else {
          $current = ReadingsVal ($dev, $elm, '');
          if($dev ne $name) {
              $reading = '.'.$dev.'_'.$elm;                                              # verstecktes Reading in SolCast abbilden wenn Set-Kommando aus fremden Device
          }
          else {
              $reading = $elm;
          }
      }
      
      if ($reading && $reading =~ /^\./xs) {                                             # verstecktes Reading für spätere Löschung merken
          push @widgetreadings, $reading;
          readingsSingleUpdate ($defs{$name}, $reading, $current, 0);
      }

      if ($cakey) {                                                                     # einzelnen Schlüssel eines Composite-Attributs behandeln
          my ($ea, $eh) = parseParams (AttrVal ($name, $elm, ''));
          my $cakeyval  = $eh->{$cakey};
          my $kv        = "$cakey=$cakeyval" if(defined $cakeyval);
          $widget       = "<div class='fhemWidget' cmd='' reading='' dev='' arg='$arg' current='$cakeyval' type='set $dev attrKeyVal $elm $cakey='></div>";
      }
      else {
          $widget = ___widgetFallback ( { name     => $name,
                                          dev      => $dev,
                                          ctyp     => $ctyp,
                                          elm      => $elm,
                                          reading  => $reading,
                                          arg      => $arg
                                        }
                                      );      
      }

      if (!$widget) {
          $widget = FW_pH ("cmd=$ctyp $dev $elm", $elm, 0, "", 1, 1);
      }
  }

return $widget;
}

################################################################
#        adaptierte FW_widgetFallbackFn aus FHEMWEB
################################################################
sub ___widgetFallback {
  my $pars     = shift;
  my $name     = $pars->{name};
  my $dev      = $pars->{dev};
  my $ctyp     = $pars->{ctyp};                                    # Kommandotyp: set/attr
  my $elm      = $pars->{elm};
  my $reading  = $pars->{reading};
  my $arg      = $pars->{arg};

  return '' if(!$arg || $arg eq "noArg");

  my $current = ReadingsVal ($name, $reading, undef);

  if (!defined $current) {
      $reading = ' ';
      $current = ' ';
  }

  if ($current =~ /((<td|<div|<\/div>).*?)/xs) {                   # Eleminierung von störenden HTML Elementen aus aktuellem Readingwert
      $current = ' ';
  }

  $current =~ s/$elm //;
  $current = ReplaceEventMap ($dev, $current, 1);

  return "<div class='fhemWidget' cmd='$elm' reading='$reading' dev='$dev' arg='$arg' current='$current' type='$ctyp'></div>";
}

################################################################
#      ownHeader ValueFormat
################################################################
sub ___ghoValForm {
  my $paref = shift;
  my $name  = $paref->{name};
  my $dev   = $paref->{dev};
  my $rdg   = $paref->{rdg};
  my $val   = $paref->{val};
  my $unit  = $paref->{unit};
  my $type  = $paref->{type};

  my $fn    = AttrVal ($name, 'graphicHeaderOwnspecValForm', '');

  return ($val, $unit) if(!$fn || !$dev || !$rdg || !defined $val);

  my $DEVICE  = $dev;
  my $READING = $rdg;
  my $VALUE   = $val;
  my $UNIT    = $unit;
  my $err;

  if (!ref $fn && $fn =~ m/^\{.*\}$/xs) {                                       # normale Funktionen
      my $efn = eval $fn;

      if ($@) {
          Log3 ($name, 1, "$name - ERROR in function graphicHeaderOwnspecValForm: ".$@);
          $err = $@;
      }
      else {
          if (ref $efn ne 'HASH') {
              $val  = $VALUE;
              $unit = $UNIT;
          }
          else {
              $fn = $efn;
          }
      }
  }

  if (ref $fn eq 'HASH') {                                                     # Funktionshash
      my $vf = "";
      $vf = $fn->{$rdg}             if(exists $fn->{$rdg});
      $vf = $fn->{"$dev.$rdg"}      if(exists $fn->{"$dev.$rdg"});
      $vf = $fn->{"$rdg.$val"}      if(exists $fn->{"$rdg.$val"});
      $vf = $fn->{"$dev.$rdg.$val"} if(exists $fn->{"$dev.$rdg.$val"});
      $fn = $vf;

      if ($fn =~ m/^%/xs) {
          $val = sprintf $fn, $val;
      }
      elsif ($fn ne "") {
          my $vnew = eval $fn;

          if ($@) {
              Log3 ($name, 1, "$name - ERROR in graphicHeaderOwnspecValForm Hash resolution -> '$fn': ".$@);
              $err = $@;
          }
          else {
              $val = $vnew;
          }
      }
  }

  if ($val =~ /^\s*(-?\d+(\.\d+)?)/xs) {                                       # Value und Unit numerischer Werte trennen
      ($val, my $u1) = split /\s+/, $val;
      $unit          = $u1 ? $u1 : $unit;
  }

  if ($err) {
      $err            = (split "at", $err)[0];
      $paref->{state} = 'ERROR - graphicHeaderOwnspecValForm: '.$err;
      singleUpdateState ($paref);
  }

return ($val, $unit);
}

################################################################
#            Erstellung des Ebenentrenners
################################################################
sub _levelSeparator {
  my $paref    = shift;
  my $dstyle   = $paref->{dstyle};                        # TD-Style
  my $maxhours = $paref->{maxhours};

  my $colspan  = $maxhours + 2;

  my $ret = "<tr>";
  $ret   .= "<td colspan='$colspan' align='center' $dstyle><hr></td>";
  $ret   .= "</tr>";

return $ret;
}

################################################################
#    Consumer in forecastGraphic (Balken) anzeigen
#    (Hat zur Zeit keine Wirkung !)
################################################################
sub _showConsumerInGraphicBeam {
  my $paref = shift;
  my $name  = $paref->{name};
  my $type  = $paref->{type};
  my $hfcg  = $paref->{hfcg};
  my $lang  = $paref->{lang};

  my $hash = $defs{$name};

  # get consumer list and display it in Graphics
  ################################################
  my @consumers = sort{$a<=>$b} keys %{$data{$name}{consumers}};                          # definierte Verbraucher ermitteln

  for (@consumers) {
      next if(!$_);
      my ($itemName, undef) = split(':',$_);
      $itemName =~ s/^\s+|\s+$//gx;                                                              # trim it, if blanks were used
      $_        =~ s/^\s+|\s+$//gx;                                                              # trim it, if blanks were used

      # check if listed device is planned
      ####################################
      if (ReadingsVal($name, $itemName."_Planned", "no") eq "yes") {                             # get start and end hour
          my ($start, $end);                                                                     # werden auf Balken Pos 0 - 23 umgerechnet, nicht auf Stunde !!, Pos = 24 -> ungültige Pos = keine Anzeige

          if($lang eq "DE") {
              (undef,undef,undef,$start) = ReadingsVal($name, $itemName."_PlannedOpTimeBegin", '00.00.0000 24') =~ m/(\d{2}).(\d{2}).(\d{4})\s(\d{2})/x;
              (undef,undef,undef,$end)   = ReadingsVal($name, $itemName."_PlannedOpTimeEnd",   '00.00.0000 24') =~ m/(\d{2}).(\d{2}).(\d{4})\s(\d{2})/x;
          }
          else {
              (undef,undef,undef,$start) = ReadingsVal($name, $itemName."_PlannedOpTimeBegin", '0000-00-00 24') =~ m/(\d{4})-(\d{2})-(\d{2})\s(\d{2})/x;
              (undef,undef,undef,$end)   = ReadingsVal($name, $itemName."_PlannedOpTimeEnd",   '0000-00-00 24') =~ m/(\d{4})-(\d{2})-(\d{2})\s(\d{2})/x;
          }

          $start   = int($start);
          $end     = int($end);
          my $flag = 0;                                                                          # default kein Tagesverschieber

          #correct the hour for accurate display
          #######################################
          if ($start < $hfcg->{0}{time}) {                                                       # gridconsumption seems to be tomorrow
              $start = 24-$hfcg->{0}{time}+$start;
              $flag  = 1;
          }
          else {
              $start -= $hfcg->{0}{time};
          }

          if ($flag) {                                                                           # gridconsumption seems to be tomorrow
              $end = 24-$hfcg->{0}{time}+$end;
          }
          else {
              $end -= $hfcg->{0}{time};
          }

          $_ .= ":".$start.":".$end;
      }
      else {
          $_ .= ":24:24";
      }
  }

return;
}

################################################################
#         Verbraucherlegende und Steuerung
################################################################
sub _graphicConsumerLegend {
  my $paref         = shift;
  my $name          = $paref->{name};
  my $clink         = $paref->{clink};
  my $graphicselect = $paref->{graphicselect};                                               # Optionen der Grafikselektion

  my ($clstyle, $clpos) = split '_', $paref->{clegendpos};
  my @consumers         = sort{$a<=>$b} keys %{$data{$name}{consumers}};                     # definierte Verbraucher ermitteln

  return q{} if($graphicselect =~ /_noCons/xs || !scalar @consumers);

  my $hash   = $defs{$name};
  my $ftui   = $paref->{ftui};
  my $lang   = $paref->{lang};
  my $dstyle = $paref->{dstyle};                        # TD-Style

  my $staticon;

  ## Tabelle Start
  #################
  my $ctable = qq{<table align='left' width='100%'>};
  $ctable   .= qq{<tr style='font-weight:bold; text-align:center;'>};

  $ctable   .= qq{<td style='text-align:left' $dstyle> $hqtxt{cnsm}{$lang}  </td>};
  $ctable   .= qq{<td>                                                      </td>};
  $ctable   .= qq{<td>                                                      </td>};
  $ctable   .= qq{<td $dstyle>                         $hqtxt{eiau}{$lang}  </td>};
  $ctable   .= qq{<td $dstyle>                         $hqtxt{auto}{$lang}  </td>};

  $ctable   .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>};
  $ctable   .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>};

  my $cnum   = @consumers;

  if ($cnum > 1) {
      $ctable .= qq{<td style='text-align:left' $dstyle> $hqtxt{cnsm}{$lang}  </td>};
      $ctable .= qq{<td>                                                      </td>};
      $ctable .= qq{<td>                                                      </td>};
      $ctable .= qq{<td $dstyle>                         $hqtxt{eiau}{$lang}  </td>};
      $ctable .= qq{<td $dstyle>                         $hqtxt{auto}{$lang}  </td>};
  }
  else {
      my $blk  = '&nbsp;' x 8;
      $ctable .= qq{<td $dstyle> $blk </td>};
      $ctable .= qq{<td>         $blk </td>};
      $ctable .= qq{<td>         $blk </td>};
      $ctable .= qq{<td $dstyle> $blk </td>};
      $ctable .= qq{<td $dstyle> $blk </td>};
  }

  $ctable   .= qq{</tr>};

  if ($clpos ne 'top') {
       $ctable .= qq{<tr><td colspan="12"><hr></td></tr>};
  }

  my $modulo = 1;
  my $tro    = 0;

  for my $c (@consumers) {
      my $noshow = isConsumerNoshow ($hash, $c);
      
      next if($noshow =~ /[12]/xs);                                                                 # Consumer ausblenden

      my $caicon                  = $paref->{caicon};                                               # Consumer AdviceIcon
      my ($err, $cname, $dswname) = getCDnames  ($hash, $c);                                        # Consumer und Switch Device Name
      my $calias                  = ConsumerVal ($name, $c, 'alias',   $cname);                     # Alias des Consumerdevices
      my $cicon                   = ConsumerVal ($name, $c, 'icon',        '');                     # Icon des Consumerdevices
      my $oncom                   = ConsumerVal ($name, $c, 'oncom',       '');                     # Consumer Einschaltkommando
      my $offcom                  = ConsumerVal ($name, $c, 'offcom',      '');                     # Consumer Ausschaltkommando
      my $autord                  = ConsumerVal ($name, $c, 'autoreading', '');                     # Readingname f. Automatiksteuerung
      my $auto                    = ConsumerVal ($name, $c, 'auto',         1);                     # Automatic Mode

      my $cmdon      = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=set $name clientAction $c 0 set $dswname $oncom')"};
      my $cmdoff     = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=set $name clientAction $c 0 set $dswname $offcom')"};
      my $cmdautoon  = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=set $name clientAction $c 0 setreading $dswname $autord 1')"};
      my $cmdautooff = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=set $name clientAction $c 0 setreading $dswname $autord 0')"};
      my $implan     = qq{"FW_cmd('$::FW_ME$::FW_subdir?XHR=1&cmd=set $name clientAction $c 0 consumerImmediatePlanning $c')"};

      if ($ftui eq "ftui") {
          $cmdon      = qq{"ftui.setFhemStatus('set $name clientAction $c 0 set $dswname $oncom')"};
          $cmdoff     = qq{"ftui.setFhemStatus('set $name clientAction $c 0 set $dswname $offcom')"};
          $cmdautoon  = qq{"ftui.setFhemStatus('set $name clientAction $c 0 setreading $cname $autord 1')"};
          $cmdautooff = qq{"ftui.setFhemStatus('set $name clientAction $c 0 setreading $cname $autord 0')"};
          $implan     = qq{"ftui.setFhemStatus('set $name clientAction $c 0 consumerImmediatePlanning $c')"};
      }

      $cmdon      = q{} if(!$oncom);
      $cmdoff     = q{} if(!$offcom);
      $cmdautoon  = q{} if(!$autord);
      $cmdautooff = q{} if(!$autord);

      my $swicon  = q{};                                                                              # Schalter ein/aus Icon
      my $auicon  = q{};                                                                              # Schalter Automatic Icon
      my $isricon = q{};                                                                              # Zustand IsRecommended Icon

      $paref->{consumer} = $c;

      my ($planstate,$starttime,$stoptime,$supplmnt) = __getPlanningStateAndTimes ($paref);
      $supplmnt                                      = '-' if(!$supplmnt);
      my ($iilt,$rlt)                                = isInLocktime ($paref);                         # Sperrzeit Status ermitteln
      my $mode                                       = getConsumerPlanningMode ($hash, $c);           # Planungsmode 'can' oder 'must'

      my $sm          = ConsumerVal ($name, $c, 'surpmeth', 'default');
      $sm             = $sm eq 'default' || $sm =~ /_/ ? $sm : $sm.'_all';
      my $smr         = ConsumerVal ($name, $c, 'surpmethResult', 0);
      my $pstate      = $caicon eq "times"    ? $hqtxt{pstate}{$lang}  : $htitles{pstate}{$lang};
      my $surplusinfo = isConsRcmd($hash, $c) ? $htitles{splus}{$lang} : $htitles{nosplus}{$lang};
      $surplusinfo   .= " (${sm}: $smr W)";

      $pstate =~ s/<mode>/$mode/xs;
      $pstate =~ s/<pstate>/$planstate/xs;
      $pstate =~ s/<supplmnt>/$supplmnt/xs;
      $pstate =~ s/<start>/$starttime/xs;
      $pstate =~ s/<stop>/$stoptime/xs;
      $pstate =~ s/<RLT>/$rlt/xs;
      $pstate =~ s/\s+/&nbsp;/gxs         if($caicon eq "times");

      if ($clink) {
          $calias = qq{<a title="$cname" href="$::FW_ME$::FW_subdir?detail=$cname" style="color: inherit !important;" target="_blank">$c - $calias</a>};
      }

      if ($caicon ne "none") {
          if (isInTimeframe($hash, $c)) {                                                             # innerhalb Planungszeitraum ?
              if ($caicon eq "times") {
                  $isricon = $pstate.'<br>'.$surplusinfo;
              }
              else {
                  $isricon = "<a title='$htitles{conrec}{$lang}\n\n$surplusinfo\n$pstate' onClick=$implan>".FW_makeImage($caicon, '')." </a>";
                  if ($planstate =~ /priority/xs) {
                      my (undef,$color) = split '@', $caicon;
                      $color            = $color ? '@'.$color : '';
                      $isricon          = "<a title='$htitles{conrecba}{$lang}\n\n$surplusinfo\n$pstate' onClick=$implan>".FW_makeImage('batterie'.$color, '')." </a>";
                  }
              }
          }
          else {
              if ($caicon eq "times") {
                  $isricon =  $pstate.'<br>'.$surplusinfo;
              }
              else {
                  ($caicon) = split '@', $caicon;
                  $isricon  = "<a title='$htitles{connorec}{$lang}\n\n$surplusinfo\n$pstate' onClick=$implan>".FW_makeImage($caicon.'@grey', '')." </a>";
              }
          }
      }

      if ($modulo % 2){
          $ctable .= qq{<tr>};
          $tro     = 1;
      }

      if (!$auto) {
          $staticon = FW_makeImage('ios_off_fill@red', $htitles{iaaf}{$lang});
          $auicon   = "<a title= '$htitles{iaaf}{$lang}' onClick=$cmdautoon> $staticon</a>";
      }

      if ($auto) {
          $staticon = FW_makeImage('ios_on_till_fill@orange', $htitles{ieas}{$lang});
          $auicon   = "<a title='$htitles{ieas}{$lang}' onClick=$cmdautooff> $staticon</a>";
      }

      if ($noshow !~ /[9]/xs) {                                                                     # mit $noshow '9' die Schalter im Paneel ausblenden 
          if (isConsumerPhysOff($hash, $c)) {                                                       # Schaltzustand des Consumerdevices off
              if ($cmdon) {
                  $staticon = FW_makeImage('ios_off_fill@red', $htitles{iave}{$lang});
                  $swicon   = "<a title='$htitles{iave}{$lang}' onClick=$cmdon> $staticon</a>";
              }
              else {
                  $staticon = FW_makeImage('ios_off_fill@grey', $htitles{ians}{$lang});
                  $swicon   = "<a title='$htitles{ians}{$lang}'> $staticon</a>";
              }
          }

          if (isConsumerPhysOn($hash, $c)) {                                                        # Schaltzustand des Consumerdevices on
              if($cmdoff) {
                  $staticon = FW_makeImage('ios_on_fill@green', $htitles{ieva}{$lang});
                  $swicon   = "<a title='$htitles{ieva}{$lang}' onClick=$cmdoff> $staticon</a>";
              }
              else {
                  $staticon = FW_makeImage('ios_on_fill@grey', $htitles{iens}{$lang});
                  $swicon   = "<a title='$htitles{iens}{$lang}'> $staticon</a>";
              }
          }
      }

      if ($clstyle eq 'icon') {
          $cicon   = FW_makeImage($cicon);
          $ctable .= "<td style='text-align:left; white-space:nowrap;' $dstyle>$calias       </td>";
          $ctable .= "<td style='text-align:center'                    $dstyle>$cicon        </td>";
          $ctable .= "<td style='text-align:center'                    $dstyle>$isricon      </td>";
          $ctable .= "<td style='text-align:center'                    $dstyle>$swicon       </td>";
          $ctable .= "<td style='text-align:center'                    $dstyle>$auicon       </td>";
      }
      else {
          my (undef,$co) = split '@', $cicon;
          $co      = '' if (!$co);
          $ctable .= "<td style='text-align:left'   $dstyle><font color='$co'>$calias </font></td>";
          $ctable .= "<td>                                                                   </td>";
          $ctable .= "<td>                                  $isricon                         </td>";
          $ctable .= "<td style='text-align:center' $dstyle>$swicon                          </td>";
          $ctable .= "<td style='text-align:center' $dstyle>$auicon                          </td>";
      }

      if (!($modulo % 2)) {
          $ctable .= qq{</tr>};
          $tro     = 0;
      }
      else {
          $ctable .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>};
          $ctable .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>};
      }

      $modulo++;
  }

  delete $paref->{consumer};

  $ctable .= qq{</tr>} if($tro);

  if ($clpos ne 'bottom') {
       $ctable .= qq{<tr><td colspan='12'><hr></td></tr>};
  }

  $ctable .= qq{</table>};

return $ctable;
}

################################################################
#    Werte erste Stunde in Balkengrafik
################################################################
sub _beamGraphicFirstHour {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $hfcg      = $paref->{hfcg};
  my $offset    = $paref->{offset};
  my $hourstyle = $paref->{hourstyle};
  my $beam1cont = $paref->{beam1cont};
  my $beam2cont = $paref->{beam2cont};
  my $lang      = $paref->{lang};
  my $kw        = $paref->{kw};

  my ($day, $bn);

  my $hash                             = $defs{$name};
  my $stt                              = NexthoursVal ($hash, 'NextHour00', 'starttime', '0000-00-00 24');
  my ($year,$month,$day_str,$thishour) = $stt =~ m/(\d{4})-(\d{2})-(\d{2})\s(\d{2})/x;

  my ($val1, $val2, $val3, $val4, $val5, $val6, $val7, $val8, $val9, $val10);
  my $hbsocs;

  $thishour++;

  $hfcg->{0}{time_str} = $thishour;
  $thishour            = int($thishour);                                                            # keine führende Null

  $hfcg->{0}{time}     = $thishour;
  $hfcg->{0}{day_str}  = $day_str;
  $day                 = int($day_str);
  $hfcg->{0}{day}      = $day;
  $hfcg->{0}{mktime}   = fhemTimeLocal (0,0,$thishour,$day,int($month)-1,$year-1900);               # gleich die Unix Zeit dazu holen
  $hfcg->{0}{time}    += $offset;

  if ($hfcg->{0}{time} < 0) {                                                                       # Tageswechsel: day muss jetzt neu berechnet werden !
      $hfcg->{0}{time}   += 24;
      my $n_day           = strftime "%d", localtime($hfcg->{0}{mktime} - (3600 * abs($offset)));
      $hfcg->{0}{day}     = int($n_day);
      $hfcg->{0}{day_str} = $n_day;
  }

  $hfcg->{0}{time_str} = sprintf '%02d', $hfcg->{0}{time};

  $hfcg->{0}{weather} = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'weatherid', 999);
  $hfcg->{0}{wcc}     = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'wcc',       '-');
  $hfcg->{0}{sunalt}  = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'sunalt',    '-');
  $hfcg->{0}{sunaz}   = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'sunaz',     '-');
  $hfcg->{0}{don}     = HistoryVal ($name, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'DoN',         0);

  $val1 = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'pvfc',  0);
  $val2 = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'pvrl',  0);
  $val3 = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'gcons', 0);
  $val4 = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'confc', 0);
  $val5 = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'con',   0);
  $val6 = sprintf "%.2f", (HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'conprice',  0) * $val3 / 1000);  # Energiekosten der Stunde
  $val7 = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'gfeedin', 0);
  $val8 = sprintf "%.2f", (HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'feedprice', 0) * $val7 / 1000);  # Einspeisevergütung der Stunde

  ## Batterien Selektionshash erstellen
  #######################################
  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;

      $hbsocs->{0}{$bn}{beam1cont} = $beam1cont =~ /batsocCombi_${bn}/xs    ? sprintf "%.1f", HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'batsoc'.$bn, 0)     :       # real erreichter SoC (Vergangenheit) / SoC-Prognose
                                     $beam1cont =~ /batsocForecast_${bn}/xs ? sprintf "%.1f", HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'batprogsoc'.$bn, 0) :       # nur SoC-Prognose
                                     $beam1cont =~ /batsocReal_${bn}/xs     ? sprintf "%.1f", HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'batsoc'.$bn, 0)     :       # nur real erreichter SoC
                                     0;

      $hbsocs->{0}{$bn}{beam2cont} = $beam2cont =~ /batsocCombi_${bn}/xs    ? sprintf "%.1f", HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'batsoc'.$bn, 0)     :       # real erreichter SoC (Vergangenheit) / SoC-Prognose
                                     $beam2cont =~ /batsocForecast_${bn}/xs ? sprintf "%.1f", HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'batprogsoc'.$bn, 0) :       # nur SoC-Prognose
                                     $beam2cont =~ /batsocReal_${bn}/xs     ? sprintf "%.1f", HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'batsoc'.$bn, 0)     :       # nur real erreichter SoC
                                     0;

      $hbsocs->{0}{$bn}{beam1cont} = 100 if($hbsocs->{0}{$bn}{beam1cont} >= 100);
      $hbsocs->{0}{$bn}{beam2cont} = 100 if($hbsocs->{0}{$bn}{beam2cont} >= 100);
  }

  ## Batterien summarische Werte erstellen
  ##########################################
  my $bcapsum = CurrentVal ($name, 'batcapsum', 0);                                                        # Summe installierte Batterie Kapazität in Wh

  if ($bcapsum) {
      my $socprogwhsum = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'socprogwhsum', 0);
      my $socwhsum     = HistoryVal ($hash, $hfcg->{0}{day_str}, $hfcg->{0}{time_str}, 'socwhsum', 0);
      $val9            = sprintf "%.1f", (100 * $socprogwhsum / $bcapsum);                                 # Summe Prognose SoC in % über alle Batterien
      $val10           = sprintf "%.1f", (100 * $socwhsum / $bcapsum);                                     # Summe real erreichter SoC in % über alle Batterien
  }

  ## Zuordnung Werte zu den Balken entsprechend Selektion
  #########################################################
  $hfcg->{0}{beam1}    = $beam1cont eq 'pvForecast'          ? $val1  :
                         $beam1cont eq 'pvReal'              ? $val2  :
                         $beam1cont eq 'gridconsumption'     ? $val3  :
                         $beam1cont eq 'consumptionForecast' ? $val4  :
                         $beam1cont eq 'consumption'         ? $val5  :
                         $beam1cont eq 'energycosts'         ? $val6  :
                         $beam1cont eq 'gridfeedin'          ? $val7  :
                         $beam1cont eq 'feedincome'          ? $val8  :
                         $beam1cont eq 'batsocForecastSum'   ? $val9  :
                         $beam1cont eq 'batsocRealSum'       ? $val10 :
                         $beam1cont =~ /^batsoc/xs           ? $hbsocs->{0}{(split '_', $beam1cont)[1]}{beam1cont} :
                         undef;

  $hfcg->{0}{beam2}    = $beam2cont eq 'pvForecast'          ? $val1  :
                         $beam2cont eq 'pvReal'              ? $val2  :
                         $beam2cont eq 'gridconsumption'     ? $val3  :
                         $beam2cont eq 'consumptionForecast' ? $val4  :
                         $beam2cont eq 'consumption'         ? $val5  :
                         $beam2cont eq 'energycosts'         ? $val6  :
                         $beam2cont eq 'gridfeedin'          ? $val7  :
                         $beam2cont eq 'feedincome'          ? $val8  :
                         $beam2cont eq 'batsocForecastSum'   ? $val9  :
                         $beam2cont eq 'batsocRealSum'       ? $val10 :
                         $beam2cont =~ /^batsoc/xs           ? $hbsocs->{0}{(split '_', $beam2cont)[1]}{beam2cont} :
                         undef;

  $hfcg->{0}{beam1}  //= 0;
  $hfcg->{0}{beam2}  //= 0;
  my %roundable        = map { $_ => 1 } qw(pvForecast pvReal consumptionForecast consumption);
  my @beams            = ($beam1cont, $beam2cont);
  $hfcg->{0}{diff}     = sprintf "%.1f", ($hfcg->{0}{beam1} - $hfcg->{0}{beam2});
  $hfcg->{0}{diff}     = sprintf "%.0f", $hfcg->{0}{diff} if($kw eq 'Wh' && grep { $roundable{$_} } @beams);
  
  my $epc = CurrentVal ($hash, 'ePurchasePriceCcy', 0);
  my $efc = CurrentVal ($hash, 'eFeedInTariffCcy',  0);

  $hfcg->{0}{beam1txt} = $beam1cont eq 'pvForecast'          ? $htitles{pvgenefc}{$lang}." ($kw)"  :
                         $beam1cont eq 'pvReal'              ? $htitles{pvgenerl}{$lang}." ($kw)"  :
                         $beam1cont eq 'gridconsumption'     ? $htitles{enppubgd}{$lang}." ($kw)"  :
                         $beam1cont eq 'consumptionForecast' ? $htitles{enconsfc}{$lang}." ($kw)"  :
                         $beam1cont eq 'consumption'         ? $htitles{enconsrl}{$lang}." ($kw)"  :
                         $beam1cont eq 'energycosts'         ? $htitles{enpchcst}{$lang}." ($epc)" :
                         $beam1cont eq 'gridfeedin'          ? $htitles{enfeedgd}{$lang}." ($kw)"  :
                         $beam1cont eq 'feedincome'          ? $htitles{rengfeed}{$lang}." ($efc)" :
                         $beam1cont eq 'batsocForecastSum'   ? $htitles{socfcsum}{$lang}           :
                         $beam1cont eq 'batsocRealSum'       ? $htitles{socresum}{$lang}           :
                         $beam1cont =~ /batsocCombi_/xs      ? $htitles{socrfcba}{$lang}." ".(split '_', $beam1cont)[1]." (%)" :
                         $beam1cont =~ /batsocForecast_/xs   ? $htitles{socfcbat}{$lang}." ".(split '_', $beam1cont)[1]." (%)" :
                         $beam1cont =~ /batsocReal_/xs       ? $htitles{socrebat}{$lang}." ".(split '_', $beam1cont)[1]." (%)" :
                         '';
  $hfcg->{0}{beam2txt} = $beam2cont eq 'pvForecast'          ? $htitles{pvgenefc}{$lang}." ($kw)"  :
                         $beam2cont eq 'pvReal'              ? $htitles{pvgenerl}{$lang}." ($kw)"  :
                         $beam2cont eq 'gridconsumption'     ? $htitles{enppubgd}{$lang}." ($kw)"  :
                         $beam2cont eq 'consumptionForecast' ? $htitles{enconsfc}{$lang}." ($kw)"  :
                         $beam2cont eq 'consumption'         ? $htitles{enconsrl}{$lang}." ($kw)"  :
                         $beam2cont eq 'energycosts'         ? $htitles{enpchcst}{$lang}." ($epc)" :
                         $beam2cont eq 'gridfeedin'          ? $htitles{enfeedgd}{$lang}." ($kw)"  :
                         $beam2cont eq 'feedincome'          ? $htitles{rengfeed}{$lang}." ($efc)" :
                         $beam2cont eq 'batsocForecastSum'   ? $htitles{socfcsum}{$lang}           :
                         $beam2cont eq 'batsocRealSum'       ? $htitles{socresum}{$lang}           :
                         $beam2cont =~ /batsocCombi_/xs      ? $htitles{socrfcba}{$lang}." ".(split '_', $beam2cont)[1]." (%)" :
                         $beam2cont =~ /batsocForecast_/xs   ? $htitles{socfcbat}{$lang}." ".(split '_', $beam2cont)[1]." (%)" :
                         $beam2cont =~ /batsocReal_/xs       ? $htitles{socrebat}{$lang}." ".(split '_', $beam2cont)[1]." (%)" :
                         '';

  $hfcg->{0}{time_str} = sprintf('%02d', $hfcg->{0}{time}-1).$hourstyle;

return $thishour;
}

################################################################
#    Werte restliche Stunden in Balkengrafik
################################################################
sub _beamGraphicRemainingHours {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $hfcg      = $paref->{hfcg};
  my $offset    = $paref->{offset};
  my $maxhours  = $paref->{maxhours};
  my $hourstyle = $paref->{hourstyle};
  my $beam1cont = $paref->{beam1cont};
  my $beam2cont = $paref->{beam2cont};
  my $kw        = $paref->{kw};

  my ($val1, $val2, $val3, $val4, $val5, $val6, $val7, $val8, $val9, $val10);
  my $hbsocs;

  my $hash     = $defs{$name};
  my $maxVal   = $hfcg->{0}{beam1};                                                                     # Startwert
  my $maxStVal = $hfcg->{0}{beam1} + $hfcg->{0}{beam2};                                                 # Start Staplewert
  my $maxDif   = $hfcg->{0}{diff};                                                                      # für Typ diff
  my $minDif   = $hfcg->{0}{diff};                                                                      # für Typ diff
  my $bcapsum  = CurrentVal ($name, 'batcapsum', 0);                                                    # Summe installierte Batterie Kapazität in Wh

  for my $i (1..($maxhours*2)-1) {                                                                      # doppelte Anzahl berechnen    my $val1 = 0;
      ($val1, $val2, $val3 ,$val4 ,$val5, $val6, $val7 ,$val8, $val9, $val10) = (0,0,0,0,0,0,0,0,0,0);

      $hfcg->{$i}{time} = $hfcg->{0}{time} + $i;

      while ($hfcg->{$i}{time} > 24) {
          $hfcg->{$i}{time} -= 24;                                                                      # wird bis zu 2x durchlaufen
      }

      $hfcg->{$i}{time_str} = sprintf '%02d', $hfcg->{$i}{time};

      my $nh;                                                                                           # next hour

      if ($offset < 0) {
          if ($i <= abs($offset)) {                                                                     # $daystr stimmt nur nach Mitternacht, vor Mitternacht muß $hfcg->{0}{day_str} als Basis verwendet werden !
              my $ds = strftime "%d", localtime ($hfcg->{0}{mktime} - (3600 * abs($offset+$i)));        # V0.49.4

              if ($hfcg->{$i}{time} == 24) {                                                            # Sonderfall Mitternacht
                  $ds = strftime "%d", localtime ($hfcg->{0}{mktime} - (3600 * (abs($offset-$i+1))));
              }

              $hfcg->{$i}{weather} = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'weatherid', 999);
              $hfcg->{$i}{wcc}     = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'wcc',       '-');
              $hfcg->{$i}{sunalt}  = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'sunalt',    '-');
              $hfcg->{$i}{sunaz}   = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'sunaz',     '-');
              $hfcg->{$i}{don}     = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'DoN',         0);

              $val1 = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'pvfc',  0);
              $val2 = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'pvrl',  0);
              $val3 = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'gcons', 0);
              $val4 = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'confc', 0);
              $val5 = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'con',   0);
              $val6 = sprintf "%.2f", (HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'conprice',  0) * $val3 / 1000);  # Energiekosten der Stunde
              $val7 = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'gfeedin', 0);
              $val8 = sprintf "%.2f", (HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'feedprice', 0) * $val7 / 1000);  # Einspeisevergütung der Stunde

              ## Batterien Selektionshash erstellen
              #######################################
              for my $bn (1..MAXBATTERIES) {
                  $bn = sprintf "%02d", $bn;

                  $hbsocs->{$i}{$bn}{beam1cont} = $beam1cont =~ /batsocCombi_${bn}/xs    ? sprintf "%.1f", HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'batsoc'.$bn, 0)     :       # real erreichter SoC (Vergangenheit) / SoC-Prognose
                                                  $beam1cont =~ /batsocForecast_${bn}/xs ? sprintf "%.1f", HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'batprogsoc'.$bn, 0) :       # nur SoC-Prognose
                                                  $beam1cont =~ /batsocReal_${bn}/xs     ? sprintf "%.1f", HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'batsoc'.$bn, 0)     :       # nur real erreichter SoC
                                                  0;

                  $hbsocs->{$i}{$bn}{beam2cont} = $beam2cont =~ /batsocCombi_${bn}/xs    ? sprintf "%.1f", HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'batsoc'.$bn, 0)     :       # real erreichter SoC (Vergangenheit) / SoC-Prognose
                                                  $beam2cont =~ /batsocForecast_${bn}/xs ? sprintf "%.1f", HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'batprogsoc'.$bn, 0) :       # nur SoC-Prognose
                                                  $beam2cont =~ /batsocReal_${bn}/xs     ? sprintf "%.1f", HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'batsoc'.$bn, 0)     :       # nur real erreichter SoC
                                                  0;

                  $hbsocs->{$i}{$bn}{beam1cont} = 100 if($hbsocs->{$i}{$bn}{beam1cont} >= 100);
                  $hbsocs->{$i}{$bn}{beam2cont} = 100 if($hbsocs->{$i}{$bn}{beam2cont} >= 100);
              }

              ## Batterien summarische Werte erstellen
              ##########################################
              if ($bcapsum) {
                  my $socprogwhsum = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'socprogwhsum', 0);
                  my $socwhsum     = HistoryVal ($name, $ds, $hfcg->{$i}{time_str}, 'socwhsum', 0);
                  $val9            = sprintf "%.1f", (100 * $socprogwhsum / $bcapsum);                        # Summe Prognose SoC in % über alle Batterien
                  $val10           = sprintf "%.1f", (100 * $socwhsum / $bcapsum);                            # Summe real erreichter SoC in % über alle Batterien
              }

              $hfcg->{$i}{day_str} = $ds;
              $hfcg->{$i}{day}     = int($ds);
          }
          else {
              $nh = sprintf '%02d', ($i + $offset);
          }
      }
      else {
          $nh = sprintf '%02d', $i;
      }

      if (defined $nh) {
          $hfcg->{$i}{weather} = NexthoursVal ($name, 'NextHour'.$nh, 'weatherid', 999);
          $hfcg->{$i}{wcc}     = NexthoursVal ($name, 'NextHour'.$nh, 'wcc',       '-');
          $hfcg->{$i}{sunalt}  = NexthoursVal ($name, 'NextHour'.$nh, 'sunalt',    '-');
          $hfcg->{$i}{sunaz}   = NexthoursVal ($name, 'NextHour'.$nh, 'sunaz',     '-');
          $hfcg->{$i}{don}     = NexthoursVal ($name, 'NextHour'.$nh, 'DoN',         0);
          my $stt              = NexthoursVal ($name, 'NextHour'.$nh, 'starttime',  '');

          $val1 = NexthoursVal ($name, 'NextHour'.$nh, 'pvfc',  0);
          $val4 = NexthoursVal ($name, 'NextHour'.$nh, 'confc', 0);

          ## Batterien Selektionshash anreichern
          ########################################
          for my $bn (1..MAXBATTERIES) {
              $bn = sprintf "%02d", $bn;

              $hbsocs->{$i}{$bn}{beam1cont} = $beam1cont =~ /batsoc(Combi|Forecast)_${bn}/xs ? NexthoursVal ($name, 'NextHour'.$nh, 'soc'.$bn, 0) :     # Kombi-Content oder nur SoC-Prognose
                                              0;

              $hbsocs->{$i}{$bn}{beam2cont} = $beam2cont =~ /batsoc(Combi|Forecast)_${bn}/xs ? NexthoursVal ($name, 'NextHour'.$nh, 'soc'.$bn, 0) :     # Kombi-Content oder nur SoC-Prognose
                                              0;

              $hbsocs->{$i}{$bn}{beam1cont} = 100 if($hbsocs->{$i}{$bn}{beam1cont} >= 100);
              $hbsocs->{$i}{$bn}{beam2cont} = 100 if($hbsocs->{$i}{$bn}{beam2cont} >= 100);
          }

              ## Batterien summarische Werte erstellen
              ##########################################
              if ($bcapsum) {
                  my $socprogwhsum = NexthoursVal ($name, 'NextHour'.$nh, 'socprogwhsum', 0);
                  $val9            = sprintf "%.1f", (100 * $socprogwhsum / $bcapsum);                                 # Summe Prognose SoC in % über alle Batterien
              }

          my $day_str = ($stt =~ m/(\d{4})-(\d{2})-(\d{2})\s(\d{2})/xs)[2];

          if ($day_str) {
              $hfcg->{$i}{day_str} = $day_str;
              $hfcg->{$i}{day}     = int $day_str;
          }
      }

      ## Zuordnung Werte zu den Balken entsprechend Selektion
      #########################################################
      $hfcg->{$i}{beam1}    = $beam1cont eq 'pvForecast'          ? $val1  :
                              $beam1cont eq 'pvReal'              ? $val2  :
                              $beam1cont eq 'gridconsumption'     ? $val3  :
                              $beam1cont eq 'consumptionForecast' ? $val4  :
                              $beam1cont eq 'consumption'         ? $val5  :
                              $beam1cont eq 'energycosts'         ? $val6  :
                              $beam1cont eq 'gridfeedin'          ? $val7  :
                              $beam1cont eq 'feedincome'          ? $val8  :
                              $beam1cont eq 'batsocForecastSum'   ? $val9  :
                              $beam1cont eq 'batsocRealSum'       ? $val10 :
                              $beam1cont =~ /^batsoc/xs           ? $hbsocs->{$i}{(split '_', $beam1cont)[1]}{beam1cont} :
                              undef;

      $hfcg->{$i}{beam2}    = $beam2cont eq 'pvForecast'          ? $val1  :
                              $beam2cont eq 'pvReal'              ? $val2  :
                              $beam2cont eq 'gridconsumption'     ? $val3  :
                              $beam2cont eq 'consumptionForecast' ? $val4  :
                              $beam2cont eq 'consumption'         ? $val5  :
                              $beam2cont eq 'energycosts'         ? $val6  :
                              $beam2cont eq 'gridfeedin'          ? $val7  :
                              $beam2cont eq 'feedincome'          ? $val8  :
                              $beam2cont eq 'batsocForecastSum'   ? $val9  :
                              $beam2cont eq 'batsocRealSum'       ? $val10 :
                              $beam2cont =~ /^batsoc/xs           ? $hbsocs->{$i}{(split '_', $beam2cont)[1]}{beam2cont} :
                              undef;

      $hfcg->{$i}{time_str} = sprintf ('%02d', $hfcg->{$i}{time}-1).$hourstyle;

      $hfcg->{$i}{beam1} //= 0;
      $hfcg->{$i}{beam2} //= 0;
      my %roundable        = map { $_ => 1 } qw(pvForecast pvReal consumptionForecast consumption);
      my @beams            = ($beam1cont, $beam2cont);
      $hfcg->{$i}{diff}    = sprintf "%.1f", ($hfcg->{$i}{beam1} - $hfcg->{$i}{beam2});
      $hfcg->{$i}{diff}    = sprintf "%.0f", $hfcg->{$i}{diff} if($kw eq 'Wh' && grep { $roundable{$_} } @beams);

      $maxVal   = $hfcg->{$i}{beam1}                      if($hfcg->{$i}{beam1} > $maxVal);
      $maxVal   = $hfcg->{$i}{beam2}                      if($hfcg->{$i}{beam2} > $maxVal);
      $maxStVal = $hfcg->{$i}{beam1} + $hfcg->{$i}{beam2} if($maxStVal          < $hfcg->{$i}{beam1} + $hfcg->{$i}{beam2});
      $maxDif   = $hfcg->{$i}{diff}                       if($hfcg->{$i}{diff}  > $maxDif);
      $minDif   = $hfcg->{$i}{diff}                       if($hfcg->{$i}{diff}  < $minDif);
  }

  my $back = {
      maxVal   => $maxVal,
      maxStVal => $maxStVal,
      maxDif   => $maxDif,
      minDif   => $minDif,
  };

return $back;
}

################################################################
#   Batteriewerte zur Anzeige in Balkengrafik vorbereiten
#   Anzeigehash mit Werten auffüllen
################################################################
sub _beamFillupBatValues {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hfcg  = $paref->{hfcg};

  my $hash = $defs{$name};
  my $hh;

  for my $idx (sort keys %{$data{$name}{nexthours}}) {
      for my $bn (1..MAXBATTERIES) {                                            # alle Batterien
          $bn      = sprintf "%02d", $bn;
          my $rcdc = NexthoursVal ($name, $idx, 'rcdchargebat'.$bn, undef);
          my $stt  = NexthoursVal ($name, $idx, 'starttime',        undef);
          next if(!defined $stt || !defined $rcdc);

          my (undef,undef,$day_str,$time_str) = $stt =~ m/(\d{4})-(\d{2})-(\d{2})\s(\d{2})/xs;

          $hh->{$day_str}{$time_str}{'rcdchargebat'.$bn} = $rcdc;
          $hh->{$day_str}{$time_str}{'lcintimebat'.$bn}  = NexthoursVal ($name, $idx, 'lcintimebat'.$bn, undef);
          $hh->{$day_str}{$time_str}{'strategybat'.$bn}  = NexthoursVal ($name, $idx, 'strategybat'.$bn, undef);
          $hh->{$day_str}{$time_str}{'soc'.$bn}          = NexthoursVal ($name, $idx, 'soc'.$bn,         undef);
      }
  }

  for my $kdx (sort keys %{$hfcg}) {
      next if(!isNumeric ($kdx));

      my $ds = $hfcg->{$kdx}{day_str};
      my $ts = $hfcg->{$kdx}{time_str};

      next if(!defined $ds || !defined $ts);

      $ts = (split ":", $ts)[0];                                           # Forum: https://forum.fhem.de/index.php?msg=1332721

      for my $bn (1..MAXBATTERIES) {
          $bn = sprintf "%02d", $bn;
          $ds = sprintf "%02d", $ds;

          ## Einfügen prepared NextHour Werte
          #####################################
          $hfcg->{$kdx}{'rcdchargebat'.$bn} = $hh->{$ds}{$ts}{'rcdchargebat'.$bn} if(defined $hh->{$ds}{$ts}{'rcdchargebat'.$bn});
          $hfcg->{$kdx}{'lcintimebat'.$bn}  = $hh->{$ds}{$ts}{'lcintimebat'.$bn}  if(defined $hh->{$ds}{$ts}{'lcintimebat'.$bn});
          $hfcg->{$kdx}{'strategybat'.$bn}  = $hh->{$ds}{$ts}{'strategybat'.$bn}  if(defined $hh->{$ds}{$ts}{'strategybat'.$bn});
          $hfcg->{$kdx}{'soc'.$bn}          = $hh->{$ds}{$ts}{'soc'.$bn}          if(defined $hh->{$ds}{$ts}{'soc'.$bn});

          ## Auffüllen mit History Werten (Achtung: Stundenverschieber relativ zu Nexthours)
          ####################################################################################
          if (!defined $hh->{$ds}{$ts}{'rcdchargebat'.$bn}) {
              my $histsoc  = HistoryVal ($hash, $ds, (sprintf "%02d", $ts+1), 'batsoc'.$bn,      undef);
              my $lcintime = HistoryVal ($hash, $ds, (sprintf "%02d", $ts+1), 'lcintimebat'.$bn, undef);
              my $strategy = HistoryVal ($hash, $ds, (sprintf "%02d", $ts+1), 'strategybat'.$bn, undef);

              if (defined $histsoc) {
                  $hfcg->{$kdx}{'rcdchargebat'.$bn} = 'hist';
                  $hfcg->{$kdx}{'lcintimebat'.$bn}  = $lcintime;
                  $hfcg->{$kdx}{'strategybat'.$bn}  = $strategy;
                  $hfcg->{$kdx}{'soc'.$bn}          = $histsoc;
              }
          }
      }
  }

return;
}

################################################################
#    Balkenausgabe für forecastGraphic
################################################################
sub _beamGraphic {
  my $paref      = shift;
  my $name       = $paref->{name};
  my $hfcg       = $paref->{hfcg};
  my $maxhours   = $paref->{maxhours};
  my $weather    = $paref->{weather};
  my $show_night = $paref->{show_night};                     # alle Balken (Spalten) anzeigen ?
  my $showdiff   = $paref->{showdiff};                       # zusätzliche Anzeige $di{} in allen Typen
  my $scm        = $paref->{scm};                            # Scale Mode
  my $lotype     = $paref->{lotype};
  my $height     = $paref->{height} // BHEIGHTLEVEL;         # Fallback, sollte eigentlich nicht vorkommen
  my $spacesz    = $paref->{spacesz};
  my $kw         = $paref->{kw};
  my $colorb1    = $paref->{colorb1};
  my $colorb2    = $paref->{colorb2};
  my $fcolor1    = $paref->{fcolor1};
  my $fcolor2    = $paref->{fcolor2};
  my $offset     = $paref->{offset};
  my $thishour   = $paref->{thishour};
  my $maxVal     = $paref->{maxVal};                         # Maximalwert von beam1 ODER beam2
  my $maxStVal   = $paref->{maxStVal};                       # Maximalwert des Stapels beam1 UND beam2
  my $maxDif     = $paref->{maxDif};
  my $minDif     = $paref->{minDif};
  my $beam1cont  = $paref->{beam1cont};
  my $beam2cont  = $paref->{beam2cont};
  my $barcount   = $paref->{barcount} // 9999;               # Sync Anzahl Balken dieser Ebene mit voriger Ebene

  $lotype = 'single' if($beam1cont eq $beam2cont);           # User Auswahl Layout überschreiben bei gleichen Beamcontent !

  # Wenn Table class=block alleine steht, zieht es bei manchen Styles die Ausgabe auf 100% Seitenbreite
  # lässt sich durch einbetten in eine zusätzliche Table roomoverview eindämmen
  # Die Tabelle ist recht schmal angelegt, aber nur so lassen sich Umbrüche erzwingen

  my ($val, $z2, $z3, $z4, $z1, $titz2, $titz3);

  $paref->{beampos} = 'top';                                                               # Lagedefinition "über den Balken"
  my $ret           = q{};

  my $colspan = $maxhours + 2;
  my $m       = $paref->{modulo} % 2;
  $maxVal     = 1.1 if(!int $maxVal);                                                      # devision by zero & log(x) Problem
  $maxStVal   = 1.1 if(!int $maxStVal);                                                    # devision by zero Problem
  
  ## zusätzlicher Abstand vor der ersten Reihe
  ##############################################
  my $pt = CurrentVal ($name, 'beamPaddingTop', 0);

  if ($pt) {
      $ret .= "<tr class='$htr{$m}{cl}'>";
      $ret .= "<td colspan='$colspan' align='center' style='padding-left: 10px; padding-top: ${pt}px; padding-bottom: 0px;'>";
      $ret .= "</td>";
      $ret .= "</tr>";
  }

  ## Wetteranzeige über den Balken
  ##################################
  $ret .= __weatherOnBeam ($paref) if($weather);

  ## Batterieanzeige über den Balken
  ####################################
  $ret .= __batteryOnBeam ($paref);

  if ($showdiff eq 'top') {                                                                                     # Zusätzliche Zeile Ertrag - Verbrauch
      $ret .= "<tr class='$htr{$m}{cl}'><td class='solarfc'></td>";

      my $ii = 0;

      for my $i (0..($maxhours * 2) - 1) {                                                                      # gleiche Bedingung wie oben
          next if(__dontNightshowSkipSync ($name, $paref, $i));

          $ii++;                                                                                                # wieviele Stunden haben wir bisher angezeigt ?
          last if($ii > $maxhours || $ii > $barcount);                                                          # vorzeitiger Abbruch

          $val = normBeamWidth ($paref, 'diff', $i, 'beam1');

          if ($val ne '&nbsp;') {                                                                               # Forum: https://forum.fhem.de/index.php/topic,117864.msg1166215.html#msg1166215
              $val = $hfcg->{$i}{diff} < 0 ? '<b>'.$val.'<b/>' :
                     $val > 0              ? '+'  .$val        :
                     $val;                                                                                      # negative Zahlen in Fettschrift, 0 aber ohne +
          }

          $ret .= "<td class='solarfc' style='vertical-align:middle; text-align:center;'>$val</td>";
      }

      $ret .= "<td class='solarfc'></td></tr>";                                                                 # freier Platz am Ende
  }

  $ret .= "<tr class='$htr{$m}{cl}'><td class='solarfc'></td>";                                                 # Neue Zeile mit freiem Platz am Anfang

  my $ii   = 0;
  my $mbdf = 0;

  for my $i (0..($maxhours * 2) - 1) {                                                                          # gleiche Bedingung wie oben
      next if(__dontNightshowSkipSync ($name, $paref, $i));

      $ii++;
      last if($ii > $maxhours || $ii > $barcount);

      $paref->{barcount} = $ii;                                                                                 # Anzahl Balken zur Begrenzung der nächsten Ebene registrieren

      # Berechnung der Zonen
      ########################
      if ($lotype eq 'single') {
          $z1 = __normBeamHeight ( { val       => $maxVal - $hfcg->{$i}{beam1}, 
                                     maxVal    => $maxVal, 
                                     maxStVal  => $maxStVal,
                                     height    => $height, 
                                     ground    => 0,
                                     scalemode => 'lin'
                                   } 
                                 ) + $spacesz * 10;

          $z3    =__normBeamHeight ( { val => $hfcg->{$i}{beam1}, maxVal => $maxVal, height => $height, ground => 0, scalemode => $scm  } );
          $titz3 = qq/title="$hfcg->{0}{beam1txt}"/;
      }

      if ($lotype eq 'double') {
          # he - freier der Raum über den Balken. spacesz wird nicht verwendet, da bei diesem Typ keine Zahlen über den Balken stehen
          # z2 - primärer Balkenwert ggf. mit Icon
          # z3 - sekundärer Balkenwert, bei zu kleinem Wert wird der Platz komplett Zone 2 zugeschlagen und nicht angezeigt
          # z2 und z3 nach Bedarf tauschen, wenn sekundärer Balkenwert > primärer Balkenwert (außer bei 'staple')

          if ($scm eq 'staple') {
              $z2    = $hfcg->{$i}{beam1};
              $z3    = $hfcg->{$i}{beam2};
              $titz2 = qq/title="$hfcg->{0}{beam1txt}"/;
              $titz3 = qq/title="$hfcg->{0}{beam2txt}"/;
              $mbdf  = $maxStVal - ($z2 + $z3);                             # Wertedifferenz abs. Maxwert und größerem Balkenwert              
          }
          else {
              if ($hfcg->{$i}{beam1} >= $hfcg->{$i}{beam2}) {                                                        
                  $z2    = $hfcg->{$i}{beam1};
                  $z3    = $hfcg->{$i}{beam2};
                  $titz2 = qq/title="$hfcg->{0}{beam1txt}"/;
                  $titz3 = qq/title="$hfcg->{0}{beam2txt}"/;
              }
              else {                                                                                                                        # tauschen, Betrag Beam1 < Betrag Beam2 
                  $z2    = $hfcg->{$i}{beam2};
                  $z3    = $hfcg->{$i}{beam1};
                  $titz2 = qq/title="$hfcg->{0}{beam2txt}"/;
                  $titz3 = qq/title="$hfcg->{0}{beam1txt}"/;
              }
              
              $mbdf = $maxVal - $z2;                                         # Wertedifferenz abs. Maxwert und größerem Balkenwert
          }
   
          $z1  = __normBeamHeight ( { val => $mbdf, maxVal => $maxVal, height => $height, ground => 0, scalemode => 'lin' } );
          $z2  = __normBeamHeight ( { val => $z2,   maxVal => $maxVal, height => $height, ground => 0, scalemode => $scm  } );                                                                     
          $z3  = __normBeamHeight ( { val => $z3,   maxVal => $maxVal, height => $height, ground => 0, scalemode => $scm  } );  
          $z2 -= $z3 if($scm eq 'lin');                                                                                                 # effektive Stapelhöhe, da $z2 + $z3 übereinander dargestellt wird
          
          if ($scm eq 'log' && $z2) {
              my $z3perc = int (100 / $z2 * $z3);
              $z3        = int ($z3 / 100 * $z3perc);
              $z3       -= $height * 0.1 if($z3);
              $z2       -= $z3;
          }
      }

      if ($lotype eq 'diff') {
          # he - freier der Raum über den Balken , Zahl positiver Wert + spacesz
          # z2 - positiver Balken inkl Icon
          # z3 - negativer Balken
          # z4 - Zahl negativer Wert + spacesz

          my ($px_pos,$px_neg);
          my $maxValBeam = 0;                                                                                   # ToDo:  maxValBeam noch aus maxVal ableiten

          if ($maxValBeam) {                                                                                    # Feste Aufteilung +/- , jeder 50 % bei maxValBeam = 0
              $px_pos = int ($height/2);
              $px_neg = $height - $px_pos;                                                                      # Rundungsfehler vermeiden
          }
          else {                                                                                                # Dynamische hoch/runter Verschiebung der Null-Linie
              if ($minDif >= 0 ) {                                                                              # keine negativen Balken vorhanden, die Positiven bekommen den gesammten Raum
                  $px_neg = 0;
                  $px_pos = $height;
              }
              else {
                  if ($maxDif > 0) {
                      $px_neg = int ($height * abs($minDif) / ($maxDif + abs($minDif)));                        # Wieviel % entfallen auf unten ?
                      $px_pos = $height - $px_neg;                                                              # der Rest ist oben
                  }
                  else {                                                                                        # keine positiven Balken vorhanden, die Negativen bekommen den gesammten Raum
                      $px_neg = $height;
                      $px_pos = 0;
                  }
              }
          }

          if ($hfcg->{$i}{diff} >= 0) {                                                                         # Zone 2 & 3 mit ihren direkten Werten vorbesetzen
              $z2 = $hfcg->{$i}{diff};
              $z3 = abs ($minDif);
          }
          else {
              $z2 = $maxDif;
              $z3 = abs ($hfcg->{$i}{diff});                                                                    # Nur Betrag ohne Vorzeichen
          }

          $titz2 = qq/title="$hfcg->{0}{beam1txt}"/;
          $titz3 = qq/title="$hfcg->{0}{beam2txt}"/;
                                                                                                                # Alle vorbesetzen Werte umrechnen auf echte Ausgabe px
          $z1 = (!$px_pos || !$maxDif) ? 0 : int(($maxDif-$z2) / $maxDif * $px_pos);                            # Teilung durch 0 vermeiden
          $z2 = ($px_pos - $z1) ;

          $z4 = (!$px_neg || !$minDif) ? 0 : int((abs($minDif)-$z3) / abs($minDif) * $px_neg);                  # Teilung durch 0 unbedingt vermeiden
          $z3 = ($px_neg - $z4);
                                                                                                                # Beiden Zonen die Werte ausgeben könnten muß spacesz als zusätzlicher Raum zugeschlagen werden !
          $z1 += $spacesz;
          $z4 += $spacesz if($z3);                                                                              # komplette Grafik ohne negativ Balken, keine Ausgabe von z3 & z4
      }

      ## Erstellung der Balken
      ##########################
      # das style des nächsten TD bestimmt ganz wesentlich das gesammte Design
      # das \n erleichtert das lesen des Seitenquelltext beim debugging
      # vertical-align:bottom damit alle Balken und Ausgaben wirklich auf der gleichen Grundlinie sitzen

      $ret .="<td style='text-align: center; padding-left:1px; padding-right:1px; margin:0px; vertical-align:bottom; padding-top:0px'>\n";

      $z1 /= 10;                                                                                                    # freier der Raum über den Balken
      $z1  = $z1 < 20 ? 20 : $z1;

      if ($lotype eq 'single') {
          $val = normBeamWidth ($paref, 'beam1', $i, 'beam1');

          $ret .="<table width='100%' height='100%'>";                                                              # mit width=100% etwas bessere Füllung der Balken
          $ret .="<tr class='$htr{$m}{cl}' style='height:".$z1."px'>";
          $ret .="<td class='solarfc' style='vertical-align:bottom; color:#$fcolor1;' $titz3>".$val;
          $ret .="</td></tr>";

          if ($hfcg->{$i}{beam1} || $show_night) {                                                                  # Balken nur einfärben wenn der User via Attr eine Farbe vorgibt, sonst bestimmt class odd von TR alleine die Farbe
              my $style = "style=\"padding-bottom:0px; vertical-align:top; margin-left:auto; margin-right:auto;";
              $style   .= defined $colorb1 ? " background-color:#$colorb1\"" : '"';                                 # Syntaxhilight

              $ret .= "<tr class='odd' style='height:".$z3."px;'>";
              $ret .= "<td align='center' class='solarfc' $style $titz3>";

              # inject the new icon if defined
              ##################################
              #$ret .= consinject($hash,$i,@consumers) if($s);

              $ret .= "</td></tr>";
          }
      }

      if ($lotype eq 'double') {
          my ($color1, $color2, $style1, $style2, $v);

          my $style = "style='padding-bottom:0px; padding-top:1px; vertical-align:top; margin-left:auto; margin-right:auto;";

          $ret .="<table width='100%' height='100%'>\n";                                                             # mit width=100% etwas bessere Füllung der Balken
          $ret .="<tr class='$htr{$m}{cl}' style='height:".$z1."px'><td class='solarfc'></td></tr>";                 # Freiraum über den Balken einfügen

          if ($hfcg->{$i}{beam1} > $hfcg->{$i}{beam2} || $scm eq 'staple') {                                         # wer ist oben, Beam2 oder Beam1 ? Wert und Farbe für Zone 2 & 3 vorbesetzen
              $val    = normBeamWidth ($paref, 'beam1', $i, 'beam1');
              $color1 = $colorb1;
              $style1 = $style." background-color:#$color1; color:#$fcolor1;'";

              if ($z3) {                                                                                             # die Zuweisung können wir uns sparen wenn Zone 3 nachher eh nicht ausgegeben wird
                  $v      = normBeamWidth ($paref, 'beam2', $i, 'beam2');
                  $color2 = $colorb2;
                  $style2 = $style." background-color:#$color2; color:#$fcolor2;'";
              }
          }
          else {
              $val    = normBeamWidth ($paref, 'beam2', $i, 'beam2');
              $color1 = $colorb2;
              $style1 = $style." background-color:#$color1; color:#$fcolor2;'";

              if ($z3) {
                  $v      = normBeamWidth ($paref, 'beam1', $i, 'beam1');
                  $color2 = $colorb1;
                  $style2 = $style." background-color:#$color2; color:#$fcolor1;'";
              }
          }

          $ret .= "<tr class='odd' style='height:".$z2."px'>";
          $ret .= "<td align='center' class='solarfc' $style1 $titz2>".$val;

          # inject the new icon if defined
          ##################################
          #$ret .= consinject($hash,$i,@consumers) if($s);

          $ret .= "</td></tr>";

          if ($z3) {                                                                                             # die Zone 3 lassen wir bei zu kleinen Werten auch ganz weg
              $ret .= "<tr class='odd' style='height:".$z3."px'>";
              $ret .= "<td align='center' class='solarfc' $style2 $titz3>".$v;
              $ret .= "</td></tr>";
          }
      }

      if ($lotype eq 'diff') {                                                                                  # Type diff
          my $style = "style='padding-bottom:0px; padding-top:1px; vertical-align:top; margin-left:auto; margin-right:auto;";
          $ret     .= "<table width='100%' border='0'>\n";                                                      # Tipp : das nachfolgende border=0 auf 1 setzen hilft sehr Ausgabefehler zu endecken

          $val = ($hfcg->{$i}{diff} > 0) ? normBeamWidth ($paref, 'diff', $i, 'beam1') : '';
          $val = '&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;' if($hfcg->{$i}{diff} == 0);                                  # Sonderfall , hier wird die 0 gebraucht !

          if ($val) {
              $ret .= "<tr class='$htr{$m}{cl}' style='height:".$z1."px'>";
              $ret .= "<td class='solarfc' style='vertical-align:bottom; color:#$fcolor1;'>".$val;
              $ret .= "</td></tr>";
          }

          if ($hfcg->{$i}{diff} >= 0) {                                                                          # mit Farbe 1 colorb1 füllen
              $style .= " background-color:#$colorb1'";
              $z2     = 1 if ($hfcg->{$i}{diff} == 0);                                                           # Sonderfall , 1px dünnen Strich ausgeben
              $ret   .= "<tr class='odd' style='height:".$z2."px'>";
              $ret   .= "<td align='center' class='solarfc' $style $titz2>";
              $ret   .= "</td></tr>";
          }
          else {                                                                                                 # ohne Farbe
              $z2 = 2 if($hfcg->{$i}{diff} == 0);                                                                # Sonderfall, hier wird die 0 gebraucht !
              if ($z2 && $val) {                                                                                 # z2 weglassen wenn nicht unbedigt nötig bzw. wenn zuvor he mit val keinen Wert hatte
                  $ret .= "<tr class='$htr{$m}{cl}' style='height:".$z2."px'>";
                  $ret .= "<td class='solarfc'>";
                  $ret .= "</td></tr>";
              }
          }

          if ($hfcg->{$i}{diff} < 0) {                                                                                                   # Negativ Balken anzeigen ?
              $style .= " background-color:#$colorb2'";                                                                                  # mit Farbe 2 colorb2 füllen
              $ret   .= "<tr class='odd' style='height:".$z3."px'>";
              $ret   .= "<td align='center' class='solarfc' $style $titz3>";
              $ret   .= "</td></tr>";
          }
          elsif ($z3) {                                                                                                                  # ohne Farbe
              $ret .= "<tr class='$htr{$m}{cl}' style='height:".$z3."px'>";
              $ret .= "<td class='solarfc'>";
              $ret .= "</td></tr>";
          }

          if ($z4) {                                                                                                                     # kann entfallen wenn auch z3 0 ist
              $val  = $hfcg->{$i}{diff} < 0 ? normBeamWidth ($paref, 'diff', $i, 'beam1') : '&nbsp;';
              $ret .= "<tr class='$htr{$m}{cl}' style='height:".$z4."px'>";
              $ret .= "<td class='solarfc' style='vertical-align:top'>".$val;
              $ret .= "</td></tr>";
          }
      }

      if ($showdiff eq 'bottom') {                                                                                                      # zusätzliche diff Anzeige
          $val  = normBeamWidth ($paref, 'diff', $i, 'beam1');

          if ($val ne '&nbsp;') {                                             # negative Zahlen in Fettschrift, 0 aber ohne +
              $val  = $hfcg->{$i}{diff} < 0 ? '<b>'.$val.'<b/>' :
                      $val > 0              ? '+'.$val          :
                      $val;
          }

          $ret .= "<tr class='$htr{$m}{cl}'><td class='solarfc' style='vertical-align:middle; text-align:center;'>$val";
          $ret .= "</td></tr>";
      }

      ## die Zeitleiste
      ###################
      $ret .= "<tr class='$htr{$m}{cl}'><td class='solarfc' style='vertical-align:bottom; text-align:center;'>";
      $ret .= $hfcg->{$i}{time} == $thishour ?                                                                                           # wenn Hervorhebung nur bei gesetztem Attr 'graphicHistoryHour' ? dann hinzufügen: "&& $offset < 0"
                                   '<a class="changed" style="visibility:visible"><span>'.$hfcg->{$i}{time_str}.'</span></a>' :
                                   $hfcg->{$i}{time_str};

      if ($hfcg->{$i}{time} == $thishour) {
          $thishour = 99;                                                                                                                # nur einmal verwenden !
      }

      $ret .="</td></tr></table></td>";
  }

  $ret .= "<td class='solarfc'></td>";
  $ret .= "</tr>";

  $paref->{beampos} = 'bottom';                                                                                                          # Lagedefinition "unter den Balken"

  ## Batterieanzeige unterhalb der Balken
  #########################################
  $ret .= __batteryOnBeam ($paref);

  delete $paref->{beampos};

  ## zusätzlicher Abstand nach der letzten Reihe
  ################################################
  my $pb = CurrentVal ($name, 'beamPaddingBottom', 0);

  if ($pb) {
      $ret .= "<tr class='$htr{$m}{cl}'>";
      $ret .= "<td colspan='$colspan' align='center' style='padding-left: 10px; padding-top: 0px; padding-bottom: ${pb}px;'>";
      $ret .= "</td>";
      $ret .= "</tr>";
  }

return $ret;
}

############################################################################################
#  liefert Signal ob Werte angezeigt werden sollen obwohl
#  die Nachtstunden nicht angezeigt werden sowie die
#  bei Synchronisation der nachfolgenden Balkendiagramm-Ebenen
#  mit Balkendiagramm-Ebene 1
#
#  skip          = 0 - Wert soll angezeigt werden
#  skip          = 1 - Wert soll nicht angezeigt werden
#  paref->skip   = 1 - Synchronisation Anzeige des Balkens in nächsten Ebenen verhindern
#  paref->noSkip = 1 - Synchronisation Anzeige des Balkens in nächsten Ebenen erzwingen
#
############################################################################################
sub __dontNightshowSkipSync {
  my $name  = shift;
  my $paref = shift;
  my $i     = shift;

  my $skip = 0;

  if ($paref->{skip}{$i} && !$paref->{noSkip}{$i}) {
     $skip = 1 if($paref->{layersync});                                           # Anwendung bei Zeitsynchronisation zwischen Ebene 1 und den folgenden Balkengrafikebenen
  }
  elsif (!$paref->{show_night}      && !$paref->{hfcg}{$i}{don} &&
         !$paref->{hfcg}{$i}{beam1} && !$paref->{hfcg}{beam2}   &&
         !$paref->{noSkip}{$i}) {

      $paref->{skip}{$i} = 1 if($paref->{layersync});                             # Anwendung bei Zeitsynchronisation zwischen Ebene 1 und den folgenden Balkengrafikebenen
      $skip              = 1;
  }
  else {
      $paref->{noSkip}{$i} = 1 if($paref->{layersync});                           # Anwendung bei Zeitsynchronisation zwischen Ebene 1 und den folgenden Balkengrafikebenen
  }

return $skip;
}

################################################################
# Liefert eine linear oder logarithmisch normalisierte 
# Balkenhöhe in px.
# Das Ergebnis wird um die Mindesthöhe $ground angehoben, d.h.
# der Balken wird nicht niedriger als $ground
################################################################
sub __normBeamHeight {                                                    
  my $paref     = shift;
  my $val       = $paref->{val}       // 0;
  my $maxVal    = $paref->{maxVal};
  my $height    = $paref->{height};
  my $ground    = $paref->{ground}    // 0;             # eine minimale Balkenhöhe die immer eingehalten werden soll
  my $scalemode = $paref->{scalemode} // 'lin';         # lin / log / staple
  
  my $px = 0;
  
  if ($scalemode eq 'lin') {
      $px = $ground + (($val / $maxVal) * ($height - $ground));
  }
  elsif ($scalemode eq 'staple') {
      $px = $ground + (($val / $maxVal) * ($height - $ground));
  }
  elsif ($scalemode eq 'log' && $val * 1 > 0) {                               # logarithmische Anzeige wenn Mode log, kein Logarithmus für negative Zahlen
      $px = $ground + ((log ($val) / log ($maxVal)) * ($height - $ground));
  }

return int ($px);
}

################################################################
#                   Wetter Icon Zeile
################################################################
sub __weatherOnBeam {
  my $paref      = shift;
  my $name       = $paref->{name};
  my $hfcg       = $paref->{hfcg};
  my $maxhours   = $paref->{maxhours};
  my $show_night = $paref->{show_night};                     # alle Balken (Spalten) anzeigen ?
  my $colorw     = $paref->{colorw};                         # Wetter Icon Farbe
  my $colorwn    = $paref->{colorwn};                        # Wetter Icon Farbe Nacht
  my $width      = $paref->{width};
  my $lang       = $paref->{lang};
  my $barcount   = $paref->{barcount} // 9999;               # Sync Anzahl Balken dieser Ebene mit voriger Ebene

  my $m   = $paref->{modulo} % 2;
  my $ret = q{};
  $ret    .= "<tr class='$htr{$m}{cl}'><td class='solarfc'></td>";                                           # freier Platz am Anfang

  my $ii  = 0;

  for my $i (0..($maxhours * 2) - 1) {
      last if (!defined ($hfcg->{$i}{weather}));

      $hfcg->{$i}{weather} = 999 if(!defined $hfcg->{$i}{weather});
      my $wcc              = $hfcg->{$i}{wcc} // '-';                                                        # Bewölkungsgrad ergänzen

      debugLog ($paref, 'graphic', "weather id beam number >$i< (start hour $hfcg->{$i}{time_str}): wid $hfcg->{$i}{weather} / wcc $wcc") if($ii < $maxhours);

      my $skip = __dontNightshowSkipSync ($name, $paref, $i);

      if ($skip) {
          debugLog ($paref, 'graphic', "Weather position >$i< is skipped due to don't show night condition") if($ii < $maxhours);
          next;
      }

      $ii++;                                                                                                 # wieviele Stunden Icons haben sind beechnet?
      last if($ii > $maxhours || $ii > $barcount);
                                                                                                             # ToDo : sollte im Fehlerfall Title mit der ID besetzen um in FHEMWEB sofort die ID sehen zu können
      my ($icon_name, $title) = weather2icon ($name, $lang, $hfcg->{$i}{weather});

      $wcc   += 0 if(isNumeric ($wcc));                                                                      # Javascript Fehler vermeiden: https://forum.fhem.de/index.php/topic,117864.msg1233661.html#msg1233661
      $title .= ': '.$wcc;
      $title .= '&#10;';
      $title .= $htitles{sunpos}{$lang}.':';
      $title .= '&#10;';
      $title .= $htitles{elevatio}{$lang}.' '.$hfcg->{$i}{sunalt};
      $title .= '&#10;';
      $title .= $htitles{azimuth}{$lang}.' '.$hfcg->{$i}{sunaz};

      if ($icon_name eq 'unknown') {
          debugLog ($paref, "graphic", "unknown weather id: ".$hfcg->{$i}{weather}.", please inform the maintainer");
      }

      $icon_name .= $hfcg->{$i}{don} ? '@'.$colorw : '@'.$colorwn;
      my $val     = FW_makeImage ($icon_name) // q{};

      if ($val =~ /title="$icon_name"/xs) {                                                                  # passendes Icon beim User nicht vorhanden ! ( attr web iconPath falsch/prüfen/update ? )
          $val = '<b>???<b/>';
          debugLog ($paref, "graphic", qq{ERROR - the icon "$weather_ids{$hfcg->{$i}{weather}}{icon}.svg" not found. Please check attribute "iconPath" of your FHEMWEB instance and/or update your FHEM software});
      }

      $ret .= "<td title='$title' class='solarfc' width='$width' style='margin:1px; vertical-align:middle align:center; padding-bottom:1px;'>$val</td>";
  }

  $ret .= "<td class='solarfc'></td></tr>";                                                                  # freier Platz am Ende der Icon Zeile

return $ret;
}

################################################################
#         Batterieanzeige in Balkengrafik
# vorbereitete Werte (_beamFillupBatValues) in Anzeige einfügen
################################################################
sub __batteryOnBeam {
  my $paref    = shift;
  my $name     = $paref->{name};
  my $maxhours = $paref->{maxhours};
  my $width    = $paref->{width};
  my $lang     = $paref->{lang};
  my $hfcg     = $paref->{hfcg};
  my $t        = $paref->{t};
  my $barcount = $paref->{barcount} // 9999;                                                          # Sync Anzahl Balken dieser Ebene mit voriger Ebene

  my $m     = $paref->{modulo} % 2;
  my $day   = strftime "%d", localtime($t);                                                           # aktueller Tag (range 01 .. 31)
  my $chour = strftime "%H", localtime($t);                                                           # aktuelle Stunde in 24h format (00-23)
  my $ret   = q{};

  for my $bn (1..MAXBATTERIES) {                                                                      # für jede definierte Batterie
      $bn = sprintf "%02d", $bn;
      my ($err, $badev, $h) = isDeviceValid ( { name => $name, obj => 'setupBatteryDev'.$bn, method => 'attr' } );
      next if($err);

      my $bshow = BatteryVal ($name, $bn, 'bshowingraph',     0);
      my $bpos  = BatteryVal ($name, $bn, 'bposingraph', 'totp');
      next if($bshow != $paref->{chartlvl} || $bpos ne $paref->{beampos});                            # Anzeige nur auf Grafikebene "chartlvl" bzw. oberhalb/unterhalb der Balken

      $ret  .= "<tr class='$htr{$m}{cl}'><td class='solarfc'></td>";                                  # freier Platz am Anfang
      my $ii = 0;

      for my $i (0..($maxhours * 2) - 1) {
          my $skip = __dontNightshowSkipSync ($name, $paref, $i);

          if ($skip) {
              debugLog ($paref, 'graphic', "Battery $bn recommandation pos >$i< skipped due to don't show night condition") if($ii < $maxhours);
              next;
          }

          $ii++;                                                                                      # wieviele Stunden Icons sind bisher beechnet?
          last if($ii > $maxhours || $ii > $barcount);

          my $bname     = BatteryVal ($name, $bn, 'bname',      '');
          my $balias    = BatteryVal ($name, $bn, 'balias', $bname);
          my $bpowerin  = BatteryVal ($name, $bn, 'bpowerin',    0);
          my $bpowerout = BatteryVal ($name, $bn, 'bpowerout',   0);
          my $blabel    = BatteryVal ($name, $bn, 'blabel', 'none');

          my $day_str   = $hfcg->{$i}{day_str};
          my $time_str  = $hfcg->{$i}{time_str};
          $time_str     = (split ":", $time_str)[0];                                                  # Forum: https://forum.fhem.de/index.php?msg=1332721
          my $soc       = $hfcg->{$i}{'soc'.$bn};
          my $lcintime  = $hfcg->{$i}{'lcintimebat'.$bn};                                             # Lademanagement für Batterie XX ist aktiviert
          my $strategy  = $hfcg->{$i}{'strategybat'.$bn} // '-';                                      # Ladestrategie 
          
          my $stysymbol = $strategy eq 'loadRelease' ? 'ldreleas' : 
                          $strategy eq 'optPower'    ? 'optchpow' :
						  $strategy eq 'smartPower'  ? 'smtchpow' :
                          'norate';
          
          my ($bpower, $currsoc);

          if ($day_str eq $day && $time_str eq $chour) {                                              # akt. Leistung nur für aktuelle Stunde
              $bpower  = $bpowerin  ? $bpowerin      :
                         $bpowerout ? 0 - $bpowerout :                                                # __substituteIcon: bpowerout als NEGATIVEN Wert übergeben!
                         0;

              $currsoc = BatteryVal ($name, $bn, 'bcharge', 0);
          }

          my ($bicon, $title) = __substituteIcon ( { name  => $name,                                  # Icon / Status des Batterie Devices
                                                     pn    => $bn,
                                                     ptyp  => 'battery',
                                                     flag  => $hfcg->{$i}{'rcdchargebat'.$bn},
                                                     msg1  => $balias,
                                                     msg2  => $lcintime,
                                                     msg3  => $htitles{$stysymbol}{$lang},
                                                     soc   => $soc,
                                                     pcurr => $bpower,
                                                     lang  => $lang
                                                   }
                                                 );

          $title   .= defined $currsoc ? "\n".$htitles{socbacur}{$lang}.": ".$currsoc." %" : '';
          my $image = defined $hfcg->{$i}{'rcdchargebat'.$bn} ? FW_makeImage ($bicon) : '';
          
          if ($image && $blabel ne 'none') {              
              if ($blabel eq 'below') {
                  $image  = '<div class="batcontainer_below">'.$image;
                  $image .= '<div class="batsoc_below">'.sprintf ("%.0f", $soc);
              }
              elsif ($blabel eq 'beside') {
                  $image  = '<div class="batcontainer_beside">'.$image;
                  $image .= '<div class="batsoc_beside">'.sprintf ("%.0f", $soc);                  
              }
              
              $image .= '</div></div>';
          }

          $ret .= "<td title='$title' class='solarfc' width='$width' style='margin:1px; vertical-align:middle align:center; padding-bottom:1px;'>$image</td>";

          debugLog ($paref, 'graphic', "Battery $bn pos >$i< day: $day_str, time: $time_str, Power ('-' = out): ".(defined $bpower ? $bpower : 'undef').
                                       " W, Rcmd: ".(defined $hfcg->{$i}{'rcdchargebat'.$bn} ? $hfcg->{$i}{'rcdchargebat'.$bn} : 'undef').
                                       ", SoC: ".(defined $soc ? $soc : 'undef')." %, lcintime: ".(defined $lcintime ? $lcintime : 'undef'));   
      }

      $ret .= "<td class='solarfc'></td></tr>" if($ret);                                                  # freier Platz am Ende der Icon Zeile
  }

return $ret;
}

######################################################################################
#                  Energieflußgrafik
# M - MoveTo setzt den aktuellen Punkt fest, von dem aus der Pfad starten soll
#     (https://wiki.selfhtml.org/wiki/SVG/Tutorials/Pfade#MoveTo)
# L - LineTo zeichnet eine Linie vom aktuellen zum angegebenen Punkt
#     (https://wiki.selfhtml.org/wiki/SVG/Tutorials/Pfade#LineTo)
######################################################################################
sub _flowGraphic {
  my $paref          = shift;
  my $hash           = $paref->{hash};
  my $name           = $paref->{name};
  my $type           = $paref->{type};
  my $flowgsize      = $paref->{flowgsize};
  my $flowgani       = $paref->{flowgani};
  my $flowgxshift    = $paref->{flowgxshift};                                  # X-Verschiebung der Flußgrafikbox (muß negiert werden)
  my $flowgyshift    = $paref->{flowgyshift};                                  # Y-Verschiebung der Flußgrafikbox (muß negiert werden)
  my $flowgconsumer  = $paref->{flowgconsumer};                                # Verbraucher in der Energieflußgrafik anzeigen
  my $flowgconsTime  = $paref->{flowgconsTime};                                # Verbraucher Restlaufzeit in der Energieflußgrafik anzeigen
  my $flowgconX      = $paref->{flowgconX};
  my $flowgconsPower = $paref->{flowgconsPower};
  my $cdist          = $paref->{flowgconsDist};                                # Abstand Consumer zueinander
  my $exth2cdist     = $paref->{flowgh2cDist};                                 # vertikaler Abstand Home -> Consumer Zeile
  my $lang           = $paref->{lang};

  my $gconMetered      = CurrentVal ($name, 'gridconsumption',  0);
  my $node2gridMetered = CurrentVal ($name, 'gridfeedin',       0);            # vom Inverter-Knoten zum Grid
  my $cselfMetered     = CurrentVal ($name, 'selfconsumption',  0);
  my $showgenerators   = CurrentVal ($name, 'showGenerators',   0);            # Generatoren-Zeile anzeigen

  my $stna   = $name;
  $stna     .= int (rand (1500));

  my ($y_pos, $y_pos1, $y_pos2, $err);

  for my $re (keys %hrepl) {                                                   # V 1.37.1 Ziffern etc. eliminieren, Forum: https://forum.fhem.de/index.php?msg=1323229
      $stna =~ s/$re/$hrepl{$re}/gxs;
  }

  ## definierte Batterien ermitteln und zusammenfassen
  ######################################################
  my $hasbat = 1;                                                                       # initial Batterie vorhanden
  my ($batin, $batout);

  for my $bn (1..MAXBATTERIES) {                                                        # für jede definierte Batterie
      $bn    = sprintf "%02d", $bn;
      ($err) = isDeviceValid ( { name => $name, obj => 'setupBatteryDev'.$bn, method => 'attr' } );
      next if($err);

      my $batinpow  = BatteryVal ($name, $bn, 'bpowerin', undef);
      my $batoutpow = BatteryVal ($name, $bn, 'bpowerout', undef);
      $batin       += $batinpow  if(defined $batinpow);
      $batout      += $batoutpow if(defined $batoutpow);
  }

  my $soc = __normDecPlaces (CurrentVal ($name, 'batsoctotal', 0));                     # resultierender SoC (%) aller Batterien als Cluster

  if (!defined $batin && !defined $batout) {
      $hasbat = 0;
      $batin  = 0;
      $batout = 0;
      $soc    = 0;
  }

  debugLog ($paref, 'graphic', "Battery initial summary - batin: $batin, batout: $batout");

  ## definierte Producer + Inverter ermitteln und zusammenfassen
  ################################################################
  my $pdcr        = {};                                                        # Hashref Producer
  my $ppall       = 0;                                                         # Summe Erzeugung alle nicht PV-Producer
  my $pv2node     = 0;                                                         # Summe PV-Erzeugung alle Inverter
  my $pv2grid     = 0;
  my $pv2bat      = 0;
  my $dc2inv2node = 0;                                                         # Batteriewechselrichter DC -> Inverterknoten
  my $node2inv2dc = 0;                                                         # Batteriewechselrichter Inverterknoten -> DC
  my $lfn         = 0;

  for my $pn (1..MAXPRODUCER) {
      $pn    = sprintf "%02d", $pn;
      ($err) = isDeviceValid ( { name => $name, obj => 'setupOtherProducer'.$pn, method => 'attr' } );
      next if($err);

      my $pgen = ProducerVal ($name, $pn, 'pgeneration',        0);
      my $feed = ProducerVal ($name, $pn, 'pfeed',      'default');

      $pgen                    = __normDecPlaces ($pgen);
      $pdcr->{$lfn}{pgen}      = $pgen;                                        # aktuelle Erzeugung nicht PV-Producer
      $pdcr->{$lfn}{pn}        = $pn;                                          # Producernummer
      $pdcr->{$lfn}{feed}      = $feed;                                        # Eigenschaft der Energielieferung
      $pdcr->{$lfn}{pdc2ac}    = 0;                                            # zur Zeit nicht ausgewertet!
      $pdcr->{$lfn}{pac2dc}    = 0;                                            # immer '0' -> keine Rückwandlung
      $pdcr->{$lfn}{source}    = 'other';                                      # Art der Energiequelle
      $pdcr->{$lfn}{generator} = 'none';                                       # Angaben zum Generator
      $pdcr->{$lfn}{ptyp}      = 'producer';                                   # Typ des Producers
      $pdcr->{$lfn}{psubtyp}   = 'none';                                       # Subtyp des Producers
      $ppall                  += $pgen;                                        # aktuelle Erzeuguung aller nicht PV-Producer

      $lfn++;
  }

  for my $in (1..MAXINVERTER) {
      $in    = sprintf "%02d", $in;
      ($err) = isDeviceValid ( { name => $name, obj => 'setupInverterDev'.$in, method => 'attr' } );
      next if($err);

      my $pvin     = __normDecPlaces (InverterVal ($name, $in, 'ipvin',   0));                    # DC PV-Eingangsleistung (Summe aller zugeordnete Strings)
      my $pvout    = __normDecPlaces (InverterVal ($name, $in, 'ipvout',  0));                    # Erzeugung aus PV
      my $pdc2ac   = __normDecPlaces (InverterVal ($name, $in, 'ipdc2ac', 0));                    # Wandlung DC->AC (Batterie-Wechselrichter)
      my $pac2dc   = __normDecPlaces (InverterVal ($name, $in, 'ipac2dc', 0));                    # Rückwandlung AC->DC (Batterie-Wechselrichter)
      my $ifeed    = InverterVal ($name, $in, 'ifeed',   'default');
      my $isource  = InverterVal ($name, $in, 'isource',      'pv');

      $pdcr->{$lfn}{pn}        = $in;                                                                           # Inverternummer
      $pdcr->{$lfn}{feed}      = $ifeed;                                                                        # Eigenschaft der Energielieferung
      $pdcr->{$lfn}{source}    = $isource;                                                                      # Art der Energiequelle
      $pdcr->{$lfn}{generator} = InverterVal ($name, $in, 'istrings', 'none');                                  # Angaben zum Generator (Namen der Strings)
      $pdcr->{$lfn}{ptyp}      = 'inverter';                                                                    # Typ des Producers
      $pdcr->{$lfn}{psubtyp}   = InverterVal ($name, $in, 'itype', '');                                         # SubTyp des Inverters
      $pdcr->{$lfn}{pvin}      = $pvin;                                                                         # aktuelle DC PV-Erzeugungsleistung
      $pdcr->{$lfn}{pgen}      = $pvout;                                                                        # aktuelleLeistung aus PV-Erzeugung
      $pdcr->{$lfn}{pdc2ac}    = $pdc2ac;                                                                       # aktuelle Leistung DC->AC
      $pdcr->{$lfn}{pac2dc}    = $pac2dc;                                                                       # aktuelle Leistung AC->DC
      $pv2node                += $pvout  if($ifeed eq 'default' && $isource eq 'pv');                           # PV-Erzeugung Inverter für das Hausnetz
      $pv2grid                += $pvout  if($ifeed eq 'grid'    && $isource eq 'pv');                           # PV nur für das öffentliche Netz
      $pv2bat                 += $pvout  if($ifeed eq 'bat'     && $isource eq 'pv');                           # Direktladen PV nur in die Batterie
      $dc2inv2node            += $pdc2ac if($ifeed eq 'hybrid' || ($ifeed eq 'default' && $isource eq 'bat'));  # DC->AC / Speisung Inverter aus Batterie / Solar-Ladegerät statt PV
      $node2inv2dc            += $pac2dc if($ifeed eq 'hybrid' || ($ifeed eq 'default' && $isource eq 'bat'));  # AC->DC (Batterie- oder Hybrid-Wechselrichter)

      $lfn++;
  }

  ## Knoten <-> Batterie Resultierende und Laufketten Richtungen
  ################################################################
  my $x   = $batin - $batout;          # Resultierende von Laden und Entladen berechnen, können theoretisch gleich groß sein -> 0 setzen und Resultierende neu berechnen
  $batin  = 0;
  $batout = 0;

  if ($x > 0) {$batin = $x; $batout = 0;} elsif ($x < 0) {$batout = abs $x; $batin = 0;}                      # es darf nur $batin ODER $batout mit einem Wert > 0 geben

  debugLog ($paref, 'graphic', "Battery Node summary after calculating resultant - batin: $batin, batout: $batout");

  my $bat_color = $soc < 26 ? "$stna bat25" :
                  $soc < 76 ? "$stna bat50" :
                  "$stna bat75";

  my $grid2home_style       = $gconMetered ? "$stna active_sig"    : "$stna inactive";    # GridConsumption
  my $bat2home_style        = "$stna inactive";
  my $dc2inv2node_style     = $dc2inv2node ? "$stna active_normal" : "$stna inactive";    # Batterie zu Inverter mit source=bat
  my $gconMetered_direction = "M250,515 L670,590";
  my $bat2home_direction    = "M1200,515 L730,590";

  ## Knotensummen Erzeuger - Batterie - Home ermitteln -> Hausverbrauch ermitteln
  #################################################################################
  my $vector = __calcVectorConsumption ( { name        => $name,
                                           batout      => $batout,
                                           batin       => $batin,
                                           pv2bat      => $pv2bat,
                                           pv2node     => $pv2node,
                                           dc2inv2node => $dc2inv2node,
                                           node2inv2dc => $node2inv2dc,
                                           ppall       => $ppall,
                                           gfeedin     => $node2gridMetered,
                                           gcon        => $gconMetered
                                         }
                                       );

  my $consptn   = $vector->{vectorconsumption};                                           # Hausverbrauch auf Grundlage der Leistungsflüsse
  my $bat2home  = $vector->{bat2home};                                                    # Batterie -> Hausknoten
  my $pnodesum  = $vector->{pnodesum};                                                    # Summe Inverterknoten
  my $node2home = $vector->{node2home};                                                   # Inverterknoten -> Haus
  my $node2bat  = $vector->{node2bat};                                                    # Inverterknoten -> Batterie

  if ($vector->{batDischarge2HomeNode}) {
      $bat2home_style     = "$stna active_normal";
      $bat2home_direction = "M1200,515 L730,590";  
  }


  ## definierte Verbraucher ermitteln
  #####################################
  my $cnsmr      = {};                                                                    # Consumer Hilfshash Referenz
  my $concurpsum = 0;                                                                     # Summierung aller Consumerverbräuche
  
  for my $c (sort{$a<=>$b} keys %{$data{$name}{consumers}}) {                             # definierte Verbraucher ermitteln
      next if(isConsumerNoshow ($hash, $c) =~ /[13]/xs);                                  # auszublendende Consumer nicht berücksichtigen
      $cnsmr->{$c}{p}          = ConsumerVal ($name, $c, 'currpower',   0);
      $cnsmr->{$c}{shortalias} = ConsumerVal ($name, $c, 'aliasshort', '');               # Consumer Kurzalias
      $cnsmr->{$c}{ptyp}       = 'consumer';
      $concurpsum             += $cnsmr->{$c}{p};
  }

  my $consumercount = keys %{$cnsmr};
  $flowgconsumer    = 0 if(!$consumercount);                                              # Consumer Anzeige ausschalten wenn keine Consumer definiert
  my @consumers     = sort{$a<=>$b} keys %{$cnsmr};
  
  my $total_shortalias_length = sum  map { my $a = $_->{shortalias} // '';
                                           strlength ($a);                                 # Länge in Zeichen nach Zeichen-Dekodierung
                                         }
                                         values %{$cnsmr};
                        
  ## Verbrauch Dummy bestimmen
  ##############################
  my $cons_dmy = $consptn - $concurpsum;                                                  

  ## Producer / Inverter Koordinaten Steuerhash
  ###############################################
  my $pdist = 130;                                                                         # Abstand Producer zueinander
  my ($togrid, $tonode, $tobat, $toinv) = __sortProducer ($pdcr);                          # lfn Producer sortiert nach ptyp und feed ($toinv aktuell unbenutzt)

  my $psorted = {                                                                          # Gruppen zusammenstellen
      '1togrid' => { xicon => -100, xchain => 150,  ychain => 400, step => 30,     count => scalar @{$togrid}, sorted => $togrid },      # Producer/PV nur zu Grid
      '2tonode' => { xicon =>  350, xchain => 700,  ychain => 200, step => $pdist, count => scalar @{$tonode}, sorted => $tonode },      # Producer/PV zum Knoten
      '3tobat'  => { xicon =>  750, xchain => 1370, ychain => 430, step => 30,     count => scalar @{$tobat},  sorted => $tobat  },      # Producer/PV nur zu Batterie
  };

  ## SVG Box initialisieren mit Grid-Icon
  #########################################
  my $showproducers  = 1;
  my $flowgPrdsPower = 1;                                                                  # initial Producer akt. Erzeugung anzeigen

  $showproducers    = 0 if(!$hasbat && $psorted->{'2tonode'}{count} == 1);
  my $vbwidth       = 800;                                                                 # width and height specify the viewBox size

  my $vbminx        = -10 * $flowgxshift;                                                  # min-x and min-y represent the smallest X and Y coordinates that the viewBox may have

  my $vbminy        = 125;
  $vbminy          -= 150 if($showproducers);                                              # mehr Platz oben schaffen wenn Poducerreihe angezeigt
  $vbminy          -= INPUTROWSHIFT if($showgenerators);                                   # mehr Platz oben schaffen wenn Zellen/Input-Reihe angezeigt

  my $vbhight       = 630;
  $vbhight         -= 20  if(!$flowgconsTime);
  $vbhight         -= 20  if(!$total_shortalias_length);
  $vbhight         -= 230 if(!$flowgconsumer);

  $vbhight         += PRDCRROWSHIFT if($showproducers);                                    # Höhe Box vergrößern wenn Poducerreihe angezeigt
  $vbhight         += INPUTROWSHIFT if($showgenerators);                                   # Höhe Box vergrößern wenn Zellen/Input-Reihe angezeigt

  $vbhight         += $exth2cdist;

  $vbminy          -= $flowgyshift;                                                        # Y-Verschiebung berücksichtigen
  $vbhight         += $flowgyshift;                                                        # Y-Verschiebung berücksichtigen

  my $vbox       = "$vbminx $vbminy $vbwidth $vbhight";
  my $svgstyle   = 'width:98%; height:'.$flowgsize.'px;';
  my $animation  = $flowgani ? '@keyframes dash { to { stroke-dashoffset: 0; } }' : '';    # Animation Ja/Nein

  my $grid_color = $node2gridMetered                                ? "$stna grid_green" :
                   !$node2gridMetered && !$gconMetered && $bat2home ? "$stna grid_gray"  :
                   "$stna grid_red";

  my $strokecolstd = CurrentVal ($name, 'strokecolstd',         STROKCOLSTDDEF);
  my $strokecolsig = CurrentVal ($name, 'strokecolsig',         STROKCOLSIGDEF);
  my $strokecolina = CurrentVal ($name, 'strokecolina',         STROKCOLINADEF);
  my $strokewidth  = CurrentVal ($name, 'strokewidth',           STROKWIDTHDEF);
  my $strokeredlim = CurrentVal ($name, 'strokeCmrRedColLimit', STROKCMRREDLIM);

  my $svg = {
      text          => "{ stroke: none; fill: gray; font-size: 60px; }",
      bat25         => "{ stroke: red; fill: red; }",
      bat50         => "{ stroke: darkorange; fill: darkorange; }",
      bat75         => "{ stroke: green; fill: green; }",
      grid_green    => "{ fill: green; }",
      grid_red      => "{ fill: red; }",
      grid_gray     => "{ fill: gray; }",
      inactive      => "{ stroke: $strokecolina; stroke-width: $strokewidth; stroke-dashoffset: 20; stroke-dasharray: 10; opacity: 0.2; }",
      active_sig    => "{ stroke: $strokecolsig; stroke-width: $strokewidth; stroke-dashoffset: 20; stroke-dasharray: 10; opacity: 0.8; animation: dash 0.5s linear; animation-iteration-count: infinite; }",
      active_normal => "{ stroke: $strokecolstd; stroke-width: $strokewidth; stroke-dashoffset: 20; stroke-dasharray: 10; opacity: 0.8; animation: dash 0.5s linear; animation-iteration-count: infinite; }",
  };

  my $ret = << "END0";
      <style>
      .$stna.text          $svg->{text}
      .$stna.bat25         $svg->{bat25}
      .$stna.bat50         $svg->{bat50}
      .$stna.bat75         $svg->{bat75}
      .$stna.grid_green    $svg->{grid_green}
      .$stna.grid_red      $svg->{grid_red}
      .$stna.grid_gray     $svg->{grid_gray}
      .$stna.inactive      $svg->{inactive}
      .$stna.active_sig    $svg->{active_sig}
      .$stna.active_normal $svg->{active_normal}

      $animation
      </style>

      <svg xmlns="http://www.w3.org/2000/svg" viewBox="$vbox" style="$svgstyle" id="SVGPLOT_$stna">

      <g id="grid_$stna" class="$grid_color" transform="translate(100,260),scale(3.0)">
          <path d="M15.3,2H8.7L2,6.46V10H4V8H8v2.79l-4,9V22H6V20.59l6-3.27,6,3.27V22h2V19.79l-4-9V8h4v2h2V6.46ZM14,4V6H10V4ZM6.3,6,8,4.87V6Zm8,6L15,13.42,12,15,9,13.42,9.65,12ZM7.11,17.71,8.2,15.25l1.71.93Zm8.68-2.46,1.09,2.46-2.8-1.53ZM14,10H10V8h4Zm2-5.13L17.7,6H16Z"/>
      </g>
END0

  ## Poduzentenreihe inklusive der Inputs (Solarzellen) sofern anzuzeigen
  ## - in Reihenfolge: zum Grid - zum Knoten - zur Batterie
  #########################################################################
  $paref->{stna}           = $stna;
  $paref->{pnodesum}       = $pnodesum;
  $paref->{psorted}        = $psorted;
  $paref->{pdcr}           = $pdcr;
  $paref->{pdist}          = $pdist;
  $paref->{showgenerators} = $showgenerators;

  if (!$showproducers) {
      $paref->{y_coord}  = 165;
      $ret .= __addInputProducerIcon ($paref);                      # Solarzellen/Input-Zeile und einzelnes Producer Icon wird an Stelle des Knotens eingefügt
  }
  else {                                                            # mehr als ein Producer vorhanden
      $paref->{y_coord}  = 0;
      $ret .= __addInputProducerIcon ($paref);                      # Solarzellen/Input-Zeile und Producer Icons row einfügen

      $paref->{x_coord} = 365;
      $paref->{y_coord} = 165;
      $ret .= __addNodeIcon ($paref);                               # Knoten Icon
  }

  delete $paref->{stna};
  delete $paref->{pnodesum};
  delete $paref->{psorted};
  delete $paref->{pdcr};
  delete $paref->{pdist};
  delete $paref->{x_coord};
  delete $paref->{y_coord};
  delete $paref->{showgenerators};

  ## Consumer Liste und Icons in Grafik anzeigen
  ################################################
  my $cons_left      = 0;
  my $consumer_start = 0;
  my $cnsmrpower     = 0;
  $y_pos             = 505 + $exth2cdist;

  if ($flowgconsumer) {
      $consumer_start = __groupXstart (350, $consumercount, $cdist);
      $cons_left      = $consumer_start + 15;

      for my $c (@consumers) {
          my $calias  = ConsumerVal ($name, $c, 'alias', '');                                              # Name des Consumerdevices
          $cnsmrpower = $cnsmr->{$c}{p};

          my ($cicon) = __substituteIcon ( { hash => $hash,                                                # Icon des Consumerdevices
                                             name => $name,
                                             pn    => $c,
                                             ptyp  => $cnsmr->{$c}{ptyp},
                                             pcurr => $cnsmrpower,
                                             lang  => $lang
                                           }
                                         );
          
		  my $ccicon = (split '@', $cicon)[1];
          $cicon     = FW_makeImage         ($cicon, ''); 
          $cicon     = __normIconInnerScale ($cicon, $ccicon);       
  
          $ret .= qq{<g id="consumer_${c}_$stna" transform="translate($cons_left $y_pos)">};
          $ret .= "<title>$calias</title>".$cicon;
          $ret .= '</g> ';

          $cons_left += $cdist;
      }
  }

  ## Batterie Icon
  ##################
  if ($hasbat) {
      $ret .= << "END1";
      <g class="$bat_color" transform="translate(750,245),scale(.30) rotate (90)">
      <path d="m 134.65625,89.15625 c -6.01649,0 -11,4.983509 -11,11 l 0,180 c 0,6.01649 4.98351,11 11,11 l 95.5,0 c 6.01631,0 11,-4.9825 11,-11 l 0,-180 c 0,-6.016491 -4.98351,-11 -11,-11 l -95.5,0 z m 0,10 95.5,0 c 0.60951,0 1,0.390491 1,1 l 0,180 c 0,0.6085 -0.39231,1 -1,1 l -95.5,0 c -0.60951,0 -1,-0.39049 -1,-1 l 0,-180 c 0,-0.609509 0.39049,-1 1,-1 z"/>
      <path d="m 169.625,69.65625 c -6.01649,0 -11,4.983509 -11,11 l 0,14 10,0 0,-14 c 0,-0.609509 0.39049,-1 1,-1 l 25.5,0 c 0.60951,0 1,0.390491 1,1 l 0,14 10,0 0,-14 c 0,-6.016491 -4.98351,-11 -11,-11 l -25.5,0 z"/>
END1

      $ret .= '<path d="m 221.141,266.334 c 0,3.313 -2.688,6 -6,6 h -65.5 c -3.313,0 -6,-2.688 -6,-6 v -6 c 0,-3.314 2.687,-6 6,-6 l 65.5,-20 c 3.313,0 6,2.686 6,6 v 26 z"/>'     if ($soc > 12);
      $ret .= '<path d="m 221.141,213.667 c 0,3.313 -2.688,6 -6,6 l -65.5,20 c -3.313,0 -6,-2.687 -6,-6 v -20 c 0,-3.313 2.687,-6 6,-6 l 65.5,-20 c 3.313,0 6,2.687 6,6 v 20 z"/>' if ($soc > 38);
      $ret .= '<path d="m 221.141,166.667 c 0,3.313 -2.688,6 -6,6 l -65.5,20 c -3.313,0 -6,-2.687 -6,-6 v -20 c 0,-3.313 2.687,-6 6,-6 l 65.5,-20 c 3.313,0 6,2.687 6,6 v 20 z"/>' if ($soc > 63);
      $ret .= '<path d="m 221.141,120 c 0,3.313 -2.688,6 -6,6 l -65.5,20 c -3.313,0 -6,-2.687 -6,-6 v -26 c 0,-3.313 2.687,-6 6,-6 h 65.5 c 3.313,0 6,2.687 6,6 v 6 z"/>'          if ($soc > 88);
      $ret .= '</g>';
  }

  ## Home Icon
  ##############
  my $car   = CurrentVal ($name, 'autarkyrate', undef);
  my $hmtxt = '';
  $hmtxt    = $htitles{autarky}{$lang}.': '.$car.' %' if(defined $car);
  my $hicon = HOMEICONDEF;

  if (defined $car && CurrentVal ($name, 'homenodedyncol', 0)) {
      $car              = 100 - $car;
      my $pahcol        = '#'.val2pahColor ($car, 100);                                           # V 1.50.4
      ($hicon, my $col) = split '@', $hicon;
      $hicon            = $hicon.'@'.$pahcol;
  }

  my $chicon = (split '@', $hicon)[1];
  $hicon     = FW_makeImage         ($hicon, '');
  $hicon     = __normIconInnerScale ($hicon, $chicon);
  
  $ret .= qq{<g id="home_$stna" transform="translate(368 360)">};                                 # translate(X-Koordinate,Y-Koordinate)
  $ret .= "<title>$hmtxt</title>".$hicon;
  $ret .= '</g> ';

  ## Dummy Consumer Icon
  ########################
  if ($flowgconX) {
      my $dumtxt  = $htitles{dumtxt}{$lang};

      my ($dicon) = __substituteIcon ( { hash => $hash,                                           # Icon des Consumerdevices
                                         name => $name,
                                         pn    => '',
                                         ptyp  => 'consumerdummy',
                                         pcurr => $cons_dmy,
                                         lang  => $lang
                                       }
                                     );

      my $cdicon = (split '@', $dicon)[1];
      $dicon     = FW_makeImage         ($dicon, '');
	  $dicon     = __normIconInnerScale ($dicon, $cdicon); 

      $ret .= qq{<g id="dummy_$stna" transform="translate(660 360)">};
      $ret .= "<title>$dumtxt</title>".$dicon;
      $ret .= '</g> ';
  }

  ## Laufketten Node->Home, Node->Grid, Bat->Home
  #################################################
  my $node2home_style        = $node2home        ? "$stna active_normal" : "$stna inactive";
  my $node2gridMetered_style = $node2gridMetered ? "$stna active_normal" : "$stna inactive";

  $ret .= << "END2";
  <g transform="translate(50,50),scale(0.5)" stroke-width="27" fill="none">
  <path id="node2home_$stna" class="$node2home_style" d="M700,400 L700,580" />
  <path id="node2grid_$stna" class="$node2gridMetered_style" d="M670,400 L250,480" />
  <path id="grid2home_$stna" class="$grid2home_style" d="$gconMetered_direction" />
END2

  ## Laufketten PV->Batterie, Batterie->Home
  ##############################################
  if ($hasbat) {
      my $node2bat_style  = $node2bat     ? "$stna active_normal" : "$stna inactive";
      my $batin_direction = $node2bat < 0 ? "M1200,480 L730,400"  : "M730,400 L1200,480";
      $node2bat           = abs $node2bat;

      $ret .= << "END3";
      <path id="bat2home_$stna" class="$bat2home_style" d="$bat2home_direction" />
      <path id="pv2bat_$stna"   class="$node2bat_style" d="$batin_direction" />
END3
  }

  ## Dummy Consumer Laufketten
  ##############################
  if ($flowgconX) {
     my $consumer_style = "$stna inactive";
     $consumer_style    = "$stna active_normal" if($cons_dmy > 1);                           # current consumption Dummy
     my $chain_color    = "";                                                                # Farbe der Laufkette Consumer-Dummy

     if ($cons_dmy > 0.5 && CurrentVal ($name, 'strokeconsumerdyncol', 0)) {
         $chain_color = 'style="stroke: #'.val2pahColor ($cons_dmy, $strokeredlim).';"';
     }

     $ret .= qq{<path id="home2dummy_$stna" class="$consumer_style" $chain_color d="M790,690 L1200,690" />};  # M790,690 → Move To (Startpunkt bei x=790, y=690), L1200,690 → Line To (Zeichnet eine Linie von 790,690 nach 1200,690)
  }

  ## Laufketten Generator (Solarzellen/Input) zu Producer/Inverter
  ## Laufketten nur anzeigen wenn Solarzellen/Input-Zeile angezeigt werden soll
  ###############################################################################
  if ($showgenerators) {
      for my $st (sort keys %{$psorted}) {                                 # für jede Gruppe von Icons ('1togrid', '2tonode', '3tobat') die Gruppenmitglieder @sorted behandeln
          my @sorted;
          @sorted = @{$psorted->{$st}{sorted}} if(defined $psorted->{$st}{sorted});

          for my $lfn (@sorted) {
              my $pn        = $pdcr->{$lfn}{pn};
              my $generator = $pdcr->{$lfn}{generator};                    # Angaben zum Generator (Namen der Strings)
              my $xchain    = $pdcr->{$lfn}{xsgenerator};                  # Übernahme aus __addInputProducerIcon
              next if(!$xchain);

              my $ystart          = $pdcr->{$lfn}{ysgenerator};
              $ystart             = $showproducers ? $ystart - PRDCRROWSHIFT + 15 : $ystart + PRDCRROWSHIFT - 20;   # Unterscheidung wenn ProducerZeile angezeigt werden soll
              my $genpow          = __getGeneratorPower ( { pdcr => $pdcr, lfn => $lfn } );                         # aktuelle Generatorleistung
              my $chain_color     = '';
              my $generator_style = $genpow > 0 ? "$stna active_normal" : "$stna inactive";
              my $xcstart         = ($xchain * 2) - 30;                                                             # X-Lage Korrektur der Laufkette zur Mitte des Icons
              my $yend            = $ystart  + 120;

              $ret .= qq{<path id="geninput_${pn}_$stna" class="$generator_style" $chain_color d=" M$xcstart,$ystart L$xcstart,$yend" />};
          }
      }
  }

  ## Laufketten Producer/Inverter - in Reihenfolge: zum Grid - zum Knoten - zur Batterie
  ## Laufkette nur anzeigen wenn Producerzeile angezeigt werden soll
  ########################################################################################
  if ($showproducers) {
      for my $st (sort keys %{$psorted}) {                                                        # jedes Mitglied @sorted des Gruppenarray ('1togrid', '2tonode', '3tobat') behandeln
          my $left   = $psorted->{$st}{start} * 2;                                                # Übertrag aus Producer Icon Abschnitt
          my $count  = $psorted->{$st}{count};
          my $xchain = $psorted->{$st}{xchain};                                                   # X- Koordinate Kette am Ziel
          my $ychain = $psorted->{$st}{ychain};                                                   # Y- Koordinate Kette am Ziel
          my $step   = $psorted->{$st}{step};

          my @sorted;
          @sorted = @{$psorted->{$st}{sorted}} if(defined $psorted->{$st}{sorted});

          $xchain = __groupXstart ($xchain, $count, $pdist);

          my $producer_style;

          for my $lfn (@sorted) {
              my $ptyp        = $pdcr->{$lfn}{ptyp};
              my $source      = $pdcr->{$lfn}{source} // '';
              my $pn          = $pdcr->{$lfn}{pn};
              my $pgen        = $pdcr->{$lfn}{pgen};
              my $pdc2ac      = $pdcr->{$lfn}{pdc2ac};
              my $pac2dc      = $pdcr->{$lfn}{pac2dc};
              my $chain_color = '';                                        # Farbe der Laufkette des Producers

              $producer_style = $pgen > 0 || $pdc2ac > 0 || $pac2dc > 0 ? "$stna active_normal" : "$stna inactive";

              #if ($pgen) {
                  #$chain_color  = 'style="stroke: #'.substr(Color::pahColor(0,50,100,$p,[0,255,0, 127,255,0, 255,255,0, 255,127,0, 255,0,0]),0,6).';"';
              #}

              if ($pac2dc > 0) {                                           # Richtung Knoten -> Inverter
                  $ret .= qq{<path id="genproducer_${pn}_$stna" class="$producer_style" $chain_color d=" M$xchain,$ychain L$left,130" />};
              }
              else {                                                       # Richtung Inverter -> Knoten (Standard)
                  $ret .= qq{<path id="genproducer_${pn}_$stna" class="$producer_style" $chain_color d=" M$left,130 L$xchain,$ychain" />};
              }

              if ($ptyp eq 'inverter' && $source eq 'bat') {
                  if ($pac2dc > 0) {                                       # Richtung Inverter -> Batterie
                      $ret .= qq{<path id="genproducer_${pn}_$stna" class="$producer_style" $chain_color d=" M$left,130 L1250,440" />};
                  }
                  else {                                                   # Richtung Batterie -> Inverter (Standard)
                      $ret .= qq{<path id="genproducer_${pn}_$stna" class="$producer_style" $chain_color d=" M1250,440 L$left,130" />};
                  }
              }

              $left   += ($pdist * 2);
              $xchain += $step;
          }
      }
  }

  ## Consumer Laufketten
  ########################
  if ($flowgconsumer) {
      $cons_left          = $consumer_start * 2;
      my $cons_left_start = 0;
      my $distance_con    = 65;
      $y_pos              = 880 + 2 * $exth2cdist;

      $cons_left_start = __groupXstart (700, $consumercount, $distance_con);

      my $consumer_style;

      for my $c (@consumers) {
          $cnsmrpower = $cnsmr->{$c}{p};          
          my $cilon   = isConsumerLogOn ($hash, $c, $cnsmrpower);
          
          $consumer_style = $cilon ? "$stna active_normal" : "$stna inactive";
          my $chain_color = "";                                                                    # Farbe der Laufkette des Consumers

          if ($cilon && CurrentVal ($name, 'strokeconsumerdyncol', 0)) {
              $chain_color = 'style="stroke: #'.val2pahColor ($cnsmrpower, $strokeredlim).';"';
          }

          $ret             .= qq{<path id="home2consumer_${c}_$stna" class="$consumer_style" $chain_color d="M$cons_left_start,780 L$cons_left,$y_pos" />};
          $cons_left       += ($cdist * 2);
          $cons_left_start += $distance_con;
      }
  }

  ## Textangaben an Grafikelementen
  ###################################
  $cons_dmy    = sprintf "%.0f", $cons_dmy;                                                       # Verbrauch Dummy-Consumer
  $bat2home    = __normDecPlaces ($bat2home);
  $dc2inv2node = __normDecPlaces ($dc2inv2node);
  $node2bat    = __normDecPlaces ($node2bat);
  $consptn     = __normDecPlaces ($consptn);

  $ret .= qq{<text class="$stna text" id="nodetxt_$stna"      x="800"  y="320" style="text-anchor: start;">$pnodesum</text>}        if ($pnodesum > 0);
  $ret .= qq{<text class="$stna text" id="batsoctxt_$stna"    x="1380" y="520" style="text-anchor: start;">$soc %</text>}           if ($hasbat);                         # Lage Text Batterieladungszustand
  $ret .= qq{<text class="$stna text" id="node2hometxt_$stna" x="730"  y="520" style="text-anchor: start;">$node2home</text>}       if ($node2home);
  $ret .= qq{<text class="$stna text" id="node2gridtxt_$stna" x="420"  y="420" style="text-anchor: end;">$node2gridMetered</text>}  if ($node2gridMetered);
  $ret .= qq{<text class="$stna text" id="grid2hometxt_$stna" x="420"  y="610" style="text-anchor: end;">$gconMetered</text>}       if ($gconMetered);
  $ret .= qq{<text class="$stna text" id="batouttxt_$stna"    x="1000" y="610" style="text-anchor: start;">$bat2home</text>}        if ($bat2home && $hasbat);
  $ret .= qq{<text class="$stna text" id="node2battxt_$stna"  x="1000" y="420" style="text-anchor: start;">$node2bat</text>}        if ($node2bat && $hasbat);
  $ret .= qq{<text class="$stna text" id="hometxt_$stna"      x="600"  y="710" style="text-anchor: end;">$consptn</text>};                                                # Current_Consumption Anlage
  $ret .= qq{<text class="$stna text" id="dummytxt_$stna"     x="1380" y="710" style="text-anchor: start;">$cons_dmy</text>}        if ($flowgconX && $flowgconsPower);   # Current_Consumption Dummy


  ## Textangabe Leistung Generator (Solarzellen/Input)
  ## Text nur anzeigen wenn die Generator-Zeile angezeigt werden soll
  #####################################################################
  if ($showgenerators) {
      for my $st (sort keys %{$psorted}) {                                                                # jedes Mitglied @sorted des Gruppenarray ('1togrid', '2tonode', '3tobat') behandeln
          my @sorted;
          @sorted = @{$psorted->{$st}{sorted}} if(defined $psorted->{$st}{sorted});

          for my $lfn (@sorted) {
              my $pn    = $pdcr->{$lfn}{pn};
              my $xtext = $pdcr->{$lfn}{xsgenerator};                                                     # Übernahme aus __addInputProducerIcon
              next if(!$xtext);

              $xtext    = $xtext * 2 - 80;                                                                # Korrektur Start X-Koordinate des Textes
              my $ytext = $pdcr->{$lfn}{ysgenerator};
              $ytext    = $showproducers ? $ytext - PRDCRROWSHIFT + 5 : $ytext + PRDCRROWSHIFT - 30;      # Unterscheidung wenn ProducerZeile angezeigt werden soll

              my $genpow = __getGeneratorPower ( { pdcr => $pdcr, lfn => $lfn } );                        # aktuelle Generatorleistung
              my $lpv1   = strlength ($genpow);

              # Leistungszahl abhängig von der Größe entsprechend auf der x-Achse verschieben
              #################################################################################
              if    ($lpv1 >= 5) {$xtext -= 30}
              elsif ($lpv1 == 4) {$xtext -= 15}
              elsif ($lpv1 == 3) {$xtext -=  5}
              elsif ($lpv1 == 2) {$xtext += 10}
              elsif ($lpv1 == 1) {$xtext += 30}

              $ret .= qq{<text class="$stna text" id="generatortxt_${pn}_$stna" x="$xtext" y="$ytext">$genpow</text>};
          }
      }
  }

  ## Textangabe Producer / Inverter - in Reihenfolge: zum Grid - zum Knoten - zur Batterie
  ## Textangabe nur anzeigen wenn Producerzeile angezeigt werden soll
  ###########################################################################################
  if ($showproducers) {
      for my $st (sort keys %{$psorted}) {                                                  # jedes Mitglied @sorted des Gruppenarray ('1togrid', '2tonode', '3tobat') behandeln
          my @sorted;
          @sorted = @{$psorted->{$st}{sorted}} if(defined $psorted->{$st}{sorted});

          for my $lfn (@sorted) {
              my $pn    = $pdcr->{$lfn}{pn};
              my $xtext = $pdcr->{$lfn}{xsproducer};                                        # Übernahme aus __addInputProducerIcon
              next if(!$xtext);

              $xtext     = $xtext * 2 - 70;                                                 # Korrektur Start X-Koordinate des Textes
              my $pdrpow = __getProducerPower ( { pdcr => $pdcr, lfn => $lfn } );
              my $lpv1   = strlength ($pdrpow);

              # Leistungszahl abhängig von der Größe entsprechend auf der x-Achse verschieben
              ###############################################################################
              if    ($lpv1 >= 5) {$xtext -= 30}
              elsif ($lpv1 == 4) {$xtext -= 15}
              elsif ($lpv1 == 3) {$xtext -=  5}
              elsif ($lpv1 == 2) {$xtext += 10}
              elsif ($lpv1 == 1) {$xtext += 25}

              $ret .= qq{<text class="$stna text" id="producertxt_${pn}_$stna" x="$xtext" y="100">$pdrpow</text>} if($flowgPrdsPower);
          }
      }
  }

  ## Textangabe Consumer
  ########################
  if ($flowgconsumer) {
      $cons_left = ($consumer_start * 2) - 50;                                                         # -XX -> Start Lage Consumer Beschriftung
       
      my %offset = (
          0b00 =>   0,                                                                                 # weder Power noch Time
          0b01 =>  60,                                                                                 # nur Power
          0b10 =>  60,                                                                                 # nur Time
          0b11 => 120,                                                                                 # beide
      );

      my $y_base = 1110 + 2 * $exth2cdist;
      $y_pos     = $y_base;                                                                            # flowgconsPower
      my $mask   = $flowgconsPower ? 1 : 0;
      $y_pos1    = $y_base + $offset{$mask};                                                           # flowgconsTime
      
      $mask = $flowgconsPower && $flowgconsTime ? 3 :
              $flowgconsTime                    ? 2 :      
              $flowgconsPower                   ? 1 :
              0;
              
      $y_pos2 = $y_base + $offset{$mask};                                                              # shortalias

      for my $c (@consumers) {
          my $shortalias   = $cnsmr->{$c}{shortalias} // '';
          $cnsmrpower      = sprintf "%.1f", $cnsmr->{$c}{p};
          $cnsmrpower      = sprintf "%.0f", $cnsmrpower if($cnsmrpower > 10);
          my $consumerTime = ConsumerVal ($name, $c, 'remainTime', '');                               # Restlaufzeit
          my $rpcurr       = ConsumerVal ($name, $c, 'rpcurr',     '');                               # Readingname f. current Power

          if (!$rpcurr) {                                                                             # Workaround wenn Verbraucher ohne Leistungsmessung
              $cnsmrpower = isConsumerPhysOn($hash, $c) ? 'on' : 'off';
          }

          my $lcp = strlength ($cnsmrpower);
          my $lct = strlength ($consumerTime);
          my $lcs = strlength ($shortalias); 

          # Texte abhängig von ihrer Größe entsprechend auf der x-Achse verschieben
          ###########################################################################
          if ($flowgconsPower) {                                                            # Lage Consumer Consumption
              my $lcp_cons_left = $cons_left;
            
              if    ($lcp >= 5) {$lcp_cons_left -= 40}
              elsif ($lcp == 4) {$lcp_cons_left -= 25}
              elsif ($lcp == 3) {$lcp_cons_left -= 5 }
              elsif ($lcp == 2) {$lcp_cons_left += 7 }
              elsif ($lcp == 1) {$lcp_cons_left += 25}

              $ret .= qq{<text class="$stna text" id="consumertxt_${c}_$stna" x="$lcp_cons_left" y="$y_pos">$cnsmrpower</text>};
          }
          
          if ($flowgconsTime) {                                                            # Lage Consumer Restlaufzeit
              my $lct_cons_left = $cons_left;
              
              if    ($lct >= 5) {$lct_cons_left -= 40}
              elsif ($lct == 4) {$lct_cons_left -= 25}
              elsif ($lct == 3) {$lct_cons_left -= 5 }
              elsif ($lct == 2) {$lct_cons_left += 7 }
              elsif ($lct == 1) {$lct_cons_left += 25}          
              
              $ret .= qq{<text class="$stna text" id="consumertxt_time_${c}_$stna" x="$lct_cons_left" y="$y_pos1">$consumerTime</text>};
          }
          
          if ($shortalias) {                                                              # Lage Consumer Kurzalias
              my $lcs_cons_left = $cons_left;
              
              if    ($lcs >= 10) {$lcs_cons_left -= 85}
              elsif ($lcs ==  9) {$lcs_cons_left -= 85}
              elsif ($lcs ==  8) {$lcs_cons_left -= 70}
              elsif ($lcs ==  7) {$lcs_cons_left -= 60}
              elsif ($lcs ==  6) {$lcs_cons_left -= 35}
              elsif ($lcs ==  5) {$lcs_cons_left -= 20}
              elsif ($lcs ==  4) {$lcs_cons_left -= 10}
              elsif ($lcs ==  3) {$lcs_cons_left -= 0 }
              elsif ($lcs ==  2) {$lcs_cons_left += 7 }
              elsif ($lcs ==  1) {$lcs_cons_left += 25}         
              
              $ret .= qq{<text class="$stna text" id="consumertxtalias_${c}_$stna" x="$lcs_cons_left" y="$y_pos2">$shortalias</text>};
          }
                    
          $cons_left += ($cdist * 2);
      }
  }

  $ret .= qq{</g></svg>};

return $ret;
}

################################################################
#      die anzuzeigende Generatorenleistung
################################################################
sub __getGeneratorPower {
  my $paref = shift;
  my $pdcr  = $paref->{pdcr};
  my $lfn   = $paref->{lfn};

  my $pvin    = $pdcr->{$lfn}{pvin};
  my $ptyp    = $pdcr->{$lfn}{ptyp};                       # Producertyp
  my $psubtyp = $pdcr->{$lfn}{psubtyp};                    # Subtyp des Inverters

  my $genpow  = $ptyp eq 'inverter' && $psubtyp eq 'StandardInverter' ? $pvin :
                $ptyp eq 'inverter' && $psubtyp eq 'SolarCharger'     ? $pvin :
                0;

return $genpow;
}

################################################################
#    die anzuzeigende Producer / Inverter Leistung liefern
################################################################
sub __getProducerPower {
  my $paref = shift;
  my $pdcr  = $paref->{pdcr};
  my $lfn   = $paref->{lfn};

  my $pgen   = $pdcr->{$lfn}{pgen};
  my $pdc2ac = $pdcr->{$lfn}{pdc2ac};
  my $pac2dc = $pdcr->{$lfn}{pac2dc};
  my $feed   = $pdcr->{$lfn}{feed};
  my $source = $pdcr->{$lfn}{source};
  my $ptyp   = $pdcr->{$lfn}{ptyp};

  my $pdrpow  = ($source eq 'pv'  && $feed eq 'default') || $ptyp eq 'producer' ? $pgen   :   # Otherproducer oder Standard-Wechselrichter
                 $source eq 'pv'  && $feed eq 'bat'                             ? $pgen   :   # Solar-Ladegerät
                 $source eq 'bat' && $feed eq 'default' && $pac2dc              ? $pac2dc :   # Batterie-Wechselrichter
                 $source eq 'bat' && $feed eq 'default' && $pdc2ac              ? $pdc2ac :   # Batterie-Wechselrichter
                 0;

return $pdrpow;
}

################################################################
#  erzeugt eine Liste der Producernummern sortiert von
#  links nach rechts:
#  -> alle Inverter mit Feed-Typ 'grid'
#  -> alle Producer (nicht PV)
#  -> alle Inverter mit Feed-Typ 'default'
#  -> alle Inverter mit Feed-Typ 'bat'
################################################################
sub __sortProducer {
  my $pdcr = shift;                                                           # Hashref Producer

  my @igrid   = ();
  my @togrid  = ();
  my @prod    = ();
  my @idef    = ();
  my @isrcpv  = ();
  my @isrcbat = ();
  my @tonode  = ();
  my @toinv   = ();
  my @ibat    = ();
  my @tobat   = ();

  for my $lfn (sort{$a<=>$b} keys %{$pdcr}) {
      my $ptyp = $pdcr->{$lfn}{ptyp};                                         # producer | inverter
      my $feed = $pdcr->{$lfn}{feed};                                         # default | grid | bat

      push @igrid, $lfn if($ptyp eq 'inverter' && $feed eq 'grid');           # Lieferung an öffentliches Netz
      push @prod,  $lfn if($ptyp eq 'producer');
      push @idef,  $lfn if($ptyp eq 'inverter' && $feed eq 'default');        # Lieferung an Inverterknoten
      push @ibat,  $lfn if($ptyp eq 'inverter' && $feed eq 'bat');            # Lieferung an Batterie
  }

  for my $lfn (@idef) {
      my $source = $pdcr->{$lfn}{source};

      push @isrcpv,  $lfn if($source eq 'pv');                                # Quelle ist PV-String
      push @isrcbat, $lfn if($source eq 'bat');                               # Quelle ist Batterie
  }

  push @togrid, @igrid;
  push @tonode, @prod;
  push @tonode, @isrcpv;
  push @tonode, @isrcbat;
  push @toinv,  @isrcbat;
  push @tobat,  @ibat;

return (\@togrid, \@tonode, \@tobat, \@toinv);
}

################################################################
#    Zellen/Input-Zeile und Producer Icon einfügen
################################################################
sub __addInputProducerIcon {
  my $paref          = shift;
  my $hash           = $paref->{hash};
  my $name           = $paref->{name};
  my $lang           = $paref->{lang};
  my $stna           = $paref->{stna};
  my $psorted        = $paref->{psorted};
  my $pdcr           = $paref->{pdcr};
  my $pdist          = $paref->{pdist};
  my $y_coord        = $paref->{y_coord};
  my $showgenerators = $paref->{showgenerators};

  my $don = NexthoursVal ($hash, 'NextHour00', 'DoN', 0);
  my $ret;

  for my $st (sort keys %{$psorted}) {                                                     # jedes Mitglied @sorted des Gruppenarray ('1togrid', '2tonode', '3tobat') behandeln
      my $xstart = 0;
      my $xicon  = $psorted->{$st}{xicon};
      my $count  = $psorted->{$st}{count};

      my @sorted;
      @sorted = @{$psorted->{$st}{sorted}} if(defined $psorted->{$st}{sorted});

      $xicon = __groupXstart ($xicon, $count, $pdist);

      $psorted->{$st}{start} = $xicon;                                                     # Übertrag Koordinaten
      $xstart                = $xicon + 15;

      for my $lfn (@sorted) {
          my $pn        = $pdcr->{$lfn}{pn};
          my $ptyp      = $pdcr->{$lfn}{ptyp};
          my $generator = $pdcr->{$lfn}{generator};                                        # Angaben zum Generator (Namen der Strings)
          my $pdrpow    = __getProducerPower ( { pdcr => $pdcr, lfn => $lfn } );           # aktuelle Producerleistung

          if ($showgenerators) {                                                           # Anzeige Input-Reihe
              my $genpow = __getGeneratorPower ( { pdcr => $pdcr, lfn => $lfn } );         # aktuelle Generatorleistung
              my $ystart = $y_coord;
              $ystart   -= INPUTROWSHIFT;

              if ($generator && $generator ne 'none') {
                  $pdcr->{$lfn}{xsgenerator} = $xstart;                                    # Übertrag Koordinaten für Laufketten/Text Anzeige
                  $pdcr->{$lfn}{ysgenerator} = $ystart;                                    # Übertrag Koordinaten für Laufketten/Text Anzeige

                  my ($genericon, $genertxt) = __substituteIcon ( { hash  => $hash,                                                 # Icon des Producerdevices
                                                                    name  => $name,
                                                                    msg1  => $generator,
                                                                    pn    => $pn,
                                                                    ptyp  => 'generator',
                                                                    don   => $don,         # Tag oder Nacht
                                                                    pcurr => $genpow,
                                                                    lang  => $lang
                                                                  }
                                                                );
                  
				  my $gcolor = (split '@', $genericon)[1];
                  $genericon = FW_makeImage         ($genericon, '');
				  $genericon = __normIconInnerScale ($genericon, $gcolor);
				  
				  $ret .= qq{<g id="generator_${pn}_$stna" fill="grey" transform="translate($xstart $ystart)">};
                  $ret .= "<title>$genertxt</title>".$genericon;
                  $ret .= '</g> ';
              }
          }

          my ($picon, $ptxt) = __substituteIcon ( { hash  => $hash,         # Icon des Producerdevices
                                                    name  => $name,
                                                    pn    => $pn,
                                                    ptyp  => $ptyp,
                                                    don   => $don,          # Tag oder Nacht
                                                    pcurr => $pdrpow,
                                                    lang  => $lang
                                                  }
                                                );

          my $cpicon = (split '@', $picon)[1];
          $picon     = FW_makeImage         ($picon, '');
		  $picon     = __normIconInnerScale ($picon, $cpicon); 
		  
          $ret .= qq{<g id="producer_${pn}_$stna" fill="grey" transform="translate($xstart $y_coord)">};
          $ret .= "<title>$ptxt</title>".$picon;
          $ret .= '</g> ';

          $pdcr->{$lfn}{xsproducer} = $xstart;                              # Übertrag Koordinaten für Laufketten/Text Anzeige
          $xstart += $pdist;
      }
  }

return $ret;
}

################################################################
#          Knoten Icon einfügen
################################################################
sub __addNodeIcon {
  my $paref    = shift;
  my $hash     = $paref->{hash};
  my $name     = $paref->{name};
  my $lang     = $paref->{lang};
  my $stna     = $paref->{stna};
  my $pnodesum = $paref->{pnodesum};
  my $x_coord  = $paref->{x_coord};
  my $y_coord  = $paref->{y_coord};

  my ($nicon, $ntxt) = __substituteIcon ( { hash  => $hash,
                                            name  => $name,
                                            ptyp  => 'node',
                                            pcurr => $pnodesum,
                                            lang  => $lang
                                           }
                                         );
  
  my $cnicon = (split '@', $nicon)[1];
  $nicon     = FW_makeImage         ($nicon, '');
  $nicon     = __normIconInnerScale ($nicon, $cnicon);
		  
  my $ret = qq{<g id="node_$stna" transform="translate($x_coord $y_coord)">};     # translate(X-Koordinate,Y-Koordinate)
  $ret   .= "<title>$ntxt</title>".$nicon;
  $ret   .= '</g> ';

return $ret;
}

################################################################
#       prüfe ob Icon + Farbe angegeben ist
#       und setze ggf. Ersatzwerte
#       ptyp    - Typ der Entität
#       $pn     - Positionsnummer (01...max)
#       flag    - ein beliebiges Statusflag zur Auswertung
#       msg1    - zur freien Verwendung
#       msg2    - zur freien Verwendung
#       msg3    - zur freien Verwendung
#       soc     - der SOC bei Batterien
#       $don    - Day or Night
#       $pcurr  - aktuelle Leistung / Verbrauch
################################################################
sub __substituteIcon {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $paref->{hash} // $defs{$name};
  my $ptyp  = $paref->{ptyp};
  my $pn    = $paref->{pn};
  my $msg1  = $paref->{msg1};
  my $msg2  = $paref->{msg2};
  my $msg3  = $paref->{msg3};
  my $flag  = $paref->{flag};
  my $soc   = $paref->{soc} // -9999;                                                    # auf fehlenden SoC aufmerksam machen
  my $don   = $paref->{don};
  my $pcurr = $paref->{pcurr};
  my $lang  = $paref->{lang};

  my ($color, $icon);
  my $txt = '';

  if ($ptyp eq 'consumer') {                                                             # Icon Consumer
      ($icon, $color) = split '@', ConsumerVal ($name, $pn, 'icon', CICONDEF);

      if (!$color) {
          $color = isConsumerLogOn ($hash, $pn, $pcurr) ? CICONCOLACT : CICONCOLINACT;
      }
  }
  elsif ($ptyp eq 'consumerdummy') {                                                     # Icon Dummy Consumer
      ($icon, $color) = split '@', CurrentVal ($name, 'dummyIcon', CICONDEF);
      $icon           = CICONDEF if(!$icon);
      $color          = $pcurr > 0 ? CICONCOLACT : CICONCOLINACT if(!$color);
  }
  elsif ($ptyp eq 'generator') {                                                         # Generator (z.B. String)
      ($icon, $color) = split '@', GENICONDEF.'@'.GENCOLACT;

      if (!$pcurr) {
          $color = GENCOLINACT;
      }

      $txt = $msg1 if(defined $msg1);
  }
  elsif ($ptyp eq 'battery') {                                                           # Icon Batterie
      my ($ircmd, $icharge, $idischrg, $inorcmd) = split ':', BatteryVal ($name, $pn, 'bicon', '');

      my $soctxt = '';
      my $pretxt = '';

      $soctxt     = "\n".$htitles{socbatfc}{$lang}.": ".$soc." %";                       # Text 'SoC Prognose'
      my $socicon = batSoc2icon ($soc);
                 
      $ircmd    = $ircmd    ? $ircmd    : '';
      $inorcmd  = $inorcmd  ? $inorcmd  : '';
      $icharge  = $icharge  ? $icharge  : '';
      $idischrg = $idischrg ? $idischrg : '';

      my $cgbt = AttrVal ($name, 'ctrlBatSocManagement'.$pn, '');

      if (defined $flag) {                                                               # Empfehlungszeitraum
          if ($flag) {                                                                   # Ladefreigabe
              ($icon, $color) = split '@', $ircmd;
              $icon           = $icon    ? $icon    :
                                $socicon ? $socicon :
                                BICONDEF;                                                # nur Farbe angegeben

              $color  //= BICCOLRCDDEF;

              if ($flag eq 'hist') {                                                     # erreichter SoC vergangener Stunden
                  $pretxt = $htitles{onlybatw}{$lang}." $pn: $msg1";
              }
              else {                                                                     # prognostizierte Ladefreigabe
                  $pretxt = $htitles{onlybatw}{$lang}." $pn: $msg1".($cgbt ? "\n".$htitles{bcharrel}{$lang} : '');
              }
          }
          else {                                                                         # keine Ladefreigabe
              ($icon, $color) = split '@', $inorcmd;
              $icon           = $icon    ? $icon    :
                                $socicon ? $socicon :
                                BICONDEF;                                                # nur Farbe angegeben

              $color  //= BICCOLNRCDDEF;
              $pretxt   = $htitles{onlybatw}{$lang}." $pn: $msg1".($cgbt ? "\n".$htitles{bncharel}{$lang} : '');
          }
      }
      
      $pretxt .= "\n".$htitles{lcenable}{$lang}.": ".(defined $msg2 ? ($msg2 == 1 ? $htitles{simplyes}{$lang} : $htitles{simpleno}{$lang}) : '-');
      $pretxt .= "\n".$htitles{ldstratg}{$lang}.": ".(defined $msg2 ? $msg3 : '-');

      if (defined $pcurr) {                                                              # aktueller Zustand
           if ($pcurr > 0) {                                                             # Batterie wird aufgeladen
               ($icon, $color) = split '@', $icharge;
               $icon           = $icon    ? $icon    :
                                 $socicon ? $socicon :
                                 BICONDEF;                                               # nur Farbe angegeben

               $color //= BCHGICONCOLDEF;
               $txt     = "$pretxt\nStatus: ".$htitles{ischawth}{$lang}.' '.$pcurr.' W'.$soctxt;
           }
           elsif ($pcurr < 0) {                                                          # Batterie wird entladen
               ($icon, $color) = split '@', $idischrg;
               $icon           = $icon    ? $icon    :
                                 $socicon ? $socicon :
                                 BICONDEF;                                               # nur Farbe angegeben

               $color //= BDCHICONCOLDEF;
               $txt     = "$pretxt\nStatus: ".$htitles{isdchawt}{$lang}.' '.(abs $pcurr).' W'.$soctxt;
           }
           else {                                                                        # Standby
               ($icon, $color) = split '@', $ircmd;
               $icon           = $icon    ? $icon    :
                                 $socicon ? $socicon :
                                 BICONDEF;                                               # nur Farbe angegeben

               $color //= BICCOLRCDDEF;
               $txt     = "$pretxt\nStatus: Standby".$soctxt;
           }
      }
      else {
          if (defined $flag && $flag eq 'hist') {                                        # Text 'SoC am Ende der Stunde'
              $soctxt = "\n".$htitles{socbaths}{$lang}.": ".$soc." %";
          }

          $txt = $pretxt.$soctxt;                                                        # resultierender Text
      }
      
      if ($color && $color eq 'dyn') {
          $color = val2dynColor ($soc, 0, $flag ? 0 : 0.4); 
      }
  }
  elsif ($ptyp eq 'producer') {                                                          # Icon Producer
      ($icon, $color) = split '@', ProducerVal ($name, $pn, 'picon', PRODICONDEF);
      $txt            = ProducerVal ($hash, $pn, 'palias', '');

      if (!$pcurr) {
          $color = 'grey';
      }
  }
  elsif ($ptyp eq 'inverter') {                                                          # Inverter, Smartloader
      my ($iday, $inight);

      if (InverterVal ($hash, $pn, 'isource', 'pv') eq 'bat') {
          ($iday, $inight) = split ':', InverterVal ($name, $pn, 'iicon', 'inverter:inverter');
      }
      else {
          ($iday, $inight) = split ':', InverterVal ($name, $pn, 'iicon', INVICONDEF);
      }

      if ($don || $pcurr) {                                                              # Tag -> eigenes Icon oder Standard
          $txt            = InverterVal ($name, $pn, 'ialias',    '');
          my $isource     = InverterVal ($name, $pn, 'isource', 'pv');

          $iday           = $iday ? $iday : INVICONDEF;
          ($icon, $color) = split '@', $iday;
          $color          = !$pcurr           ? INACTCOLDEF  :
                            $color            ? $color       :
                            $isource eq 'bat' ? ACTCOLINVBAT :
                            ACTCOLDEF;
      }
      else {                                                                           # Nacht -> eigenes Icon oder Mondphase
          my $mpi = CurrentVal ($name, 'moonPhaseI', MOONICONDEF);

          if ($inight) {                                                               # eigenes Icon + ggf. Farbe
              ($icon, $color) = split '@', $inight;
              $color          = $color ? $color : INACTCOLDEF;
          }
          else {
              $icon           = $hmoon{$mpi}{icon}.'@'.MOONCOLDEF;
              $txt            = $hmoon{$mpi}{$lang};
              ($icon, $color) = split '@', $icon;
          }
      }
  }
  elsif ($ptyp eq 'node') {                                                            # Knoten-Icon
      ($icon, $color) = split '@', CurrentVal ($name, 'inverterNodeIcon', NODEICONDEF);

      $color          = !$pcurr ? INACTCOLDEF :
                        $color  ? $color      :
                        ACTCOLDEF;
  }

  $icon .= '@'.$color if($color);

return ($icon, $txt);
}

###############################################################################
#   liefert ausgehend von der initialen X-Koordinate für jede Gruppe
#   eine optimierte X-Start Koordinate abhängig von der Anzahl der
#   Gruppenmitglieder (count) und dem Sollabstand (dist)
###############################################################################
sub __groupXstart {
  my $xinit = shift;
  my $count = shift;
  my $dist  = shift;

  my $xstart;

  if ($count % 2) {
      $xstart = $xinit - ($dist  * ($count -1) / 2);
  }
  else {
      $xstart = $xinit - ($dist / 2 * ($count - 1));
  }

return $xstart;
}

################################################################
#    normiere Nachkommastellen
#    Standard  - .xx (zwei Nachkommastellen)
#    wenn > 10 - xx  (keine Nachkommastelle)
#    wenn 0.0  - 0   (logisch 0)
################################################################
sub __normDecPlaces {
  my $p = shift;

  $p = sprintf "%.2f", $p;
  $p = sprintf "%.0f", $p if($p > 10);
  $p = 0                  if($p == 0);

return $p;
}

################################################################
#    liefere skaliertes Icon in einer normierten Viewbox
################################################################
sub __normIconInnerScale {
  my $icon = shift;
  my $fill = shift;                                                                            # Füll-Frbe
  my $size = shift // 70;
  my $pad  = shift // 0;

  return $icon unless $icon =~ m{<svg\b([^>]*)>(.*?)</svg>}si;
  my ($attr_str, $inner) = ($1, $2);                                                           # Extrahiere SVG-Attribute und Innen-Inhalt
                                                                                               # - $1 enthält alles zwischen '<svg' und '>'
                                                                                               # - $2 enthält den gesamten Inner-HTML-Bereich

  $attr_str =~ s/\b(?:width|height)\s*=\s*"[^"]*"//gi;                                         # Entferne bestehende Breiten-/Höhen-Attribute

  my ($x, $y, $w, $h) = (0, 0, 100, 100);                                                      # Lese viewBox-Werte oder nutze Default (0,0,100,100)
              
  if ($attr_str =~ /\bviewBox\s*=\s*"([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)"/i) {
      ($x, $y, $w, $h) = ($1, $2, $3, $4);  
  }

  my $scale = sprintf '%.4f', ( $size / ($w > $h ? $w : $h) );                                 # Berechne Skalierung und Versatz
  my $ox    = sprintf '%.1f', ( ($size - $w * $scale) / 2 - $x * $scale );                     # zentriert den Inhalt in einem Kasten mit Seitenlänge $size
  my $oy    = sprintf '%.1f', ( ($size - $h * $scale) / 2 - $y * $scale );
  
  $ox += $pad;                                                                                 # fügt $pad ViewBox-Einheiten Rand links bzw. oben hinzu.
  $oy += $pad;

  if ($fill) {     
      $inner =~ s/\bfill="[^"]*"/fill="$fill"/gi;
      for my $tag (qw(path rect circle ellipse polygon polyline line stroke)) {
          $inner =~ s{<$tag(?![^>]*\bfill=)}{<$tag fill="$fill"}gi;
      }
  }
  
  $inner = qq{<g transform="translate($ox $oy) scale($scale)">}.$inner.'</g>';                 # gib Inner-Content zurück, umgeben von der Transform-Gruppe

return $inner;
}

################################################################
#  ermittelt den Wechselrichter Arbeitstyp sowie die
#  Speisevariante
################################################################
sub exploreInverterType {
  my $h = shift;

  my $source = 'pv';

  if (defined $h->{strings}) {                                             # Strings und Wechselrichtertyp feststellen
       $source = 'bat' if($h->{strings} eq 'none');
  }

  my $feed   = defined $h->{feed}                                                ? $h->{feed} :
               $source eq 'pv' && defined $h->{acInOut} && defined $h->{dcInOut} ? 'hybrid'   :
               'default';

  my $itype = $feed   eq 'grid'   ? 'GridInverter'    :
              $feed   eq 'bat'    ? 'SolarCharger'    :
              $source eq 'bat'    ? 'BatteryInverter' :
              $feed   eq 'hybrid' ? 'HybridInverter'  :
              'StandardInverter';

return ($itype, $feed);
}

################################################################
#                 Inject consumer icon
################################################################
sub consinject {
  my ($hash,$i,@consumers) = @_;
  my $name                 = $hash->{NAME};
  my $ret                  = "";

  my $debug = getDebug ($hash);                                                        # Debug Module

  for (@consumers) {
      if ($_) {
          my ($cons,$im,$start,$end) = split (':', $_);

          if ($debug =~ /graphic/x) {
              Log3 ($name, 1, qq{$name DEBUG> Consumer to show -> $cons, relative to current time -> start: $start, end: $end}) if($i<1);
          }

          if ($im && ($i >= $start) && ($i <= $end)) {
              $ret .= FW_makeImage($im);
         }
      }
  }

return $ret;
}

###############################################################################
#                            Balkenbreite normieren
#
# Die Balkenbreite wird bestimmt durch den Wert.
# Damit alle Balken die gleiche Breite bekommen, müssen die Werte auf
# 6 Ausgabezeichen angeglichen werden.
# "align=center" gleicht gleicht es aus, alternativ könnte man sie auch
# komplett rechtsbündig ausgeben.
# Es ergibt bei fast allen Styles gute Ergebnisse, Ausnahme IOS12 & 6, da diese
# beiden Styles einen recht großen Font benutzen.
# Wird Wetter benutzt, wird die Balkenbreite durch das Icon bestimmt
#
###############################################################################
sub normBeamWidth {
  my $paref = shift;
  my $beam  = shift;
  my $i     = shift;
  my $beam1 = shift // '';                             # Anzeige der zusätzlichen Zeile (Content von Beam1/Beam2 als Hilfswert)

  my $val     = $paref->{hfcg}{$i}{$beam};
  my $weather = $paref->{hfcg}{$i}{weather};
  my $kw      = $paref->{kw};

  my $doconvert = 0;

  if ($kw eq 'kWh') {
      if ($paref->{$beam1.'cont'} !~ /batsoc|energycosts|feedincome/xs) {
          $doconvert = 1;
      }
  }

  my $n = '&nbsp;';                                                                         # positive Zahl

  if ($val < 0) {
      $n = '-';                                                                             # negatives Vorzeichen merken
      $val = abs($val);
  }

  if ($doconvert) {                                                                         # bei Anzeige in kWh muss weniger aufgefüllt werden
      $val  = sprintf "%.1f",($val / 1000);
      $val  += 0;                                                                           # keine 0.0 oder 6.0 etc

      if (defined $weather) {
          return $n eq '-' ? $val * -1 : $val;
      }

      my $dp = $val - int($val);                                                            # Nachkommstelle ?

      if (!$dp) {                                                                           # glatte Zahl ohne Nachkommastelle
          if    (!$val)     {return '&nbsp;';}                                              # 0 nicht anzeigen, passt eigentlich immer bis auf einen Fall im Typ diff
          elsif ($val < 10) {return '&nbsp;&nbsp;'.$n.$val.'&nbsp;&nbsp;';}
          else              {return '&nbsp;&nbsp;'.$n.$val.'&nbsp;';}
      }
      else {                                                                                # mit Nachkommastelle -> zwei Zeichen mehr .X
          if ($val < 10) {return '&nbsp;'.$n.$val.'&nbsp;';}
          else           {return $n.$val.'&nbsp;';}
      }
  }

  if (defined $weather) {
      return $n eq '-' ? $val * -1 : $val;
  }

  # Werte bleiben in Watt
  if    (!$val)         { return '&nbsp;'; }                                                ## no critic "Cascading" # keine Anzeige bei Null
  elsif ($val <    10)  { return '&nbsp;&nbsp;'.$n.$val.'&nbsp;&nbsp;'; }                   # z.B. 0
  elsif ($val <   100)  { return '&nbsp;'.$n.$val.'&nbsp;&nbsp;'; }
  elsif ($val <  1000)  { return '&nbsp;'.$n.$val.'&nbsp;'; }
  elsif ($val < 10000)  { return  $n.$val.'&nbsp;'; }
  else                  { return  $n.$val; }                                                # mehr als 10.000 W
}

###############################################################################
#         Zuordungstabelle "WeatherId" angepasst auf FHEM Icons
###############################################################################
sub weather2icon {
  my $name = shift;
  my $lang = shift;
  my $id   = shift;

  $id      = int $id;
  my $txt  = $lang eq "DE" ? "txtd" : "txte";

  if (defined $weather_ids{$id}) {
      return $weather_ids{$id}{icon}, encode('utf8', $weather_ids{$id}{$txt});
  }

return ('unknown','');
}

################################################################
#  Batterie SOC in ein entsprechendes Icon umsetzen
################################################################
sub batSoc2icon {
  my $soc = shift;

  my $socicon = $soc == 100 ? 'battery_100' :
                $soc >=  90 ? 'battery_90'  :
                $soc >=  80 ? 'battery_80'  :
                $soc >=  70 ? 'battery_70'  :
                $soc >=  60 ? 'battery_60'  :
                $soc >=  50 ? 'battery_50'  :
                $soc >=  40 ? 'battery_40'  :
                $soc >=  30 ? 'battery_30'  :
                $soc >=  20 ? 'battery_20'  :
                $soc >=  10 ? 'battery_10'  :
                'battery_0';

return $socicon;
}

################################################################
#      benötigte Attribute im DWD Device checken
################################################################
sub checkdwdattr {
  my $name   = shift;
  my $dwddev = shift;
  my $amref  = shift;

  my @fcprop = map { trim($_) } split ",", AttrVal ($dwddev, "forecastProperties", "pattern");
  my $fcr    = AttrVal ($dwddev, 'forecastResolution', 3);
  my $fcd    = AttrVal ($dwddev, 'forecastDays',       0);
  my ($err, $warn);

  my @aneeded;
  for my $am (@$amref) {
      next if(grep /^$am$/, @fcprop);
      push @aneeded, $am;
  }

  if (@aneeded) {
      $err = qq{ERROR - device "$dwddev" -> attribute "forecastProperties" must contain: }.join ",",@aneeded;
  }

  if ($fcr != 1) {
      $err .= ", " if($err);
      $err .= qq{ERROR - device "$dwddev" -> attribute "forecastResolution" must be set to "1"};
  }
  
  if ($fcd < DWDFCDAYSMIN) {
      $warn = qq{WARNING - device "$dwddev" -> attribute "forecastDays" is not set to the minimum value of: }.DWDFCDAYSMIN;
  }

  Log3 ($name, 2, "$name - $warn") if($warn);
  Log3 ($name, 2, "$name - $err")  if($err);

return ($err, $warn);
}

################################################################
#       AI Daten für die abgeschlossene Stunde hinzufügen
################################################################
sub _addHourAiRawdata {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $h      = $paref->{h};

  my $rho = sprintf "%02d", $h;

  debugLog ($paref, 'aiProcess', "start add AI raw data for hour: $h");

  $paref->{ood} = 1;                                                                                  # only one Day
  $paref->{rho} = $rho;

  aiAddRawData ($paref);                                                                              # Raw Daten für AI hinzufügen und sichern

  delete $paref->{ood};
  delete $paref->{rho};

return;
}

####################################################################################################
#                       Abruf und Einlesen Messagefile nonBlocking
#  $data{$name}{filemessages}{999000}{TSNEXT}: Timestamp nächster Pull Message File
####################################################################################################
sub getMessageFileNonBlocking {
  my $hash = shift;
  my $name = $hash->{NAME};

  my $tsnext = gettimeofday() + GMFILEREPEAT + int(rand(GMFILERANDOM));

  RemoveInternalTimer ($hash,   "FHEM::SolarForecast::getMessageFileNonBlocking");
  InternalTimer       ($tsnext, "FHEM::SolarForecast::getMessageFileNonBlocking", $hash, 0);

  my (undef, $disabled, $inactive) = controller ($name);
  return if($disabled || $inactive);

  delete $hash->{HELPER}{GMFRUNNING} if(defined $hash->{HELPER}{GMFRUNNING}{pid} && $hash->{HELPER}{GMFRUNNING}{pid} =~ /DEAD/xs);

  if (defined $hash->{HELPER}{GMFRUNNING}{pid}) {
      Log3 ($name, 3, qq{$name - another Message File Process with PID "$hash->{HELPER}{GMFRUNNING}{pid}" is already running ... get Message File is aborted});
      return;
  }

  my $paref = { name   => $name,
                tsnext => $tsnext,
                block  => 1
              };

  $hash->{HELPER}{GMFRUNNING} = BlockingCall ( "FHEM::SolarForecast::_retrieveMessageFile",
                                               $paref,
                                               "FHEM::SolarForecast::_processMessageFile",
                                               GMFBLTO,
                                               "FHEM::SolarForecast::_abortGetMessageFile",
                                               $hash
                                             );


  if (defined $hash->{HELPER}{GMFRUNNING}) {
      $hash->{HELPER}{GMFRUNNING}{loglevel} = 3;
  }

return;
}

###############################################################
#         Message File aus Quelle abholen
###############################################################
sub _retrieveMessageFile {
  my $paref = shift;
  my $name  = $paref->{name};
  my $block = $paref->{block} // 0;

  Log3 ($name, 4, "$name - Notification System - Message File >$messagefile< is retrieved non blocking");
  Log3 ($name, 4, "$name - Notification System - Message File Source: GitHub Repository");

  my $valid           = 1;
  my ($err, $remfile) = __httpBlockingGet ($name, BGHPATH.$messagefile.PGHPATH);

  $remfile = q{} if($remfile =~ /No\snode\strunk\/fhem\/contrib\/SolarForecast\//xs);

  if ($err) {
      $valid = 0;
      Log3 ($name, 4, "$name - Notification System - retrieve of remote Message File faulty: $err");
  }

  if (!$remfile) {
      $valid = 0;
      Log3 ($name, 4, "$name - Notification System - no remote Message File >$messagefile< found");
  }

  if ($valid) {
      $err = __updWriteFile ("$root/FHEM", $messagefile, $remfile);

      if ($err) {
          $valid = 0;
          Log3 ($name, 1, "$name - $err");
      }
      else {
          Log3 ($name, 4, "$name - Notification System - new Message File updated to $root/FHEM/$messagefile");
      }
  }

  $paref->{valid} = $valid;
  my $serial      = encode_base64 (Serialize ( $paref ), "");                           # Serialisierung

  $block ? return ($serial) : return \&_processMessageFile ($serial);

return;
}

###############################################################
#     Folgeroutine nach Message File aus Quelle abholen
###############################################################
sub _processMessageFile {
  my $serial = decode_base64 (shift);

  my $paref = eval { thaw ($serial) };                                                  # Deserialisierung
  my $name  = $paref->{name};
  my $valid = $paref->{valid};
  my $hash  = $defs{$name};

  if ($valid) {
      __readFileMessages ($paref);
  }

return;
}

####################################################################################################
#      Messagefile für Notification System lesen
#  Filestruktur:
#  0|SV|1
#  0|DE|Mitteilung ....
#  0|EN|Message...
#  $data{$name}{messages}{999000}{TS}:         Timestamp Stand Message File
#  $data{$name}{filemessages}{999000}{TSNEXT}: Timestamp nächster Pull Message File
####################################################################################################
sub __readFileMessages {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $tsnext = $paref->{tsnext};

  my $file   = "$root/FHEM/$messagefile";

  open my $fh, '<:encoding(UTF-8)', $file or return "Cannot open $file: $!";

  delete $data{$name}{filemessages};

  my $count = 0;
  
  while (my $line = <$fh>) {
      chomp $line;
      next if $line =~ /^\s*#/;                            # Kommentarzeilen überspringen

      my ($id, $lang, $msg) = split /\|/, $line, 3;
      next if(!isNumeric ($id));                           # nur numeric IDs
      next if($lang !~ /^(DE|EN|SV)$/xs);                  # nur gültige Sprachen            

      $data{$name}{filemessages}{$id}{$lang} = $msg;
      $count++;
  }

  close $fh;
    
  Log3 ($name, 4, "$name - Notification System - read local Message File >$messagefile< with $count entries.");
    
    
  $data{$name}{filemessages}{999000}{TS}     = time;
  $data{$name}{filemessages}{999000}{TSNEXT} = $tsnext;

return;
}

####################################################################################################
#                    Abbruchroutine BlockingCall Timeout
####################################################################################################
sub _abortGetMessageFile {
  my $hash   = shift;
  my $cause  = shift // "Timeout: process terminated";
  my $name   = $hash->{NAME};
  my $type   = $hash->{TYPE};

  Log3 ($name, 1, "$name -> BlockingCall $hash->{HELPER}{GMFRUNNING}{fn} pid:$hash->{HELPER}{AIBLOCKRUNNING}{pid} aborted: $cause");

  delete $hash->{HELPER}{GMFRUNNING};

return;
}

####################################################################################################
#             Mitteilungssystem füllen
#  Schweregrad SV:
#  0 - keine Mitteilung
#  1 - Mitteilung
#  2 - Warnung
#  3 - Fehler / Problem
#
#  Statusspeicher:
#  $data{$name}{messages}{999999}{RD}:         1 - gelesen, 0 - ungelesen
#  $data{$name}{messages}{999000}{TS}:         Timestamp Stand Message File
#  $data{$name}{filemessages}{999000}{TSNEXT}: Timestamp nächster Pull Message File
#  $data{$name}{messages}{999500}{TS}:         Timestamp Stand prepared Messages
####################################################################################################
sub fillupMessageSystem {
  my $paref = shift;
  my $hash  = $paref->{hash};
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};

  my $otxt   = q{};
  my $ntxt   = q{};
  my $midx   = 0;
  my $max_sv = 0;

  ## Aufnahme Stand für alt/neu Vergleich + Clear Messages
  ##########################################################
  for my $idx (sort keys %{$data{$name}{messages}}) {
      next if($idx >= IDXLIMIT);
      $otxt .= $data{$name}{messages}{$idx}{SV} if(defined $data{$name}{messages}{$idx}{SV});
      $otxt .= $data{$name}{messages}{$idx}{DE} if(defined $data{$name}{messages}{$idx}{DE});
      $otxt .= $data{$name}{messages}{$idx}{EN} if(defined $data{$name}{messages}{$idx}{EN});

      delete $data{$name}{messages}{$idx};
  }

  ## Messages füllen
  ########################################################################
  # Integration prepared Messages
  for my $smi (sort keys %{$data{$name}{preparedmessages}}) {
      next if($smi >= IDXLIMIT);
      $midx++;
      $data{$name}{messages}{$midx}{SV} = trim ($data{$name}{preparedmessages}{$smi}{SV});
      $data{$name}{messages}{$midx}{DE} = encode ('utf8', $data{$name}{preparedmessages}{$smi}{DE});
      $data{$name}{messages}{$midx}{EN} = encode ('utf8', $data{$name}{preparedmessages}{$smi}{EN});
  }
  
  # Integration File Messages
  for my $mfi (sort keys %{$data{$name}{filemessages}}) {
      next if($mfi >= IDXLIMIT);
      $midx++;
      $data{$name}{messages}{$midx}{SV} = trim ($data{$name}{filemessages}{$mfi}{SV});
      $data{$name}{messages}{$midx}{DE} = $data{$name}{filemessages}{$mfi}{DE};
      $data{$name}{messages}{$midx}{EN} = $data{$name}{filemessages}{$mfi}{EN};
  }

  $data{$name}{messages}{999000}{TS}     = $data{$name}{filemessages}{999000}{TS}     // 0;
  $data{$name}{messages}{999000}{TSNEXT} = $data{$name}{filemessages}{999000}{TSNEXT} // 0;
  $data{$name}{messages}{999500}{TS}     = $data{$name}{preparedmessages}{999500}{TS} // 0;


  ## Vergleich auf geänderte Messages
  #####################################
  for my $idx (sort keys %{$data{$name}{messages}}) {
      next if($idx >= IDXLIMIT);
      $ntxt .= $data{$name}{messages}{$idx}{SV} if(defined $data{$name}{messages}{$idx}{SV});
      $ntxt .= $data{$name}{messages}{$idx}{DE} if(defined $data{$name}{messages}{$idx}{DE});
      $ntxt .= $data{$name}{messages}{$idx}{EN} if(defined $data{$name}{messages}{$idx}{EN});
  }

  if ($ntxt ne $otxt) {                                                                   # es gibt neue Post! bzw. Änderungen -> Read-Bit läschen
      delete $data{$name}{messages}{999999}{RD};
  }

  if ($midx && !defined $data{$name}{messages}{999999}{RD}) {                             # RD = Read-Bit (undef -> Messages nicht gelesen)
      my @aidx   = map { $_ } (1..$midx);                                                 # größte vorhandene Severity finden ...
      my @values = map { $data{$name}{messages}{$_}{SV} } @aidx;
      $max_sv    = max(@values);
  }

  my $max_icon = $svicons{$max_sv};                                                       # ... und das dazugehörige Icon

return ($max_icon, $midx);
}

################################################################
#                Ausgabe des Mitteilungsystems
################################################################
sub outputMessages {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};

  my ($micon, $midx) = fillupMessageSystem ($paref);                                                 # Ergebnisse füllen (sind leer wenn Browser nicht refreshed)
  my $tfl            = $data{$name}{messages}{999000}{TS}                                     ?
                       (timestampToTimestring ($data{$name}{messages}{999000}{TS}, $lang))[0] :
                       'n.a.';

  my $tfn            = $data{$name}{messages}{999000}{TSNEXT}                                     ?
                       (timestampToTimestring ($data{$name}{messages}{999000}{TSNEXT}, $lang))[0] :
                       'n.a.';

  my $tpm            = $data{$name}{messages}{999500}{TS}  ?
                       (timestampToTimestring ($data{$name}{messages}{999500}{TS}, $lang))[0] :
                       'n.a.';
  ## Ausgabe
  ############
  my $out  = qq{<html>};
  $out    .= qq{<b>$hqtxt{msgsys}{$lang}</b> <br><br>};
  $out    .= qq{$hqtxt{impcha}{$lang} - <b>File:</b> $tfl ($hqtxt{scedld}{$lang}: $tfn), <b>System:</b> $tpm  <br>};
  $out    .= qq{($hqtxt{dmgsig}{$lang})  <br><br>};

  $out    .= qq{<table class="roomoverview" style="text-align:left; border:1px solid; padding:5px; border-spacing:5px; margin-left:auto; margin-right:auto;">};
  $out    .= qq{<tr style="font-weight:bold;">};
  $out    .= qq{<td style="text-decoration:underline;"> Pos.                  </td>};
  $out    .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>};
  $out    .= qq{<td style="text-decoration:underline;"> $hqtxt{msgimp}{$lang} </td>};
  $out    .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>};
  $out    .= qq{<td style="text-decoration:underline;"> $hqtxt{simsg}{$lang}  </td>};
  $out    .= qq{</tr>};
  $out    .= qq{<tr></tr>};

  my $hc = 0;

  for my $key (sort keys %{$data{$name}{messages}}) {
      next if($key >= IDXLIMIT);

      $hc++;
      #my $enmsg = encode ('utf8', $data{$name}{messages}{$key}{$lang});
      my $enmsg = $data{$name}{messages}{$key}{$lang};

      $out .= qq{<tr>};
      $out .= qq{<td style="padding: 5px; text-align: center">     $key                                       </td>};
      $out .= qq{<td style="padding: 5px;">                                                                   </td>};
      $out .= qq{<td style="padding: 5px; text-align: center">     $data{$name}{messages}{$key}{SV}           </td>};
      $out .= qq{<td style="padding: 5px;">                                                                   </td>};
      $out .= qq{<td style="padding-right: 5px; text-align: left"> $enmsg                                     </td>};
      $out .= qq{</tr>};

      if ($hc < $midx) {                                                                           # Zwischenzeile
          $out .= qq{<tr>};
          $out .= qq{<td> &nbsp; </td>};
          $out .= qq{</tr>};
      }
  }

  $out .= qq{</table>};
  $out .= qq{</html>};

  $out .= "<br>";
  $out .= $hqtxt{legimp}{$lang};

return $out;
}

#####################################################################
#    Eintritt in den KI AddInstance & Train Prozess normal/Blocking
#####################################################################
sub aiManageInstance {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  return if(!isPrepared4AI ($hash));

  delete $hash->{HELPER}{AIBLOCKRUNNING} if(defined $hash->{HELPER}{AIBLOCKRUNNING}{pid} && $hash->{HELPER}{AIBLOCKRUNNING}{pid} =~ /DEAD/xs);

  if (defined $hash->{HELPER}{AIBLOCKRUNNING}{pid}) {
      Log3 ($name, 3, qq{$name - another AI AddInstance & Training with PID "$hash->{HELPER}{AIBLOCKRUNNING}{pid}" is already running ... start Training aborted});
      return;
  }

  $hash->{HELPER}{AIBLOCKRUNNING} = BlockingCall ( "FHEM::SolarForecast::aiAddInstance",
                                                   $paref,
                                                   "FHEM::SolarForecast::aiFinishTrain",
                                                   AITRBLTO,
                                                   "FHEM::SolarForecast::aiAbortTrain",
                                                   $hash
                                                 );

  if (defined $hash->{HELPER}{AIBLOCKRUNNING}) {
      $hash->{HELPER}{AIBLOCKRUNNING}{loglevel} = 3;                                                       # Forum https://forum.fhem.de/index.php/topic,77057.msg689918.html#msg689918

      debugLog ($paref, 'aiProcess', qq{AI AddInstance & Training BlockingCall PID "$hash->{HELPER}{AIBLOCKRUNNING}{pid}" with Timeout }.AITRBLTO." s started");
  }

return;
}

################################################################
#     KI Instanz(en) aus Raw Daten Hash erzeugen
#     mit Ensemble-Algorithmus
################################################################
sub aiAddInstance {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $serial;

  if (!isPrepared4AI ($hash)) {
      my $err = CurrentVal ($hash, 'aicanuse', '');
      $serial = encode_base64 (Serialize ( { name         => $name,
                                             aitrainstate => "aiAddInstance not performed: $err",
                                             aiaddistate  => "aiAddInstance not performed: $err",
                                             aicanuse     => $err
                                           }
                                         ), "");

      return $serial;
  }

  my $cst = [gettimeofday];                                                  # Train Startzeit

  my @pvhdata;

  for my $idx (sort keys %{$data{$name}{aidectree}{airaw}}) {
      next if(!$idx);
      
      if (!AiRawdataVal ($name, $idx, 'pvrlvd', 1)) {
          debugLog ($paref, 'aiProcess', "AI Instance add - AI raw data (pvrlvd) is marked as invalid and is ignored - idx: $idx");
          next;
      }

      my $pvrl = AiRawdataVal ($name, $idx, 'pvrl', undef);
      next if(!defined $pvrl);
      
      my $hod  = AiRawdataVal ($name, $idx, 'hod', undef);
      next if(!defined $hod);

      my $rad1h = AiRawdataVal ($name, $idx, 'rad1h', 0);
      next if($rad1h <= 0);

      my $temp   = AiRawdataVal ($name, $idx, 'temp',      undef);
      my $wcc    = AiRawdataVal ($name, $idx, 'wcc',       undef);
      my $wid    = AiRawdataVal ($name, $idx, 'weatherid', undef);
      my $rr1c   = AiRawdataVal ($name, $idx, 'rr1c',      undef);
      my $sunalt = AiRawdataVal ($name, $idx, 'sunalt',        0);
      my $sunaz  = AiRawdataVal ($name, $idx, 'sunaz',         0);

      my $tbin   = temp2bin   ($temp)    if(defined $temp);
      my $cbin   = cloud2bin  ($wcc)     if(defined $wcc);
      my $sabin  = sunalt2bin ($sunalt);

      push @pvhdata, { rad1h => $rad1h, temp => $tbin, wcc => $cbin, wid => $wid, rr1c => $rr1c, sunalt => $sunalt, sunaz => $sunaz, hod => $hod, pvrl => $pvrl };
  }

  if (!scalar @pvhdata) {
      $serial = encode_base64 (Serialize ( { name         => $name,
                                             aitrainstate => "aiAddInstance not performed due to no Raw data",
                                             aiaddistate  => "aiAddInstance not performed due to no Raw data"
                                           }
                                         ), "");

      return $serial;
  }

  my $numtrees = CurrentVal ($name, 'aiTreesPV', AINUMTREES);

  for my $tn (1 .. $numtrees) {                                                 # Trainiere mehrere Entscheidungsbäume auf unterschiedlichen Stichproben
      my @sampled       = aiSampleData (\@pvhdata);
      my ($err, $dtree) = aiInit ($paref);

      if ($err) {
          Log3 ($name, 2, "$name - ERROR - AI::DecisionTree init error: $err");
          $serial = encode_base64 (Serialize ( { name         => $name,
                                                 aitrainstate => "aiAddInstance AI::DecisionTree init error: $err",
                                                 aiaddistate  => "aiAddInstance AI::DecisionTree init error: $err",
                                               }
                                             ), "");

          return $serial;
      }

      Log3 ($name, 3, "$name - AI::DecisionTree initialized") if($tn == 1);

      my $aiAddedToTrain = 0;

      for my $instance (@sampled) {
          eval { $dtree->add_instance (attributes => { rad1h  => $instance->{rad1h},
                                                       temp   => $instance->{temp},
                                                       wcc    => $instance->{wcc},
                                                       wid    => $instance->{wid},
                                                       rr1c   => $instance->{rr1c},
                                                       sunalt => $instance->{sunalt},
                                                       # sunaz  => $instance->{sunaz},
                                                       hod    => $instance->{hod}
                                                     },
                                                     result => $instance->{pvrl}
                                      );
                 1;
               }
               or do { Log3 ($name, 1, "$name - aiAddInstance ERROR: $@");
                       $serial = encode_base64 (Serialize ( { name         => $name,
                                                              aiaddistate  => $@,
                                                            }
                                                          ), "");

                       return $serial;
                     };

          $aiAddedToTrain++;

          debugLog ($paref, 'aiProcess', "AI Instance added Tree $tn - ".
                                         "hod: $instance->{hod}, ".
                                         "sunalt: $instance->{sunalt}, ".
                                         "sunaz: $instance->{sunaz}, ".
                                         "rad1h: $instance->{rad1h}, pvrl: instance->{pvrl}, ".
                                         "wcc: ".(defined $instance->{wcc}   ? $instance->{wcc}  : '-').", ".
                                         "wid: ".(defined $instance->{wid}   ? $instance->{wid}  : '-').", ".
                                         "rr1c: ".(defined $instance->{rr1c} ? $instance->{rr1c} : '-').", ".
                                         "temp: ".(defined $instance->{temp} ? $instance->{temp} : '-'),
                                         4);
      }

      debugLog ($paref, 'aiProcess', "AI Instance add - Tree: $tn -> ".$aiAddedToTrain." entities added for training ".(AttrVal ($name, 'verbose', 3) < 4 ? '(set verbose 4 for output more detail)' : ''));

      $data{$name}{aidectree}{object}{$tn}{dtree} = $dtree;
      $data{$name}{aidectree}{object}{$tn}{enum}  = $aiAddedToTrain;
  }

  $paref->{cst} = $cst;
  $serial = aiTrain ($paref);
  delete $paref->{cst};

return $serial;
}

################################################################
#     KI trainieren
################################################################
sub aiTrain {
  my $paref = shift;
  my $name  = $paref->{name};
  my $cst   = $paref->{cst};                                  # Train Startzeit

  my $hash = $defs{$name};
  my ($serial, $err);

  my $object = AiDetreeVal ($hash, 'object', undef);

  if (!$object) {
      $err    = 'no AI::DecisionTree object present';
      $serial = encode_base64 (Serialize ( {name         => $name,
                                            aitrainstate => "Train: not performed -> $err",
                                            aiinitstate  => "Init: $err",
                                            aicanuse     => 'ok'
                                           }
                                         ), "");

      return $serial;
  }

  my @ensemble;                                                                 # Erstelle das Ensemble
  my %entities;
  my $numtrees = CurrentVal ($name, 'aiTreesPV', AINUMTREES);

  for my $tn (1 .. $numtrees) {                                                 # Trainiere mehrere Entscheidungsbäume auf unterschiedlichen Stichproben
      my $dtree = $object->{$tn}{dtree};                                        # dtree Objekt
      my $enum  = $object->{$tn}{enum};                                         # Anazhl Elemente im Tree

      eval { $dtree->train();
             1;
           }
           or do { Log3 ($name, 1, "$name - aiTrain ERROR: $@");
                   $err    = (split / at/, $@)[0];
                   $serial = encode_base64 (Serialize ( {name         => $name,
                                                         aitrainstate => "Train: $err",
                                                         aicanuse     => 'ok'
                                                        }
                                                      ), "");

                   return $serial;
                 };

      push @ensemble, $dtree;

      $entities{$tn}  = $enum;
      $entities{rn}  += scalar $dtree->rule_statements();
  }
  
  $data{$name}{aidectree}{aitrained} = \@ensemble;

  $err = writeCacheToFile ($hash, 'aitrained', $aitrained.$name);
  my $rn;

  if (!$err) {
      $rn = delete $entities{rn};

      while (my ($tree, $ent) = each %entities) {
          debugLog ($paref, 'aiProcess', "AI trained Tree: $tree, number of entities: $ent");
      }

      debugLog ($paref, 'aiProcess', qq{Training instances and their associated information where purged from the AI object});
      debugLog ($paref, 'aiProcess', qq{AI trained and saved data into file: }.$aitrained.$name);
  }
  else {
      $serial = encode_base64 (Serialize ( {name         => $name,
                                            aitrainstate => "Train performed but not written -> $err",
                                            aicanuse     => 'ok'
                                           }
                                         ), "");

      return $serial;
  }

  setTimeTracking ($hash, $cst, 'runTimeTrainAI');                                                     # Zyklus-Laufzeit ermitteln

  $serial = encode_base64 (Serialize ( {name                => $name,
                                        aitrainstate        => 'ok',
                                        runTimeTrainAI      => CurrentVal ($hash, 'runTimeTrainAI', ''),
                                        aitrainLastFinishTs => int time,
                                        aiRulesNumber       => $rn,                                    # Returns a list of strings that describe the tree in rule-form
                                        aicanuse            => 'ok',
                                        aiaddistate         => 'ok'
                                       }
                                     )
                                     , "");

return $serial;
}

###############################################################
#    Restaufgaben nach AI Train
###############################################################
sub aiFinishTrain {
  my $serial = decode_base64 (shift);

  my $paref = eval { thaw ($serial) };                                             # Deserialisierung
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $aicanuse        = $paref->{aicanuse};
  my $aitrainstate    = $paref->{aitrainstate};
  my $runTimeTrainAI  = $paref->{runTimeTrainAI};
  my $aiinitstate     = $paref->{aiinitstate};
  my $aitrainFinishTs = $paref->{aitrainLastFinishTs};
  my $aiRulesNumber   = $paref->{aiRulesNumber};
  my $aiaddistate     = $paref->{aiaddistate} // 'ok';

  delete $data{$name}{circular}{99}{aiRulesNumber};

  $data{$name}{current}{aicanuse}                 = $aicanuse;
  $data{$name}{current}{aitrainstate}             = $aitrainstate;
  $data{$name}{current}{aiaddistate}              = $aiaddistate;
  $data{$name}{current}{aiinitstate}              = $aiinitstate     if(defined $aiinitstate);
  $data{$name}{circular}{99}{runTimeTrainAI}      = $runTimeTrainAI  if(defined $runTimeTrainAI);  # !! in Circular speichern um zu persistieren, setTimeTracking speichert zunächst in Current !!
  $data{$name}{circular}{99}{aitrainLastFinishTs} = $aitrainFinishTs if(defined $aitrainFinishTs);
  $data{$name}{circular}{99}{aiRulesNumber}       = $aiRulesNumber   if(defined $aiRulesNumber);

  if ($aitrainstate eq 'ok') {
      readCacheFile ({ name      => $name,
                       file      => $aitrained.$name,
                       cachename => 'aitrained',
                       title     => 'aiTrainedData'
                     }
                    );
  }

  $paref->{debug} = getDebug ($hash);

  if (defined $hash->{HELPER}{AIBLOCKRUNNING}) {
      debugLog ($paref, 'aiProcess', qq{AI Training BlockingCall PID "$hash->{HELPER}{AIBLOCKRUNNING}{pid}" finished, state: $aitrainstate});
      delete($hash->{HELPER}{AIBLOCKRUNNING});
  }
  else {
      debugLog ($paref, 'aiProcess', qq{AI Training finished, state: $aitrainstate});
  }

return;
}

####################################################################################################
#                    Abbruchroutine BlockingCall Timeout
####################################################################################################
sub aiAbortTrain {
  my $hash  = shift;
  my $cause = shift // "Timeout: process terminated";
  my $name  = $hash->{NAME};

  Log3 ($name, 1, "$name -> BlockingCall $hash->{HELPER}{AIBLOCKRUNNING}{fn} pid:$hash->{HELPER}{AIBLOCKRUNNING}{pid} aborted: $cause");

  delete $hash->{HELPER}{AIBLOCKRUNNING};

  $data{$name}{current}{aitrainstate}   = 'Traing (Child) process timed out';

return;
}

################################################################
#     AI Ergebnis AI::DecisionTree für ermitteln
################################################################
sub aiGetResult {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $hod    = $paref->{hod};
  my $nhtstr = $paref->{nhtstr};

  my $hash = $defs{$name};

  return 'AI usage is not prepared' if(!isPrepared4AI ($hash, 'full'));

  my $objref = AiDetreeVal ($hash, 'aitrained', '');
  return 'AI trained object is missed or not an ARRAY' if(ref $objref ne 'ARRAY');

  my $rad1h = NexthoursVal ($hash, $nhtstr, 'rad1h', 0);
  return "no rad1h for hod: $hod" if($rad1h <= 0);

  my $cst = [gettimeofday];                                                         # Startzeit

  debugLog ($paref, 'aiData', "Start AI result check for hod: $hod");

  my $wcc    = NexthoursVal ($hash, $nhtstr, 'wcc',       0);
  my $wid    = NexthoursVal ($name, $nhtstr, 'weatherid', 0);
  my $rr1c   = NexthoursVal ($hash, $nhtstr, 'rr1c',      0);
  my $temp   = NexthoursVal ($hash, $nhtstr, 'temp',     20);
  my $sunalt = NexthoursVal ($hash, $nhtstr, 'sunalt',    0);
  my $sunaz  = NexthoursVal ($hash, $nhtstr, 'sunaz',     0);

  my $tbin  = temp2bin   ($temp);
  my $cbin  = cloud2bin  ($wcc);
  my $sabin = sunalt2bin ($sunalt);

  my $new_data = {                                                                 # Prognose für neue Daten
      rad1h  => $rad1h,
      temp   => $tbin,
      wcc    => $cbin,
      wid    => $wid,
      rr1c   => $rr1c,
      sunalt => $sabin,
      # sunaz  => $sunaz,
      hod    => $hod
  };

  ## Accurate Decision
  ######################
  my @total_prediction;
  my $tn = 0;

  for my $dtree (@{$objref}) {
      $tn++;
      my $res;

      eval { $res = $dtree->get_result (attributes => $new_data);
             push @total_prediction, $res if(defined $res);
             1;
           }
           or do { Log3 ($name, 1, "$name - aiGetResult ERROR: $@");
                   return $@;
                 };

      debugLog ($paref, 'aiData', "got AI result from Tree number $tn: $res") if(defined $res);
  }

  my $tprnum = scalar @total_prediction;

  if ($tprnum) {
      my $avg_prediction = sprintf '%.0f', avgArray (\@total_prediction, $tprnum);

      debugLog ($paref, 'aiData', qq{AI accurate result found: pvaifc: $avg_prediction (hod: $hod, sunaz: $sunaz, sunalt: $sabin, Rad1h: $rad1h, wcc: $wcc, rr1c: $rr1c, temp: $tbin)});
      return ('accurate', $avg_prediction);
  }

  setTimeTracking ($hash, $cst, 'aiLastGetResultTime');                      # Laufzeit ermitteln

return 'No AI decision delivered';
}

################################################################
#     KI initialisieren
################################################################
sub aiInit {                   ## no critic "not used"
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  if (!isPrepared4AI ($hash)) {
      delete $data{$name}{circular}{99}{aiRulesNumber};
      delete $data{$name}{circular}{99}{runTimeTrainAI};
      delete $data{$name}{circular}{99}{aitrainLastFinishTs};

      my $err = CurrentVal ($hash, 'aicanuse', '');

      debugLog ($paref, 'aiProcess', $err);

      $data{$name}{current}{aiinitstate} = $err;
      return ($err);
  }

  my $dtree = new AI::DecisionTree ( verbose => 0, noise_mode => 'pick_best' );
  $data{$name}{current}{aiinitstate} = 'ok';

return ('', $dtree);
}

################################################################
#    Daten der Raw Datensammlung hinzufügen
################################################################
sub aiAddRawData {
  my $paref    = shift;
  my $name     = $paref->{name};
  my $yday     = $paref->{yday};                                             # vorheriger Tag (falls gesetzt)
  my $day      = $paref->{day} // strftime "%d",  localtime(time);           # aktueller Tag (range 01 to 31)
  my $ood      = $paref->{ood} // 0;                                         # only one (current) day
  my $rho      = $paref->{rho};                                              # only this hour of day
  my $dayname  = $paref->{dayname};
  my $ydayname = $paref->{ydayname};

  my $hash = $defs{$name};

  delete $data{$name}{current}{aitrawstate};

  my $err;
  my $dosave = 0;

  $day     = $yday     if(defined $yday);                                    # der vergangene Tag soll verarbeitet werden
  $dayname = $ydayname if(defined $ydayname);                                # Name des Vortages

  for my $pvd (sort keys %{$data{$name}{pvhist}}) {
      next if(!$pvd);

      if ($ood) {
          next if($pvd ne $day);
      }

      last if(int $pvd > int $day);

      if (!$ood) {                                                           # V 1.47.2 -> für manuelles Auffüllen mit Setter
          $dayname = HistoryVal ($hash, $pvd, 99, 'dayname', undef);
      }

      for my $hod (sort keys %{$data{$name}{pvhist}{$pvd}}) {
          next if(!$hod || $hod eq '99' || ($rho && $hod ne $rho));

          my $ridx   = _aiMakeIdxRaw ($pvd, $hod, $paref->{yt});

          my $temp   = HistoryVal ($hash, $pvd, $hod, 'temp',      undef);
          my $sunalt = HistoryVal ($hash, $pvd, $hod, 'sunalt',        0);
          my $sunaz  = HistoryVal ($hash, $pvd, $hod, 'sunaz',         0);
          my $con    = HistoryVal ($hash, $pvd, $hod, 'con',       undef);
          my $gcons  = HistoryVal ($name, $pvd, $hod, 'gcons',     undef);
          my $wcc    = HistoryVal ($hash, $pvd, $hod, 'wcc',       undef);
          my $wid    = HistoryVal ($hash, $pvd, $hod, 'weatherid', undef);            # Wetter ID
          my $rr1c   = HistoryVal ($hash, $pvd, $hod, 'rr1c',      undef);
          my $rad1h  = HistoryVal ($hash, $pvd, $hod, 'rad1h',     undef);
          my $pvrlvd = HistoryVal ($hash, $pvd, $hod, 'pvrlvd',        1);            # PV Generation valide?
          my $pvrl   = HistoryVal ($hash, $pvd, $hod, 'pvrl',      undef);

          $data{$name}{aidectree}{airaw}{$ridx}{sunalt}    = $sunalt;
          $data{$name}{aidectree}{airaw}{$ridx}{sunaz}     = $sunaz;
          $data{$name}{aidectree}{airaw}{$ridx}{dayname}   = $dayname;
          $data{$name}{aidectree}{airaw}{$ridx}{hod}       = $hod;
          $data{$name}{aidectree}{airaw}{$ridx}{temp}      = sprintf "%.0f", $temp            if(defined $temp);
          $data{$name}{aidectree}{airaw}{$ridx}{con}       = $con                             if(defined $con   && $con   >= 0);
          $data{$name}{aidectree}{airaw}{$ridx}{gcons}     = $gcons                           if(defined $gcons && $gcons >= 0);
          $data{$name}{aidectree}{airaw}{$ridx}{wcc}       = $wcc                             if(defined $wcc);
          $data{$name}{aidectree}{airaw}{$ridx}{weatherid} = $wid >= 100 ? $wid - 100 : $wid  if(defined $wid);
          $data{$name}{aidectree}{airaw}{$ridx}{rr1c}      = $rr1c                            if(defined $rr1c);
          $data{$name}{aidectree}{airaw}{$ridx}{rad1h}     = $rad1h                           if(defined $rad1h && $rad1h > 0);
          $data{$name}{aidectree}{airaw}{$ridx}{pvrl}      = $pvrl                            if(defined $pvrl  && $pvrl  > 0);
          $data{$name}{aidectree}{airaw}{$ridx}{pvrlvd}    = $pvrlvd;
          
          $dosave++;

          debugLog ($paref, 'aiProcess', "AI raw add - idx: $ridx, day: $pvd, hod: $hod, sunalt: $sunalt, sunaz: $sunaz, rad1h: ".(defined $rad1h ? $rad1h : '-').", pvrl: ".(defined $pvrl ? $pvrl : '-').", con: ".(defined $con ? $con : '-').", wcc: ".(defined $wcc ? $wcc : '-').", rr1c: ".(defined $rr1c ? $rr1c : '-').", temp: ".(defined $temp ? $temp : '-'), 4);
      }
  }

  debugLog ($paref, 'aiProcess', "AI raw add - $dosave entities added to raw data pool ".(AttrVal ($name, 'verbose', 3) != 4 ? '(set verbose 4 for output more detail)' : ''));

  if ($dosave) {
      $err = writeCacheToFile ($hash, 'airaw', $airaw.$name);

      if (!$err) {
          $data{$name}{current}{aitrawstate} = 'ok';
          debugLog ($paref, 'aiProcess', "AI raw data saved into file: ".$airaw.$name);
      }
  }

return;
}

################################################################
#    Daten aus Raw Datensammlung löschen welche die maximale
#    Haltezeit (Tage) überschritten haben
################################################################
sub aiDelRawData {
  my $paref = shift;
  my $name  = $paref->{name};

  my $hash = $defs{$name};

  if (!keys %{$data{$name}{aidectree}{airaw}}) {
      return;
  }

  my $hd   = CurrentVal ($name, 'aiStorageDuration', AISTDUDEF);                # Haltezeit KI Raw Daten (Tage)
  my $ht   = time - ($hd * 86400);
  my $day  = strftime "%d", localtime($ht);
  my $didx = _aiMakeIdxRaw ($day, '00', $ht);                                   # Daten mit idx <= $didx löschen

  debugLog ($paref, 'aiProcess', qq{AI Raw delete data equal or less than index >$didx<});

  delete $data{$name}{current}{aitrawstate};

  my ($err, $dosave);

  for my $idx (sort keys %{$data{$name}{aidectree}{airaw}}) {
      next if(!$idx || $idx > $didx);
      delete $data{$name}{aidectree}{airaw}{$idx};

      $dosave = 1;

      debugLog ($paref, 'aiProcess', qq{AI Raw data deleted - idx: $idx});
  }

  if ($dosave) {
      $err = writeCacheToFile ($hash, 'airaw', $airaw.$name);

      if (!$err) {
          $data{$name}{current}{aitrawstate} = 'ok';
          debugLog ($paref, 'aiProcess', qq{AI raw data saved into file: }.$airaw.$name);
      }
  }

return;
}

################################################################
#  den Index für AI raw Daten erzeugen
################################################################
sub _aiMakeIdxRaw {
  my $day = shift;
  my $hod = shift;
  my $t   = shift // time;

  my $ridx = strftime "%Y%m", localtime($t);
  $ridx   .= $day.$hod;

return $ridx;
}

################################################################
#     Hilfsfunktion zum Erstellen einer Stichprobe
################################################################
sub aiSampleData {
  my $data        = shift;
  my @shuffled    = shuffle @$data;
  my $sample_size = int (scalar (@$data) * 0.8);

return @shuffled[0 .. $sample_size - 1];                                  # Teilmenge zurückgeben
}

################################################################
# einen Schlüssel-Wert in die pvHistory schreiben
# $valid - Wert für Valid-Key festgelegt in $hfspvh Hash
# z.B. pvrlvd = 1: beim Learning berücksichtigen, 0: nicht
################################################################
sub writeToHistory {
  my $ph    = shift;
  my $paref = $ph->{paref};
  my $key   = $ph->{key};
  my $val   = $ph->{val};
  my $hour  = $ph->{hour};
  my $valid = $ph->{valid};

  $paref->{val}      = $val;
  $paref->{nhour}    = sprintf "%02d", $hour;
  $paref->{histname} = $key;

  if (defined $hfspvh{$key}{validkey}) {
      $paref->{$hfspvh{$key}{validkey}} = $valid;
  }

  setPVhistory ($paref);

  delete $paref->{histname};
  delete $paref->{nhour};
  delete $paref->{val};
  delete $paref->{$hfspvh{$key}{validkey}} if(defined $hfspvh{$key}{validkey});

return;
}

################################################################
#   History-Hash verwalten
################################################################
sub setPVhistory {
  my $paref     = shift;
  my $name      = $paref->{name};
  my $type      = $paref->{type};
  my $day       = $paref->{day};
  my $dayname   = $paref->{dayname};                                       # aktueller Wochentagsname
  my $nhour     = $paref->{nhour};                                         # Stunde des Tages
  my $histname  = $paref->{histname};
  my $val       = $paref->{val};                                           # Wert zur Speicherung in pvHistory (soll mal generell verwendet werden -> Change)
  my $reorg     = $paref->{reorg}     // 0;                                # Neuberechnung von Werten in Stunde "99" nach Löschen von Stunden eines Tages
  my $reorgday  = $paref->{reorgday}  // q{};                              # Tag der reorganisiert werden soll

  my $hash = $defs{$name};

  $data{$name}{pvhist}{$day}{99}{dayname} = $dayname if($day);

  if ($hfspvh{$histname} && defined &{$hfspvh{$histname}{fn}}) {
      &{$hfspvh{$histname}{fn}} ($paref);
      return;
  }

  if ($histname =~ /csm[et][0-9]+$/xs) {                                                         # Verbrauch eines Verbrauchers
      $data{$name}{pvhist}{$day}{$nhour}{$histname} = $val;

      if ($histname =~ /csme[0-9]+$/xs) {
          my $sum = 0;

          for my $k (keys %{$data{$name}{pvhist}{$day}}) {
              next if($k eq "99");
              my $csme = HistoryVal ($hash, $day, $k, "$histname", 0);
              next if(!$csme);

              $sum += $csme;
          }

          $data{$name}{pvhist}{$day}{99}{$histname} = sprintf "%.2f", $sum;
      }
  }

  if ($histname =~ /minutescsm[0-9]+$/xs) {                                                        # Anzahl Aktivminuten des Verbrauchers
      $data{$name}{pvhist}{$day}{$nhour}{$histname} = $val;
      my $minutes = 0;
      my $num     = substr ($histname,10,2);

      for my $k (keys %{$data{$name}{pvhist}{$day}}) {
          next if($k eq "99");
          my $csmm = HistoryVal ($hash, $day, $k, "$histname", 0);
          next if(!$csmm);

          $minutes += $csmm;
      }

      my $cycles = HistoryVal ($hash, $day, 99, "cyclescsm${num}", 0);

      if ($cycles) {
          $data{$name}{pvhist}{$day}{99}{"hourscsme${num}"}     = sprintf "%.2f", ($minutes / 60 );
          $data{$name}{pvhist}{$day}{99}{"avgcycmntscsm${num}"} = sprintf "%.2f", ($minutes / $cycles);
      }
  }

  if ($histname =~ /cyclescsm[0-9]+$/xs) {                                                        # Anzahl Tageszyklen des Verbrauchers
      $data{$name}{pvhist}{$day}{99}{$histname} = $val;
  }

  if ($reorg) {                                                                                   # Reorganisation Stunde "99"
      if (!$reorgday) {
         Log3 ($name, 1, "$name - ERROR reorg pvHistory - the day of reorganization is invalid or empty: >$reorgday<");
         return;
      }

      my ($r3, $r4, $r5, $r6, $r7, $r8) = (0,0,0,0,0,0);
      my $ien = {};                                                                               # Hashref Inverter energy
      my $pen = {};                                                                               # Hashref Producer energy
      my $bin = {};
      my $bot = {};

      for my $k (keys %{$data{$name}{pvhist}{$reorgday}}) {
          next if($k eq "99");

          $r3 += HistoryVal ($hash, $reorgday, $k, 'pvrl',    0);
          $r4 += HistoryVal ($hash, $reorgday, $k, 'pvfc',    0);
          $r5 += HistoryVal ($hash, $reorgday, $k, 'confc',   0);
          $r6 += HistoryVal ($hash, $reorgday, $k, 'gcons',   0);
          $r7 += HistoryVal ($hash, $reorgday, $k, 'gfeedin', 0);
          $r8 += HistoryVal ($hash, $reorgday, $k, 'con',     0);

          ## Reorg Inverter
          ##################
          for my $in (1..MAXINVERTER) {
              $in   = sprintf "%02d", $in;
              my $e = HistoryVal ($hash, $reorgday, $k, 'pvrl'.$in, undef);
              $ien->{$in} += $e if(defined $e);
          }

          ## Reorg Producer
          ##################
          for my $pn (1..MAXPRODUCER) {
              $pn   = sprintf "%02d", $pn;
              my $e = HistoryVal ($hash, $reorgday, $k, 'pprl'.$pn, undef);
              $pen->{$pn} += $e if(defined $e);
          }

          ## Reorg Battery
          ##################
          for my $bn (1..MAXBATTERIES) {
              $bn   = sprintf "%02d", $bn;
              my $bi = HistoryVal ($hash, $reorgday, $k, 'batin'.$bn,  undef);
              my $bo = HistoryVal ($hash, $reorgday, $k, 'batout'.$bn, undef);
              $bin->{$bn} += $bi if(defined $bi);
              $bot->{$bn} += $bo if(defined $bo);
          }
      }

      $data{$name}{pvhist}{$reorgday}{99}{pvrl}    = $r3;
      $data{$name}{pvhist}{$reorgday}{99}{pvfc}    = $r4;
      $data{$name}{pvhist}{$reorgday}{99}{confc}   = $r5;
      $data{$name}{pvhist}{$reorgday}{99}{gcons}   = $r6;
      $data{$name}{pvhist}{$reorgday}{99}{gfeedin} = $r7;
      $data{$name}{pvhist}{$reorgday}{99}{con}     = $r8;

      for my $in (keys %{$ien}) {
          $data{$name}{pvhist}{$reorgday}{99}{'pvrl'.$in} = $ien->{$in};
      }

      for my $pn (keys %{$pen}) {
          $data{$name}{pvhist}{$reorgday}{99}{'pprl'.$pn} = $pen->{$pn};
      }

      for my $bn (keys %{$bin}) {
          $data{$name}{pvhist}{$reorgday}{99}{'batin'.$bn}  = $bin->{$bn};
          $data{$name}{pvhist}{$reorgday}{99}{'batout'.$bn} = $bot->{$bn};
      }

      debugLog ($paref, 'saveData2Cache', "setPVhistory -> Day >$reorgday< reorganized keys: batinXX, batoutXX, pvrl, pvfc, con, confc, gcons, gfeedin, pvrlXX, pprlXX");
  }

  if ($histname) {
      debugLog ($paref, 'saveData2Cache', "setPVhistory -> store Day: $day, Hour of Day: $nhour, Key: $histname, Value: ".(defined $val ? $val : 'undef'));
  }

return;
}

################################################################
# Wert mit optional weiteren Berechnungen in pvHistory speichen
################################################################
sub _storeVal {                    ## no critic "not used"
  my $paref    = shift;
  my $name     = $paref->{name};
  my $type     = $paref->{type};
  my $day      = $paref->{day};
  my $nhour    = $paref->{nhour};
  my $histname = $paref->{histname};
  my $val      = $paref->{val};

  my $hash  = $defs{$name};
  my $store = $hfspvh{$histname}{storname};
  my ($validkey, $validval);

  $data{$name}{pvhist}{$day}{$nhour}{$store} = $val;

  if (defined $hfspvh{$histname}{validkey}) {                            # 1: bestimmter Eintrag wird intern für Prozesse (z.B. Lernprozess) berücksichtigt oder nicht (0)
      $validkey = $hfspvh{$histname}{validkey};
      $validval = $paref->{$validkey};
      $data{$name}{pvhist}{$day}{$nhour}{$validkey} = $validval;
  }

  debugLog ($paref, 'saveData2Cache', "setPVhistory -> stored simple  - Day: $day, Hour: $nhour, Key: $store, Value: ".(defined $val ? $val : 'undef').
                                      (defined $validkey ? ", ValidKey: $validkey, ValidValue: $validval" : '') );

  if (defined $hfspvh{$histname}{fpar} && $hfspvh{$histname}{fpar} eq 'comp99') {
      my $sum = 0;
      for my $k (keys %{$data{$name}{pvhist}{$day}}) {
          next if($k eq '99');
          $sum += HistoryVal ($hash, $day, $k, $store, 0);
      }

       $data{$name}{pvhist}{$day}{99}{$store} = $sum;

       debugLog ($paref, 'saveData2Cache', "setPVhistory -> stored compute - Day: $day, Hour: 99, Key: $store, Value: $sum");
  }

return;
}

################################################################
#           liefert aktuelle Einträge des in $htol
#           angegebenen internen Hash
################################################################
sub listDataPool {
  my $hash = shift;
  my $htol = shift;
  my $par  = shift // q{};

  my $name = $hash->{NAME};
  my ($sq, $h);

  if ($htol eq "pvhist") {
      $sq = _listDataPoolPvHist ($hash, $par);
  }

  if ($htol =~ /consumers|inverters|producers|strings|batteries/xs) {
      $sq = _listDataPoolVarious ($hash, $htol, $par);
  }

  if ($htol eq "circular") {
      $sq = _listDataPoolCircular ($hash, $par);
  }

  if ($htol eq "nexthours") {
      $sq = _listDataPoolNextHours ($name, $par);
  }

  if ($htol eq "qualities") {
      $sq = _listDataPoolQualities ($name, $par);
  }

  if ($htol eq "current") {
      $sq = _listDataPoolCurrent ($name, $par);
  }

  if ($htol =~ /radiationApiData|weatherApiData|statusApiData/xs) {
      $sq = _listDataPoolApiData ($name, $htol, $par);
  }

  if ($htol eq "aiRawData") {
      $sq = _listDataPoolAiRawData ($name, $par);
  }

return $sq;
}

################################################################
#            Listing des pvHistory Speichers
################################################################
sub _listDataPoolPvHist {
  my $hash = shift;
  my $par  = shift // q{};

  my $name = $hash->{NAME};

  my ($sq, $h, $hexp);
  my $export = q{};

  if ($par eq 'exportToCsv') {
      $export = 'csv';
      $par    = q{};
  }

  my $sub = sub {
      my $day = shift;
      my $ret;

      for my $key (sort {$a<=>$b} keys %{$h->{$day}}) {
          my $pvrl         = HistoryVal ($name, $day, $key, 'pvrl',         '-');
          my $pvrlvd       = HistoryVal ($name, $day, $key, 'pvrlvd',       '-');
          my $pvfc         = HistoryVal ($name, $day, $key, 'pvfc',         '-');
          my $pvapifcraw   = HistoryVal ($name, $day, $key, 'pvapifcraw',   '-');
          my $gcons        = HistoryVal ($name, $day, $key, 'gcons',        '-');
          my $con          = HistoryVal ($name, $day, $key, 'con',          '-');
          my $confc        = HistoryVal ($name, $day, $key, 'confc',        '-');
          my $gfeedin      = HistoryVal ($name, $day, $key, 'gfeedin',      '-');
          my $wid          = HistoryVal ($name, $day, $key, 'weatherid',    '-');
          my $wcc          = HistoryVal ($name, $day, $key, 'wcc',          '-');
          my $rr1c         = HistoryVal ($name, $day, $key, 'rr1c',         '-');
          my $temp         = HistoryVal ($name, $day, $key, 'temp',       undef);
          my $pvcorrf      = HistoryVal ($name, $day, $key, 'pvcorrf',      '-');
          my $dayname      = HistoryVal ($name, $day, $key, 'dayname',    undef);
          my $rad1h        = HistoryVal ($name, $day, $key, 'rad1h',        '-');
          my $sunaz        = HistoryVal ($name, $day, $key, 'sunaz',        '-');
          my $sunalt       = HistoryVal ($name, $day, $key, 'sunalt',       '-');
          my $don          = HistoryVal ($name, $day, $key, 'DoN',          '-');
          my $conprc       = HistoryVal ($name, $day, $key, 'conprice',     '-');
          my $feedprc      = HistoryVal ($name, $day, $key, 'feedprice',    '-');
          my $socprogwhsum = HistoryVal ($name, $day, $key, 'socprogwhsum', '-');
          my $socwhsum     = HistoryVal ($name, $day, $key, 'socwhsum',     '-');
          my $pd           = HistoryVal ($name, $day, $key, 'plantderated', '-');

          if ($export eq 'csv') {
              $hexp->{$day}{$key}{PVreal}              = $pvrl;
              $hexp->{$day}{$key}{PVrealValid}         = $pvrlvd;
              $hexp->{$day}{$key}{PVforecast}          = $pvfc;
              $hexp->{$day}{$key}{PVapiForecastRaw}    = $pvapifcraw;
              $hexp->{$day}{$key}{GridConsumption}     = $gcons;
              $hexp->{$day}{$key}{Consumption}         = $con;
              $hexp->{$day}{$key}{confc}               = $confc;
              $hexp->{$day}{$key}{GridFeedIn}          = $gfeedin;
              $hexp->{$day}{$key}{WeatherId}           = $wid;
              $hexp->{$day}{$key}{CloudCover}          = $wcc;
              $hexp->{$day}{$key}{TotalPrecipitation}  = $rr1c;
              $hexp->{$day}{$key}{Temperature}         = $temp    // '';
              $hexp->{$day}{$key}{PVCorrectionFactor}  = $pvcorrf eq '-' ? '' : (split "/", $pvcorrf)[0];
              $hexp->{$day}{$key}{Quality}             = $pvcorrf eq '-' ? '' : (split "/", $pvcorrf)[1];
              $hexp->{$day}{$key}{DayName}             = $dayname // '';
              $hexp->{$day}{$key}{GlobalRadiation }    = $rad1h;
              $hexp->{$day}{$key}{SunAzimuth}          = $sunaz;
              $hexp->{$day}{$key}{SunAltitude}         = $sunalt;
              $hexp->{$day}{$key}{DayOrNight}          = $don;
              $hexp->{$day}{$key}{PurchasePrice}       = $conprc;
              $hexp->{$day}{$key}{FeedInPrice}         = $feedprc;
              $hexp->{$day}{$key}{BatterySocWhSum}     = $socwhsum;
              $hexp->{$day}{$key}{BatteryProgSocWhSum} = $socprogwhsum;
              $hexp->{$day}{$key}{PlantDerated}        = $pd;
          }

          my ($inve, $invl);
          for my $in (1..MAXINVERTER) {                                              # + alle Inverter
              $in       = sprintf "%02d", $in;
              my $etoti = HistoryVal ($name, $day, $key, 'etotali'.$in, '-');
              my $pvrli = HistoryVal ($name, $day, $key, 'pvrl'.$in,    '-');

              if ($export eq 'csv') {
                  $hexp->{$day}{$key}{"Etotal${in}"} = $etoti;
                  $hexp->{$day}{$key}{"PVreal${in}"} = $pvrli;
              }

              $inve .= ', ' if($inve);
              $inve .= "etotali${in}: $etoti";
              $invl .= ', ' if($invl);
              $invl .= "pvrl${in}: $pvrli";
          }

          my ($prde, $prdl);
          for my $pn (1..MAXPRODUCER) {                                              # + alle Producer
              $pn       = sprintf "%02d", $pn;
              my $etotp = HistoryVal ($name, $day, $key, 'etotalp'.$pn, '-');
              my $pprl  = HistoryVal ($name, $day, $key, 'pprl'.$pn,    '-');

              if ($export eq 'csv') {
                  $hexp->{$day}{$key}{"Etotal${pn}"} = $etotp;
                  $hexp->{$day}{$key}{"PPreal${pn}"} = $pprl;
              }

              $prde .= ', ' if($prde);
              $prde .= "etotalp${pn}: $etotp";
              $prdl .= ', ' if($prdl);
              $prdl .= "pprl${pn}: $pprl";
          }

          my ($btotin, $batin, $btotout, $batout, $batmsoc, $batssoc, $batprogsoc, $batsoc, $lcintime, $lcstrategy);
          for my $bn (1..MAXBATTERIES) {                                            # + alle Batterien
              $bn             = sprintf "%02d", $bn;
              my $hbtotin     = HistoryVal ($name, $day, $key, 'batintotal'.$bn,  '-');
              my $hbtotout    = HistoryVal ($name, $day, $key, 'batouttotal'.$bn, '-');
              my $hbatin      = HistoryVal ($name, $day, $key, 'batin'.$bn,       '-');
              my $hbatout     = HistoryVal ($name, $day, $key, 'batout'.$bn,      '-');
              my $hbatmsoc    = HistoryVal ($name, $day, $key, 'batmaxsoc'.$bn,   '-');
              my $hbatssoc    = HistoryVal ($name, $day, $key, 'batsetsoc'.$bn,   '-');
              my $hbatprogsoc = HistoryVal ($name, $day, $key, 'batprogsoc'.$bn,  '-');
              my $hbatsoc     = HistoryVal ($name, $day, $key, 'batsoc'.$bn,      '-');
              my $intime      = HistoryVal ($name, $day, $key, 'lcintimebat'.$bn, '-');
              my $strategy    = HistoryVal ($name, $day, $key, 'strategybat'.$bn, '-');

              if ($export eq 'csv') {
                  $hexp->{$day}{$key}{"BatteryInTotal${bn}"}  = $hbtotin;
                  $hexp->{$day}{$key}{"BatteryOutTotal${bn}"} = $hbtotout;
                  $hexp->{$day}{$key}{"BatteryIn${bn}"}       = $hbatin;
                  $hexp->{$day}{$key}{"BatteryOut${bn}"}      = $hbatout;
                  $hexp->{$day}{$key}{"BatteryMaxSoc${bn}"}   = $hbatmsoc;
                  $hexp->{$day}{$key}{"BatterySetSoc${bn}"}   = $hbatssoc;
                  $hexp->{$day}{$key}{"BatteryProgSoc${bn}"}  = $hbatprogsoc;
                  $hexp->{$day}{$key}{"BatterySoc${bn}"}      = $hbatsoc;
                  $hexp->{$day}{$key}{"BatteryLCinTime${bn}"} = $intime;
                  $hexp->{$day}{$key}{"BatteryStrategy${bn}"} = $strategy;
              }

              $btotin     .= ', ' if($btotin);
              $btotin     .= "batintotal${bn}: $hbtotin";
              $btotout    .= ', ' if($btotout);
              $btotout    .= "batouttotal${bn}: $hbtotout";
              $batin      .= ', ' if($batin);
              $batin      .= "batin${bn}: $hbatin";
              $batout     .= ', ' if($batout);
              $batout     .= "batout${bn}: $hbatout";
              $batmsoc    .= ', ' if($batmsoc);
              $batmsoc    .= "batmaxsoc${bn}: $hbatmsoc";
              $batssoc    .= ', ' if($batssoc);
              $batssoc    .= "batsetsoc${bn}: $hbatssoc";
              $batprogsoc .= ', ' if($batprogsoc);
              $batprogsoc .= "batprogsoc${bn}: $hbatprogsoc";
              $batsoc     .= ', ' if($batsoc);
              $batsoc     .= "batsoc${bn}: $hbatsoc";
              $lcintime   .= ', ' if($lcintime);
              $lcintime   .= "lcintimebat${bn}: $intime";
              $lcstrategy .= ', ' if($lcstrategy);
              $lcstrategy .= "strategybat${bn}: $strategy";
          }

          $ret .= "\n      " if($ret);
          $ret .= $key." => ";
          $ret .= "pvapifcraw: $pvapifcraw, pvfc: $pvfc, pvrl: $pvrl, pvrlvd: $pvrlvd, plantderated: $pd, rad1h: $rad1h";
          $ret .= "\n            ";
          $ret .= $inve            if($inve && $key ne '99');
          $ret .= "\n            " if($inve && $key ne '99');
          $ret .= $invl            if($invl);
          $ret .= "\n            " if($invl);
          $ret .= $prde            if($prde && $key ne '99');
          $ret .= "\n            " if($prde && $key ne '99');
          $ret .= $prdl            if($prdl);
          $ret .= "\n            " if($prdl);
          $ret .= "confc: $confc, con: $con, gcons: $gcons, conprice: $conprc";
          $ret .= "\n            ";
          $ret .= "gfeedin: $gfeedin, feedprice: $feedprc";
          $ret .= "\n            ";
          $ret .= "DoN: $don, sunaz: $sunaz, sunalt: $sunalt";
          $ret .= "\n            ";

          $ret .= $btotin                                        if($key ne '99');
          $ret .= "\n            "                               if($key ne '99');
          $ret .= $btotout                                       if($key ne '99');
          $ret .= "\n            "                               if($key ne '99');

          $ret .= $batprogsoc.", socprogwhsum: $socprogwhsum"    if($key ne '99');
          $ret .= "\n            "                               if($key ne '99');
          $ret .= $batsoc.", socwhsum: $socwhsum"                if($key ne '99');
          $ret .= "\n            "                               if($key ne '99');
          $ret .= $lcintime                                      if($key ne '99');
          $ret .= "\n            "                               if($key ne '99');
          $ret .= $lcstrategy                                    if($key ne '99');
          $ret .= "\n            "                               if($key ne '99');
          
          $ret .= $batin;
          $ret .= "\n            ";
          $ret .= $batout;
          $ret .= "\n            ";

          $ret .= $batmsoc                                       if($key eq '99');
          $ret .= "\n            "                               if($key eq '99');
          $ret .= $batssoc                                       if($key eq '99');
          $ret .= "\n            "                               if($key eq '99');

          if ($key ne '99') {
              $ret .= "weatherid: $wid, ";
              $ret .= "wcc: $wcc, ";
              $ret .= "rr1c: $rr1c, ";
              $ret .= "pvcorrf: $pvcorrf ";
          }

          $ret .= "temp: $temp, "       if($temp);
          $ret .= "dayname: $dayname, " if($dayname);

          my $csm;
          for my $c (1..MAXCONSUMER) {                                                      # + alle Consumer
              $c       = sprintf "%02d", $c;
              my $nl   = 0;
              my $csmc = HistoryVal ($name, $day, $key, "cyclescsm${c}",      undef);
              my $csmt = HistoryVal ($name, $day, $key, "csmt${c}",           undef);
              my $csme = HistoryVal ($name, $day, $key, "csme${c}",           undef);
              my $csmm = HistoryVal ($name, $day, $key, "minutescsm${c}",     undef);
              my $csmh = HistoryVal ($name, $day, $key, "hourscsme${c}",      undef);
              my $csma = HistoryVal ($name, $day, $key, "avgcycmntscsm${c}",  undef);

              if ($export eq 'csv') {
                  $hexp->{$day}{$key}{"CyclesCsm${c}"}          = $csmc if(defined $csmc);
                  $hexp->{$day}{$key}{"Csmt${c}"}               = $csmt if(defined $csmt);
                  $hexp->{$day}{$key}{"Csme${c}"}               = $csme if(defined $csme);
                  $hexp->{$day}{$key}{"MinutesCsm${c}"}         = $csmm if(defined $csmm);
                  $hexp->{$day}{$key}{"HoursCsme${c}"}          = $csmh if(defined $csmh);
                  $hexp->{$day}{$key}{"AvgCycleMinutesCsm${c}"} = $csma if(defined $csma);
              }

              if (defined $csmc) {
                  $csm .= "cyclescsm${c}: $csmc";
                  $nl   = 1;
              }

              if (defined $csmt) {
                  $csm .= ", " if($nl);
                  $csm .= "csmt${c}: $csmt";
                  $nl   = 1;
              }

              if (defined $csme) {
                  $csm .= ", " if($nl);
                  $csm .= "csme${c}: $csme";
                  $nl   = 1;
              }

              if (defined $csmm) {
                  $csm .= ", " if($nl);
                  $csm .= "minutescsm${c}: $csmm";
                  $nl   = 1;
              }

              if (defined $csmh) {
                  $csm .= ", " if($nl);
                  $csm .= "hourscsme${c}: $csmh";
                  $nl   = 1;
              }

              if (defined $csma) {
                  $csm .= ", " if($nl);
                  $csm .= "avgcycmntscsm${c}: $csma";
                  $nl   = 1;
              }

              $csm .= "\n            " if($nl);
          }

          if ($csm) {
              $ret .= "\n            ";
              $ret .= $csm;
          }
          else {
              $ret .= "\n            ";
          }
      }
      return $ret;
  };

  $h = $data{$name}{pvhist};

  if (!keys %{$h}) {
      return qq{PV cache is empty.};
  }

  for my $i (keys %{$h}) {
      if (!isNumeric ($i)) {
          delete $data{$name}{pvhist}{$i};
          Log3 ($name, 2, qq{$name - INFO - invalid key "$i" was deleted from pvHistory storage});
      }
  }

  for my $idx (sort keys %{$h}) {
      next if($par && $idx ne $par);
      $sq .= $idx." => ".$sub->($idx)."\n";
  }

  if ($export eq 'csv') {
      return _writeAsCsv ($hash, $hexp, $pvhexprtcsv.$name.'.csv');
  }

return $sq;
}

################################################################
#       Listing des verschiedene Speicher
################################################################
sub _listDataPoolVarious {
  my $hash = shift;
  my $htol = shift;
  my $par  = shift // q{};

  my $name = $hash->{NAME};

  my $func = $htol eq 'consumers' ? \&ConsumerVal :
             $htol eq 'inverters' ? \&InverterVal :
             $htol eq 'producers' ? \&ProducerVal :
             $htol eq 'strings'   ? \&StringVal   :
             $htol eq 'batteries' ? \&BatteryVal  :
             '';

  my $h = $data{$name}{$htol};

  if (!keys %{$h}) {
      return ucfirst($htol).qq{ cache is empty.};
  }

  for my $i (keys %{$h}) {
      if ($i !~ /^[0-9]{2}$/ix && $htol ne 'strings') {                       # bereinigen ungültige Position, Forum: https://forum.fhem.de/index.php/topic,117864.msg1173219.html#msg1173219
          delete $data{$name}{$htol}{$i};
          Log3 ($name, 2, qq{$name - INFO - invalid key "$i" was deleted from }.ucfirst($htol).qq{ storage});
      }
  }

  my $sq;

  for my $idx (sort keys %{$h}) {
      next if($par && $idx ne $par);
      my ($cret, $s1);
      my $sp1 = _ldpspaces ($idx, q{});

      for my $ckey (sort keys %{$h->{$idx}}) {
          if (ref $h->{$idx}{$ckey} eq 'ARRAY') {
             my $aser = join " ", @{$h->{$idx}{$ckey}};
             $cret .= ($s1 ? $sp1 : "").$ckey." => ".$aser."\n";
          }

          if (ref $h->{$idx}{$ckey} eq 'HASH') {
              my $hk = qq{};
              for my $f (sort {$a<=>$b} keys %{$h->{$idx}{$ckey}}) {
                  $hk .= " " if($hk);
                  $hk .= "$f=".$h->{$idx}{$ckey}{$f};
              }
              $cret .= ($s1 ? $sp1 : "").$ckey." => ".$hk."\n";
          }
          else {
              $cret .= ($s1 ? $sp1 : "").$ckey." => ". &{$func} ($hash, $idx, $ckey, "")."\n";
          }

          $s1 = 1;
      }
      $sq .= $idx." => ".$cret."\n";
  }

return $sq;
}

################################################################
#            Listing des Circular Speichers
################################################################
sub _listDataPoolCircular {
  my $hash = shift;
  my $par  = shift // q{};

  my $name = $hash->{NAME};
  my $h    = $data{$name}{circular};

  if (!keys %{$h}) {
      return qq{Circular cache is empty.};
  }

  my $sq;

  for my $idx (sort keys %{$h}) {
      next if($par && $idx ne $par);

      my $pvrl       = CircularVal ($hash, $idx, 'pvrl',       '-');
      my $pvfc       = CircularVal ($hash, $idx, 'pvfc',       '-');
      my $pvrlsum    = CircularVal ($hash, $idx, 'pvrlsum',    '-');
      my $pvfcsum    = CircularVal ($hash, $idx, 'pvfcsum',    '-');
      my $dnumsum    = CircularVal ($hash, $idx, 'dnumsum',    '-');
      my $pvaifc     = CircularVal ($hash, $idx, 'pvaifc',     '-');
      my $pvapifc    = CircularVal ($hash, $idx, 'pvapifc',    '-');            # PV Forecast der API incl. angewendeten Korrekturfaktor
      my $pvapifcraw = CircularVal ($hash, $idx, 'pvapifcraw', '-');            # PV Forecast der API Raw
      my $aihit      = CircularVal ($hash, $idx, 'aihit',      '-');
      my $confc      = CircularVal ($hash, $idx, 'confc',      '-');
      my $gcons      = CircularVal ($hash, $idx, 'gcons',      '-');
      my $gfeedin    = CircularVal ($hash, $idx, 'gfeedin',    '-');
      my $wid        = CircularVal ($hash, $idx, 'weatherid',  '-');
      my $wtxt       = CircularVal ($hash, $idx, 'weathertxt', '-');
      my $wccv       = CircularVal ($hash, $idx, 'wcc',        '-');
      my $rr1c       = CircularVal ($hash, $idx, 'rr1c',       '-');
      my $temp       = CircularVal ($hash, $idx, 'temp',       '-');
      my $pvcorrf    = CircularVal ($hash, $idx, 'pvcorrf',    '-');
      my $quality    = CircularVal ($hash, $idx, 'quality',    '-');

      my $pvcf = _ldchash2val ( {pool => $h, idx => $idx, key => 'pvcorrf', cval => $pvcorrf} );
      my $cfq  = _ldchash2val ( {pool => $h, idx => $idx, key => 'quality', cval => $quality} );
      my $pvrs = _ldchash2val ( {pool => $h, idx => $idx, key => 'pvrlsum', cval => $pvrlsum} );
      my $pvfs = _ldchash2val ( {pool => $h, idx => $idx, key => 'pvfcsum', cval => $pvfcsum} );
      my $dnus = _ldchash2val ( {pool => $h, idx => $idx, key => 'dnumsum', cval => $dnumsum} );

      $sq .= "\n" if($sq);

      if ($idx != 99) {
          my $prdl;
          for my $pn (1..MAXPRODUCER) {                                              # alle Producer
              $pn       = sprintf "%02d", $pn;
              my $pprl  = CircularVal ($hash, $idx, 'pprl'.$pn, '-');
              $prdl    .= ', ' if($prdl);
              $prdl    .= "pprl${pn}: $pprl";
          }

          my ($bin, $bout);
          for my $bn (1..MAXBATTERIES) {                                            # alle Batterien
              $bn = sprintf "%02d", $bn;
              my $batin  = CircularVal ($hash, $idx, 'batin'. $bn, '-');
              my $batout = CircularVal ($hash, $idx, 'batout'.$bn, '-');
              $bin      .= ', ' if($bin);
              $bin      .= "batin${bn}: $batin";
              $bout     .= ', ' if($bout);
              $bout     .= "batout${bn}: $batout";
          }

            my ($pvrlnew, $pvfcnew, $conall, $gconsall);
            my @pvrlkeys   = map { $_ =~ /^pvrl_/xs   ? $_ : '' } sort keys %{$h->{$idx}};
            my @pvfckeys   = map { $_ =~ /^pvfc_/xs   ? $_ : '' } sort keys %{$h->{$idx}};
            my @conakeys   = map { $_ =~ /^con_all/xs ? $_ : '' } sort keys %{$h->{$idx}};
            my @gconsakeys = map { $_ =~ /^gcons_a/xs ? $_ : '' } sort keys %{$h->{$idx}};

            for my $prl (@pvrlkeys) {
                next if(!$prl);
                my $lref = CircularVal ($hash, $idx, $prl, '');
                next if(!$lref);

                $pvrlnew .= "\n      " if($pvrlnew);
                $pvrlnew .= _ldchash2val ( { pool => $h, idx => $idx, key => $prl, cval => $lref } );
            }

            for my $pfc (@pvfckeys) {
                next if(!$pfc);
                my $cref = CircularVal ($hash, $idx, $pfc, '');
                next if(!$cref);

                $pvfcnew .= "\n      " if($pvfcnew);
                $pvfcnew .= _ldchash2val ( { pool => $h, idx => $idx, key => $pfc, cval => $cref } );
            }

            for my $coa (@conakeys) {
                next if(!$coa);
                my $caref = CircularVal ($hash, $idx, $coa, '');
                next if(!$caref);

                $conall .= "\n      " if($conall);
                $conall .= _ldchash2val ( { pool => $h, idx => $idx, key => $coa, cval => $caref } );
            }

            for my $gcoa (@gconsakeys) {
                next if(!$gcoa);
                my $gcaref = CircularVal ($hash, $idx, $gcoa, '');
                next if(!$gcaref);

                $gconsall .= "\n      " if($gconsall);
                $gconsall .= _ldchash2val ( { pool => $h, idx => $idx, key => $gcoa, cval => $gcaref } );
            }

          $sq .= $idx." => pvapifcraw: $pvapifcraw, pvapifc: $pvapifc, pvaifc: $pvaifc, pvfc: $pvfc, aihit: $aihit, pvrl: $pvrl";
          $sq .= "\n      $bin";
          $sq .= "\n      $bout";
          $sq .= "\n      confc: $confc, gcons: $gcons, gfeedin: $gfeedin, wcc: $wccv, rr1c: $rr1c";
          $sq .= "\n      temp: $temp, wid: $wid, wtxt: $wtxt";
          $sq .= "\n      $prdl";
          $sq .= "\n      pvcorrf: $pvcf";
          $sq .= "\n      quality: $cfq";
          $sq .= "\n      pvrlsum: $pvrs";
          $sq .= "\n      pvfcsum: $pvfs";
          $sq .= "\n      dnumsum: $dnus";
          $sq .= "\n      $conall"    if($conall);
          $sq .= "\n      $gconsall"  if($gconsall);
          $sq .= "\n      $pvrlnew"   if($pvrlnew);
          $sq .= "\n      $pvfcnew"   if($pvfcnew);
      }
      else {
          my ($batvl1, $batvl2, $batvl3, $batvl4, $batvl5, $batvl6, $batvl7);

          my $con      = CircularVal ($hash, $idx, 'todayConsumption',    '-');
          my $gcontot  = CircularVal ($hash, $idx, 'gridcontotal',        '-');
          my $idgcon   = CircularVal ($hash, $idx, 'initdaygcon',         '-');
          my $idfi     = CircularVal ($hash, $idx, 'initdayfeedin',       '-');
          my $fitot    = CircularVal ($hash, $idx, 'feedintotal',         '-');
          my $tdayDvtn = CircularVal ($hash, $idx, 'tdayDvtn',            '-');
          my $ydayDvtn = CircularVal ($hash, $idx, 'ydayDvtn',            '-');
          my $rtaitr   = CircularVal ($hash, $idx, 'runTimeTrainAI',      '-');
          my $fsaitr   = CircularVal ($hash, $idx, 'aitrainLastFinishTs', '-');
          my $airn     = CircularVal ($hash, $idx, 'aiRulesNumber',       '-');
          my $aicts    = CircularVal ($hash, $idx, 'attrInvChangedTs',    '-');

          for my $bn (1..MAXBATTERIES) {                                            # + alle Batterien
              $bn          = sprintf "%02d", $bn;
              my $idbintot = CircularVal ($hash, $idx, 'initdaybatintot'. $bn, '-');
              my $idboutot = CircularVal ($hash, $idx, 'initdaybatouttot'.$bn, '-');
              my $bintot   = CircularVal ($hash, $idx, 'batintot'.        $bn, '-');
              my $boutot   = CircularVal ($hash, $idx, 'batouttot'.       $bn, '-');
              my $lstmsr   = CircularVal ($hash, $idx, 'lastTsMaxSocRchd'.$bn, '-');
              my $ntsmsc   = CircularVal ($hash, $idx, 'nextTsMaxSocChge'.$bn, '-');
              my $dtocare  = CircularVal ($hash, $idx, 'days2care'.       $bn, '-');
              $batvl1     .= ', ' if($batvl1);
              $batvl1     .= "initdaybatintot${bn}: $idbintot";
              $batvl2     .= ', ' if($batvl2);
              $batvl2     .= "initdaybatouttot${bn}: $idboutot";
              $batvl3     .= ', ' if($batvl3);
              $batvl3     .= "batintot${bn}: $bintot";
              $batvl4     .= ', ' if($batvl4);
              $batvl4     .= "batouttot${bn}: $boutot";
              $batvl5     .= ', ' if($batvl5);
              $batvl5     .= "lastTsMaxSocRchd${bn}: $lstmsr";
              $batvl6     .= ', ' if($batvl6);
              $batvl6     .= "nextTsMaxSocChge${bn}: $ntsmsc";
              $batvl7     .= ', ' if($batvl7);
              $batvl7     .= "days2care${bn}: $dtocare";
          }

          $sq .= $idx." => tdayDvtn: $tdayDvtn, ydayDvtn: $ydayDvtn \n";
          $sq .= "      todayConsumption: $con, feedintotal: $fitot, initdayfeedin: $idfi \n";
          $sq .= "      gridcontotal: $gcontot, initdaygcon: $idgcon \n";
          $sq .= "      $batvl1\n";
          $sq .= "      $batvl2\n";
          $sq .= "      $batvl3\n";
          $sq .= "      $batvl4\n";
          $sq .= "      $batvl5\n";
          $sq .= "      $batvl6\n";
          $sq .= "      $batvl7\n";
          $sq .= "      runTimeTrainAI: $rtaitr, aitrainLastFinishTs: $fsaitr, aiRulesNumber: $airn \n";
          $sq .= "      attrInvChangedTs: $aicts \n";
      }
  }

return $sq;
}

################################################################
#       Listing des NextHours Speicher
################################################################
sub _listDataPoolNextHours {
  my $name = shift;
  my $par  = shift // q{};

  my $h = $data{$name}{nexthours};
  my $sq;

  if (!keys %{$h}) {
      return qq{NextHours cache is empty.};
  }

  for my $idx (sort keys %{$h}) {
      my $nhts       = NexthoursVal ($name, $idx, 'starttime',    '-');
      my $day        = NexthoursVal ($name, $idx, 'day',          '-');
      my $hod        = NexthoursVal ($name, $idx, 'hourofday',    '-');
      my $today      = NexthoursVal ($name, $idx, 'today',        '-');
      my $pvfc       = NexthoursVal ($name, $idx, 'pvfc',         '-');
      my $pvapifc    = NexthoursVal ($name, $idx, 'pvapifc',      '-');       # PV Forecast der API incl. angewendeten Korrekturfaktor
      my $pvapifcraw = NexthoursVal ($name, $idx, 'pvapifcraw',   '-');       # PV Forecast der API Raw
      my $pvaifc     = NexthoursVal ($name, $idx, 'pvaifc',       '-');       # PV Forecast der KI
      my $aihit      = NexthoursVal ($name, $idx, 'aihit',        '-');       # KI ForeCast Treffer Status
      my $wid        = NexthoursVal ($name, $idx, 'weatherid',    '-');
      my $wcc        = NexthoursVal ($name, $idx, 'wcc',          '-');
      my $crang      = NexthoursVal ($name, $idx, 'cloudrange',   '-');
      my $rr1c       = NexthoursVal ($name, $idx, 'rr1c',         '-');
      my $rrange     = NexthoursVal ($name, $idx, 'rainrange',    '-');
      my $rad1h      = NexthoursVal ($name, $idx, 'rad1h',        '-');
      my $pvcorrf    = NexthoursVal ($name, $idx, 'pvcorrf',      '-');
      my $temp       = NexthoursVal ($name, $idx, 'temp',         '-');
      my $confc      = NexthoursVal ($name, $idx, 'confc',        '-');
      my $confcex    = NexthoursVal ($name, $idx, 'confcEx',      '-');
      my $don        = NexthoursVal ($name, $idx, 'DoN',          '-');
      my $sunaz      = NexthoursVal ($name, $idx, 'sunaz',        '-');
      my $sunalt     = NexthoursVal ($name, $idx, 'sunalt',       '-');
      my $socprgs    = NexthoursVal ($name, $idx, 'socprogwhsum', '-');
      my $dinrang    = NexthoursVal ($name, $idx, 'DaysInRange',  '-');

      my ($rcdbat, $socs, $lcintime, $lcstrategy);
      for my $bn (1..MAXBATTERIES) {                                            # alle Batterien
          $bn = sprintf "%02d", $bn;
          my $rcdcharge = NexthoursVal ($name, $idx, 'rcdchargebat'.$bn, '-');
          my $intime    = NexthoursVal ($name, $idx, 'lcintimebat'.$bn,  '-');
          my $strategy  = NexthoursVal ($name, $idx, 'strategybat'.$bn,  '-');
          my $socxx     = NexthoursVal ($name, $idx, 'soc'.$bn,          '-');
          $rcdbat      .= ', ' if($rcdbat);
          $rcdbat      .= "rcdchargebat${bn}: $rcdcharge";
          $lcintime    .= ', ' if($lcintime);
          $lcintime    .= "lcintimebat${bn}: $intime";
          $lcstrategy  .= ', ' if($lcstrategy);
          $lcstrategy  .= "strategybat${bn}: $strategy";
          $socs        .= ', ' if($socs);
          $socs        .= "soc${bn}: $socxx";
      }

      $sq .= "\n" if($sq);
      $sq .= $idx." => ";
      $sq .= "starttime: $nhts, day: $day, hourofday: $hod, today: $today";
      $sq .= "\n              ";
      $sq .= "pvapifcraw: $pvapifcraw, pvapifc: $pvapifc, pvaifc: $pvaifc, pvfc: $pvfc, aihit: $aihit";
      $sq .= "\n              ";
      $sq .= "confc: $confc, confcEx: $confcex, weatherid: $wid, wcc: $wcc, rr1c: $rr1c, temp: $temp";
      $sq .= "\n              ";
      $sq .= "rad1h: $rad1h, sunaz: $sunaz, sunalt: $sunalt, DoN: $don";
      $sq .= "\n              ";
      $sq .= "rrange: $rrange, crange: $crang, DaysInRange: $dinrang, correff: $pvcorrf";
      $sq .= "\n              ";
      $sq .= $socs.", socprogwhsum: $socprgs";
      $sq .= "\n              ";
      $sq .= $rcdbat;
      $sq .= "\n              ";
      $sq .= $lcintime;
      $sq .= "\n              ";
      $sq .= $lcstrategy;
  }

return $sq;
}

################################################################
#       Listing des Qualities Speicher
################################################################
sub _listDataPoolQualities {
  my $name = shift;
  my $par  = shift // q{};

  my $h = $data{$name}{nexthours};
  my $sq;

  if (!keys %{$h}) {
      return qq{NextHours cache is empty.};
  }

  for my $idx (sort keys %{$h}) {
      my $nhfc    = NexthoursVal ($name, $idx, 'pvfc', undef);
      next if(!$nhfc);

      my $nhts    = NexthoursVal ($name, $idx, 'starttime',  '-');
      my $pvcorrf = NexthoursVal ($name, $idx, 'pvcorrf',  '-/-');
      my $aihit   = NexthoursVal ($name, $idx, 'aihit',      '-');
      my $pvfc    = NexthoursVal ($name, $idx, 'pvfc',       '-');
      my $wcc     = NexthoursVal ($name, $idx, 'wcc',        '-');
      my $sunalt  = NexthoursVal ($name, $idx, 'sunalt',     '-');
      my $dinrang = NexthoursVal ($name, $idx, 'DaysInRange',  '-');

      my ($f,$q)  = split "/", $pvcorrf;
      $sq        .= "\n" if($sq);
      $sq        .= "Start: $nhts, Quality: $q, Factor: $f, AI usage: $aihit, PV expect: $pvfc Wh, Sun Alt: $sunalt, Cloud: $wcc, DaysInRange: $dinrang";
  }

return $sq;
}

################################################################
#       Listing des Current Speicher
################################################################
sub _listDataPoolCurrent {
  my $name = shift;
  my $par  = shift // q{};

  my $h = $data{$name}{current};
  my $sq;

  if (!keys %{$h}) {
      return qq{Current values cache is empty.};
  }

  for my $idx (sort keys %{$h}) {
      if (ref $h->{$idx} eq 'ARRAY') {
         my $aser = join " ",@{$h->{$idx}};
         $sq     .= $idx." => ".$aser."\n";
      }
      elsif (ref $h->{$idx} eq 'HASH') {
          my $s1;
          my $sp1 = _ldpspaces ($idx, q{});
          $sq    .= $idx." => ";

          for my $idx1 (sort keys %{$h->{$idx}}) {
              if (ref $h->{$idx}{$idx1} eq 'HASH') {
                  my $s2;
                  my $sp2 = _ldpspaces ($idx1, $sp1);
                  $sq    .= ($s1 ? $sp1 : "").$idx1." => ";

                  for my $idx2 (sort keys %{$h->{$idx}{$idx1}}) {
                      my $s3;
                      my $sp3 = _ldpspaces ($idx2, $sp2);
                      $sq .= ($s2 ? $sp2 : "").$idx2." => ";

                      if (ref $h->{$idx}{$idx1}{$idx2} eq 'HASH') {
                          for my $idx3 (sort keys %{$h->{$idx}{$idx1}{$idx2}}) {
                              $sq .= ($s3 ? $sp3 : "").$idx3." => ".(defined $h->{$idx}{$idx1}{$idx2}{$idx3} ? $h->{$idx}{$idx1}{$idx2}{$idx3} : '')."\n";
                              $s3 = 1;
                          }
                      }
                      else {
                          $sq .= (defined $h->{$idx}{$idx1}{$idx2} ? $h->{$idx}{$idx1}{$idx2} : '')."\n";
                      }

                      $s1 = 1;
                      $s2 = 1;
                  }
              }
              else {
                  $sq .= (defined $h->{$idx}{$idx1} ? $h->{$idx}{$idx1} : '')."\n";
              }
          }
      }
      else {
          $sq .= $idx." => ".(defined $h->{$idx} ? $h->{$idx} : '')."\n";
      }
  }

return $sq;
}

################################################################
#       Listing der APiData Speicher
################################################################
sub _listDataPoolApiData {
  my $name = shift;
  my $htol = shift;
  my $par  = shift // q{};

  my $h = $data{$name}{solcastapi};
  $h    = $data{$name}{weatherapi}  if($htol eq 'weatherApiData');
  $h    = $data{$name}{statusapi}   if($htol eq 'statusApiData');

  if (!keys %{$h}) {
      return qq{The API values cache is empty.};
  }

  my $git = sub {
      my $it     = shift;
      my @sorted = sort { $a cmp $b } keys %$it;
      my $key    = shift @sorted;

      my $ret = {};
      $ret    = { $key => $it->{$key} } if($key);

      return $ret;
  };

  my $sq;
  my $pve   = q{};
  my $itref = dclone $h;                                                         # Deep Copy von $h

  for my $idx (sort keys %{$itref}) {
      my $s1;
      my $sp1 = _ldpspaces ($idx, q{});
      $sq    .= $idx." => ";

      while (my ($tag, $item) = each %{$git->($itref->{$idx})}) {
          $sq .= ($s1 ? $sp1 : "").$tag." => ";

          if (ref $item eq 'HASH') {
              my $s2;
              my $sp2 = _ldpspaces ($tag, $sp1);

              while (my ($tag1, $item1) = each %{$git->($itref->{$idx}{$tag})}) {
                  $item1 //= '-';
                  $sq .= ($s2 ? $sp2 : "")."$tag1: ".$item1."\n";
                  $s2  = 1;
                  delete $itref->{$idx}{$tag}{$tag1};
              }
          }

          $s1  = 1;
          $sq .= "\n" if($sq !~ /\n$/xs);

          delete $itref->{$idx}{$tag};
      }
  }

return $sq;
}

################################################################
#       Listing aiRawData Speicher
################################################################
sub _listDataPoolAiRawData {
  my $name = shift;
  my $par  = shift // q{};

  my $h      = $data{$name}{aidectree}{airaw};
  my $maxcnt = keys %{$h};
  
  if (!$maxcnt) {
      return qq{aiRawData values cache is empty.};
  }

  my $sq = "<b>Number of datasets:</b> ".$maxcnt."\n";

  for my $idx (sort keys %{$h}) {
      my $hod    = AiRawdataVal ($name, $idx, 'hod',       '-');
      my $sunalt = AiRawdataVal ($name, $idx, 'sunalt',    '-');
      my $sunaz  = AiRawdataVal ($name, $idx, 'sunaz',     '-');
      my $rad1h  = AiRawdataVal ($name, $idx, 'rad1h',     '-');
      my $wcc    = AiRawdataVal ($name, $idx, 'wcc',       '-');
      my $wid    = AiRawdataVal ($name, $idx, 'weatherid', '-');
      my $rr1c   = AiRawdataVal ($name, $idx, 'rr1c',      '-');
      my $pvrl   = AiRawdataVal ($name, $idx, 'pvrl',      '-');
      my $pvrlvd = AiRawdataVal ($name, $idx, 'pvrlvd',    '-');
      my $temp   = AiRawdataVal ($name, $idx, 'temp',      '-');
      my $nod    = AiRawdataVal ($name, $idx, 'dayname',   '-');
      my $con    = AiRawdataVal ($name, $idx, 'con',       '-');
      my $gcons  = AiRawdataVal ($name, $idx, 'gcons',     '-');

      $sq .= "\n";
      $sq .= "$idx => hod: $hod, nod: $nod, sunaz: $sunaz, sunalt: $sunalt, rad1h: $rad1h, ";
      $sq .= "wcc: $wcc, wid: $wid, rr1c: $rr1c, pvrl: $pvrl, pvrlvd: $pvrlvd, con: $con, gcons: $gcons, temp: $temp";
  }

return $sq;
}

################################################################
#  Hashwert aus CircularVal in formatierten String umwandeln
################################################################
sub _ldchash2val {
  my $paref = shift;
  my $pool  = $paref->{pool};
  my $idx   = $paref->{idx};
  my $key   = $paref->{key};
  my $cval  = $paref->{cval};

  my $ret  = qq{};
  my $ret2 = qq{};

  if (ref $cval eq 'HASH') {
      no warnings 'numeric';

      for my $f (sort {$a<=>$b} keys %{$pool->{$idx}{$key}}) {
          next if($f eq 'simple');

          if (ref $pool->{$idx}{$key}{$f} eq 'ARRAY') {
              my @sub_arrays = arraySplitBy (20, @{$pool->{$idx}{$key}{$f}});              # Array in Teil-Arrays zu je 20 Elemente aufteilen
              my $ln0        = strlength ($key);
              my $blk0       = '&nbsp;' x 17;
              my $blkadd0    = '&nbsp;' x (7 - ($ln0 > 7 ? 0 : $ln0));

              my $ln1        = strlength ($f);
              my $blkadd1    = '&nbsp;' x (3 - ($ln1 > 3 ? 0 : $ln1));

              for my $suaref (@sub_arrays) {                                               # für jedes Teil-Array Join ausführen
                  my $suajoined = join ' ', @{$suaref};

                  if (!$ret) {
                      $ret .= $key.$blkadd0.' => ';
                      $ret .= $f.$blkadd1.' @ '.$suajoined;
                  }
                  else {
                      $ret .= "\n".$blk0;
                      $ret .= $f.$blkadd1.' @ '.$suajoined;
                  }
              }
          }
          elsif ($f !~ /\./xs) {
              $ret .= " " if($ret);
              $ret .= "$f=".$pool->{$idx}{$key}{$f};
              my $ct = ($ret =~ tr/=// // 0) / 10;
              $ret .= "\n              " if($ct =~ /^[1-9](.{1})?$/);
          }
          elsif ($f =~ /\./xs) {
              $ret2 .= " " if($ret2);
              $ret2 .= "$f=".$pool->{$idx}{$key}{$f};
              my $ct2 = ($ret2 =~ tr/=// // 0) / 10;
              $ret2 .= "\n              " if($ct2 =~ /^[1-9](.{1})?$/);
          }
      }

      if ($ret2) {
          $ret .= "\n               " if($ret && $ret !~ /\n\s+$/xs);
          $ret .= $ret2;
      }

      use warnings;

      if (defined $pool->{$idx}{$key}{simple}) {
          $ret .= "\n              " if($ret && $ret !~ /\n\s+$/xs);
          $ret .= " "                if($ret);
          $ret .= "simple=".$pool->{$idx}{$key}{simple};
      }
  }
  else {
      $ret = $cval;
  }

return $ret;
}

################################################################
#  Berechnung führende Spaces für Hashanzeige
#  $str - String dessen Länge für die Anzahl Spaces
#         herangezogen wird
#  $sp  - vorhandener Space-String der erweitert wird
################################################################
sub _ldpspaces {
  my $str   = shift;
  my $sp    = shift // q{};
  my $const = shift // 4;

  my $le  = $const + strlength ($str);
  my $spn = $sp;

  for (my $i = 0; $i < $le; $i++) {
      $spn .= " ";
  }

return $spn;
}

################################################################
#   Export Speicherstruktur in CSV-Datei
################################################################
sub _writeAsCsv {
  my $hash    = shift;
  my $hexp    = shift;
  my $outfile = shift // return "No file specified for writing data";

  my @data;

  ## Header schreiben
  #####################
  my @head = qw (Day Hour);
  for my $hexd (sort{$a<=>$b} keys %{$hexp}) {
      for my $hexh (sort{$a<=>$b} keys %{$hexp->{$hexd}}) {
          for my $hk (sort keys %{$hexp->{$hexd}{$hexh}}) {
              push @head, $hk;
          }
          last;
      }
      last;
  }

  push @data, join(',', map { s{"}{""}g; qq{"$_"};} @head);

  ## Daten schreiben
  ####################
  for my $exd (sort{$a<=>$b} keys %{$hexp}) {
      for my $exh (sort{$a<=>$b} keys %{$hexp->{$exd}}) {
          push my @aexp, ($exd, $exh);

          for my $k (sort keys %{$hexp->{$exd}{$exh}}) {
              my $val = $hexp->{$exd}{$exh}{$k};
              $val    =~ s/\./,/xs;
              push @aexp, $val;
          }

          push @data, join(',', map { s{"}{""}g; qq{"$_"};} @aexp);
      }
  }

  my $err = FileWrite ($outfile, @data);
  return $err if($err);

return "The memory structure was written to the file $outfile";
}

################################################################
#        validiert die aktuelle Anlagenkonfiguration
################################################################
sub checkPlantConfig {
  my $hash = shift;

  my $name = $hash->{NAME};
  my $warnmsg;

  setModel ($hash);                                                                            # Model setzen

  my $lang        = AttrVal        ($name, 'ctrlLanguage', AttrVal ('global', 'language', DEFLANG));
  my $pcf         = ReadingsVal    ($name, 'pvCorrectionFactor_Auto', 'off');
  my $raname      = AttrVal        ($name, 'setupRadiationAPI',          '');
  my $version     = $hash->{HELPER}{VERSION} // '-';
  my ($acu, $aln) = isAutoCorrUsed ($name);

  my $ok     = FW_makeImage ('10px-kreis-gruen.png',     '');
  my $nok    = FW_makeImage ('10px-kreis-rot.png',       '');
  my $warn   = FW_makeImage ('message_attention@orange', '');
  my $info   = FW_makeImage ('message_info',             '');

  my $result = {                                                                                    # Ergebnishash
      'String Configuration' => { 'state' => $ok, 'result' => '', 'note' => '', 'info' => 0, 'warn' => 0, 'fault' => 0 },
      'Weather Properties'   => { 'state' => $ok, 'result' => '', 'note' => '', 'info' => 0, 'warn' => 0, 'fault' => 0 },
      'Common Settings'      => { 'state' => $ok, 'result' => '', 'note' => '', 'info' => 0, 'warn' => 0, 'fault' => 0 },
      'FTUI Widget Files'    => { 'state' => $ok, 'result' => '', 'note' => '', 'info' => 0, 'warn' => 0, 'fault' => 0 },
      'Perl Modules'         => { 'state' => $ok, 'result' => '', 'note' => '', 'info' => 0, 'warn' => 0, 'fault' => 0 },
      'Data Memory'          => { 'state' => $ok, 'result' => '', 'note' => '', 'info' => 0, 'warn' => 0, 'fault' => 0 },
      'Plant Control'        => { 'state' => $ok, 'result' => '', 'note' => '', 'info' => 0, 'warn' => 0, 'fault' => 0 },
  };

  my $sub = sub {
      my $string = shift;
      my $ret;

      for my $key (sort keys %{$data{$name}{strings}{$string}}) {
          $ret .= ", " if($ret);
          $ret .= $key.": ".$data{$name}{strings}{$string}{$key};
      }

      return $ret;
  };

  ## Check Strings
  ##################
  my $err = _createStringConfig ($hash);

  if ($err) {
      $result->{'String Configuration'}{state}  = $nok;
      $result->{'String Configuration'}{result} = $err;
      $result->{'String Configuration'}{fault}  = 1;
  }

  for my $sn (sort keys %{$data{$name}{strings}}) {
      my $sp = $sn." => ".$sub->($sn)."<br>";

      $result->{'String Configuration'}{note} .= $sn." => ".$sub->($sn)."<br>";

      if ($data{$name}{strings}{$sn}{peak} >= 500) {
          $result->{'String Configuration'}{result} .= qq{The peak value of string "$sn" is very high. };
          $result->{'String Configuration'}{result} .= qq{Check if you entered peak power in Wp instead of kWp. Ignore the Warning if the entered value is correct. <br>};
          $result->{'String Configuration'}{state}   = $warn;
          $result->{'String Configuration'}{warn}    = 1;
      }

      if (!isSolCastUsed ($hash) && !isVictronKiUsed ($hash)) {
          if ($sp !~ /azimut.*?peak.*?tilt/x) {
              $result->{'String Configuration'}{result} .= qq{Any of the parameter 'azimut', 'peak' or 'tilt' is missing. <br>};
              $result->{'String Configuration'}{state}   = $nok;
              $result->{'String Configuration'}{fault}   = 1;                                   # Test Vollständigkeit: z.B. Süddach => dir: S, peak: 5.13, tilt: 45
          }
      }
      elsif (isVictronKiUsed ($hash)) {
          if($sp !~ /KI-based\s=>\speak/xs) {
              $result->{'String Configuration'}{result} .= qq{The parameter 'peak' is missing. <br>};
              $result->{'String Configuration'}{state}   = $nok;
              $result->{'String Configuration'}{fault}   = 1;
          }
      }
      else {                                                                                    # Strahlungsdevice SolCast-API
          if($sp !~ /peak.*?pk/x) {
              $result->{'String Configuration'}{result} .= qq{Any of the parameter 'peak' or 'pk' is missing. <br>};
              $result->{'String Configuration'}{state}   = $nok;
              $result->{'String Configuration'}{fault}   = 1;                                   # Test Vollständigkeit
          }
      }
  }

  if (!$result->{'String Configuration'}{fault} && !$result->{'String Configuration'}{warn}) {
      $result->{'String Configuration'}{result} = $hqtxt{fulfd}{$lang};
  }

  ## Check Attribute DWD Wetterdevice
  #####################################
  my $mosm = '';
  my $resh;

  for my $step (1..MAXWEATHERDEV) {
      my ($valid, $fcname, $apiu) = isWeatherDevValid ($hash, 'setupWeatherDev'.$step);
      next if(!$valid && $step ne 1);

      if (!$valid) {
          $result->{'Weather Properties'}{state} = $nok;

          if (!$fcname) {
              $result->{'Weather Properties'}{result} .= qq{No DWD device is defined in attribute "setupWeatherDev$step". <br>};
          }
          else {
              $result->{'Weather Properties'}{result} .= qq{The DWD device "$fcname" doesn't exist. <br>};
          }

          $result->{'Weather Properties'}{fault} = 1;
      }
      else {
          if (!$apiu) {                                                         # keine Wetter-API -> Wetterdevice
              ($err, $warnmsg) = checkdwdattr ($name, $fcname, \@dweattrmust);
              
              if ($warnmsg) {
                  $result->{'Weather Properties'}{state}   = $warn;
                  $result->{'Weather Properties'}{result} .= $warnmsg.'<br>';
                  $result->{'Weather Properties'}{warn}    = 1;
              }

              if ($err) {
                  $result->{'Weather Properties'}{state}   = $nok;
                  $result->{'Weather Properties'}{result} .= $err.'<br>';
                  $result->{'Weather Properties'}{fault}   = 1;
              }
              else {
                  $mosm = AttrVal ($fcname, 'forecastRefresh', 6) == 6 ? 'MOSMIX_L' : 'MOSMIX_S';

                  if ($mosm eq 'MOSMIX_L') {
                      $result->{'Weather Properties'}{state}   = $info;
                      $result->{'Weather Properties'}{result} .= qq(The device "$fcname" uses "$mosm" which is only updated by DWD every 6 hours. <br>);
                      $result->{'Weather Properties'}{info}    = 1;
                  }

                  $result->{'Weather Properties'}{result} .= $hqtxt{fulfd}{$lang}." ($hqtxt{attrib}{$lang}: setupWeatherDev$step)<br>";
              }

              $result->{'Weather Properties'}{note} .= qq{checked parameters and attributes of device "$fcname": <br>};
              $result->{'Weather Properties'}{note} .= 'forecastProperties -> '.join (',', @dweattrmust).'<br>';
              $result->{'Weather Properties'}{note} .= 'forecastRefresh '.($mosm eq 'MOSMIX_L' ? '-> set attribute to below "6" if possible' : '').'<br>';
              $result->{'Weather Properties'}{note} .= 'forecastDays <br>';          
          }
          else {
              $result->{'Weather Properties'}{result} .= $hqtxt{fulfd}{$lang}." ($hqtxt{attrib}{$lang}: setupWeatherDev$step)<br>";
          }
      }
  }

  ## Alter DWD Wetterdaten
  ##########################
  ($err, $resh) = isWeatherAgeExceeded ( {name => $name, lang => $lang} );

  if (!$err && $resh->{exceed}) {
      $result->{'Weather Properties'}{state} = $warn;
      $result->{'Weather Properties'}{note} .= qq{The Prediction time of Weather data is older than expected when using $resh->{mosmix}. <br>};
      $result->{'Weather Properties'}{note} .= qq{Data time forecast: $resh->{fctime} <br>};
      $result->{'Weather Properties'}{note} .= qq{Check the DWD device(s) for proper functioning of the data retrieval. <br>};
      $result->{'Weather Properties'}{warn}  = 1;
  }

  $result->{'Weather Properties'}{note} .= '<br>';
  $result->{'Weather Properties'}{note} .= qq{checked global Weather parameters: <br>};
  $result->{'Weather Properties'}{note} .= 'MOSMIX variant or ICON Forecast Model, Age of Weather data. <br>';

  ## Check DWD Radiation Device
  ###############################
  if (isDWDUsed ($hash)) {
      $result->{'DWD Radiation Properties'}{state}  = $ok;
      $result->{'DWD Radiation Properties'}{result} = '';
      $result->{'DWD Radiation Properties'}{note}   = '';
      $result->{'DWD Radiation Properties'}{fault}  = 0;

      if (!$raname || !$defs{$raname}) {
          $result->{'DWD Radiation Properties'}{state}   = $nok;
          $result->{'DWD Radiation Properties'}{result} .= qq{The DWD device "$raname" doesn't exist <br>};
          $result->{'DWD Radiation Properties'}{fault}   = 1;
      }
      else {
          ($err, $warnmsg) = checkdwdattr ($name, $raname, \@draattrmust);

          if ($err) {
              $result->{'DWD Radiation Properties'}{state}   = $nok;
              $result->{'DWD Radiation Properties'}{result} .= $err.'<br>';
              $result->{'DWD Radiation Properties'}{note}   .= qq{<br>Check the parameters set in device '$raname': attribute 'forecastProperties' <br>};
              $result->{'DWD Radiation Properties'}{fault}   = 1;
          }
          else {
              $mosm = AttrVal ($raname, 'forecastRefresh', 6) == 6 ? 'MOSMIX_L' : 'MOSMIX_S';

              if ($mosm eq 'MOSMIX_L') {
                  $result->{'DWD Radiation Properties'}{state}   = $info;
                  $result->{'DWD Radiation Properties'}{result} .= qq(The device "$raname" uses "$mosm" which is only updated by DWD every 6 hours. <br>);
                  $result->{'DWD Radiation Properties'}{info}    = 1;
              }
          }
      }

      ## Alter DWD Radiation
      #######################
      ($err, $resh) = isRad1hAgeExceeded ( {name => $name, lang => $lang} );

      if (!$err && $resh->{exceed}) {
          $result->{'DWD Radiation Properties'}{state} = $warn;
          $result->{'DWD Radiation Properties'}{note} .= qq{The Prediction time of radiation data (Rad1h) is older than expected when using $resh->{mosmix}. <br>};
          $result->{'DWD Radiation Properties'}{note} .= qq{Data time forecast: $resh->{fctime} <br>};
          $result->{'DWD Radiation Properties'}{note} .= qq{Check the DWD device '$raname' for proper functioning of the data retrieval.<br>};
          $result->{'DWD Radiation Properties'}{warn}  = 1;
      }

      if (!$result->{'DWD Radiation Properties'}{fault}) {
          $result->{'DWD Radiation Properties'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
      }

      $result->{'DWD Radiation Properties'}{note} .= '<br>';
      $result->{'DWD Radiation Properties'}{note} .= qq{checked global Radiation parameters: <br>};
      $result->{'DWD Radiation Properties'}{note} .= 'MOSMIX variant, Age of Radiation data. <br>';
      $result->{'DWD Radiation Properties'}{note} .= qq{<br>checked parameters and attributes device "$raname": <br>};
      $result->{'DWD Radiation Properties'}{note} .= 'forecastProperties -> '.join (',', @draattrmust).'<br>';
      $result->{'DWD Radiation Properties'}{note} .= 'forecastDays <br>';
      $result->{'DWD Radiation Properties'}{note} .= 'forecastRefresh '.($mosm eq 'MOSMIX_L' ? '-> set attribute to below "6" if possible' : '').'<br>';
  }

  ## Check Rooftop und Roof Ident Pair Settings (SolCast)
  #########################################################
  if (isSolCastUsed ($hash)) {
      $result->{'Roof Ident Pair Settings'}{state}  = $ok;
      $result->{'Roof Ident Pair Settings'}{result} = '';
      $result->{'Roof Ident Pair Settings'}{note}   = '';
      $result->{'Roof Ident Pair Settings'}{fault}  = 0;

      $result->{'Rooftop Settings'}{state}          = $ok;
      $result->{'Rooftop Settings'}{result}         = '';
      $result->{'Rooftop Settings'}{note}           = '';
      $result->{'Rooftop Settings'}{fault}          = 0;

      my $rft = AttrVal ($name, 'setupRoofTops', '');

      if (!$rft) {
          $result->{'Rooftop Settings'}{state}   = $nok;
          $result->{'Rooftop Settings'}{result} .= qq{No RoofTops are defined <br>};
          $result->{'Rooftop Settings'}{note}   .= qq{Set your Rooftops with "attr $name setupRoofTops". <br>};
          $result->{'Rooftop Settings'}{fault}   = 1;

          $result->{'Roof Ident Pair Settings'}{state}   = $nok;
          $result->{'Roof Ident Pair Settings'}{result} .= qq{Setting the Rooftops is a necessary preparation for the definition of Roof Ident Pairs<br>};
          $result->{'Roof Ident Pair Settings'}{note}   .= qq{See the "Rooftop Settings" section below. <br>};
          $result->{'Roof Ident Pair Settings'}{fault}   = 1;
      }
      else {
          $result->{'Rooftop Settings'}{result} .= $hqtxt{fulfd}{$lang};
          $result->{'Rooftop Settings'}{note}   .= qq{Rooftops defined: }.$rft.qq{<br>};
      }

      my ($a,$h) = parseParams ($rft);

      while (my ($is, $pk) = each %$h) {
          my $rtid   = StatusAPIVal ($hash, '?IdPair', '?'.$pk, 'rtid',   '');
          my $apikey = StatusAPIVal ($hash, '?IdPair', '?'.$pk, 'apikey', '');

          if (!$rtid || !$apikey) {
              my $res  = qq{String "$is" has no Roof Ident Pair "$pk" defined or has no Rooftop-ID and/or SolCast-API key assigned. <br>};
              my $note = qq{Set the Roof Ident Pair "$pk" with "set $name roofIdentPair". <br>};

              $result->{'Roof Ident Pair Settings'}{state}   = $nok;
              $result->{'Roof Ident Pair Settings'}{result} .= $res;
              $result->{'Roof Ident Pair Settings'}{note}   .= $note;
              $result->{'Roof Ident Pair Settings'}{fault}   = 1;
          }
          else {
              $result->{'Roof Ident Pair Settings'}{note}   .= qq{checked "$is" Roof Ident Pair "$pk":<br>rtid=$rtid, apikey=$apikey <br>};
          }
      }

      if (!$result->{'Roof Ident Pair Settings'}{fault}) {
          $result->{'Roof Ident Pair Settings'}{result} = $hqtxt{fulfd}{$lang};
      }
  }

  ## Allgemeine Settings (auch API spezifisch)
  ##############################################
  my $eocr                     = AttrVal       ($name, 'event-on-change-reading', '');
  my $gdn                      = AttrVal       ('global', 'dnsServer', '');
  my $aiprep                   = isPrepared4AI ($hash, 'full');
  my $aiusemsg                 = CurrentVal    ($hash, 'aicanuse', '');
  my ($cset, $lat, $lon, $alt) = locCoordinates();
  my $einstds                  = "";

  if (!$eocr || $eocr ne '.*') {
      $einstds                              = 'to .*' if($eocr ne '.*');
      $result->{'Common Settings'}{state}   = $info;
      $result->{'Common Settings'}{result} .= qq{Attribute 'event-on-change-reading' is not set $einstds. <br>};
      $result->{'Common Settings'}{note}   .= qq{Setting attribute 'event-on-change-reading = .*' is recommended to improve the runtime performance.<br>};
      $result->{'Common Settings'}{info}    = 1;
  }

  if ($lang ne 'DE') {
      $result->{'Common Settings'}{state}   = $info;
      $result->{'Common Settings'}{result} .= qq{The language is set to '$lang'. <br>};
      $result->{'Common Settings'}{note}   .= qq{If the local attribute "ctrlLanguage" or the global attribute "language" is changed to "DE" most of the outputs are in German.<br>};
      $result->{'Common Settings'}{info}    = 1;
  }
  
  if (!$aiprep) {
      $result->{'Common Settings'}{state}   = $info;
      $result->{'Common Settings'}{result} .= qq{AI support for the PV forecast is not used. <br>};
      $result->{'Common Settings'}{note}   .= qq{$aiusemsg.<br>};
      $result->{'Common Settings'}{info}    = 1;
  }

  if (!$lat) {
      $result->{'Common Settings'}{state}   = $warn;
      $result->{'Common Settings'}{result} .= qq{Attribute latitude in global device is not set. <br>};
      $result->{'Common Settings'}{note}   .= qq{Set the coordinates of your installation in the latitude attribute of the global device.<br>};
      $result->{'Common Settings'}{warn}    = 1;
  }

  if (!$lon) {
      $result->{'Common Settings'}{state}   = $warn;
      $result->{'Common Settings'}{result} .= qq{Attribute longitude in global device is not set. <br>};
      $result->{'Common Settings'}{note}   .= qq{Set the coordinates of your installation in the longitude attribute of the global device.<br>};
      $result->{'Common Settings'}{warn}    = 1;
  }
  
  if (!$gdn) {
      $result->{'Common Settings'}{state}   = $nok;
      $result->{'Common Settings'}{result} .= qq{Attribute dnsServer in global device is not set. <br>};
      $result->{'Common Settings'}{note}   .= qq{Set global attribute dnsServer to the IP Adresse of your DNS Server.<br>};
      $result->{'Common Settings'}{fault}   = 1;
  }

  if (!$alt) {
      $result->{'Common Settings'}{state}   = $nok;
      $result->{'Common Settings'}{result} .= qq{Attribute altitude in global device is not set. <br>};
      $result->{'Common Settings'}{note}   .= qq{Set the altitude in meters above sea level in the altitude attribute of the global device.<br>};
      $result->{'Common Settings'}{fault}   = 1;
  }

  my ($cmerr, $cmupd, $cmmsg, $cmrec) = checkModVer ($name, '76_SolarForecast', 'https://fhem.de/fhemupdate/controls_fhem.txt');

  if (!$cmerr && !$cmupd) {
      $result->{'Common Settings'}{note}   .= qq{$cmmsg <br>};
      $result->{'Common Settings'}{note}   .= qq{checked module: <br>};
      $result->{'Common Settings'}{note}   .= qq{76_SolarForecast <br>};
  }

  if ($cmerr) {
      $result->{'Common Settings'}{state}   = $warn;
      $result->{'Common Settings'}{result} .= qq{$cmmsg <br>};
      $result->{'Common Settings'}{note}   .= qq{$cmrec <br>};
      $result->{'Common Settings'}{warn}    = 1;
  }

  if ($cmupd) {
      $result->{'Common Settings'}{state}   = $warn;
      $result->{'Common Settings'}{result} .= qq{$cmmsg <br>};
      $result->{'Common Settings'}{note}   .= qq{$cmrec <br>};
      $result->{'Common Settings'}{warn}    = 1;
  }

  if ($result->{'Common Settings'}{result}) {
      $result->{'Common Settings'}{result} .= '<br>';
  }

  if (isForecastSolarUsed ($hash)) {                                                         # allg. Settings bei Nutzung Forecast.Solar API
      if ($pcf !~ /on/xs) {
          $result->{'Common Settings'}{state}   = $info;
          $result->{'Common Settings'}{result} .= qq{pvCorrectionFactor_Auto is set to "$pcf" <br>};
          $result->{'Common Settings'}{note}   .= qq{Set pvCorrectionFactor_Auto to "on_complex" is recommended.<br>};
      }

      if (!$result->{'Common Settings'}{fault}) {
          $result->{'Common Settings'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
          $result->{'Common Settings'}{note}   .= qq{<br>checked parameters and attributes: <br>};
          $result->{'Common Settings'}{note}   .= qq{pvCorrectionFactor_Auto <br>};
      }
  }

  if (isOpenMeteoUsed ($hash)) {                                                             # allg. Settings bei Nutzung Open-Meteo API
      if ($aidtabs) {
          $result->{'Common Settings'}{state}   = $info;
          $result->{'Common Settings'}{result} .= qq{The Perl module AI::DecisionTree is missing. <br>};
          $result->{'Common Settings'}{note}   .= qq{If you want use AI support, please install it with e.g. "cpan install AI::DecisionTree" or "sudo apt-get install libai-decisiontree-perl" on Linux Systems if the installation with cpan doesn't work.<br>};
          $result->{'Common Settings'}{info}    = 1;
      }

      if ($pcf !~ /on/xs) {
          $result->{'Common Settings'}{state}   = $info;
          $result->{'Common Settings'}{result} .= qq{pvCorrectionFactor_Auto is set to "$pcf" <br>};
          $result->{'Common Settings'}{note}   .= qq{Set pvCorrectionFactor_Auto to "on_complex" is recommended.<br>};
      }

      if (!$result->{'Common Settings'}{fault}) {
          $result->{'Common Settings'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
          $result->{'Common Settings'}{note}   .= qq{<br>checked parameters and attributes: <br>};
          $result->{'Common Settings'}{note}   .= qq{pvCorrectionFactor_Auto <br>};
      }
  }

  if (isSolCastUsed ($hash)) {                                                               # allg. Settings bei Nutzung SolCast API
      my $lam = StatusAPIVal ($hash, 'SolCast', '?All', 'response_message', 'success');

      if ($pcf !~ /on/xs) {
          $result->{'Common Settings'}{state}   = $info;
          $result->{'Common Settings'}{result} .= qq{pvCorrectionFactor_Auto is set to "$pcf" <br>};
          $result->{'Common Settings'}{note}   .= qq{set pvCorrectionFactor_Auto to "on_complex" is recommended if the SolCast efficiency factor is already adjusted.<br>};
      }

      if ($lam =~ /You have exceeded your free daily limit/i) {
          $result->{'API Access'}{state}        = $warn;
          $result->{'API Access'}{result}      .= qq{The last message from SolCast API is:<br>"$lam"<br>};
          $result->{'API Access'}{note}        .= qq{Wait until the next day when the limit resets.<br>};
          $result->{'API Access'}{warn}         = 1;
      }
      elsif ($lam ne 'success') {
          $result->{'API Access'}{state}        = $nok;
          $result->{'API Access'}{result}      .= qq{The last message from SolCast API is:<br>"$lam"<br>};
          $result->{'API Access'}{note}        .= qq{Check the validity of your API key and Rooftop identificators.<br>};
          $result->{'API Access'}{fault}        = 1;
      }

      if (!$result->{'Common Settings'}{fault}) {
          $result->{'Common Settings'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
          $result->{'Common Settings'}{note}   .= qq{<br>checked parameters and attributes: <br>};
          $result->{'Common Settings'}{note}   .= qq{pvCorrectionFactor_Auto <br>};
      }
  }

  if (isDWDUsed ($hash)) {                                                               # allg. Settings bei Nutzung DWD API
      my $lam = StatusAPIVal ($hash, 'DWD', '?All', 'response_message', 'success');

      if ($aidtabs) {
          $result->{'Common Settings'}{state}   = $info;
          $result->{'Common Settings'}{result} .= qq{The Perl module AI::DecisionTree is missing. <br>};
          $result->{'Common Settings'}{note}   .= qq{If you want use AI support, please install it with e.g. "cpan install AI::DecisionTree".<br>};
          $result->{'Common Settings'}{info}    = 1;
      }

      if ($pcf !~ /on/xs) {
          $result->{'Common Settings'}{state}   = $info;
          $result->{'Common Settings'}{result} .= qq{pvCorrectionFactor_Auto is set to "$pcf" <br>};
          $result->{'Common Settings'}{note}   .= qq{Set pvCorrectionFactor_Auto to "on_complex" or "on_complex_ai" is recommended.<br>};
      }

      if ($lam ne 'success') {
          $result->{'API Access'}{state}        = $nok;
          $result->{'API Access'}{result}      .= qq{DWD last message:<br>"$lam"<br>};
          $result->{'API Access'}{note}        .= qq{Check the setup of the device "$raname". <br>};
          $result->{'API Access'}{note}        .= qq{It is possible that not all readings are transmitted when "$raname" is newly set up or was changed. <br>};
          $result->{'API Access'}{note}        .= qq{In this case, wait until tomorrow and check again.<br>};
          $result->{'API Access'}{fault}        = 1;
      }

      if (!$result->{'Common Settings'}{fault}) {
          $result->{'Common Settings'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
          $result->{'Common Settings'}{note}   .= qq{<br>checked Perl modules: <br>};
          $result->{'Common Settings'}{note}   .= qq{AI::DecisionTree <br>};
          $result->{'Common Settings'}{note}   .= qq{<br>checked parameters and attributes: <br>};
          $result->{'Common Settings'}{note}   .= qq{pvCorrectionFactor_Auto <br>};
      }
  }

  if (isVictronKiUsed ($hash)) {                                                              # allg. Settings bei Nutzung VictronKI-API
      my $vrmcr = StatusAPIVal ($hash, '?VRM', '?API', 'credentials', '');

      if ($pcf !~ /on/xs) {
          $result->{'Common Settings'}{state}   = $warn;
          $result->{'Common Settings'}{result} .= qq{pvCorrectionFactor_Auto is set to "$pcf" <br>};
          $result->{'Common Settings'}{note}   .= qq{set pvCorrectionFactor_Auto to "on_complex" is recommended.<br>};
          $result->{'Common Settings'}{warn}    = 1;
      }

      if (!$vrmcr) {
          $result->{'API Access'}{state}        = $nok;
          $result->{'API Access'}{result}      .= qq{The Victron VRM Portal credentials are not set. <br>};
          $result->{'API Access'}{note}        .= qq{set the credentials with command "set $name vrmCredentials".<br>};
          $result->{'API Access'}{fault}        = 1;
      }

      if (!$result->{'Common Settings'}{fault}) {
          $result->{'Common Settings'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
          $result->{'Common Settings'}{note}   .= qq{<br>checked parameters and attributes: <br>};
          $result->{'Common Settings'}{note}   .= qq{pvCorrectionFactor_Auto, vrmCredentials <br>};
      }
  }

  if (!$result->{'Common Settings'}{fault}) {
      $result->{'Common Settings'}{note}   .= qq{global->latitude, global->longitude, global->altitude <br>};
      $result->{'Common Settings'}{note}   .= qq{global->language, global->dnsServer <br>};
      $result->{'Common Settings'}{note}   .= qq{event-on-change-reading, ctrlLanguage <br>};
  }

  ## installierte Perl Module
  #############################
  if ($aidtabs) {
      $result->{'Perl Modules'}{state}   = $info;
      $result->{'Perl Modules'}{result} .= qq{The Perl module AI::DecisionTree is missing. <br>};
      $result->{'Perl Modules'}{note}   .= qq{If you want use AI support, please install it with e.g. "cpan install AI::DecisionTree".<br>};
      $result->{'Perl Modules'}{info}    = 1;
  }

  if (!$result->{'Perl Modules'}{info} && !$result->{'Perl Modules'}{warn} && !$result->{'Perl Modules'}{fault}) {
      $result->{'Perl Modules'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
      $result->{'Perl Modules'}{note}   .= qq{<br>checked installed Perl Modules: <br>};
      $result->{'Perl Modules'}{note}   .= qq{AI::DecisionTree <br>};
  }

  ## Datenspeicher Check
  ########################
  my $confault = 0;

  for my $dy (sort{$a<=>$b} keys %{$data{$name}{pvhist}}) {
      for my $hh (sort{$a<=>$b} keys %{$data{$name}{pvhist}{$dy}}) {
          my $hcon = HistoryVal ($hash, $dy, $hh, 'con', 0);                                        # historische Verbrauchswerte

          if ($hcon < 0) {                                                                          # V1.45.7
              $confault++;
              Log3 ($name, 1, "$name - WARNING - The stored Energy consumption of day/hour $dy/$hh is negative. This appears to be an error. The incorrect value can be deleted with 'set $name reset consumptionHistory $dy $hh'.");
          }
      }
  }

  if ($confault) {
      $result->{'Data Memory'}{state}   = $warn;
      $result->{'Data Memory'}{result} .= qq{There may be '$confault' incorrect value(s) in the 'con' key of the pvHistory Storage. <br>};
      $result->{'Data Memory'}{note}   .= qq{See Logfile for detailed information and how these value(s) could be corrected. <br>};
      $result->{'Data Memory'}{warn}    = 1;
  }

  if (!$result->{'Data Memory'}{info} && !$result->{'Data Memory'}{warn} && !$result->{'Data Memory'}{fault}) {
       $result->{'Data Memory'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
       $result->{'Data Memory'}{note}   .= qq{<br>checked Data Memory: <br>};
       $result->{'Data Memory'}{note}   .= qq{pvHistory key 'con' <br>};
  }
  
  ## Plant Control Check
  ########################
  my $rdcs = CurrentVal ($name, 'reductionState', ''); 
  my $fipl = CurrentVal ($name, 'feedinPowerLimit', '');
  
  if (!$rdcs) {
      $result->{'Plant Control'}{state}   = $info;
      $result->{'Plant Control'}{result} .= qq{It may be useful setting 'plantControl->reductionState'. <br>};
      $result->{'Plant Control'}{note}   .= qq{The 'reductionState' parameter informs $name whether the PV system is down-regulated. (see Command Reference) <br>};
      # $result->{'Plant Control'}{note}   .= qq{(see <a href='https://toolkit.solcast.com.au/rooftop-sites/' target='_blank'>SolCast API</a>) <br>};
      $result->{'Plant Control'}{info}    = 1;
  }
  
  if (!$fipl && isBatteryUsed ($name)) {
      $result->{'Plant Control'}{state}   = $info;
      $result->{'Plant Control'}{result} .= qq{It may be useful setting 'plantControl->feedinPowerLimit' if Batteries are installed. <br>};
      $result->{'Plant Control'}{note}   .= qq{The 'feedinPowerLimit' parameter is helpful in conjunction with the 'ctrlBatSocManagementXX' attribute to prevent a possible curtailment of the PV system and to make optimum use of the yield if battery(ies) are used. <br>};
      $result->{'Plant Control'}{note}   .= qq{(see this <a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#PV-Prognose_und_Verbrauch_optimierte_Beladungssteuerung_unter_Ber%C3%BCcksichtigung_einer_Wirkleistungsbegrenzung' target='_blank'>section</a> in the german Wiki) <br>};
      $result->{'Plant Control'}{info}    = 1;
  }

  if (!$result->{'Plant Control'}{info} && !$result->{'Plant Control'}{warn} && !$result->{'Plant Control'}{fault}) {
       $result->{'Plant Control'}{result} .= $hqtxt{fulfd}{$lang}.'<br>';
       $result->{'Plant Control'}{note}   .= qq{<br>checked plantControl: <br>};
       $result->{'Plant Control'}{note}   .= qq{keys 'reductionState', 'feedinPowerLimit' <br>};
  }

  ## FTUI Widget Support
  ########################
  my $tpath = "$root/www/tablet/css";
  my $upd   = 0;
  $err      = 0;

  if (!-d $tpath) {
      $result->{'FTUI Widget Files'}{result}  .= $hqtxt{widnin}{$lang};
      $result->{'FTUI Widget Files'}{note}    .= qq{There is no need to install SolarForecast FTUI widgets.<br>};
  }
  else {
      my $cfurl = BPATH.CFILE.PPATH;

      for my $file (@fs) {
          ($cmerr, $cmupd, $cmmsg, $cmrec) = checkModVer ($name, $file, $cfurl);

          $err = 1 if($cmerr);
          $upd = 1 if($cmupd);
      }

      if ($err) {
          $result->{'FTUI Widget Files'}{state}   = $warn;
          $result->{'FTUI Widget Files'}{result} .= $hqtxt{widerr}{$lang}.'<br>';
          $result->{'FTUI Widget Files'}{result} .= $cmmsg.'<br>';
          $result->{'FTUI Widget Files'}{note}   .= qq{Update the FHEM Tablet UI Widget Files with the command:  <br>};
          $result->{'FTUI Widget Files'}{note}   .= qq{"get $name ftuiFramefiles".  <br>};
          $result->{'FTUI Widget Files'}{note}   .= qq{After that do the test again. If the error is permanent, please inform the maintainer.<br>};
          $result->{'FTUI Widget Files'}{warn}    = 1;

          $upd = 0;
      }

      if ($upd) {
          $result->{'FTUI Widget Files'}{state}   = $warn;
          $result->{'FTUI Widget Files'}{result} .= $hqtxt{widnup}{$lang};
          $result->{'FTUI Widget Files'}{note}   .= qq{Update the FHEM Tablet UI Widget Files with the command:  <br>};
          $result->{'FTUI Widget Files'}{note}   .= qq{"get $name ftuiFramefiles".  <br>};
          $result->{'FTUI Widget Files'}{warn}    = 1;
      }

      if (!$result->{'FTUI Widget Files'}{fault} && !$result->{'FTUI Widget Files'}{warn} && !$result->{'FTUI Widget Files'}{info}) {
          $result->{'FTUI Widget Files'}{result}  .= $hqtxt{widok}{$lang};
          $result->{'FTUI Widget Files'}{note}    .= qq{checked Files: <br>};
          $result->{'FTUI Widget Files'}{note}    .= (join ', ', @fs).qq{ <br>};
      }
  }

  ## Ausgabe
  ############
  my $out  = qq{<html>};
  $out    .= qq{<b>}.$hqtxt{plntck}{$lang}.qq{ - Modul Version: $version, Model: $hash->{MODEL} </b> <br><br>};

  $out    .= qq{<table class="roomoverview" style="text-align:left; border:1px solid; padding:5px; border-spacing:5px; margin-left:auto; margin-right:auto;">};
  $out    .= qq{<tr style="font-weight:bold;">};
  $out    .= qq{<td style="text-decoration:underline; padding: 5px;"> $hqtxt{object}{$lang} </td>};
  $out    .= qq{<td style="text-decoration:underline;"> $hqtxt{state}{$lang} </td>};
  $out    .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>};
  $out    .= qq{<td style="text-decoration:underline;"> $hqtxt{result}{$lang} </td>};
  $out    .= qq{<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>};
  $out    .= qq{<td style="text-decoration:underline;"> $hqtxt{note}{$lang} </td>};
  $out    .= qq{</tr>};
  $out    .= qq{<tr></tr>};

  my $hz = keys %{$result};
  my $hc = 0;
  my $cf = 0;                                                                                     # config fault: 1 -> Konfig fehlerhaft, 0 -> Konfig ok
  my $wn = 0;                                                                                     # Warnung wenn 1
  my $io = 0;                                                                                     # Info wenn 1

  for my $key (sort keys %{$result}) {
      $hc++;
      $cf = $result->{$key}{fault} if($result->{$key}{fault});
      $wn = $result->{$key}{warn}  if($result->{$key}{warn});
      $io = $result->{$key}{info}  if($result->{$key}{info});

      $result->{$key}{state} = $warn if($result->{$key}{warn});
      $result->{$key}{state} = $nok  if($result->{$key}{fault});

      $out .= qq{<tr>};
      $out .= qq{<td style="padding: 5px; white-space:nowrap;"> <b>$key</b>              </td>};
      $out .= qq{<td style="padding: 5px; text-align: center"> $result->{$key}{state}    </td>};
      $out .= qq{<td style="padding: 5px;">                                              </td>};
      $out .= qq{<td style="padding: 0px;"> $result->{$key}{result}                      </td>};
      $out .= qq{<td style="padding: 0px;">                                              </td>};
      $out .= qq{<td style="padding-right: 5px; text-align: left"> $result->{$key}{note} </td>};
      $out .= qq{</tr>};

      if ($hc < $hz) {                                                                           # Zwischenzeile
          $out .= qq{<tr>};
          $out .= qq{<td> &nbsp; </td>};
          $out .= qq{</tr>};
      }
  }

  $out .= qq{</table>};
  $out .= qq{</html>};

  $out .= "<br>";

  if ($cf) {
      $out .= encode ("utf8", $hqtxt{strnok}{$lang});
  }
  elsif ($wn) {
      $out .= encode ("utf8", $hqtxt{strwn}{$lang});
  }
  else {
      $out .= encode ("utf8", $hqtxt{strok}{$lang});
  }

  $out =~ s/ (Bitte eventuelle Hinweise|Please note any information).*// if(!$io);
  $out =~ s/<I>/$info/gx;
  $out =~ s/<W>/$warn/gx;

return $out;
}

#####################################################################
#  Ermittelt den PV Überschuß nach verschiedenen Verfahren
#  ($surpmeth). Auswertung des Schieberegisters surplusslidereg.
#
#  $surpmeth = default - der aktuell gemessene Überschuß
#  $surpmeth = 2 .. 20 - Durchschnitt der letzten X Messungen
#  $surpmeth = median  - Median der vorhandenen Überschußwerte
#  $surpmeth = <Device>:<Reading> - Device/Reading Kombination
#                                   die einen berechneten
#                                   User spezifischen PV-Überschuß
#                                   liefert
#
#  Rückgabe:  PV Überschuß
#
#####################################################################
sub determSurplus {
  my $name = shift;
  my $c    = shift;

  my $surpmeth = ConsumerVal ($name, $c, 'surpmeth', 'default');
  my $splref   = CurrentVal  ($name, 'surplusslidereg',     '');
  my $method   = 'default';
  my ($surplus, $fallback);

  if ($surpmeth =~ /median/xs) {                                          # Median der Werte in surplusslidereg, !kann UNDEF sein!
      my $num  = (split '_', $surpmeth)[1];                               # Anzahl der (letzten) Array-Elemente die für Median verwendet werden sollen
      $surplus = medianArray ($splref, $num);
      $method  = $num ? "median:$num" : "median:all";
  }
  elsif ($surpmeth =~ /average/xs) {                                      # Average Ermittlung, !kann UNDEF sein!
      my $num  = (split '_', $surpmeth)[1];                               
      $surplus = avgArray ($splref, $num);
      $method  = $num ? "average:$num" : "average:all";
  }
  elsif ($surpmeth eq 'default') {                                        # aktueller Energieüberschuß
      $surplus = CurrentVal ($name, 'surplus', 0);
      $method  = 'default';
  }
  elsif ($surpmeth =~ /.*:.*/xs) {
      my ($dv, $rd) = split ':', $surpmeth;
      $method       = "$dv:$rd";
      my ($err)     = isDeviceValid ( { name => $name, obj => $dv, method => 'string' } );

      if ($err) {
          $fallback = 1;
          Log3 ($name, 1, qq{$name - ERROR of consumer $c key 'surpmeth':  $err (fall back to default Surplus determination)});
      }
      else {
          $surplus = ReadingsNum ($dv, $rd, '');

          if (!isNumeric ($surplus)) {
              $fallback = 1;
              Log3 ($name, 1, qq{$name - ERROR of consumer $c key 'surpmeth': Device $dv / Reading $rd is not numeric (fall back to default Surplus determination)});
          }
      }
  }

  if ($fallback) {                                                        # Fall Back
      $surplus = CurrentVal ($name, 'surplus', 0);
      $method  = $method." but fallback to 'default'";
  }
  
  $surplus //= 0;

return ($method, $surplus);
}

################################################################
#  Array auf eine festgelegte Anzahl Elemente beschränken,
#  Das älteste Element wird entfernt
#
#  $aref  = Referenz zum Array
#  $limit = die Anzahl Elemente auf die gekürzt werden soll
#           (default SLIDENUMMAX)
#
################################################################
sub limitArray {
  my $aref  = shift;
  my $limit = shift // SLIDENUMMAX;

  return if(ref $aref ne 'ARRAY');

  while (scalar @{$aref} > $limit) {
      shift @{$aref};
  }

return;
}

################################################################
#  Array auf eine festgelegte Anzahl Elemente beschränken.
#  Es wird das kleinste und das größte Elemente entfernt
#
#  $aref  = Referenz zum Array
#  $limit = die Anzahl Elemente auf die gekürzt werden soll
#           (default SPLSLIDEMAX)
#
################################################################
sub removeMinMaxArray {
  my $aref  = shift;
  my $limit = shift // SPLSLIDEMAX;

  return if(ref $aref ne 'ARRAY' || scalar @$aref <= $limit);          # Abbruchbedingung

  my ($min, $max) = (sort { $a <=> $b } @$aref)[0, -1];                # finde Min- und Max-Werte
  @$aref          = grep { $_ != $min && $_ != $max } @$aref;          # Entferne die Werte

  removeMinMaxArray ($aref, $limit) if(@$aref > 20);                   # Rekursiver Aufruf, wenn nötig

return;
}

################################################################
#  Durchschnitt der Werte eines Array ermitteln
#
#  $aref  = Referenz zum Array
#  $num   = Anzahl der zu verwendenden Elemente
#           (es MÜSSEN die num Anzahl
#           Elemente im Array vorhanden sein)
#
################################################################
sub avgArray {
  my $aref = shift;
  my $num  = shift // SLIDENUMMAX;

  return undef if(ref $aref ne 'ARRAY' || scalar @{$aref} < $num);
  
  my @tail = @{$aref}[-$num .. -1];                                 # es werden die neuesten num Elemente verwendet
  
  my $sum = 0;
  $sum   += $_ for @tail;

  my $avg = $sum / $num;

return $avg;
}

######################################################################################
#  Median der Werte eines Array ermitteln
#  (https://www.ionos.de/digitalguide/online-marketing/web-analyse/median-berechnen/)
#
#  $aref  = Referenz zum Array
#  $num   = Anzahl der neuesten zu verwendenden Array Elemente   
#
######################################################################################
sub medianArray {
  my $aref = shift;
  my $num  = shift;

  return if(ref $aref ne 'ARRAY' || !scalar @{$aref});     
  
  if (defined $num) {                                                   # Anzahl der (neuesten) Elemente die verwendet werden sollen
      return unless $num =~ /^\d+$/ && $num > 0 && $num <= @$aref;
  }
        
  my @tail   = defined $num ? @{$aref}[-$num .. -1] : @{$aref};     
  my @sorted = sort { $a <=> $b } @tail;                                # Numerisch aufsteigend
  my $n      = scalar @sorted;
  my $mid    = int ($n/2);

  my $median = $n % 2 ? $sorted[$mid] :                                 # ungerade Elemente -> Median Element steht in der Mitte von @sorted
               ($sorted[$mid - 1] + $sorted[$mid]) / 2;                 # gerade Elemente -> Median ist der Durchschnitt der beiden mittleren Elemente
  
return $median;
}

################################################################
#     Berechnen Tag / Stunden Verschieber
#     aus aktueller Stunde + lfd. Nummer
################################################################
sub calcDayHourMove {
  my $chour = shift;
  my $num   = shift;

  my $fh = int ($chour) + $num;
  my $fd = int ($fh / 24) ;
  $fh    = $fh - ($fd * 24);

return ($fd, $fh);
}

################################################################
#  Zeit gemäß DWD_OpenData-Format
#  Berechnen Tag / Stunden Verschieber ab aktuellen Tag
#  Input:   YYYY-MM-DD HH:MM:SS
#  Output:  $fd - 0 (Heute), 1 (Morgen), 2 (Übermorgen), ....
#           $fh - Stunde von $fd ohne führende Null
#  Return:  fc${fd}_${fh}
################################################################
sub formatWeatherTimestrg {
  my $date = shift // return;

  my $cdate = strftime "%Y-%m-%d", localtime(time);
  my $refts = timestringToTimestamp ($cdate.' 00:00:00');                                      # Referenztimestring
  my $datts = timestringToTimestamp ($date);
  my $fd    = int (($datts - $refts) / 86400);
  my $fh    = int ((split /[ :]/, $date)[1]);

return "fc${fd}_${fh}";
}

################################################################
#    Spezialfall auflösen wenn Wert von $val2 dem
#    Redingwert von $val1 entspricht sofern $val1 negativ ist
################################################################
sub substSpecialCases {
  my $paref = shift;
  my $dev   = $paref->{dev};
  my $rdg   = $paref->{rdg};
  my $rdgf  = $paref->{rdgf};

  my $val1  = ReadingsNum ($dev, $rdg, 0) * $rdgf;
  my $val2;

  if($val1 <= 0) {
      $val2 = abs($val1);
      $val1 = 0;
  }
  else {
      $val2 = 0;
  }

return ($val1,$val2);
}

################################################################
#              Timestrings berechnen
#  gibt Zeitstring in lokaler Zeit zurück
################################################################
sub timestampToTimestring {
  my $epoch = shift;
  my $lang  = shift // '';

  return if($epoch !~ /[0-9]/xs);

  if (strlength ($epoch) == 13) {                                                                   # Millisekunden
      $epoch = $epoch / 1000;
  }

  my ($lyear,$lmonth,$lday,$lhour,$lmin,$lsec) = (localtime($epoch))[5,4,3,2,1,0];
  my $tm;

  $lyear += 1900;                                                                                   # year is 1900 based
  $lmonth++;                                                                                        # month number is zero based

  my ($sec,$min,$hour,$day,$mon,$year) = (localtime(time))[0,1,2,3,4,5];                            # Standard f. z.B. Readingstimstamp
  $year += 1900;
  $mon++;

  my $realtm = sprintf ("%04d-%02d-%02d %02d:%02d:%02d", $year,$mon,$day,$hour,$min,$sec);          # engl. Variante von aktuellen timestamp
  my $tmdef  = sprintf ("%04d-%02d-%02d %02d:%s", $lyear,$lmonth,$lday,$lhour,"00:00");             # engl. Variante von $epoch für Logging-Timestamps etc. (Minute/Sekunde == 00)
  my $tmfull = sprintf ("%04d-%02d-%02d %02d:%02d:%02d", $lyear,$lmonth,$lday,$lhour,$lmin,$lsec);  # engl. Variante Vollzeit von $epoch

  if ($lang eq "DE") {
      $tm = sprintf ("%02d.%02d.%04d %02d:%02d:%02d", $lday,$lmonth,$lyear,$lhour,$lmin,$lsec);     # deutsche Variante Vollzeit von $epoch
  }
  else {
      $tm = $tmfull;
  }

return ($tm, $tmdef, $realtm, $tmfull);
}

################################################################
#  einen Zeitstring YYYY-MM-TT hh:mm:ss in einen Unix
#  Timestamp umwandeln
################################################################
sub timestringToTimestamp {
  my $tstring = shift;

  my($y, $mo, $d, $h, $m, $s) = $tstring =~ /([0-9]{4})-([0-9]{2})-([0-9]{2})\s([0-9]{2}):([0-9]{2}):([0-9]{2})/xs;
  return if(!$mo || !$y);

  my $timestamp = fhemTimeLocal($s, $m, $h, $d, $mo-1, $y-1900);

return $timestamp;
}

################################################################
#  einen Zeitstring YYYY-MM-TT hh:mm:ss in einen Unix
#  Timestamp GMT umwandeln
################################################################
sub timestringToTimestampGMT {
  my $tstring = shift;

  my($y, $mo, $d, $h, $m, $s) = $tstring =~ /([0-9]{4})-([0-9]{2})-([0-9]{2})\s([0-9]{2}):([0-9]{2}):([0-9]{2})/xs;
  return if(!$mo || !$y);

  my $tsgm = fhemTimeGm ($s, $m, $h, $d, $mo-1, $y-1900);

return $tsgm;
}

###############################################################
#   Konvertiere UTC zu lokaler Zeit
###############################################################
sub timestringUTCtoLocal {
  my $name    = shift;
  my $timstr  = shift;
  my $pattern = shift // '%Y-%m-%dT%H:%M:%S';

  my ($err, $ctime) = convertTimeZone ( { name      => $name,
                                          pattern   => $pattern,
                                          dtstring  => $timstr,
                                          tzcurrent => 'UTC',
                                          tzconv    => 'local',
                                          writelog  => 0
                                        }
                                      );

  if ($err) {
      $err = 'ERROR while converting time zone: '.$err;
  }

return ($err, $ctime);
}

################################################################
#  Timestrings aus Startzeit Timestamp und gegebenen Offset (s)
#  berechnen, Rückgabe als Hashreferenz
################################################################
sub timestringsFromOffset {
  my $epoch  = shift;
  my $offset = shift // 0;

  return if($epoch !~ /^-?[0-9]*(.[0-9]*)?$/xs);

  if (strlength ($epoch) == 13) {                                                               # Millisekunden
      $epoch = $epoch / 1000;
  }

  my @ts = localtime ($epoch + $offset);                                                        # Offset kann pos. oder negativ sein

  my $dt = {
      year    => (strftime "%Y",       (@ts)),                                                  # Jahr
      month   => (strftime "%m",       (@ts)),                                                  # Monat
      day     => (strftime "%d",       (@ts)),                                                  # Tag (range 01 .. 31)
      date    => (strftime "%Y-%m-%d", (@ts)),                                                  # Datum
      hour    => (strftime "%H",       (@ts)),                                                  # Stunde in 24h format (00-23)
      minute  => (strftime "%M",       (@ts)),                                                  # Minute (00-59)
      dayname => (strftime "%a",       (@ts)),                                                  # Wochentagsname
  };

return $dt;
}

################################################################
#  Zeitstring der Form 2023-05-27T14:24:30+02:00 formatieren
#  in YYYY-MM-TT hh:mm:ss
################################################################
sub timestringFormat {
  my $tstring = shift;

  return if(!$tstring);

  $tstring = (split '\+', $tstring)[0];
  $tstring =~ s/T/ /g;

return $tstring;
}

################################################################
# Speichern Readings, Wert, Zeit in zentralen Readings Store
################################################################
sub storeReading {
  my $rdg = shift;
  my $val = shift;
  my $ts1 = shift;

  my $cmps = $rdg.'<>'.$val;
  $cmps   .= '<>'.$ts1 if(defined $ts1);

  push @da, $cmps;

return;
}

################################################################
#             Readings aus Array erstellen
# $doevt:  1-Events erstellen, 0-keine Events erstellen
#
# readingsBulkUpdate($hash,$reading,$value,$changed,$timestamp)
#
################################################################
sub createReadingsFromArray {
  my $hash  = shift;
  my $doevt = shift // 0;

  return if(!scalar @da);

  readingsBeginUpdate ($hash);

  for my $elem (@da) {
      my ($rn,$rval,$ts) = split "<>", $elem, 3;

      readingsBulkUpdate ($hash, $rn, $rval, undef, $ts);
  }

  readingsEndUpdate ($hash, $doevt);

  @da = ();                                                      # completely empty @ARRAY

return;
}

################################################################
#        "state" updaten
################################################################
sub singleUpdateState {
  my $paref = shift;

  my $hash  = $paref->{hash};
  my $val   = $paref->{state} // 'unknown';
  my $evt   = $paref->{evt}   // 0;

  readingsSingleUpdate ($hash, 'state', $val, $evt);

return;
}

################################################################
#         Zentralschleife freigeben
################################################################
sub releaseCentralTask {
  my $hash = shift;
  my $name = $hash->{NAME};

  RemoveInternalTimer ($hash, 'FHEM::SolarForecast::releaseCentralTask');

  $data{$name}{current}{ctrunning} = 0;

return;
}

################################################################
#  erstellt einen Debug-Eintrag im Log
################################################################
sub debugLog {
  my $paref   = shift;
  my $dreg    = shift;                       # Regex zum Vergleich
  my $dmsg    = shift;                       # auszugebender Meldungstext
  my $verbose = shift // 1;

  my $name  = $paref->{name};
  my $debug = $paref->{debug};

  if ($debug =~ /$dreg/x) {
      Log3 ($name, $verbose, "$name DEBUG> $dmsg");
  }

return;
}

##################################################################
# Konvertiert Azimut von der Solar-Konvention (+180 .. 0 .. -180) 
# in die astronomische Konvention (0 ... 360°)
##################################################################
sub azSolar2Astro {
  my ($azsolar) = @_;

return ($azsolar + 180) % 360;
}

###################################################################
#  liefert eine dynamische Farbe abhängig von "$val" und dem 
#  Ende-Wert "$end" zurück
#  https://www.w3schools.com/colors/colors_picker.asp
#  https://wiki.fhem.de/wiki/Color#Skalenfarbe_mit_Color::pahColor
###################################################################
sub val2pahColor {
  my $val = shift;
  my $end = shift // 400;

  my $beg = 0;
  my $mid = $end / 2;

  my $color = substr (Color::pahColor ($beg, $mid, $end, $val, [40,198,45, 127,255,0, 251,158,4, 255,127,0, 255,0,0]), 0, 6);

return $color;
}

############################################################################
#  Interpretiert einen übergebenen Wert zwischen 0..100 als Farbe
#  zwischen Rot..Grün
#  $satiety:  Sättigung 0.1..1, 1 oder nicht gesetzt -> volle Sättigung
#  $opacity:  Deckkraft 0..1    1 = voll deckend, 0 = komplett transparent
############################################################################
sub val2dynColor {
  my $val     = shift;                                          # Wert von 0 bis 100
  my $satiety = shift;                                          # Sättigung 0.1 (mehr Grau) ..1 (Original)
  my $opacity = shift;
    
  $val = max(0, min(100, $val));

  my ($r, $g, $b, $t);

  if ($val <= 50) {                                             # Übergang: Rot (#FF0000) → Orange (#FF8C00)
      $t = $val / 50;
      $r = 255;
      $g = int (140 * $t);                                      # 0 → 140
      $b = 0;
  } 
  else {                                                        # Übergang: Orange (#FF8C00) → Dunkelgrün (#00C000)
      $t = ($val - 50) / 50;
      $r = int (255 * (1 - $t));                                # 255 → 0
      $g = int (140 + (192 - 140) * $t);                        # 140 → 192 (z.B. C0)
      $b = 0;
    }
    
  ($r, $g, $b) = _reduceSaturation ($r, $g, $b, $satiety);      # optional Sättigung bei gesetztem satiety
    
  if ($opacity) {                                               # Alpha-Wert: 1 = voll deckend, 0 = komplett transparent
      return sprintf ("#%02X%02X%02X%02X", $r, $g, $b, int ($opacity * 255 + 0.5));
  }                     
    
return sprintf ("#%02X%02X%02X", $r, $g, $b);
}

sub _reduceSaturation {
  my ($r, $g, $b, $satiety) = @_;

  return ($r, $g, $b) unless $satiety;

  ($r, $g, $b)    = map { $_ / 255 } ($r, $g, $b);           # RGB normalisieren auf [0,1]
  my ($h, $s, $v) = Color::rgb2hsv ($r, $g, $b);             # Umwandlung RGB → HSV
  $s             *= $satiety;                                # Sättigung verringern → Farbe wird grauer: 0.1 -> fast ganz grau, 0.6 -> nur leicht verblasst
  ($r, $g, $b)    = Color::hsv2rgb ($h, $s, $v);             # HSV → zurück zu RGB

return map { int($_ * 255 + 0.5) } ($r, $g, $b);             # Zurück in 0–255 Bereich
}

################################################################
#    alle Readings eines Devices oder nur Reading-Regex
#    löschen
################################################################
sub deleteReadingspec {
  my $hash = shift;
  my $spec = shift // ".*";

  my $readingspec = '^'.$spec.'$';

  for my $reading ( grep { /$readingspec/x } keys %{$hash->{READINGS}} ) {
      readingsDelete ($hash, $reading);
  }

return;
}

######################################################################################
#     NOTIFYDEV und "Probably associated with" erstellen
######################################################################################
sub createAssociatedWith {
  my $hash = shift;
  my $name = $hash->{NAME};
  my $type = $hash->{TYPE};

  RemoveInternalTimer ($hash, 'FHEM::SolarForecast::createAssociatedWith');

  if ($init_done) {
      my (@cd, @nd);
      my ($afc, $ara, $ain, $ame, $aba, $h);

      my $fcdev1 = AttrVal ($name, 'setupWeatherDev1', '');                  # Weather forecast Device 1
      ($afc,$h)  = parseParams ($fcdev1);
      $fcdev1    = $afc->[0] // '';

      my $fcdev2 = AttrVal ($name, 'setupWeatherDev2', '');                  # Weather forecast Device 2
      ($afc,$h)  = parseParams ($fcdev2);
      $fcdev2    = $afc->[0] // '';

      my $fcdev3 = AttrVal ($name, 'setupWeatherDev3', '');                  # Weather forecast Device 3
      ($afc,$h)  = parseParams ($fcdev3);
      $fcdev3    = $afc->[0] // '';

      my $radev = AttrVal ($name, 'setupRadiationAPI', '');                  # Radiation forecast Device
      ($ara,$h) = parseParams ($radev);
      $radev    = $ara->[0] // '';

      my $medev = AttrVal ($name, 'setupMeterDev', '');                      # Meter Device
      ($ame,$h) = parseParams ($medev);
      $medev    = $ame->[0] // '';
      push @cd, $medev;

      for my $c (sort{$a<=>$b} keys %{$data{$name}{consumers}}) {            # Consumer Devices
          my $consumer  = AttrVal ($name, "consumer${c}", "");
          my ($ac,$hc)  = parseParams ($consumer);
          my ($codev)   = split ":", ($ac->[0] // '');
          my ($dswitch) = split ":", ($hc->{switchdev} // '');               # alternatives Schaltdevice
          push @cd, $codev   if($codev);
          push @cd, $dswitch if($dswitch);
      }

      for my $bn (1..MAXBATTERIES) {                                         # Battery Devices
          $bn       = sprintf "%02d", $bn;
          my $badev = AttrVal ($name, "setupBatteryDev${bn}", '');
          my ($aba) = parseParams ($badev);
          push @cd, $aba->[0] if($aba->[0]);
      }

      for my $in (1..MAXINVERTER) {                                          # Inverter Devices
          $in       = sprintf "%02d", $in;
          my $inc   = AttrVal ($name, "setupInverterDev${in}", '');
          my ($ind) = parseParams ($inc);
          push @cd, $ind->[0] if($ind->[0]);
      }

      @nd = @cd;

      push @nd, $fcdev1 if($fcdev1 && $fcdev1 !~ /-API/xs);
      push @nd, $fcdev2 if($fcdev2 && $fcdev2 !~ /-API/xs);
      push @nd, $fcdev3 if($fcdev3 && $fcdev3 !~ /-API/xs);
      push @nd, $radev  if($radev  && $radev  !~ /-API/xs);
      push @nd, $medev;

      for my $prn (1..MAXPRODUCER) {                                         # Producer Devices
          $prn      = sprintf "%02d", $prn;
          my $pdc   = AttrVal ($name, "setupOtherProducer${prn}", "");
          my ($prd) = parseParams ($pdc);
          push @nd, $prd->[0] if($prd->[0]);
      }

      my @ndn = ();

      for my $e (@nd) {
          next if(grep /^$e$/, @ndn);
          push @ndn, $e;
      }

      my %seen;

      if (@cd) {
          $hash->{NOTIFYDEV} = join ",", grep { !$seen{$_ }++ } @cd;
      }

      if (@nd) {
          undef %seen;
          my $asw = join " ", grep { !$seen{$_ }++ } @nd;
          readingsSingleUpdate ($hash, ".associatedWith", $asw, 0);
      }
  }
  else {
      InternalTimer (gettimeofday() + 3, 'FHEM::SolarForecast::createAssociatedWith', $hash, 0);
  }

return;
}

################################################################
#  Funktion liefert den Planungsmodus eines Verbrauchers
#  mode kann sein:
#       can
#       must
################################################################
sub getConsumerPlanningMode {
  my $hash = shift;
  my $c    = shift;

  my $name = $hash->{NAME};
  my $mode = ConsumerVal ($hash, $c, 'mode', DEFCMODE);                                    # Consumer Planungsmode

  if ($mode =~ /^(?:can|must)$/xs) {
      return $mode;
  }

  ## Mode kann über Device:Reading gesteuert sein
  #################################################
  my ($dv, $rd) = split ':', $mode;
  my ($err)     = isDeviceValid ( { name => $hash->{NAME}, obj => $dv, method => 'string' } );

  if ($err) {
      Log3 ($name, 1, qq{$name - ERROR - consumer >$c< - The device '$dv' in consumer key 'mode' doesn't exist. Fall back to 'DEFCMODE' mode.});
      return DEFCMODE;
  }

  $err  = q{};
  $mode = ReadingsVal ($dv, $rd, '');

  if ($mode !~ /^(?:can|must)$/xs) {
      Log3 ($name, 1, qq{$name - ERROR - consumer >$c< - The reading '$rd' of device '$dv' is invalid or doesn't contain a valid mode. Fall back to 'DEFCMODE' mode.});
      return DEFCMODE;
  }

return $mode;
}

################################################################
#     Consumer mintime ermitteln und zurückliefern
################################################################
sub getConsumerMintime {
  my $paref   = shift;
  my $name    = $paref->{name};
  my $c       = $paref->{c};
  my $nolog   = $paref->{nolog};
  my $lang    = $paref->{lang};
  my $debug   = $paref->{debug};

  my $hash    = $defs{$name};
  my $err     = '';

  my $mintime = ConsumerVal ($hash, $c, 'mintime', DEFMINTIME);

  if (isSunPath ($hash, $c)) {                                                                 # SunPath ist in mintime gesetzt
      my $t                      = time;
      my ($riseshift, $setshift) = sunShift   ($hash, $c);
      my $sunrisestartts         = CurrentVal ($hash, 'sunriseTodayTs', 0) + $riseshift;
      my $startts                = $t if($t > $sunrisestartts);

      my $tdiff                  = (CurrentVal ($hash, 'sunsetTodayTs',  0) + $setshift) -
                                   (defined $startts ? $startts : $sunrisestartts);

      $mintime                   = sprintf '%.1f', ($tdiff / 60);

      if ($debug =~ /consumerPlanning/x && !$nolog) {
          Log3 ($name, 1, "$name DEBUG> consumer '$c' - mintime is controlled by 'SunPath'");

          if (defined $startts) {
              my $starttime = (timestampToTimestring ($startts, $lang))[3];
              Log3 ($name, 1, "$name DEBUG> consumer '$c' - Sunrise is replaced by $starttime, as the time of sunrise is in the past");
          }
          else {
              my $startsunrisetime = (timestampToTimestring ($sunrisestartts, $lang))[3];
              Log3 ($name, 1, "$name DEBUG> consumer '$c' - Sunrise is shifted by >".($riseshift / 60)."< minutes");
              Log3 ($name, 1, "$name DEBUG> consumer '$c' - starttime is set to >$startsunrisetime<");
          }

          Log3 ($name, 1, "$name DEBUG> consumer '$c' - Sunset is shifted by >". ($setshift / 60)."< minutes");
          Log3 ($name, 1, "$name DEBUG> consumer '$c' - mintime calculated: ".$mintime." minutes");
      }
  }
  elsif ($mintime =~ /.*:.*/xs) {
      if ($debug =~ /consumerPlanning/x && !$nolog) {
          Log3 ($name, 1, "$name DEBUG> consumer '$c' - use Device:Reading -> '$mintime' for getting mintime");
      }

      my ($dv, $rd) = split ':', $mintime;
      ($err)        = isDeviceValid ( { name => $name, obj => $dv, method => 'string' } );

      if (!$err) {
          $mintime = ReadingsVal ($dv, $rd, '');

          if (!isNumeric ($mintime)) {
              $err = "The reading '$rd' of device '$dv' is invalid or doesn't contain a numeric value";
          }
      }
  }

return ($err, $mintime);
}

################################################################
#   Planungsdaten Consumer löschen
#   $c - Consumer Nummer
################################################################
sub deleteConsumerPlanning {
  my $hash = shift;
  my $c    = shift;

  my $type   = $hash->{TYPE};
  my $name   = $hash->{NAME};
  my $calias = ConsumerVal ($hash, $c, "alias", "");

  delete $data{$name}{consumers}{$c}{planstate};
  delete $data{$name}{consumers}{$c}{planSupplement};
  delete $data{$name}{consumers}{$c}{planswitchon};
  delete $data{$name}{consumers}{$c}{planswitchoff};
  delete $data{$name}{consumers}{$c}{plandelete};
  delete $data{$name}{consumers}{$c}{ehodpieces};

  deleteReadingspec ($hash, "consumer${c}.*");

  Log3($name, 3, qq{$name - Consumer planning of "$calias" deleted});

return;
}

################################################################
#             Steuerparameter berechnen / festlegen
################################################################
sub controller {
  my $name = shift;

  my $interval = CurrentVal ($name, 'cycleInterval', DEFINTERVAL);            # 0 wenn manuell gesteuert
  my $idval    = IsDisabled ($name);
  my $disabled = $idval == 1 ? 1 : 0;
  my $inactive = $idval == 3 ? 1 : 0;

return ($interval, $disabled, $inactive);
}

################################################################
#  Internal MODEL und Model abhängige Setzungen / Löschungen
################################################################
sub setModel {
  my $hash = shift;
  my $name = $hash->{NAME};

  my $radapi = AttrVal ($name, 'setupRadiationAPI', 'DWD');
  my $wthapi = AttrVal ($name, 'setupWeatherDev1',  'DWD');

  if    ($radapi =~ /SolCast-/xs)              { $hash->{MODEL} = 'SolCastAPI';              }
  elsif ($radapi =~ /ForecastSolar-/xs)        { $hash->{MODEL} = 'ForecastSolarAPI';        }
  elsif ($radapi =~ /VictronKI-/xs)            { $hash->{MODEL} = 'VictronKiAPI';            }
  elsif ($radapi =~ /OpenMeteoDWDEnsemble-/xs) { $hash->{MODEL} = 'OpenMeteoDWDEnsembleAPI'; }
  elsif ($radapi =~ /OpenMeteoDWD-/xs)         { $hash->{MODEL} = 'OpenMeteoDWDAPI';         }
  elsif ($radapi =~ /OpenMeteoDWD_D2-/xs)      { $hash->{MODEL} = 'OpenMeteoDWDD2API';       }
  elsif ($radapi =~ /OpenMeteoWorld-/xs)       { $hash->{MODEL} = 'OpenMeteoWorldAPI';       }
  else                                         { $hash->{MODEL} = 'DWD';                     }

  if    ($wthapi =~ /OpenMeteoDWDEnsemble-/xs) { $hash->{WEATHERMODEL} = 'OpenMeteoDWDEnsembleAPI'; }
  elsif ($wthapi =~ /OpenMeteoDWD-/xs)         { $hash->{WEATHERMODEL} = 'OpenMeteoDWDAPI';         }
  elsif ($wthapi =~ /OpenMeteoDWD_D2-/xs)      { $hash->{WEATHERMODEL} = 'OpenMeteoDWDD2API';       }
  elsif ($wthapi =~ /OpenMeteoWorld-/xs)       { $hash->{WEATHERMODEL} = 'OpenMeteoWorldAPI';       }
  else                                         { $hash->{WEATHERMODEL} = 'DWD';                     }

return;
}

################################################################
#  Laufzeit Ergebnis erfassen und speichern
################################################################
sub setTimeTracking {
  my $hash = shift;
  my $st   = shift;                  # Startzeitstempel
  my $tkn  = shift;                  # Name des Zeitschlüssels

  my $name = $hash->{NAME};
  my $type = $hash->{TYPE};

  $data{$name}{current}{$tkn} = sprintf "%.5f", tv_interval($st);

return;
}

################################################################
#  Voraussetzungen zur Nutzung der KI prüfen, Status setzen
#  und Prüfungsergebnis (0/1) zurückgeben
################################################################
sub isPrepared4AI {
  my $hash = shift;
  my $full = shift // q{};                   # wenn true -> auch Auswertung ob on_.*_ai gesetzt ist

  my $name        = $hash->{NAME};
  my $type        = $hash->{TYPE};
  my ($acu, $aln) = isAutoCorrUsed ($name);

  my $err;

  if (!isDWDUsed($hash) && !isOpenMeteoUsed($hash)) {
      $err = qq(Unfortunately, AI support is not possible with the selected radiation API MODEL.);
  }
  elsif ($aidtabs) {
      $err = qq(The Perl module AI::DecisionTree is missing. Please install it with e.g. "cpan install AI::DecisionTree" for AI support);
  }
  elsif ($full && $acu !~ /ai/xs) {
      $err = "Set pvCorrectionFactor_Auto to '<any>_ai' for switch on AI support";
  }

  if ($err) {
      $data{$name}{current}{aicanuse} = $err;
      return 0;
  }

  $data{$name}{current}{aicanuse} = 'ok';

return 1;
}

################################################################
#  Funktion liefert 1 wenn Consumer physisch "eingeschaltet"
#  ist, d.h. der Wert onreg des Readings rswstate wahr ist
################################################################
sub isConsumerPhysOn {
  my $hash = shift;
  my $c    = shift;
  my $name = $hash->{NAME};

  my ($err, $cname, $dswname) = getCDnames ($hash, $c);                  # Consumer und Switch Device Name

  if ($err) {
      Log3 ($name, 1, "$name - ERROR - $err");
      return 0;
  }

  my $reg      = ConsumerVal ($hash, $c, 'onreg',       'on');
  my $rswstate = ConsumerVal ($hash, $c, 'rswstate', 'state');           # Reading mit Schaltstatus
  my $swstate  = ReadingsVal ($dswname, $rswstate,   'undef');

  if ($swstate =~ m/^$reg$/x) {
      return 1;
  }

return 0;
}

################################################################
#  Funktion liefert 1 wenn Consumer physisch "ausgeschaltet"
#  ist, d.h. der Wert offreg des Readings rswstate wahr ist
################################################################
sub isConsumerPhysOff {
  my $hash = shift;
  my $c    = shift;
  my $name = $hash->{NAME};

  my ($err, $cname, $dswname) = getCDnames ($hash, $c);                  # Consumer und Switch Device Name

  if ($err) {
      Log3 ($name, 1, "$name - ERROR - $err");
      return 0;
  }

  my $reg      = ConsumerVal ($hash, $c, 'offreg',     'off');
  my $rswstate = ConsumerVal ($hash, $c, 'rswstate', 'state');           # Reading mit Schaltstatus
  my $swstate  = ReadingsVal ($dswname, $rswstate,    'undef');

  if ($swstate =~ m/^$reg$/x) {
      return 1;
  }

return 0;
}

################################################################
#  Funktion liefert 1 wenn Consumer logisch "eingeschaltet"
#  ist, d.h. wenn der Energieverbrauch über einem bestimmten
#  Schwellenwert oder der prozentuale Verbrauch über dem
#  Defaultwert DEFPOPERCENT ist.
#
#  Logisch "on" schließt physisch "on" mit ein.
################################################################
sub isConsumerLogOn {
  my $hash  = shift;
  my $c     = shift;
  my $pcurr = shift // 0;

  my $name  = $hash->{NAME};
  my $cname = ConsumerVal ($name, $c, 'name', '');                                         # Devicename Customer
  my ($err) = isDeviceValid ( { name => $name, obj => $cname, method => 'string' } );

  if ($err) {
      Log3 ($name, 1, qq{$name - ERROR - The consumer device '$cname' is invalid. The 'on'-state can't be identified.});
      return 0;
  }

  if (isConsumerPhysOff ($hash, $c)) {                                                     # Device ist physisch ausgeschaltet
      return 0;
  }

  my $type       = $hash->{TYPE};
  my $nompower   = ConsumerVal ($name, $c, "power",          0);                           # nominale Leistung lt. Typenschild
  my $rpcurr     = ConsumerVal ($name, $c, "rpcurr",        "");                           # Reading für akt. Verbrauch angegeben ?
  my $pthreshold = ConsumerVal ($name, $c, "powerthreshold", 0);                           # Schwellenwert (W) ab der ein Verbraucher als aktiv gewertet wird

  if (!$rpcurr && isConsumerPhysOn ($hash, $c)) {                                          # Workaround wenn Verbraucher ohne Leistungsmessung
      $pcurr = $nompower;
  }

  my $currpowerpercent = $pcurr;
  $currpowerpercent    = ($pcurr / $nompower) * 100 if($nompower > 0);

  $data{$name}{consumers}{$c}{currpowerpercent} = $currpowerpercent;

  if ($pcurr > $pthreshold || (!$pthreshold && $currpowerpercent > DEFPOPERCENT)) {        # Verbraucher ist logisch aktiv
      return 1;
  }

return 0;
}

################################################################
#  Consumer $c in Grafik ausblenden (1) oder nicht (0)
#  0 - nicht aublenden (default)
#  1 - ausblenden
#  2 - nur in Consumerlegende ausblenden
#  3 - nur in Flowgrafik ausblenden
#  9 - Schaltersysmbol im Consumerpanel ausblenden
################################################################
sub isConsumerNoshow {
  my $hash = shift;
  my $c    = shift;

  my $noshow = ConsumerVal ($hash, $c, 'noshow', 0);                                 # Schalter "Ausblenden"

  if (!isNumeric ($noshow)) {                                                        # Key "noshow" enthält Signalreading
      my $rdg                   = $noshow;
      my ($err, $dev, $dswname) = getCDnames ($hash, $c);                            # Consumer und Switch Device Name

      if ($noshow =~ /:/xs) {
          ($dev, $rdg) = split ":", $noshow;
      }

      $noshow = ReadingsNum ($dev, $rdg, 0);
  }

  if ($noshow !~ /[01239]/xs) {                                                      # nur Ergebnisse 0..X zulassen
      $noshow = 0;
  }

return $noshow;
}

################################################################
#  Funktion liefert "1" wenn die zusätzliche Einschaltbedingung
#  aus dem Schlüssel "swoncond" im Consumer Attribut wahr ist
#
#  $info - den Info-Status
#  $err  - einen Error-Status
#
################################################################
sub isAddSwitchOnCond {
  my $name = shift;
  my $c    = shift;

  my $info = q{};
  my $swon = 0;

  my $dswoncond = ConsumerVal ($name, $c, 'dswoncond', '');                     # Device zur Lieferung einer zusätzlichen Einschaltbedingung
  my ($err)     = isDeviceValid ( { name   => $name,
                                    obj    => $dswoncond,
                                    method => 'string',
                                  }
                                );

  if ($dswoncond && $err) {
      $err = qq{ERROR - The device "$dswoncond" doesn't exist! Check the key "swoncond" in attribute "consumer${c}"};
      return ($swon, $info, $err);
  }

  $err          = q{};
  my $rswoncond = ConsumerVal ($name, $c, 'rswoncond',     '');             # Reading zur Lieferung einer zusätzlichen Einschaltbedingung
  my $swoncode  = ConsumerVal ($name, $c, 'swoncondition', '');             # Regex einer zusätzliche Einschaltbedingung
  my $condval   = ReadingsVal ($dswoncond, $rswoncond,     '');             # Wert zum Vergleich mit Regex

  if ($swoncode =~ m/^\{.*\}$/xs) {                                         # wertet Perl-Code aus
      my $VALUE = $condval;
      my $true  = eval $swoncode;

      if ($@) {
          Log3 ($name, 1, "$name - ERROR in swoncond Code execution: ".$@);
      }

      if ($true) {
          $info  = qq{The return value “$true” resulted in 'true' after exec "$swoncode" \n};
          $info .= "-> Check successful ";
          $swon  = 1;
      }
      else {
          $info = qq{The return value “$true” resulted in 'false' after exec "$swoncode" \n};
          $swon = 0;
      }
  }
  elsif ($condval =~ m/^$swoncode$/x) {                                     # wertet Regex aus
      $info  = qq{value "$condval" matches the Regex "$swoncode" \n};
      $info .= "-> Check successful ";
      $swon  = 1;
  }
  else {
      $info = qq{The value of device "$dswoncond", reading "$rswoncond" doesn't match the condition "$swoncode"};
  }

return ($swon, $info, $err);
}

################################################################
#  Funktion liefert "1" wenn eine Ausschaltbedingung
#  erfüllt ist
#  ("swoffcond" oder "interruptable" im Consumer Attribut)
#  Der Inhalt von "interruptable" wird optional in $cond
#  übergeben.
#
#  $info - den Info-Status
#  $err  - einen Error-Status
#
################################################################
sub isAddSwitchOffCond {
  my $hash = shift;
  my $c    = shift;
  my $cond = shift // q{};
  my $hyst = shift // 0;                                                          # Hysterese

  my $name       = $hash->{NAME};
  my $swoff      = 0;
  my $info       = q{};
  my $dswoffcond = q{};                                                           # Device zur Lieferung einer Ausschaltbedingung
  my $rswoffcond = q{};                                                           # Reading zur Lieferung einer Ausschaltbedingung
  my $swoffcode  = q{};                                                           # Code/Regex der Ausschaltbedingung (wenn wahr)

  if ($cond) {
      ($dswoffcond, $rswoffcond, $swoffcode) = split ":", $cond, 3;
  }
  else {
      $dswoffcond = ConsumerVal ($hash, $c, 'dswoffcond',     '');
      $rswoffcond = ConsumerVal ($hash, $c, 'rswoffcond',     '');
      $swoffcode  = ConsumerVal ($hash, $c, 'swoffcondition', '');
  }

  my ($err) = isDeviceValid ( { name => $name, obj => $dswoffcond, method => 'string' } );

  if ($dswoffcond && $err) {
      $err = qq{ERROR - The device "$dswoffcond" doesn't exist! Check the key "swoffcond" or "interruptable" in attribute "consumer${c}"};
      return (0, $info, $err);
  }

  $err        = q{};
  my $condval = ReadingsVal ($dswoffcond, $rswoffcond, undef);

  if (defined $condval) {
      if ($swoffcode =~ m/^\{.*\}$/xs) {                                                                 # wertet Perl-Code aus
          my $VALUE = $condval;
          my $true  = eval $swoffcode;

          if ($@) {
              Log3 ($name, 1, "$name - ERROR in interruptable or swoffcond Code execution: ".$@);
          }

          if ($true) {
              $info   = qq{The return value “$true” resulted in 'true' after exec "$swoffcode" \n};
              $info  .= "-> Check successful ";
              $swoff  = 1;
          }
          else {
              $info  = qq{The return value “$true” resulted in 'false' after exec "$swoffcode" \n};
              $swoff = 0;
          }
      }
      elsif ($condval =~ m/^$swoffcode$/x) {                                                            # wertet Regex aus
          $info   = qq{value "$condval" matches the Regex "$swoffcode" \n};
          $info  .= "-> Check successful ";
          $swoff  = 1;
      }
      else {
          $info  = qq{value "$condval" doesn't match the Regex "$swoffcode" \n};
          $swoff = 0;
      }

      if ($hyst && isNumeric ($condval)) {                                                              # Hysterese berücksichtigen
          $condval -= $hyst;

          if ($condval =~ m/^$swoffcode$/x) {
              $info   = qq{value "$condval" (included hysteresis = $hyst) matches the Regex "$swoffcode" \n};
              $info  .= "-> Check successful ";
              $swoff  = 1;
          }
          else {
              $info  = qq{device: "$dswoffcond", reading: "$rswoffcond" , value: "$condval" (included hysteresis = $hyst) doesn't match Regex: "$swoffcode" \n};
              $swoff = 0;
          }
      }

      $info .= qq{(the effect depends on the switch context)};
  }

return ($swoff, $info, $err);
}

################################################################
#  Funktion liefert "1", wenn sich die Anlage im 
#  Status 'Abregelung' befindet. (plantControl->reductionState)
#  
#  valCurrent:  reductionState -> <Device>:<Reading>:<Regex> 
#  $info - den Info-Status
#  $err  - einen Error-Status
#
################################################################
sub isReductionState {
  my $name = shift;

  my $info     = q{};
  my $rdcstate = 0;

  my $rdcs = CurrentVal ($name, 'reductionState', ''); 
  return ($rdcstate, 'reductionState not set', '') if(!$rdcs);
  
  my ($rdcdev, $rdcrd, $rdcrgx) = split ":", $rdcs;                      # $rdcdev / $rdcrd -> Device / Reading zur Lieferung des Abregelungsstatus
  
  my ($err) = isDeviceValid ( { name   => $name,
                                obj    => $rdcdev,
                                method => 'string',
                              }
                            );

  if ($err) {
      $err = qq{ERROR - The device "$rdcdev" doesn't exist! Check the key plantControl->reductionState".};
      return ($rdcstate, $info, $err);
  }

  $err       = q{};
  my $rdcval = ReadingsVal ($rdcdev, $rdcrd, '');                           # Wert zum Vergleich mit Regex

  if ($rdcrgx =~ m/^\{.*\}$/xs) {                                           # wertet Perl-Code aus
      my $VALUE = $rdcval;
      my $true  = eval $rdcrgx;

      if ($@) {
          Log3 ($name, 1, "$name - ERROR in plantControl->reductionState Code execution: ".$@);
      }

      if ($true) {
          $info  = qq{The value “$rdcval” resulted in 'true' after exec "$rdcrgx"};
          $rdcstate  = 1;
      }
      else {
          $info = qq{The value “$rdcval” resulted in 'false' after exec "$rdcrgx" \n};
          $rdcstate = 0;
      }
  }
  elsif ($rdcval =~ m/^$rdcrgx$/x) {                                     # wertet Regex aus
      $info  = qq{value "$rdcval" matches the Regex "$rdcrgx"};
      $rdcstate  = 1;
  }
  else {
      $info = qq{The value of device "$rdcdev", reading "$rdcrd" doesn't match the condition "$rdcrgx"};
  }

return ($rdcstate, $info, $err);
}

################################################################
#  Funktion liefert "1" wenn die angegebene Bedingung
#  aus dem Consumerschlüssel 'spignorecond' erfüllt ist.
#
#  $info - den Info-Status
#  $err  - einen Error-Status
#
################################################################
sub isSurplusIgnoCond {
  my $hash  = shift;
  my $c     = shift;
  my $debug = shift;

  my $name = $hash->{NAME};
  my $igno = 0;
  my $info = q{};

  my $digncond = ConsumerVal ($hash, $c, 'dspignorecond', '');                          # Device zur Lieferung einer "Überschuß Ignore-Bedingung"
  my ($err)    = isDeviceValid ( { name   => $name,
                                   obj    => $digncond,
                                   method => 'string',
                                 }
                               );
  if ($digncond && $err) {
      $err = qq{ERROR - the device "$digncond" doesn't exist! Check the key "spignorecond" in attribute "consumer${c}"};
      return ($igno, $info, $err);
  }

  $err           = q{};
  my $rigncond   = ConsumerVal ($hash, $c, 'rigncond',          '');                   # Reading zur Lieferung einer zusätzlichen Einschaltbedingung
  my $ignorecode = ConsumerVal ($hash, $c, 'spignorecondition', '');                   # Code/Regex für PV Überschuß Ignore
  my $condval    = ReadingsVal ($digncond, $rigncond,        undef);                   # Wert zum Vergleich mit Code/Regex

  if ($debug =~ /consumerSwitching${c}/x && defined $condval) {
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - PV surplus ignore condition - device: $digncond, reading: $rigncond, condition: $ignorecode});
  }

  if (defined $condval) {
      if ($ignorecode =~ m/^\{.*\}$/xs) {                                              # wertet Perl-Code aus
          my $VALUE = $condval;
          my $true  = eval $ignorecode;

          if ($@) {
              Log3 ($name, 1, "$name - ERROR in surplus ignore condition Code execution: ".$@);
          }

          if ($true) {
              $info   = qq{Value “$condval” resulted in 'true' after exec "$ignorecode" \n};
              $info  .= "-> Check successful ";
              $igno  = 1;
          }
          else {
              $info  = qq{Value “$condval” resulted in 'false' after exec "$ignorecode" \n};
              $igno = 0;
          }
      }
      elsif ($condval =~ m/^$ignorecode$/x) {                                          # wertet Regex aus
          $igno = 1;
      }
      else {
          $info = qq{Value "$condval" doesn't match the condition: "$ignorecode"};
      }
  }

return ($igno, $info, $err);
}

################################################################
#  liefert den Status des Timeframe von Consumer $c
################################################################
sub isInTimeframe {
  my $hash = shift;
  my $c    = shift;

return ConsumerVal ($hash, $c, 'isIntimeframe', 0);
}

################################################################
#  liefert Entscheidung ob sich Consumer $c noch in der
#  Sperrzeit befindet
################################################################
sub isInLocktime {
  my $paref = shift;
  my $name  = $paref->{name};
  my $c     = $paref->{consumer};
  my $t     = $paref->{t};

  my $hash = $defs{$name};
  my $iilt = 0;
  my $rlt  = 0;
  my $lt   = 0;
  my $clt  = 0;

  my $ltt = isConsumerPhysOn  ($hash, $c) ? 'onlt'  :                             # Typ der Sperrzeit
            isConsumerPhysOff ($hash, $c) ? 'offlt' :
            '';

  my ($cltoff, $clton) = split ":", ConsumerVal ($hash, $c, 'locktime', '0:0');
  $clton             //= 0;                                                       # $clton undef möglich, da Angabe optional

  if ($ltt eq 'onlt') {
      $lt = ConsumerVal ($hash, $c, 'lastAutoOnTs', 0);
      $clt = $clton;
  }
  elsif ($ltt eq 'offlt') {
      $lt  = ConsumerVal ($hash, $c, 'lastAutoOffTs', 0);
      $clt = $cltoff;
  }

  if ($t - $lt <= $clt) {
      $iilt = 1;
      $rlt  = $clt - ($t - $lt);                                                  # remain lock time
  }

return ($iilt, $rlt);
}

################################################################
#  liefert den Status "Consumption Recommended" von Consumer $c
################################################################
sub isConsRcmd {
  my $hash = shift;
  my $c    = shift;

return ConsumerVal ($hash, $c, 'isConsumptionRecommended', 0);
}

################################################################
#       ist Batterie installiert ?
#       1 - ja, 0 - nein
################################################################
sub isBatteryUsed {
  my $name = shift;

  my $valid = 0;

  for my $bn (1..MAXBATTERIES) {
      $bn = sprintf "%02d", $bn;
      my ($err) = isDeviceValid ( { name => $name, obj => 'setupBatteryDev'.$bn, method => 'attr' } );
      next if($err);

      $valid = 1;
  }

return $valid;
}

################################################################
#  ist Consumer $c unterbrechbar (1|2) oder nicht (2|3)
################################################################
sub isInterruptable {
  my $hash  = shift;
  my $c     = shift;
  my $hyst  = shift // 0;
  my $print = shift // 0;                                                                  # Print out Debug Info

  my $name    = $hash->{NAME};
  my $intable = ConsumerVal ($hash, $c, 'interruptable', 0);

  if ($intable eq '0') {
      return 0;
  }
  elsif ($intable eq '1') {
      return 1;
  }

  my ($swoffcond, $info, $err) = isAddSwitchOffCond ($hash, $c, $intable, $hyst);
  Log3 ($name, 1, "$name - $err") if($err);

  my $debug = getDebug ($hash);                                                           # Debug Module

  if ($print && $debug =~ /consumerSwitching${c}/x) {
      Log3 ($name, 1, qq{$name DEBUG> consumer "$c" - Interrupt Info: $info});
  }

  if ($swoffcond) {
      return 2;
  }
  else {
      return 3;
  }

return;
}

################################################################
#  Prüfung auf numerischen Wert (vorzeichenbehaftet)
################################################################
sub isNumeric {
  my $val = shift // q{empty};

  my $ret = 0;

  if($val =~ /^-?(?:\d+(?:\.\d*)?|\.\d+)$/xs) {
      $ret = 1;
  }

return $ret;
}

################################################################
#  Prüfung auf Verwendung von DWD als Strahlungsquelle
################################################################
sub isDWDUsed {
  my $hash = shift;

  my $ret = 0;

  if (InternalVal ($hash->{NAME}, 'MODEL', '') eq 'DWD') {
      $ret = 1;
  }

return $ret;
}

################################################################
#  Prüfung auf Verwendung von SolCast API
################################################################
sub isSolCastUsed {
  my $hash = shift;

  my $ret = 0;

  if (InternalVal ($hash->{NAME}, 'MODEL', '') eq 'SolCastAPI') {
      $ret = 1;
  }

return $ret;
}

################################################################
#  Prüfung auf Verwendung von ForecastSolar API
################################################################
sub isForecastSolarUsed {
  my $hash = shift;

  my $ret = 0;

  if (InternalVal ($hash->{NAME}, 'MODEL', '') eq 'ForecastSolarAPI') {
      $ret = 1;
  }

return $ret;
}

################################################################
#  Prüfung auf Verwendung von Victron VRM API (KI basierend)
################################################################
sub isVictronKiUsed {
  my $hash = shift;

  my $ret = 0;

  if (InternalVal ($hash->{NAME}, 'MODEL', '') eq 'VictronKiAPI') {
      $ret = 1;
  }

return $ret;
}

################################################################
#  Prüfung auf Verwendung von Open-Meteo API
################################################################
sub isOpenMeteoUsed {
  my $hash = shift;

  my $ret = 0;

  if (InternalVal ($hash->{NAME}, 'MODEL', '') =~ /^OpenMeteo/xs) {
      $ret = 1;
  }

return $ret;
}

################################################################
#  Prüfung auf Verwendung von Open-Meteo API als
#  Lieferant für Wetterdaten
################################################################
sub isWeatherOpenMeteoUsed {
  my $hash = shift;

  my $ret = 0;

  if (InternalVal ($hash->{NAME}, 'WEATHERMODEL', '') =~ /^OpenMeteo/xs) {
      $ret = 1;
  }

return $ret;
}

################################################################
#       welche PV Autokorrektur wird verwendet ?
#       Standard bei nur "on" -> on_simple
#       $aln: 1 - Lernen aktiviert (default)
#             0 - Lernen deaktiviert
################################################################
sub isAutoCorrUsed {
  my $name = shift;

  my $cauto = ReadingsVal ($name, 'pvCorrectionFactor_Auto', 'off');

  my $acu = $cauto =~ /on_simple_ai/xs      ? 'on_simple_ai'      :
            $cauto =~ /on_simple/xs         ? 'on_simple'         :
            $cauto =~ /on_complex_ai/xs     ? 'on_complex_ai'     :
            $cauto =~ /on_complex_api_ai/xs ? 'on_complex_api_ai' :
            $cauto =~ /on_complex/xs        ? 'on_complex'        :
            $cauto =~ /standby/xs           ? 'standby'           :
            $cauto =~ /on/xs                ? 'on_simple'         :
            q{};

  my $aln = $cauto =~ /noLearning/xs ? 0 : 1;

return ($acu, $aln);
}

################################################################
#  liefert Status ob SunPath in mintime gesetzt ist
################################################################
sub isSunPath {
  my $hash = shift;
  my $c    = shift;

  my $is      = 0;
  my $mintime = ConsumerVal ($hash, $c, 'mintime', DEFMINTIME);

  if ($mintime =~ /^SunPath/xsi) {
      $is = 1;

      my $sunset  = CurrentVal ($hash, 'sunsetTodayTs',  1);
      my $sunrise = CurrentVal ($hash, 'sunriseTodayTs', 5);

      if ($sunrise > $sunset) {
          $is      = 0;
          my $name = $hash->{NAME};

          Log3 ($name, 1, qq{$name - ERROR - consumer >$c< use >mintime=SunPath< but readings >Today_SunRise< / >Today_SunSet< are not set properly.});
      }
  }

return $is;
}

#####################################################################
#    Prüft ob das im Ojekt übergebene Device valide ist
#    input:  $obj    - das Objekt (Reading, Attr, String)
#            method  - Art des Objekts
#                      reading: Device ist im Reading Value enthalten
#                      attr:    Device ist im Attr Value enthalten
#                      string:  Device ist im Objekt-Inhalt enthalten
#    return: $err    - evtl. Fehler
#            $a->[0] - das extrahierte Device
#            $h      - Hash der geparsten Entität
#####################################################################
sub isDeviceValid {
  my $paref  = shift;
  my $name   = $paref->{name};
  my $obj    = $paref->{obj};
  my $method = $paref->{method} // 'reading';

  my $err = '';
  my $dev = '';

  if ($method eq 'reading') {
      $dev = ReadingsVal ($name, $obj, '');
      return qq{Reading '$obj' is not set or is empty} if(!$dev);
  }
  elsif ($method eq 'attr') {
      $dev = AttrVal ($name, $obj, '');
      return qq{Attribute '$obj' is not set} if(!$dev);
  }
  elsif ($method eq 'string') {
      return qq{Object '$obj' is empty} if(!$obj);
      $dev = $obj;
  }

  my ($a, $h) = parseParams ($dev);

  my ($dv, $al) = !$a->[0]         ? ('', '')             :
                  $a->[0] =~ /:/xs ? (split ':', $a->[0]) :
                  ($a->[0], '');                                               # (optionalen) SF-spezifischen Alias abtrennen

  if (!$dv || !$defs{$dv}) {
      $dv //= '';
      $err  = qq{The device '$dv' doesn't exist or is not a valid device.};
      $err  = qq{There is no device set. Check the syntax with the command reference.}            if(!$dv);
      $err  = qq{The device '$dv' doesn't exist anymore! Delete or change the attribute '$obj'.}  if(!$defs{$dv} && $method eq 'attr' && $obj =~ /consumer/);
  }

  if ($err) {
      Log3 ($name, 1, "$name - ERROR - $err");
  }

  if ($al) {                                                                   # Leerzeichen im SF-Alias generieren
      $al =~ s/\+/ /g;
  }

return ($err, $dv, $h, $al);
}

#####################################################################
#    Prüft ob das in setupWeatherDevX
#    übergebene Weather Device valide ist
#    return - $valid -> ist die Angabe valide (1)
#             $apiu  -> wird ein Device oder API verwendet
#####################################################################
sub isWeatherDevValid {
  my $hash  = shift;
  my $wattr = shift;

  my ($rapi, $wapi) = ('', '');
  my $valid  = 0;
  my $apiu   = '';
  my $fcname = AttrVal ($hash->{NAME}, $wattr, '');                               # Weather Forecast Device/API
  return if(!$fcname);

  if (!$defs{$fcname}) {                                                          # kein Device -> API genutzt? 
      if ($fcname =~ /^OpenMeteo/xs) {
          $valid = 1;
          $apiu  = $fcname;
      }
  }
  else {                                                                          # DWD Device -> Typ Prüfung
      if ($defs{$fcname}{TYPE} eq 'DWD_OpenData') {
          $valid = 1;
      }
  }

return ($valid, $fcname, $apiu);
}

################################################################
#  Inhalt des Attr graphicHeaderOwnspecValForm validieren
################################################################
sub isGhoValFormValid {
  my $name = shift;
  my $code = shift;

  my $err       = q{};
  ($err, $code) = checkCode ($name, $code);

return $err;
}

###################################################################
#  püft das Alter fc_time aller Wetterdevices
#  $result->{agedv} : Name des DWD mit ältesten Daten
#  $result->{mosmix}: gewählte MOSMIX Variante
#  $result->{fctime}: Datenstand (Forecast Time)
#  $result->{exceed}: Bewertung ob zulässiges Alter überschritten
###################################################################
sub isWeatherAgeExceeded {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};

  my $hash   = $defs{$name};
  my $currts = int time;
  my $agets  = $currts;

  my $resh->{agedv} = '-';
  $resh->{mosmix}   = '-';
  $resh->{exceed}   = '';
  $resh->{fctime}   = '-';

  my ($newts, $th);

  for my $step (1..MAXWEATHERDEV) {
      my ($valid, $fcname, $apiu) = isWeatherDevValid ($hash, 'setupWeatherDev'.$step);
      next if(!$valid && $step ne 1);

      if (!$apiu) {
          if (!$fcname) {
              return (qq{No DWD device is defined in attribute "setupWeatherDev$step"}, $resh);
          }
          
          if (!$valid) {
              return (qq{The DWD device "$fcname" doesn't exist}, $resh);
          }

          my $fct = ReadingsVal ($fcname, 'fc_time', '');
          return (qq{The reading 'fc_time' ($fcname) doesn't exist or is empty}, $resh) if(!$fct);

          $newts = timestringToTimestamp ($fct);

          if ($newts <= $agets) {
              $agets         = $newts;
              $resh->{agedv} = $fcname;
              $resh->{apiu}  = $apiu;
          }
      }
      else {
          my ($rapi, $wapi) = getStatusApiName ($hash);
          $newts            = StatusAPIVal     ($hash, $wapi, '?All', 'lastretrieval_timestamp', $agets);

          if ($newts <= $agets) {
              $agets         = $newts;
              $resh->{agedv} = $fcname;
              $resh->{apiu}  = $apiu;
          }
      }
  }

  if (!$resh->{apiu}) {                                                                                 # DWD Device ist Wetterdatenlieferant
      $resh->{mosmix} = AttrVal ($resh->{agedv}, 'forecastRefresh', 6) == 6 ? 'MOSMIX_L' : 'MOSMIX_S';
      $th             = $resh->{mosmix} eq 'MOSMIX_S' ? 7200 : 25200;
  }
  else {                                                                                                # API ist Wetterdatenlieferant
      $resh->{mosmix} = 'ICON';
      $th = 5400;
  }

  $resh->{exceed} = $currts - $agets > $th ? 1 : 0;
  $resh->{fctime} = (timestampToTimestring ($agets, $lang))[0];

return ('', $resh);
}

###################################################################
#  püft das Alter fc_time des DWD Rad1h Devices
#  $result->{agedv} : Name des DWD Rad1h Devices
#  $result->{mosmix}: gewählte MOSMIX Variante
#  $result->{fctime}: Datenstand (Forecast Time)
#  $result->{exceed}: Bewertung ob zulässiges Alter überschritten
###################################################################
sub isRad1hAgeExceeded {
  my $paref = shift;
  my $name  = $paref->{name};
  my $lang  = $paref->{lang};

  my $hash   = $defs{$name};
  my $currts = int time;
  my $fcname = CurrentVal ($hash, 'dwdRad1hDev', '');

  my $resh->{agedv} = '-';
  $resh->{mosmix}   = '-';
  $resh->{exceed}   = '';
  $resh->{fctime}   = '-';

  if (!$fcname || !$defs{$fcname}) {
      if (!$fcname) {
          return (qq{No DWD device is defined in "setupRadiationAPI"}, $resh);
      }
      else {
          return (qq{The DWD device "$fcname" doesn't exist}, $resh);
      }
  }

  my $fct = ReadingsVal ($fcname, 'fc_time', '');
  return (qq{The reading 'fc_time' ($fcname) doesn't exist or is empty}, $resh) if(!$fct);

  $resh->{agedv}  = $fcname;
  $resh->{mosmix} = AttrVal ($resh->{agedv}, 'forecastRefresh', 6) == 1 ? 'MOSMIX_S' : 'MOSMIX_L';

  my $agets       = timestringToTimestamp ($fct);
  my $th          = $resh->{mosmix} eq 'MOSMIX_S' ? 7200 : 25200;
  $resh->{exceed} = $currts - $agets > $th ? 1 : 0;
  $resh->{fctime} = (timestampToTimestring ($agets, $lang))[0];

return ('', $resh);
}

################################################################
#  Verschiebung von Sonnenaufgang / Sonnenuntergang
#  bei Verwendung von mintime = SunPath
################################################################
sub sunShift {
  my $hash = shift;
  my $c    = shift;

  my $riseshift = ConsumerVal ($hash, $c, 'sunriseshift', 0);                  # Verschiebung (Sekunden) Sonnenaufgang bei SunPath Verwendung
  my $setshift  = ConsumerVal ($hash, $c, 'sunsetshift',  0);                  # Verschiebung (Sekunden) Sonnenuntergang bei SunPath Verwendung


return ($riseshift, $setshift);
}

################################################################
#  Prüfung ob global Attr latitude und longitude gesetzt sind
#  gibt latitude, longitude und altitude zurück
################################################################
sub locCoordinates {

  my $set = 0;
  my $lat = AttrVal ('global', 'latitude',  '');
  my $lon = AttrVal ('global', 'longitude', '');
  my $alt = AttrVal ('global', 'altitude',   0);

  if ($lat && $lon) {
      $set = 1;
  }

return ($set, $lat, $lon, $alt);
}

################################################################
#  liefert die Zeit des letzten Schaltvorganges
################################################################
sub lastConsumerSwitchtime {
  my $hash = shift;
  my $c    = shift;
  my $name = $hash->{NAME};

  my ($err, $cname, $dswname) = getCDnames ($hash, $c);                        # Consumer und Switch Device Name

  if ($err) {
      Log3 ($name, 1, qq{$name - ERROR - The last switching time can't be identified due to the device '$dswname' is invalid. Please check device names in consumer "$c" attribute});
      return;
  }

  my $rswstate = ConsumerVal           ($hash, $c, 'rswstate', 'state');       # Reading mit Schaltstatus
  my $swtime   = ReadingsTimestamp     ($dswname, $rswstate,        '');       # Zeitstempel im Format 2016-02-16 19:34:24
  my $swtimets;
  $swtimets    = timestringToTimestamp ($swtime) if($swtime);                  # Unix Timestamp Format erzeugen

return ($swtime, $swtimets);
}

################################################################
#  transformiert den ausführlichen Consumerstatus in eine
#  einfache Form
################################################################
sub simplifyCstate {
  my $ps = shift;

  $ps = $ps =~ /planned/xs        ? 'planned'      :
        $ps =~ /suspended/xs      ? 'suspended'    :
        $ps =~ /switching\son/xs  ? 'starting'     :
        $ps =~ /switched\son/xs   ? 'started'      :
        $ps =~ /switching\soff/xs ? 'stopping'     :
        $ps =~ /switched\soff/xs  ? 'finished'     :
        $ps =~ /priority/xs       ? 'priority'     :
        $ps =~ /interrupting/xs   ? 'interrupting' :
        $ps =~ /interrupted/xs    ? 'interrupted'  :
        $ps =~ /continuing/xs     ? 'continuing'   :
        $ps =~ /continued/xs      ? 'continued'    :
        $ps =~ /noSchedule/xs     ? 'noSchedule'   :
        'unknown';

return $ps;
}

################################################################
#        Länge eines Strings (auch mit Umlauten)
################################################################
sub strlength {
  my $string = shift // return 0;
 
  my $decoded = decode ('UTF-8', $string);

return length ($decoded);
}

################################################################
#  Prüfung eines übergebenen Regex
################################################################
sub checkRegex {
  my $regexp = shift;

  return 'no Regex is provided' if(!defined $regexp);

  eval { "Hallo" =~ m/^$regexp$/;
         1;
       }
       or do { my $err = (split " at", $@)[0];
               return "Bad regexp: ".$err;
             };

return;
}

################################################################
#                 prüfen Angabe hh[:mm]
################################################################
sub checkhhmm {
  my $val = shift;

  my $valid = 0;

  if ($val =~ /^([0-9]{1,2})(:[0-5]{1}[0-9]{1})?$/xs) {
      $valid = 1 if(int $1 < 24);
  }

return $valid;
}

################################################################
#          prüfen validen Code in $val
################################################################
sub checkCode {
  my $name = shift;
  my $val  = shift;
  my $cc1  = shift // 0;                                 # wenn 1 checkCode1 ausführen

  my $err;

  if (!$val || $val !~ m/^\s*\{.*\}\s*$/xs) {
      return qq{Usage of $name is wrong. The function has to be specified as "{<your own code>}"};
  }

  if ($cc1) {
      ($err, $val) = checkCode1 ($name, $val);
      return ($err, $val);
  }

  my %specials = ( "%DEVICE"  => $name,
                   "%READING" => $name,
                   "%VALUE"   => 1,
                   "%UNIT"    => 'kW',
                 );

  $err = perlSyntaxCheck ($val, %specials);
  return $err if($err);

  if ($val =~ m/^\{.*\}$/xs && $val =~ m/=>/ && $val !~ m/\$/ ) {           # Attr wurde als Hash definiert
      my $av = eval $val;

      return $@ if($@);

      $av  = eval $val;
      $val = $av if(ref $av eq "HASH");
  }

return ('', $val);
}

################################################################
#          prüfen validen Code in $val
################################################################
sub checkCode1 {
  my $name = shift;
  my $val  = shift;

  my $hash = $defs{$name};

  $val =~ m/^\s*(\{.*\})\s*$/xs;
  $val = $1;
  $val = eval $val;
  return $@ if($@);

return ('', $val);
}

################################################################
#  die eingestellte Modulsprache ermitteln
################################################################
sub getLang {
  my $hash = shift;

  my $name  = $hash->{NAME};
  my $glang = AttrVal ('global', 'language', DEFLANG);
  my $lang  = AttrVal ($name, 'ctrlLanguage', $glang);

return $lang;
}

################################################################
#  den eingestellte Debug Modus ermitteln
################################################################
sub getDebug {
  my $hash = shift;

  my $debug = AttrVal ($hash->{NAME}, 'ctrlDebug', 'none');

return $debug;
}

################################################################
#  Namen des Consumerdevices und des zugeordneten
#  Switch Devices ermitteln
################################################################
sub getCDnames {
  my $hash = shift;
  my $c    = shift;

  my $cname   = ConsumerVal ($hash, $c, "name",        "");                                         # Name des Consumerdevices
  my $dswname = ConsumerVal ($hash, $c, 'dswitch', $cname);                                         # alternatives Switch Device
  my ($err)   = isDeviceValid ( { name => $hash->{NAME}, obj => $dswname, method => 'string' } );
  $err        = qq{$err. Please check device names in consumer '$c' attribute} if($err);

return ($err, $cname, $dswname);
}

################################################################
#  Namen der Strahlungs-API und Wetter-API ermitteln.
#  Wird als Schlüssel in statusapi bzw. weatherapi verwendet.
#  Return:
#  $rapi - Name der Strahlungsdaten-API
#  $wapi - Name der Wetter-API
################################################################
sub getStatusApiName {
  my $hash = shift;

  my $rapi = isOpenMeteoUsed     ($hash) ? 'OpenMeteo'     :
             isForecastSolarUsed ($hash) ? 'ForecastSolar' :
             isSolCastUsed       ($hash) ? 'SolCast'       :
             isVictronKiUsed     ($hash) ? 'VictronKi'     :
             isDWDUsed           ($hash) ? 'DWD'           :
             '';

  my $wapi = isWeatherOpenMeteoUsed ($hash) ? 'OpenMeteo' :
             '';

return ($rapi, $wapi);
}

################################################################
#  diskrete Temperaturen in "Bins" wandeln
################################################################
sub temp2bin {
  my $val = shift;

  my $bin = $val >=  35  ?  35 :
            $val >   32  ?  35 :
            $val >=  30  ?  30 :
            $val >   27  ?  30 :
            $val >=  25  ?  25 :
            $val >   22  ?  25 :
            $val >=  20  ?  20 :
            $val >   17  ?  20 :
            $val >=  15  ?  15 :
            $val >   12  ?  15 :
            $val >=  10  ?  10 :
            $val >    7  ?  10 :
            $val >=   5  ?   5 :
            $val >    2  ?   5 :
            $val >=   0  ?   0 :
            $val >   -2  ?   0 :
            $val >=  -5  ?  -5 :
            $val >  - 7  ?  -5 :
            $val >= -10  ? -10 :
            $val >  -12  ? -10 :
            $val >= -15  ? -15 :
            $val >  -17  ? -15 :
            -20;

return $bin;
}

################################################################
#  diskrete Bewölkung in "Bins" wandeln
################################################################
sub cloud2bin {
  my $val = shift;

  my $bin = $val == 100 ? '100' :
            $val >  97  ? '100' :
            $val >= 95  ? '95'  :
            $val >  92  ? '95'  :
            $val >= 90  ? '90'  :
            $val >  87  ? '90'  :
            $val >= 85  ? '85'  :
            $val >  82  ? '85'  :
            $val >= 80  ? '80'  :
            $val >  77  ? '80'  :
            $val >= 75  ? '75'  :
            $val >  72  ? '75'  :
            $val >= 70  ? '70'  :
            $val >  67  ? '70'  :
            $val >= 65  ? '65'  :
            $val >  62  ? '65'  :
            $val >= 60  ? '60'  :
            $val >  57  ? '60'  :
            $val >= 55  ? '55'  :
            $val >  52  ? '55'  :
            $val >= 50  ? '50'  :
            $val >  47  ? '50'  :
            $val >= 45  ? '45'  :
            $val >  42  ? '45'  :
            $val >= 40  ? '40'  :
            $val >  37  ? '40'  :
            $val >= 35  ? '35'  :
            $val >  32  ? '35'  :
            $val >= 30  ? '30'  :
            $val >  27  ? '30'  :
            $val >= 25  ? '25'  :
            $val >  22  ? '25'  :
            $val >= 20  ? '20'  :
            $val >  17  ? '20'  :
            $val >= 15  ? '15'  :
            $val >  12  ? '15'  :
            $val >= 10  ? '10'  :
            $val >  7   ? '10'  :
            $val >= 5   ? '05'  :
            $val >  2   ? '05'  :
            '00';

return $bin;
}

################################################################
#  diskrete Sonnen Höhe (altitude) in "Bins" wandeln
################################################################
sub sunalt2bin {
  my $val = shift;

  my $bin = $val == 90  ? 90  :
            $val >  87  ? 90  :
            $val >= 85  ? 85  :
            $val >  82  ? 85  :
            $val >= 80  ? 80  :
            $val >  77  ? 80  :
            $val >= 75  ? 75  :
            $val >  72  ? 75  :
            $val >= 70  ? 70  :
            $val >  67  ? 70  :
            $val >= 65  ? 65  :
            $val >  62  ? 65  :
            $val >= 60  ? 60  :
            $val >  57  ? 60  :
            $val >= 55  ? 55  :
            $val >  52  ? 55  :
            $val >= 50  ? 50  :
            $val >  47  ? 50  :
            $val >= 45  ? 45  :
            $val >  42  ? 45  :
            $val >= 40  ? 40  :
            $val >  37  ? 40  :
            $val >= 35  ? 35  :
            $val >  32  ? 35  :
            $val >= 30  ? 30  :
            $val >  27  ? 30  :
            $val >= 25  ? 25  :
            $val >  22  ? 25  :
            $val >= 20  ? 20  :
            $val >  17  ? 20  :
            $val >= 15  ? 15  :
            $val >  12  ? 15  :
            $val >= 10  ? 10  :
            $val >  7   ? 10  :
            $val >= 5   ? 5   :
            $val >  2   ? 5   :
            0;

return $bin;
}

###############################################################################
#   Teilt das Original-Array in Unter-Arrays auf, die den Inhalt des
#   Originals enthalten. Die Größe jedes Unterarrays ist gleich oder kleiner als
#   $split_size, wobei das letzte Array in der Regel kleiner ist, wenn nicht
#   genügend Elemente in @original vorhanden sind.
#   (aus https://metacpan.org/dist/Array-Split/source/lib/Array/Split.pm)
#
#   arraySplitBy ($split_size, @original)
###############################################################################
sub arraySplitBy {
  my $split_size = shift;

  $split_size = max ($split_size, 1);
  my @sub_arrays;

  while (@_) {
      push @sub_arrays, [splice @_, 0, $split_size];
  }

return @sub_arrays;
}

###############################################################################
#   Teilt das angegebene Array in die Anzahl $count Unterarrays auf.
#   Es wird versucht, so viele Unter-Arrays zu erstellen, wie $count angibt,
#   aber es werden weniger zurückgegeben, wenn nicht genügend Elemente in
#   @original vorhanden sind.
#
#   Gibt eine Liste von Array-Referenzen zurück.
#   (aus https://metacpan.org/dist/Array-Split/source/lib/Array/Split.pm)
#
#   arraySplitInto ($count, @original)
###############################################################################
sub arraySplitInto {
  my ($count, @original) = @_;

  $count   = max( $count, 1 );
  my $size = ceil @original / $count;

return arraySplitBy ($size, @original);
}

###############################################################################
#                    verscrambelt einen String
###############################################################################
sub chew {
  my $sstr = shift;

  $sstr    = encode_base64 ($sstr, '');
  my @key  = qw(1 3 4 5 6 3 2 1 9);
  my $len  = scalar @key;
  my $i    = 0;
  my $dstr = join "", map { $i = ($i + 1) % $len; chr((ord($_) + $key[$i]) % 256) } split //, $sstr;   ## no critic 'Map blocks';

return $dstr;
}

###############################################################################
#             entpackt einen mit chew behandelten String
###############################################################################
sub assemble {
  my $sstr = shift;

  my @key  = qw(1 3 4 5 6 3 2 1 9);
  my $len  = scalar @key;
  my $i    = 0;
  my $dstr = join "", map { $i = ($i + 1) % $len; chr((ord($_) - $key[$i] + 256) % 256) } split //, $sstr;    ## no critic 'Map blocks';
  $dstr    = decode_base64 ($dstr);

return $dstr;
}

###############################################################
#                   Daten Serialisieren
###############################################################
sub Serialize {
  my $dat  = shift;
  my $name = $dat->{name};

  my $serial = eval { freeze ($dat)
                    }
                    or do { Log3 ($name, 1, "$name - Serialization ERROR: $@");
                            return;
                          };

return $serial;
}

################################################################
#  Funktion um mit Storable eine Struktur in ein File
#  zu schreiben
################################################################
sub fileStore {
  my $obj  = shift;
  my $file = shift;

  my $err;
  my $ret = eval { nstore ($obj, $file) };

  if (!$ret || $@) {
      $err = $@ ? $@ : 'I/O problems or other internal error';
  }

return $err;
}

################################################################
#  Funktion um mit Storable eine Struktur aus einem File
#  zu lesen
################################################################
sub fileRetrieve {
  my $file = shift;

  my ($err, $obj);

  if (-e $file) {
      eval { $obj = retrieve ($file) };

      if (!$obj || $@) {
          $err = $@ ? $@ : 'I/O error while reading';
      }
  }

return ($err, $obj);
}

###############################################################
#  erzeugt eine Zeile Leerzeichen. Die Anzahl der
#  Leerzeichen ist etwas größer als die Zeichenzahl des
#  längsten Teilstrings (Trenner \n)
###############################################################
sub lineFromSpaces {
  my $str = shift // return;
  my $an  = shift // 5;

  my @sps = split "\n", $str;
  my $mlen = 1;

  for my $s (@sps) {
      my $len = strlength ($s);
      $mlen   = $len if($len && $len > $mlen);
  }

  $mlen = $mlen > LPOOLLENLIM ? LPOOLLENLIM : $mlen;

  my $ret = "\n";
  $ret   .= "&nbsp;" x ($mlen + $an);

return $ret;
}

################################################################
#  Funktion um userspezifische Programmaufrufe nach
#  Aktualisierung aller Readings zu ermöglichen
################################################################
sub userExit {
  my $paref = shift;
  my $name  = $paref->{name};
  my $hash  = $defs{$name};

  my $uefn = AttrVal ($name, 'ctrlUserExitFn', '');
  return if(!$uefn);

  $uefn =~ s/\s*#.*//g;                                             # Kommentare entfernen
  $uefn =~ s/^\s+|\s+$//g;                                          # nur Anfang und Ende trimmen
  my $result;

  if ($uefn =~ /^\{.*\}$/s) {                                       # unnamed Funktion direkt in ctrlUserExitFn mit {...}      
        my $coderef = eval "sub $uefn;";
        
        if ($@) {
            Log3 ($name, 1, "$name - ERROR compiling userExitFn: $@");
        } 
        elsif (ref $coderef eq 'CODE') {
            eval { $result = $coderef->() };
            Log3 ($name, 1, "$name - ERROR executing userExitFn: $@") if($@);
        } 
        else {
            Log3 ($name, 1, "$name - no valid function block in ctrlUserExitFn");
        }
  }

return $result;
}

###############################################################################
#    Wert des pvhist-Hash zurückliefern
#    Usage:
#    HistoryVal ($hash or $name, $day, $hod, $key, $def)
#
#    $day: Tag des Monats (01,02,...,31)
#    $hod: Stunde des Tages (01,02,...,24,99)
#    $key:    etotaliXX      - totale PV Erzeugung (Wh) des Inverters XX
#             pvrlXX         - realer PV Ertrag (Wh) des Inverters XX
#             pvfc           - PV Vorhersage
#             pprlXX         - Energieerzeugung des Produzenten XX
#             etotalpXX      - Zählerstand "Energieertrag total" (Wh) des Produzenten XX
#             confc          - Vorhersage Hausverbrauch (Wh)
#             gcons          - realer Netzbezug
#             gfeedin        - reale Netzeinspeisung
#             batintotalXX   - Gesamtladung Batterie XX (Wh) zu Beginn der Stunde
#             batinXX        - Ladung Batterie XX innerhalb der Stunde (Wh)
#             batouttotalXX  - Gesamtentladung Batterie XX (Wh)
#             batoutXX       - Entladung Batterie XX innerhalb der Stunde (Wh)
#             batmsoc        - max. SOC des Tages (%)
#             batmaxsocXX    - maximum SOC (%) der Batterie XX des Tages
#             batsetsocXX    - optimaler (berechneter) SOC (%) der Batterie XX für den Tag
#             weatherid      - Wetter ID
#             wcc            - Grad der Bewölkung
#             temp           - Außentemperatur
#             rr1c           - Gesamtniederschlag (1-stündig) letzte 1 Stunde kg/m2
#             pvcorrf        - PV Autokorrekturfaktor f. Stunde des Tages
#             dayname        - Tagesname (Kürzel)
#             csmt${c}       - Totalconsumption Consumer $c (1..MAXCONSUMER)
#             csme${c}       - Consumption Consumer $c (1..MAXCONSUMER) in $hod
#             minutescsm${c} - Laufzeit des Consumers in Minuten in $hod
#             sunaz          - Azimuth der Sonne (in Dezimalgrad)
#             sunalt         - Höhe der Sonne (in Dezimalgrad)
#    $def: Defaultwert
#
###############################################################################
sub HistoryVal {
  my $name = shift;
  my $day  = shift;
  my $hod  = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined($data{$name}{pvhist})                    &&
      defined($data{$name}{pvhist}{$day})              &&
      defined($data{$name}{pvhist}{$day}{$hod})        &&
      defined($data{$name}{pvhist}{$day}{$hod}{$key})) {
      return  $data{$name}{pvhist}{$day}{$hod}{$key};
  }

return $def;
}

#####################################################################################################
#    Wert des circular-Hash zurückliefern
#    Achtung: die Werte im circular-Hash haben nicht
#             zwingend eine Beziehung zueinander !!
#
#    Usage:
#    CircularVal ($hash or $name, $hod, $key, $def)
#
#    $hod: Stunde des Tages (01,02,...,24) bzw. 99 (besondere Verwendung)
#    $key:    pvrl               - realer PV Ertrag
#             pvfc               - PV Vorhersage
#             pvrlsum            - Summe PV Ertrag über die gesamte Laufzeit
#             pvfcsum            - Summe PV Prognose über die gesamte Laufzeit
#             dnumsum            - Anzahl der Tage der Durchschnittsberechnung über die gesamte Laufzeit
#             confc              - Vorhersage Hausverbrauch (Wh)
#             gcons              - realer Netzbezug
#             gfeedin            - reale Netzeinspeisung
#             batinXX            - Ladung Batterie XX (Wh)
#             batoutXX           - Entladung Batterie XX (Wh)
#             weatherid          - DWD Wetter id
#             weathertxt         - DWD Wetter Text
#             wcc                - DWD Wolkendichte
#             rr1c               - Gesamtniederschlag (1-stündig) letzte 1 Stunde kg/m2
#             temp               - Außentemperatur
#             pvcorrf            - PV Autokorrekturfaktoren (<Sonne Altitude>.<Cloudcover> = Faktor)
#             lastTsMaxSocRchdXX - Timestamp des letzten Erreichens von SoC >= maxSoC
#             nextTsMaxSocChgeXX - Timestamp bis zu dem die Batterie mindestens einmal maxSoC erreichen soll
#             days2careXX        - verbleibende Tage bis der Batterie XX Pflege-SoC (default MAXSOCDEF) erreicht sein soll
#             tdayDvtn           - heutige Abweichung PV Prognose/Erzeugung in %
#             ydayDvtn           - gestrige Abweichung PV Prognose/Erzeugung in %
#             initdayfeedin      - initialer Wert für "gridfeedin" zu Beginn des Tages (Wh)
#             feedintotal        - Einspeisung PV Energie total (Wh)
#             initdaygcon        - initialer Wert für "gcon" zu Beginn des Tages (Wh)
#             initdaybatintotXX  - initialer Wert für Batterie intotal zu Beginn des Tages (Wh)
#             batintotXX         - aktuell total Batterieladung XX (Wh)
#             initdaybatouttotXX - initialer Wert für Batterie outtotal zu Beginn des Tages (Wh)
#             batouttotXX        - aktuell total Batterieentladung (Wh)
#             gridcontotal       - Netzbezug total (Wh)
#             aiRulesNumber      - Anzahl der Regeln in der trainierten KI-Instanz
#
#    $def: Defaultwert
#
#####################################################################################################
sub CircularVal {
  my $name = shift;
  my $hod  = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if(defined($data{$name}{circular})              &&
     defined($data{$name}{circular}{$hod})        &&
     defined($data{$name}{circular}{$hod}{$key})) {
     return  $data{$name}{circular}{$hod}{$key};
  }

return $def;
}

########################################################################################################
#  Wert des Autokorrekturfaktors
#  für eine bestimmte Sun Altitude-Range aus dem Circular-Hash
#  zurückliefern
#  Usage:
#  $f = CircularSunCloudkorrVal ($hash or $name, $hod, $sabin, $crang, $def)
#
#  $f:      Korrekturfaktor f. Stunde des Tages
#
#  $hod:    Stunde des Tages (01,02,...,24)
#  $sabin:  Sun Altitude Bin (0..90)
#  $crang:  Bewölkung Bin (0..100) oder "simple"
#  $def:    Defaultwert
#
########################################################################################################
sub CircularSunCloudkorrVal {
  my $name  = shift;
  my $hod   = shift;
  my $sabin = shift;
  my $crang = shift;
  my $def   = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  my $corrf = $def;
  my $qual  = $def;
  my $idx   = 'simple';

  if ($crang ne 'simple') {
      $idx = $sabin.'.'.$crang;
  }

  if (defined ($data{$name}{circular})                         &&
      defined ($data{$name}{circular}{$hod})                   &&
      defined ($data{$name}{circular}{$hod}{pvcorrf})          &&
      defined ($data{$name}{circular}{$hod}{pvcorrf}{$idx})) {
      $corrf = $data{$name}{circular}{$hod}{pvcorrf}{$idx};
  }

  if (defined ($data{$name}{circular})                         &&
      defined ($data{$name}{circular}{$hod})                   &&
      defined ($data{$name}{circular}{$hod}{quality})          &&
      defined ($data{$name}{circular}{$hod}{quality}{$idx})) {
      $qual = $data{$name}{circular}{$hod}{quality}{$idx};
  }

return ($corrf, $qual);
}

########################################################################################################
#    Die durchschnittliche reale PV Erzeugung, PV Prognose und Tage
#    einer bestimmten Bewölkungs-Range aus dem circular-Hash zurückliefern
#    Usage:
#    ($pvrlsum, $pvfcsum, $dnumsum) = CircularSumVal ($hash or $name, $hod, $sabin, $crang, $def)
#
#    $pvrlsum:   Summe reale PV Erzeugung pro Bewölkungsbereich über die gesamte Laufzeit
#    $pvfcsum:   Summe PV Prognose pro Bewölkungsbereich über die gesamte Laufzeit
#    $dnumsum:   Anzahl Tage pro Bewölkungsbereich über die gesamte Laufzeit
#
#    $hod:       Stunde des Tages (01,02,..,24)
#    $sabin:     Sun Altitude Bin (0..90)
#    $crang:     Bewölkung Bin (1..100) oder "simple"
#    $def:       Defaultwert
#
#######################################################################################################
sub CircularSumVal {
  my $name  = shift;
  my $hod   = shift;
  my $sabin = shift;
  my $crang = shift;
  my $def   = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  my $pvrlsum = $def;
  my $pvfcsum = $def;
  my $dnumsum = $def;
  my $idx     = 'simple';

  if ($crang ne 'simple') {
      $idx = $sabin.'.'.$crang;
  }

  if (defined ($data{$name}{circular})                         &&
      defined ($data{$name}{circular}{$hod})                   &&
      defined ($data{$name}{circular}{$hod}{pvrlsum})          &&
      defined ($data{$name}{circular}{$hod}{pvrlsum}{$idx})) {
      $pvrlsum = $data{$name}{circular}{$hod}{pvrlsum}{$idx};
  }

  if (defined ($data{$name}{circular})                         &&
      defined ($data{$name}{circular}{$hod})                   &&
      defined ($data{$name}{circular}{$hod}{pvfcsum})          &&
      defined ($data{$name}{circular}{$hod}{pvfcsum}{$idx})) {
      $pvfcsum = $data{$name}{circular}{$hod}{pvfcsum}{$idx};
  }

  if (defined ($data{$name}{circular})                         &&
      defined ($data{$name}{circular}{$hod})                   &&
      defined ($data{$name}{circular}{$hod}{dnumsum})          &&
      defined ($data{$name}{circular}{$hod}{dnumsum}{$idx})) {
      $dnumsum = $data{$name}{circular}{$hod}{dnumsum}{$idx};
  }

return ($pvrlsum, $pvfcsum, $dnumsum);
}

#########################################################################################
# Wert des nexthours-Hash zurückliefern
# Usage:
# NexthoursVal ($hash or $name, $nhr, $key, $def)
#
# $nhr: nächste Stunde (NextHour00, NextHour01,...)
# $key: starttime  - Startzeit der abgefragten nächsten Stunde
#       hourofday  - Stunde des Tages
#       pvfc       - PV Vorhersage in Wh
#       pvaifc     - erwartete PV Erzeugung der KI (Wh)
#       aihit      - Trefferstatus KI
#       weatherid  - DWD Wetter id
#       wcc        - DWD Wolkendichte
#       cloudrange - berechnete Bewölkungsrange
#       rr1c       - Gesamtniederschlag während der letzten Stunde kg/m2
#       rad1h      - Globalstrahlung (kJ/m2)
#       confc      - prognostizierter Hausverbrauch (Wh)
#       confcEx    - prognostizierter Hausverbrauch ohne registrierte Consumer (Wh)
#       today      - 1 wenn heute
#       correff    - verwendeter Korrekturfaktor / Qualität
#       DoN        - Sonnenauf- und untergangsstatus (0 - Nacht, 1 - Tag)
# $def: Defaultwert
#
#########################################################################################
sub NexthoursVal {
  my $name = shift;
  my $nhr  = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined ($data{$name}{nexthours})              &&
      defined ($data{$name}{nexthours}{$nhr})        &&
      defined ($data{$name}{nexthours}{$nhr}{$key})) {
      return  $data{$name}{nexthours}{$nhr}{$key};
  }

return $def;
}

###################################################################################################
# Wert des current-Hash zurückliefern
# Usage:
# CurrentVal ($hash or $name, $key, $def)
#
# $key: aiinitstate          - Initialisierungsstatus der KI
#       aitrainstate         - Traisningsstatus der KI
#       aiaddistate          - Add Instanz Status der KI
#       ctrunning            - aktueller Ausführungsstatus des Central Task
#       dwdRad1hAge          - Alter des Rad1h Wertes als Datumstring
#       dwdRad1hAgeTS        - Alter des Rad1h Wertes als Unix Timestamp
#       genslidereg          - Schieberegister PV Erzeugung (Array)
#       h4fcslidereg         - Schieberegister 4h PV Forecast (Array)
#       surplusslidereg      - Schieberegister PV Überschuß (Array)
#       moonPhaseI           - aktuelle Mondphase (1 .. 8)
#       batsocslidereg       - Schieberegister Batterie SOC (Array)
#       consumption          - aktueller Verbrauch (W)
#       consumerdevs         - alle registrierten Consumerdevices (Array)
#       consumerCollected    - Statusbit Consumer Attr gesammelt und ausgewertet
#       gridconsumption      - aktueller Netzbezug
#       temp                 - aktuelle Außentemperatur
#       surplus              - aktueller PV Überschuß
#       tomorrowconsumption  - Verbrauch des kommenden Tages
#       allstringspeak       - Peakleistung aller Strings nach temperaturabhängiger Korrektur
#       allstringscount      - aktuelle Anzahl der Anlagenstrings
#       tomorrowconsumption  - erwarteter Gesamtverbrauch am morgigen Tag
#       sunriseToday         - Sonnenaufgang heute
#       sunriseTodayTs       - Sonnenaufgang heute Unix Timestamp
#       sunsetToday          - Sonnenuntergang heute
#       sunsetTodayTs        - Sonnenuntergang heute Unix Timestamp
#
# $def: Defaultwert
#
###################################################################################################
sub CurrentVal {
  my $name = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{current}        &&
      defined $data{$name}{current}{$key}) {
      return  $data{$name}{current}{$key};
  }

return $def;
}

###################################################################################################
# Wert des String Hash zurückliefern
# Usage:
# StringVal ($hash or $name, $strg, $key, $def)
#
# $strg:        - Name des Strings aus setupInverterStrings
# $key:  peak   - Peakleistung aus setupStringPeak
#        tilt   - Neigungswinkel der Module aus setupStringDeclination
#        dir    - Ausrichtung der Module als Azimut-Bezeichner (N,NE,E,SE,S,SW,W,NW)
#        azimut - Ausrichtung der Module als Azimut Angabe -180 .. 0 .. 180
#
# $def:  Defaultwert
#
###################################################################################################
sub StringVal {
  my $name = shift;
  my $strg = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{strings}              &&
      defined $data{$name}{strings}{$strg}       &&
      defined $data{$name}{strings}{$strg}{$key}) {
      return  $data{$name}{strings}{$strg}{$key};
  }

return $def;
}

###################################################################################################
# Wert AI::DecisionTree Objects zurückliefern
# Usage:
# AiDetreeVal ($hash or $name, key, $def)
#
# key: object     - das AI Object
#      aitrained  - AI trainierte Daten
#      airaw      - Rohdaten für AI Input = Raw Trainigsdaten
#
# $def:  Defaultwert
#
###################################################################################################
sub AiDetreeVal {
  my $name = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{aidectree}        &&
      defined $data{$name}{aidectree}{$key}) {
      return  $data{$name}{aidectree}{$key};
  }

return $def;
}

###################################################################################################
# Wert AI Raw Data zurückliefern
# Usage:
# AiRawdataVal ($hash or $name, $idx, $key, $def)
# AiRawdataVal ($hash, '', '', $def)      -> den gesamten Hash airaw lesen
#
# $idx:            - Index
# $key: rad1h      - Strahlungsdaten
#       temp       - Temeperatur als Bin
#       wcc        - Bewölkung als Bin
#       rr1c       - Gesamtniederschlag (1-stündig) letzte 1 Stunde kg/m2
#       hod        - Stunde des Tages
#       sunalt     - Höhe der Sonne (in Dezimalgrad)
#       pvrl       - reale PV Erzeugung
#
# $def:  Defaultwert
#
###################################################################################################
sub AiRawdataVal {
  my $name = shift;
  my $idx  = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (!$idx && !$key) {
      if (defined $data{$name}{aidectree}{airaw}) {
          return  $data{$name}{aidectree}{airaw};
      }
  }

  if (defined $data{$name}{aidectree}{airaw}          &&
      defined $data{$name}{aidectree}{airaw}{$idx}    &&
      defined $data{$name}{aidectree}{airaw}{$idx}{$key}) {
      return  $data{$name}{aidectree}{airaw}{$idx}{$key};
  }

return $def;
}

###################################################################################################################
# Wert des consumer-Hash zurückliefern
# Usage:
# ConsumerVal ($hash or $name, $co, $key, $def)
#
# $co:  Consumer Nummer (01,02,03,...)
# $key: name            - Name des Verbrauchers (Device)
#       alias           - Alias des Verbrauchers (Device)
#       autoreading     - Readingname f. Automatiksteuerung
#       type            - Typ des Verbrauchers
#       state           - Schaltstatus des Consumers
#       power           - nominale Leistungsaufnahme des Verbrauchers in W
#       mode            - Planungsmode des Verbrauchers
#       icon            - Icon für den Verbraucher
#       mintime         - min. Einplanungsdauer
#       onreg           - Regex für phys. Zustand "ein"
#       offreg          - Regex für phys. Zustand "aus"
#       oncom           - Einschaltkommando
#       offcom          - Ausschaltkommando
#       physoffon       - physischer Schaltzustand ein/aus
#       logoffon        - logischer Schaltzustand ein/aus
#       onoff           - logischer ein/aus Zustand des am Consumer angeschlossenen Endverbrauchers
#       asynchron       - Arbeitsweise des FHEM Consumer Devices
#       retotal         - Reading der Leistungsmessung
#       uetotal         - Unit der Leistungsmessung
#       rpcurr          - Readingname des aktuellen Verbrauchs
#       powerthreshold  - Schwellenwert d. aktuellen Leistung(W) ab der ein Verbraucher als aktiv gewertet wird
#       energythreshold - Schwellenwert (Wh pro Stunde) ab der ein Verbraucher als aktiv gewertet wird
#       upcurr          - Unit des aktuellen Verbrauchs
#       avgenergy       - initialer / gemessener Durchschnittsverbrauch pro Stunde
#       runtimeAvgDay   - durchschnittliche 'On'-Zeit an einem Tag (Minuten)
#       epieces         - prognostizierte Energiescheiben (Hash)
#       ehodpieces      - geplante Energiescheiben nach Tagesstunde (hour of day) (Hash)
#       dswoncond       - Device zur Lieferung einer zusätzliche Einschaltbedingung
#       planstate       - Planungsstatus
#       planswitchon    - geplante Switch-On Zeit
#       planswitchoff   - geplante Switch-Off Zeit
#       planSupplement  - Ergänzung zum Planungsstatus
#       rswoncond       - Reading zur Lieferung einer zusätzliche Einschaltbedingung
#       swoncondition   - Regex einer zusätzliche Einschaltbedingung
#       dswoffcond      - Device zur Lieferung einer vorrangige Ausschaltbedingung
#       rswoffcond      - Reading zur Lieferung einer vorrangige Ausschaltbedingung
#       swoffcondition  - Regex einer einer vorrangige Ausschaltbedingung
#       isIntimeframe   - ist Zeit innerhalb der Planzeit ein/aus
#       interruptable   - Consumer "on" ist während geplanter "ein"-Zeit unterbrechbar
#       lastAutoOnTs    - Timestamp des letzten On-Schaltens bzw. letzter Fortsetzung (nur Automatik-Modus)
#       lastAutoOffTs   - Timestamp des letzten Off-Schaltens bzw. letzter Unterbrechnung (nur Automatik-Modus)
#       hysteresis      - Hysterese
#       sunriseshift    - Verschiebung (Sekunden) Sonnenaufgang bei SunPath Verwendung
#       sunsetshift     - Verschiebung (Sekunden) Sonnenuntergang bei SunPath Verwendung
#
# $def: Defaultwert
#
####################################################################################################################
sub ConsumerVal {
  my $name = shift;
  my $co   = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{consumers}             &&
      defined $data{$name}{consumers}{$co}        &&
      defined $data{$name}{consumers}{$co}{$key}) {
      return  $data{$name}{consumers}{$co}{$key};
  }

return $def;
}

###################################################################################################
# Wert des Batterie-Hash zurückliefern
# Usage:
# BatteryVal ($hash or $name, $bn, $key, $def)
#
# $bn:  Batterie Nummer (01,02,03,...)
# $key: balias       - Alias des Batterie Devices
#       bname        - Name des Batterie Devices
#       basynchron   - Asynchron Modus
#       bcharge      - Bat SOC in %
#       binstcap     - installierte Batteriekapazität in Wh
#       bpowerin     - Batterie momentane Ladeleistung
#       bpowerout    - Batterie momentane Entladeleistung
#       bicon        - Batterie Icons
#       bshowingraph - Batterie in Balkengrafik anzeigen
#
# $def: Defaultwert
#
###################################################################################################
sub BatteryVal {
  my $name = shift;
  my $bn   = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{batteries}             &&
      defined $data{$name}{batteries}{$bn}        &&
      defined $data{$name}{batteries}{$bn}{$key}) {
      return  $data{$name}{batteries}{$bn}{$key};
  }

return $def;
}

###################################################################################################
# Wert des Inverter-Hash zurückliefern
# Usage:
# InverterVal ($hash or $name, $in, $key, $def)
#
# $in:  Inverter Nummer (01,02,03,...)
# $key: ietotal            - Stand etotal des WR
#       ipvout             - aktuelle Leistung an Netz oder Batterie aus PV Erzeugung
#       invertercap        - Bemessungsleistung der Wechselrichters (max. W)
#       iname              - Name des Inverterdevices
#       iicon              - Icon des Inverters
#       ialias             - Alias des Inverters
#
# $def: Defaultwert
#
###################################################################################################
sub InverterVal {
  my $name = shift;
  my $in   = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{inverters}             &&
      defined $data{$name}{inverters}{$in}        &&
      defined $data{$name}{inverters}{$in}{$key}) {
      return  $data{$name}{inverters}{$in}{$key};
  }

return $def;
}

###################################################################################################
# Wert des non-PV Producer-Hash zurückliefern
# Usage:
# ProducerVal ($hash or $name, $pn, $key, $def)
#
# $pn:  Producer Nummer (01,02,03,...)
# $key: petotal             - Stand etotal des Producers
#       pgeneration         - aktuelle Erzeugung Producers
#       pname               - Name des Producersdevices
#       picon               - Icon des Producers
#       palias              - Alias des Producers
#
# $def: Defaultwert
#
###################################################################################################
sub ProducerVal {
  my $name = shift;
  my $pn   = shift;
  my $key  = shift;
  my $def  = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{producers}             &&
      defined $data{$name}{producers}{$pn}        &&
      defined $data{$name}{producers}{$pn}{$key}) {
      return  $data{$name}{producers}{$pn}{$key};
  }

return $def;
}

##########################################################################################################################################################
# Wert des solcastapi-Hash zurückliefern
# Usage:
# RadiationAPIVal ($hash or $name, $tring, $ststr, $key, $def)
#
# $tring:  Stringname aus "setupInverterStrings" (?All für allg. Werte)
# $ststr:  Startzeit der Form YYYY-MM-DD hh:00:00
# $key:    pv_estimate50 - PV Schätzung in Wh
#          Rad1h         - vorhergesagte Globalstrahlung (Model DWD)
# $def:    Defaultwert
#
# Sonderabfragen:
# RadiationAPIVal ($hash, '?All', $ststr, 'Rad1h', $def) - Globalstrahlung mit Startzeit ohne Stringbezug
##########################################################################################################################################################
sub RadiationAPIVal {
  my $name   = shift;
  my $string = shift;
  my $ststr  = shift;
  my $key    = shift;
  my $def    = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{solcastapi}                         &&
      defined $data{$name}{solcastapi}{$string}                &&
      defined $data{$name}{solcastapi}{$string}{$ststr}        &&
      defined $data{$name}{solcastapi}{$string}{$ststr}{$key}) {
      return  $data{$name}{solcastapi}{$string}{$ststr}{$key};
  }

return $def;
}

##########################################################################################################################################################
# Wert des weatherAPI-Hash zurückliefern
# Usage:
# WeatherAPIVal ($hash or $name, $apiname, $tstr, $key, $def)
#
# $apiname:  Hauptname der API gemäß setupWeatherDevX (z.B. OpenMeteo)
# $tstr:     Zeitwert der Form fcX_XX (z.B. fc1_19)
# $key:      Parameter (z.B. don, neff, rr1c, ...)
# $def:      Defaultwert
#
##########################################################################################################################################################
sub WeatherAPIVal {
  my $name    = shift;
  my $apiname = shift;
  my $tstr    = shift;
  my $key     = shift;
  my $def     = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{weatherapi}                         &&
      defined $data{$name}{weatherapi}{$apiname}               &&
      defined $data{$name}{weatherapi}{$apiname}{$tstr}        &&
      defined $data{$name}{weatherapi}{$apiname}{$tstr}{$key}) {
      return  $data{$name}{weatherapi}{$apiname}{$tstr}{$key};
  }

return $def;
}

##########################################################################################################################################################
# Wert des StatusAPI-Hash zurückliefern
# Usage:
# StatusAPIVal ($hash or $name, $apiname, '?All', $key, $def)
#
# $apiname:  Hauptname der API gemäß setupWeatherDevX (z.B. OpenMeteo)
# $tstr:     default '?All'
# $key:      Parameter
# $def:      Defaultwert
#
# StatusAPIVal ($hash, $apiname, '?All', 'lastretrieval_time',      $def) - letzte Abfrage Zeitstring
# StatusAPIVal ($hash, $apiname, '?All', 'lastretrieval_timestamp', $def) - letzte Abfrage Unix Timestamp
# StatusAPIVal ($hash, $apiname, '?All', 'todayDoneAPIrequests',    $def) - heute ausgeführte API Requests
# StatusAPIVal ($hash, $apiname, '?All', 'todayDoneAPIcalls',       $def) - heute ausgeführte API Calls (hat u.U. mehrere Requests)
# StatusAPIVal ($hash, $apiname, '?All', 'todayRemainingAPIrequests $def) - heute verbleibende API Requests
# StatusAPIVal ($hash, $apiname, '?All', 'todayRemainingAPIcalls',  $def) - heute noch mögliche API Calls (ungl. Requests !)
# StatusAPIVal ($hash, $apiname, '?All', 'currentAPIinterval',      $def) - aktuelles API Request Intervall
# StatusAPIVal ($hash, $apiname, '?All', 'response_message',        $def) - letzte API Antwort
# StatusAPIVal ($hash, $apiname, '?All', 'place',                   $def) - ForecastSolarAPI -> Location der Anlage
# StatusAPIVal ($hash, $apiname, '?All', 'requests_limit',          $def) - ForecastSolarAPI -> Request Limit innerhalb der Periode
# StatusAPIVal ($hash, $apiname, '?All', 'requests_limit_period',   $def) - ForecastSolarAPI -> Periode für Request Limit
# StatusAPIVal ($hash, $apiname, '?All', 'requests_remaining',      $def) - ForecastSolarAPI -> verbleibende Requests innerhalb der laufenden Periode
# StatusAPIVal ($hash, $apiname, '?All', 'response_code',           $def) - ForecastSolarAPI -> letzter Antwortcode
# StatusAPIVal ($hash, $apiname, '?All', 'retryat_time',            $def) - ForecastSolarAPI -> Zwangsverzögerung des nächsten Calls bis Uhrzeit
# StatusAPIVal ($hash, $apiname, '?All', 'retryat_timestamp',       $def) - ForecastSolarAPI -> Zwangsverzögerung des nächsten Calls bis UNIX-Zeitstempel
#
# Sonderabfragen:
# StatusAPIVal ($hash, '?IdPair', '?<pk>', 'rtid',                  $def) - SolCast RoofTop-ID, <pk> = Paarschlüssel
# StatusAPIVal ($hash, '?IdPair', '?<pk>', 'apikey',                $def) - SolCast API-Key, <pk> = Paarschlüssel
##########################################################################################################################################################
sub StatusAPIVal {
  my $name    = shift;
  my $apiname = shift;
  my $tstr    = shift;
  my $key     = shift;
  my $def     = shift;

  if (ref $name eq 'HASH') {
      $name = $name->{NAME};
  }

  if (defined $data{$name}{statusapi}                         &&
      defined $data{$name}{statusapi}{$apiname}               &&
      defined $data{$name}{statusapi}{$apiname}{$tstr}        &&
      defined $data{$name}{statusapi}{$apiname}{$tstr}{$key}) {
      return  $data{$name}{statusapi}{$apiname}{$tstr}{$key};
  }

return $def;
}

1;

=pod
=item summary    Visualization of solar predictions for PV systems and Consumer control
=item summary_DE Visualisierung von solaren Vorhersagen für PV Anlagen und Verbrauchersteuerung

=begin html

<a id="SolarForecast"></a>
<h3>SolarForecast</h3>
<br>
The SolarForecast module generates a forecast for the solar yield on the basis of the values
from generic sources and integrates further information as a basis for control systems based on this forecast. <br>

To create the solar forecast, the SolarForecast module can use different services and sources: <br><br>

  <ul>
     <table>
     <colgroup> <col width="25%"> <col width="75%"> </colgroup>
        <tr><td> <b>DWD</b>                       </td><td>solar forecast based on MOSMIX data of the German Weather Service                                                                           </td></tr>
        <tr><td> <b>SolCast-API </b>              </td><td>uses forecast data of the <a href='https://toolkit.solcast.com.au/rooftop-sites/' target='_blank'>SolCast API</a>                           </td></tr>
        <tr><td> <b>ForecastSolar-API</b>         </td><td>uses forecast data of the <a href='https://doc.forecast.solar/api' target='_blank'>Forecast.Solar API</a>                                   </td></tr>
        <tr><td> <b>OpenMeteoDWD-API</b>          </td><td>ICON weather models of the German Weather Service (DWD) via <a href='https://open-meteo.com/en/docs/dwd-api' target='_blank'>Open-Meteo</a> </td></tr>
        <tr><td> <b>OpenMeteoDWDEnsemble-API</b>  </td><td>Access to the <a href='https://www.dwd.de/DE/forschung/wettervorhersage/num_modellierung/04_ensemble_methoden/ensemble_vorhersage/ensemble_vorhersagen.html' target='_blank'>global ensemble forecast system (EPS)</a> of the DWD </td></tr>
        <tr><td> <b>OpenMeteoWorld-API</b>        </td><td>Seamlessly combines weather models from organizations such as NOAA, DWD, CMCC and ECMWF via <a href='https://open-meteo.com/en/docs' target='_blank'>Open-Meteo</a> </td></tr>
        <tr><td> <b>VictronKI-API</b>             </td><td>Victron Energy API of the <a href='https://www.victronenergy.com/blog/2023/07/05/new-vrm-solar-production-forecast-feature/' target='_blank'>VRM Portal</a>         </td></tr>
     </table>
  </ul>
  <br>

The use of the mentioned API's is limited to the respective free version of the selected service. <br>
AI support can be activated depending on the model used. <br><br>

In addition to the PV generation forecast, consumption values or grid reference values are recorded and used for a
consumption forecast. <br>
The module calculates a future energy surplus from the forecast values, which is used to plan the operation of consumers.
Furthermore, the module offers <a href="#SolarForecast-Consumer">Consumer Integration</a> for integrated
planning and control of PV surplus dependent consumer circuits. Support for optimum battery
SoC management is also part of the range of functions. <br><br>

At the first definition of the module the user is supported by a Guided Procedure to make all initial entries. <br>
At the end of the process and after relevant changes to the system or device configuration, it is essential to perform a
<a href="#SolarForecast-set-plantConfiguration">set &lt;name&gt; plantConfiguration ceck</a>
to ensure that the system configuration is correct.

<ul>
  <a id="SolarForecast-define"></a>
  <b>Define</b>
  <br><br>

  <ul>
    A SolarForecast Device is created with: <br><br>

    <ul>
      <b>define &lt;name&gt; SolarForecast </b>
    </ul>
    <br>

    After the definition of the device, depending on the forecast sources used, it is mandatory to store additional
    plant-specific information. <br>
    The following set commands and attributes are used to store information that is relevant for the function of the
    module: <br><br>

      <ul>
         <table>
         <colgroup> <col width="25%"> <col width="75%"> </colgroup>
            <tr><td> <b>setupWeatherDevX</b>       </td><td>DWD_OpenData Device which provides meteorological data (e.g. cloud cover)     </td></tr>
            <tr><td> <b>setupRadiationAPI </b>     </td><td>DWD_OpenData Device or API for the delivery of radiation data.                </td></tr>
            <tr><td> <b>setupInverterDevXX</b>     </td><td>Device which provides PV performance data                                     </td></tr>
            <tr><td> <b>setupMeterDev</b>          </td><td>Device which supplies network I/O data                                        </td></tr>
            <tr><td> <b>setupBatteryDevXX</b>      </td><td>Device which provides battery performance data (if available)                 </td></tr>
            <tr><td> <b>setupInverterStrings</b>   </td><td>Identifier of the existing plant strings                                      </td></tr>
            <tr><td> <b>setupStringAzimuth</b>     </td><td>Azimuth of the plant strings                                                  </td></tr>
            <tr><td> <b>setupStringPeak</b>        </td><td>the DC peak power of the plant strings                                        </td></tr>
            <tr><td> <b>roofIdentPair</b>          </td><td>the identification data (when using the SolCast API)                          </td></tr>
            <tr><td> <b>setupRoofTops</b>          </td><td>the Rooftop parameters (when using the SolCast API)                           </td></tr>
            <tr><td> <b>setupStringDeclination</b> </td><td>the angle of inclination of the plant modules                                 </td></tr>
         </table>
      </ul>
      <br>

    In order to enable an adjustment to the personal system, correction factors can be manually fixed or automatically
    applied dynamically.
    <br><br>
  </ul>

  <a id="SolarForecast-Consumer"></a>
  <b>Consumer Integration</b>
  <br><br>

  <ul>
    The user can register consumers (e.g. switchable sockets) directly in the module and let the SolarForecast module take
    over the planning of the on/off times as well as their execution. Registration is done using the
    <a href="#SolarForecast-attr-consumer">ConsumerXX attributes</a>. In addition to the FHEM consumer device, a number
    of mandatory or optional keys are specified in the attributes that influence the scheduling and switching behavior of
    the consumer. <br>
    The keys are described in detail in the ConsumerXX help.
    In order to learn how to use the consumer control, it is advisable to first create one or
    more dummies and register these devices as consumers.
    <br><br>

    A dummy device according to this pattern is suitable for this purpose:
    <br><br>

    <ul>
        define SolCastDummy dummy                                                                                                   <br>
        attr SolCastDummy userattr nomPower                                                                                         <br>
        attr SolCastDummy alias SolarForecast Consumer Dummy                                                                        <br>
        attr SolCastDummy cmdIcon on:remotecontrol/black_btn_GREEN off:remotecontrol/black_btn_RED                                  <br>
        attr SolCastDummy devStateIcon off:light_light_dim_100@grey on:light_light_dim_100@darkorange                               <br>
        attr SolCastDummy group Solarforecast                                                                                       <br>
        attr SolCastDummy icon solar_icon                                                                                           <br>
        attr SolCastDummy nomPower 1000                                                                                             <br>
        attr SolCastDummy readingList BatIn BatOut BatVal  BatInTot BatOutTot bezW einW Batcharge Temp automatic                    <br>
        attr SolCastDummy room Energy,Testroom                                                                                      <br>
        attr SolCastDummy setList BatIn BatOut BatVal BatInTot BatOutTot bezW einW Batcharge on off Temp                            <br>
        attr SolCastDummy userReadings actpow {ReadingsVal ($name, 'state', 'off') eq 'on' ? AttrVal ($name, 'nomPower', 100) : 0}  <br>
    </ul>

    <br><br>
  </ul>

  <a id="SolarForecast-set"></a>
  <b>Set</b>
  <ul>

    <ul>
      <a id="SolarForecast-set-aiDecTree"></a>
      <li><b>aiDecTree </b> <br><br>

      If AI support is enabled in the SolarForecast Device, various AI actions can be performed manually.
      The manual execution of the AI actions is generally not necessary, since the processing of all necessary steps is
      already performed automatically in the module.
      <br><br>

      <ul>
       <table>
       <colgroup> <col width="20%"> <col width="80%"> </colgroup>
          <tr><td> <b>addInstAndTrain</b>  </td><td>The AI is enriched with the currently available PV, radiation and environmental data.                                       </td></tr>
          <tr><td>                         </td><td>The AI is then trained using the historical data.                                                                           </td></tr>
          <tr><td>                         </td><td>Successfully generated decision trees are saved in the file system.                                                         </td></tr>
          <tr><td>                         </td><td>                                                                                                                            </td></tr>
          <tr><td> <b>addRawData</b>       </td><td>Relevant PV, radiation and environmental data are extracted and stored for later use.                                       </td></tr>
          <tr><td>                         </td><td>                                                                                                                            </td></tr>
          <tr><td><b>rawDataGHIreplace</b> </td><td>Historical GHI (Global Horizontal Irradiance) values are retrieved from the Open-Meteo service and the values in aiRawData  </td></tr>
          <tr><td>                         </td><td>(see  <a href="#SolarForecast-get-valDecTree">get ... valDecTree aiRawData</a>) replaces existing values 'rad1h'
                                                     or adds them if they are not available.                                                                                    </td></tr>
         </table>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-attrKeyVal"></a>
      <li><b>attrKeyVal &lt;Attribute&gt; [&lt;Device&gt;] &lt;Key=Value&gt; </b> <br><br>

      One or more key=value pairs in the collective attributes (aiControl, consumerXX, plantControl, setup.*, etc.) can be
      can be reset or changed. <br>
      If a device is mandatory, as required in the setup.* attributes, it can also be set or changed.
      The change is saved automatically if autosave=0 is NOT set in the global device.
      <br><br>

      <ul>
        <b>Example: </b> <br>
        set &lt;name&gt; attrKeyVal setupBatteryDev01 asynchron=1 <br>
        set &lt;name&gt; attrKeyVal setupBatteryDev02 BatteryDummy2 asynchron=1 <br>
        set &lt;name&gt; attrKeyVal plantControl cycleInterval=77 <br>
        set &lt;name&gt; attrKeyVal plantControl batteryPreferredCharge=0 consForecastInPlanning=1 cycleInterval=77 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-batteryTrigger"></a>
      <li><b>batteryTrigger &lt;1on&gt;=&lt;Value&gt; &lt;1off&gt;=&lt;Value&gt; [&lt;2on&gt;=&lt;Value&gt; &lt;2off&gt;=&lt;Value&gt; ...] </b> <br><br>

      Generates triggers when the battery charge exceeds or falls below certain values (SoC in %). <br>
      The SoC used is formed as the resulting SoC (sum of the current charge of all battery devices in relation to the total installed
      total capacity), i.e. all batteries are considered as one cluster. <br>
      If the last three SoC measurements exceed a defined <b>Xon-Bedingung</b>, the reading <b>batteryTrigger_X = on</b>
      is created/set. <br>
      If the last three SoC measurements fall below a defined <b>Xoff-Bedingung</b>, the reading
      <b>batteryTrigger_X = off</b> is created/set. <br>
      Any number of trigger conditions can be specified. Xon/Xoff conditions do not necessarily have to be defined in pairs.
      <br>
      <br>

      <ul>
        <b>Example: </b> <br>
        set &lt;name&gt; batteryTrigger 1on=30 1off=10 2on=70 2off=20 3on=15 4off=90<br>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-consumerNewPlanning"></a>
      <li><b>consumerNewPlanning &lt;Consumer number&gt; </b> <br><br>

      The existing planning of the specified consumer is deleted. <br>
      The new planning is carried out immediately, taking into account the parameters set in the consumerXX attribute.
      <br><br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; consumerNewPlanning 01 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-cycleInterval"></a>
      <li><b>cycleInterval &lt;Integer&gt; </b> <br><br>

      Repetition interval of the data collection in seconds. <br>
      The command is suitable for dynamically changing the 'cycleInterval' key in the 'plantControl' attribute.
      The conditions of the 'plantControl' attribute apply to the entry.
      <br><br>

      <ul>
        <b>Example: </b> <br>
        set &lt;name&gt; cycleInterval 120 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-consumerImmediatePlanning"></a>
      <li><b>consumerImmediatePlanning &lt;Consumer number&gt; </b> <br><br>

      Immediate switching on of the consumer at the current time is scheduled.
      Any keys <b>notbefore</b>, <b>notafter</b> respectively <b>mode</b> set in the consumerXX attribute are ignored <br>
      <br>

      <ul>
        <b>Example: </b> <br>
        set &lt;name&gt; consumerImmediatePlanning 01 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-energyH4Trigger"></a>
      <li><b>energyH4Trigger &lt;1on&gt;=&lt;Value&gt; &lt;1off&gt;=&lt;Value&gt; [&lt;2on&gt;=&lt;Value&gt; &lt;2off&gt;=&lt;Value&gt; ...] </b> <br><br>

      Generates triggers on exceeding or falling below the 4-hour PV forecast (NextHours_Sum04_PVforecast). <br>
      Überschreiten die letzten drei Messungen der 4-Stunden PV Vorhersagen eine definierte <b>Xon-Bedingung</b>, wird das Reading
      <b>energyH4Trigger_X = on</b> erstellt/gesetzt.
      If the last three measurements of the 4-hour PV predictions exceed a defined <b>Xon condition</b>,
      the Reading <b>energyH4Trigger_X = off</b> is created/set. <br>
      Any number of trigger conditions can be specified.
      Xon/Xoff conditions do not necessarily have to be defined in pairs. <br>
      <br>

      <ul>
        <b>Example: </b> <br>
        set &lt;name&gt; energyH4Trigger 1on=2000 1off=1700 2on=2500 2off=2000 3off=1500 <br>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-operatingMemory"></a>
      <li><b>operatingMemory backup | save | recover-&lt;File&gt; </b> <br><br>

      The pvHistory (PVH) and pvCircular (PVC) components of the internal cache database are stored in the file system. <br>
      The target directory is "../FHEM/FhemUtils". This process is carried out regularly by the module in the background.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="17%"> <col width="83%"> </colgroup>
            <tr><td> <b>backup</b>               </td><td>Saves the active in-memory structures with the current timestamp.                                                                             </td></tr>
            <tr><td>                             </td><td><a href="#SolarForecast-attr-plantControl">plantControl->backupFilesKeep</a> generations of the files are saved. Older versions are deleted.  </td></tr>
            <tr><td>                             </td><td>Files: PVH_SolarForecast_&lt;name&gt;_&lt;Timestamp&gt;, PVC_SolarForecast_&lt;name&gt;_&lt;Timestamp&gt;                                     </td></tr>
            <tr><td>                             </td><td>                                                                                                                                              </td></tr>
            <tr><td> <b>save</b>                 </td><td>The active in-memory structures are saved.                                                                                                    </td></tr>
            <tr><td>                             </td><td>Files: PVH_SolarForecast_&lt;name&gt;, PVC_SolarForecast_&lt;name&gt;                                                                         </td></tr>
            <tr><td>                             </td><td>                                                                                                                                              </td></tr>
            <tr><td> <b>recover-&lt;File&gt;</b> </td><td>Restores the data of the selected backup file as an active in-memory structure.                                                               </td></tr>
            <tr><td>                             </td><td>To avoid inconsistencies, the PVH.* and PVC.* files should be restored in pairs                                                               </td></tr>
            <tr><td>                             </td><td>with the same time stamp.                                                                                                                     </td></tr>
         </table>
      </ul>
      <br>
    </ul>
    </li>
    <br>

    <ul>
      <a id="SolarForecast-set-operationMode"></a>
      <li><b>operationMode  </b> <br><br>
      The SolarForecast device is deactivated with <b>inactive</b>. The <b>active</b> option reactivates the device.
      The behavior corresponds to the "disable" attribute, but is particularly suitable for use in Perl scripts as
      compared to the "disable" attribute, it is not necessary to save the device configuration.
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-plantConfiguration"></a>
      <li><b>plantConfiguration </b> <br><br>

      Depending on the selected command option, the following operations are performed: <br><br>

      <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>check</b>     </td><td>Checks the current plant configuration. A plausibility check                  </td></tr>
            <tr><td>                  </td><td>is performed and the result and any notes or errors are output.               </td></tr>
            <tr><td> <b>save</b>      </td><td>Secures important parameters of the plant configuration.                      </td></tr>
            <tr><td>                  </td><td>The operation is performed automatically every day shortly after 00:00.       </td></tr>
            <tr><td> <b>restore</b>   </td><td>Restores a saved plant configuration                                          </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-powerTrigger"></a>
      <li><b>powerTrigger &lt;1on&gt;=&lt;Value&gt; &lt;1off&gt;=&lt;Value&gt; [&lt;2on&gt;=&lt;Value&gt; &lt;2off&gt;=&lt;Value&gt; ...] </b> <br><br>

      Generates triggers when certain PV generation values (Current_PV) are exceeded or not reached. <br>
      If the last three measurements of PV generation exceed a defined <b>Xon condition</b>, the Reading
      <b>powerTrigger_X = on</b> is created/set.
      If the last three measurements of the PV generation fall below a defined <b>Xoff-Bedingung</b>, the Reading
      <b>powerTrigger_X = off</b> is created/set.
      <br>
      Any number of trigger conditions can be specified. Xon/Xoff conditions do not necessarily have to be defined in pairs.
      <br><br>

      <ul>
        <b>Example: </b> <br>
        set &lt;name&gt; powerTrigger 1on=1000 1off=500 2on=2000 2off=1000 3on=1600 4off=1100<br>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-pvCorrectionFactor_Auto"></a>
      <li><b>pvCorrectionFactor_Auto </b> <br><br>

      Switches the automatic prediction correction on/off.
      The mode of operation differs depending on the selected method. <br>
      (default: off)
      <br><br>

      <b>on_simple(_ai):</b> <br>
      In this method, the hourly predicted amount of energy is compared with the real amount of energy generated and a
      correction factor used for the future for the respective hour. The forecast data provided by the selected API is
      <b>not</b> additionally related to other conditions such as cloud cover or temperatures. <br>
      If the AI support is switched on (on_simple_ai) and a PV forecast value is supplied by the AI, this value is used
      instead of the API value.
      <br><br>

      <b>on_complex(_ai):</b> <br>
      In this method, the hourly predicted amount of energy is compared with the real amount of energy generated and a
      correction factor used for the future for the respective hour. The forecast data provided by the selected API is
      also additionally linked to other conditions such as cloud cover or temperatures. <br>
      If AI support is switched on (on_complex_ai) and a PV forecast value is provided by the AI, this value is used
      instead of the API value.
      <br><br>

      <b>Note:</b> The automatic prediction correction is learning and needs time to optimise the correction values.
      After activation, optimal predictions cannot be expected immediately!
      <br><br>

      <b>on_complex_api_ai:</b> <br>
      The method works in the same way as 'on_complex_ai', but the PV forecast value used is calculated by averaging the supplied
      API value and the AI value.
      <br><br>

      Below are some API-specific tips that are merely best practice recommendations.
      <br><br>

      <b>Model OpenMeteo...API:</b> <br>
      The recommended autocorrection method is <b>on_complex</b> or <b>on_complex_ai</b>.
      <br><br>

      <b>Model SolCastAPI:</b> <br>
      The recommended autocorrection method is <b>on_complex</b>. <br>
      Before turning on autocorrection, optimise the forecast with the following steps: <br><br>
      <ul>
         <li>
         In the RoofTop editor of the SolCast API, define the
         <a href="https://articles.solcast.com.au/en/articles/2959798-what-is-the-efficiency-factor?_ga=2.119610952.1991905456.1665567573-1390691316.1665567573"><b>efficiency factor</b></a>
         according to the age of the plant. <br>
         With an 8-year-old plant, it would be 84 (100 - (8 x 2%)). <br>
         </li>
         <li>
         after sunset, the Reading Today_PVdeviation is created, which shows the deviation between the forecast and the real
         PV generation in percent.
         </li>
         </li>
         <li>
         according to the deviation, adjust the efficiency factor in steps until an optimum is found, i.e. the smallest
         daily deviation is found
         </li>
         <li>
         If you think you have found the optimal setting, you can set pvCorrectionFactor_Auto on*.
         </li>
      </ul>
      <br>

      Ideally, this process is carried out in a phase of stable meteorological conditions (uniform sun or cloud cover).
      cloud cover).
      <br><br>

      <b>Model VictronKiAPI:</b> <br>
      This model is based on Victron Energy's AI-supported API.
      The recommended autocorrect method is <b>off</b>. <br><br>

      <b>Model DWD:</b> <br>
      The recommended autocorrect method is <b>on_complex</b> or <b>on_complex_ai</b>. <br><br>

      <b>Model ForecastSolarAPI:</b> <br>
      The recommended autocorrect method is <b>on_complex</b>.
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-pvCorrectionFactor_" data-pattern="pvCorrectionFactor_.*"></a>
      <li><b>pvCorrectionFactor_XX &lt;Zahl&gt; </b> <br><br>

      Manual correction factor for hour XX of the day. <br>
      (default: 1.0) <br><br>

      Depending on the setting <a href="#SolarForecast-set-pvCorrectionFactor_Auto">pvCorrectionFactor_Auto </a> ('off' or 'on_.*'),
      a static or dynamic default setting is made: <br><br>

      <ul>
         <table>
         <colgroup> <col width="10%"> <col width="90%"> </colgroup>
            <tr><td> <b>off</b>     </td><td>The set correction factor is not overwritten by the auto-correction.                         </td></tr>
            <tr><td>                </td><td>In the pvCorrectionFactor_XX reading, the status is signaled by the addition 'manual fix'.   </td></tr>
            <tr><td>                </td><td>                                                                                             </td></tr>
            <tr><td> <b>on_.*</b>   </td><td>The set correction factor is overwritten by the auto-correction or AI                        </td></tr>
            <tr><td>                </td><td>if a calculated correction value is available in the system.                                 </td></tr>
            <tr><td>                </td><td>In the pvCorrectionFactor_XX reading, the status is signaled by the addition 'manual flex'.  </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-reset"></a>
      <li><b>reset </b> <br><br>

       Deletes the data source selected from the drop-down list, readings belonging to the function or other internal
       data structures. <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>aiData</b>             </td><td>deletes an existing AI instance including all training and raw data and reinitializes it                                              </td></tr>
            <tr><td> <b>batteryTriggerSet</b>  </td><td>deletes the trigger points of the battery storage                                                                                     </td></tr>
            <tr><td> <b>consumerPlanning</b>   </td><td>deletes the planning data of all registered consumers                                                                                 </td></tr>
            <tr><td>                           </td><td>To delete the planning data of only one consumer, use:                                                                                </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumerPlanning &lt;Consumer number&gt; </ul>                                                             </td></tr>
            <tr><td>                           </td><td>The module carries out an automatic rescheduling of the consumer circuit.                                                             </td></tr>
            <tr><td> <b>consumerMaster</b>     </td><td>deletes the current and historical data of all registered consumers from the memory                                                   </td></tr>
            <tr><td>                           </td><td>The defined consumer attributes remain and the data is collected again.                                                               </td></tr>
            <tr><td>                           </td><td>To delete the data of only one consumer use:                                                                                          </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumerMaster &lt;Consumer number&gt; </ul>                                                               </td></tr>
            <tr><td> <b>consumptionHistory</b> </td><td>deletes the stored consumption values of the house from the pvHistory memory                                                          </td></tr>
            <tr><td>                           </td><td>To delete the consumption values of a specific day:                                                                                   </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumptionHistory &lt;Day&gt;   (e.g. set &lt;name&gt; reset consumptionHistory 08) </ul>                 </td></tr>
            <tr><td>                           </td><td>To delete the consumption values of a specific hour of a day:                                                                         </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumptionHistory &lt;Day&gt; &lt;Hour&gt; (e.g. set &lt;name&gt; reset consumptionHistory 08 10) </ul>   </td></tr>
            <tr><td> <b>energyH4TriggerSet</b> </td><td>deletes the 4-hour energy trigger points                                                                                              </td></tr>
            <tr><td> <b>powerTriggerSet</b>    </td><td>deletes the trigger points for PV generation values                                                                                   </td></tr>
            <tr><td> <b>pvCorrection</b>       </td><td>Deletes the readings pvCorrectionFactor* and hidden control readings of the correction system.                                        </td></tr>
            <tr><td>                           </td><td>To delete all previously stored PV correction factors from the caches:                                                                </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvCorrection cached </ul>                                                                                  </td></tr>
            <tr><td>                           </td><td>To delete stored PV correction factors of a certain hour from the caches:                                                             </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvCorrection cached &lt;Hour&gt;  </ul>                                                                    </td></tr>
            <tr><td>                           </td><td><ul>(e.g. set &lt;name&gt; reset pvCorrection cached 10)       </ul>                                                                  </td></tr>
            <tr><td> <b>pvHistory</b>          </td><td>deletes the memory of all historical days (01 ... 31)                                                                                 </td></tr>
            <tr><td>                           </td><td>To delete a specific historical day:                                                                                                  </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvHistory &lt;Day&gt;   (e.g. set &lt;name&gt; reset pvHistory 08) </ul>                                   </td></tr>
            <tr><td>                           </td><td>To delete a specific hour of a historical day:                                                                                        </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvHistory &lt;Day&gt; &lt;Hour&gt;  (e.g. set &lt;name&gt; reset pvHistory 08 10) </ul>                    </td></tr>
            <tr><td> <b>roofIdentPair</b>      </td><td>deletes all saved SolCast API Rooftop ID / API Key pairs.                                                                             </td></tr>
            <tr><td>                           </td><td>To delete a specific pair, specify its key &lt;pk&gt;:                                                                                </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset roofIdentPair &lt;pk&gt;   (e.g. set &lt;name&gt; reset roofIdentPair p1) </ul>                            </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-roofIdentPair"></a>
      <li><b>roofIdentPair &lt;pk&gt; rtid=&lt;Rooftop-ID&gt; apikey=&lt;SolCast API Key&gt; </b> <br>
       (only when using Model SolCastAPI) <br><br>

       The retrieval of each rooftop created in
       <a href='https://toolkit.solcast.com.au/rooftop-sites' target='_blank'>SolCast Rooftop Sites</a> is to be identified
       by specifying a pair <b>Rooftop-ID</b> and <b>API-Key</b>. <br>
       The key &lt;pk&gt; uniquely identifies a linked Rooftop ID / API key pair. Any number of pairs can be created
       <b>one after the other</b>. In that case, a new name for "&lt;pk&gt;" is to be used in each case.
       <br><br>

       The key &lt;pk&gt; is assigned in the atribute <a href="#SolarForecast-attr-setupRoofTops">setupRoofTops</a> to the
       Rooftops (=Strings) to be retrieved.
       <br><br>

       <ul>
        <b>Examples: </b> <br>
        set &lt;name&gt; roofIdentPair p1 rtid=92fc-6796-f574-ae5f apikey=oNHDbkKuC_eGEvZe7ECLl6-T1jLyfOgC <br>
        set &lt;name&gt; roofIdentPair p2 rtid=f574-ae5f-92fc-6796 apikey=eGEvZe7ECLl6_T1jLyfOgC_oNHDbkKuC <br>
       </ul>

        <br>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-vrmCredentials"></a>
      <li><b>vrmCredentials user=&lt;Benutzer&gt; pwd=&lt;Paßwort&gt; idsite=&lt;idSite&gt; </b> <br>
      (only when using Model VictronKiAPI) <br><br>

       If the Victron VRM API is used, the required access data must be stored with this set command. <br><br>

      <ul>
         <table>
         <colgroup> <col width="10%"> <col width="90%"> </colgroup>
            <tr><td> <b>user</b>   </td><td>Username for the Victron VRM Portal                                              </td></tr>
            <tr><td> <b>pwd</b>    </td><td>Password for access to the Victron VRM Portal                                    </td></tr>
            <tr><td> <b>idsite</b> </td><td>idSite is the identifier "XXXXXX" in the Victron VRM Portal Dashboard URL.       </td></tr>
            <tr><td>               </td><td>URL of the Victron VRM Dashboard:                                                </td></tr>
            <tr><td>               </td><td>https://vrm.victronenergy.com/installation/<b>XXXXXX</b>/dashboard               </td></tr>
         </table>
      </ul>
      <br>

      To delete the stored credentials, only the argument <b>delete</b> must be passed to the command. <br><br>

       <ul>
        <b>Examples: </b> <br>
        set &lt;name&gt; vrmCredentials user=john@example.com pwd=somepassword idsite=212008 <br>
        set &lt;name&gt; vrmCredentials delete <br>
       </ul>

      </li>
    </ul>
    <br>

  </ul>
  <br>

  <a id="SolarForecast-get"></a>
  <b>Get</b>
  <ul>
    <ul>
      <a id="SolarForecast-get-data"></a>
      <li><b>data </b> <br><br>
      Starts data collection to determine the solar forecast and other values.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-dwdCatalog"></a>
      <li><b>dwdCatalog </b> <br><br>
      The German Weather Service (DWD) provides a catalog of MOSMIX stations. <br>
      The stations provide data whose meaning is explained in this
      <a href='https://www.dwd.de/DE/leistungen/opendata/help/schluessel_datenformate/kml/mosmix_elemente_xls.html' target='_blank'>Overview</a>.
      The DWD distinguishes between MOSMIX_L and MOSMIX_S stations, which differ in terms of update frequency
      and data volume. <br>
      This command reads the catalog into SolarForecast and saves it in the file
      ./FHEM/FhemUtils/DWDcat_SolarForecast. <br>
      The catalog can be extensively filtered and saved in GPS Exchange Format (GPX).
      The latitude and logitude coordinates are displayed in decimal degrees. <br>
      Regex expressions in the corresponding keys are used for filtering. The Regex is enclosed in
      ^...$ for evaluation. <br>
      The following parameters can be specified. Without parameters, the entire catalog is output: <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>byID</b>               </td><td>The output is sorted by station ID. (default)                                                                                      </td></tr>
            <tr><td> <b>byName</b>             </td><td>The output is sorted by station name.                                                                                              </td></tr>
            <tr><td> <b>force</b>              </td><td>The latest version of the DWD station catalog is loaded into the system.                                                           </td></tr>
            <tr><td> <b>exportgpx</b>          </td><td>The (filtered) stations are saved in the file ./FHEM/FhemUtils/DWDcat_SolarForecast.gpx.                                           </td></tr>
            <tr><td>                           </td><td>This file can be displayed in the <a href='https://www.j-berkemeier.de/ShowGPX.html' target='_blank'>GPX viewer</a>, for example.  </td></tr>
            <tr><td> <b>id=&lt;Regex&gt;</b>   </td><td>Filtering is carried out according to station ID.                                                                                  </td></tr>
            <tr><td> <b>name=&lt;Regex&gt;</b> </td><td>Filtering is carried out according to station name.                                                                                </td></tr>
            <tr><td> <b>lat=&lt;Regex&gt;</b>  </td><td>Filtering is carried out according to latitude.                                                                                    </td></tr>
            <tr><td> <b>lon=&lt;Regex&gt;</b>  </td><td>Filtering is carried out according to longitude.                                                                                   </td></tr>
         </table>
      </ul>
      <br>

       <ul>
        <b>Example: </b> <br>
        get &lt;name&gt; dwdCatalog byName name=ST.* exportgpx lat=(48|49|50|51|52)\..* lon=([5-9]|10|11|12|13|14|15)\..* <br>
        # filters the stations largely to German locations beginning with "ST" and exports the data in GPS Exchange format
       </ul>

    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-forecastQualities"></a>
      <li><b>forecastQualities </b> <br><br>
      Shows the correction factors currently used to determine the PV forecast with the respective start time and the
      average forecast quality achieved so far for this period.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-ftuiFramefiles"></a>
      <li><b>ftuiFramefiles </b> <br><br>
      SolarForecast provides widgets for
      <a href='https://wiki.fhem.de/wiki/FHEM_Tablet_UI' target='_blank'>FHEM Tablet UI v2 (FTUI2)</a>. <br>
      If FTUI2 is installed on the system, the files for the framework can be loaded into the FTUI directory structure
      with this command. <br>
      The setup and use of the widgets is described in Wiki
      <a href='https://wiki.fhem.de/wiki/SolarForecast_FTUI_Widget' target='_blank'>SolarForecast FTUI Widget</a>.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-html"></a>
      <li><b>html </b> <br><br>
      The SolarForecast graphic is retrieved and displayed as HTML code. <br>
      <b>Note:</b> By the attribute <a href="#SolarForecast-attr-graphicHeaderOwnspec">graphicHeaderOwnspec</a>
      generated set or attribute commands in the user-specific area of the header are generally hidden for technical
      reasons. <br>
      One of the following selections can be given as an argument to the command:
      <br><br>

      <ul>
        <table>
        <colgroup> <col width="30%"> <col width="70%"> </colgroup>
        <tr><td> <b>both</b>                    </td><td>displays graphic header, load panel, bar graph and energy flow graph (default)        </td></tr>
        <tr><td> <b>both_noHead</b>             </td><td>displays load panel, bar graph and energy flow graph                                  </td></tr>
        <tr><td> <b>both_noCons</b>             </td><td>displays graph header, bar graph and energy flow graph                                </td></tr>
        <tr><td> <b>both_noHead_noCons</b>      </td><td>displays bar graph and energy flow graph                                              </td></tr>
        <tr><td> <b>swap</b>                    </td><td>like 'both', with swapped bar and energy flow graph sequence                          </td></tr>
        <tr><td> <b>swap_noHead</b>             </td><td>like 'both_noHead', with swapped bar and energy flow graph sequence                   </td></tr>
        <tr><td> <b>swap_noCons</b>             </td><td>like 'both_noCons', with swapped bar and energy flow graph sequence                   </td></tr>
        <tr><td> <b>swap_noHead_noCons</b>      </td><td>like 'both_noHead_noCons', with swapped bar and energy flow graph sequence            </td></tr>
        <tr><td> <b>flow</b>                    </td><td>displays graphic header, load panel and energy flow graphic                           </td></tr>
        <tr><td> <b>flow_noHead</b>             </td><td>displays load panel and energy flow graph                                             </td></tr>
        <tr><td> <b>flow_noCons</b>             </td><td>displays graphic header and energy flow graphic                                       </td></tr>
        <tr><td> <b>flow_noHead_noCons</b>      </td><td>displays energy flow graph                                                            </td></tr>
        <tr><td> <b>forecast</b>                </td><td>displays graphic header, consumer panel and bar graph                                 </td></tr>
        <tr><td> <b>forecast_noHead</b>         </td><td>displays consumer panel and bar graph                                                 </td></tr>
        <tr><td> <b>forecast_noCons</b>         </td><td>displays graphic header and bar chart                                                 </td></tr>
        <tr><td> <b>forecast_noHead_noCons</b>  </td><td>displays bar graph                                                                    </td></tr>
        <tr><td> <b>none</b>                    </td><td>only displays graphic header and consumer panel                                       </td></tr>
        </table>
      </ul>
      <br>

      The graphic can be retrieved and embedded in your own code. This can be done in a simple way by defining
      a weblink device: <br><br>

      <ul>
        define wl.SolCast5 weblink htmlCode { FHEM::SolarForecast::pageAsHtml ('SolCast5', '-', '&lt;argument&gt;') }
      </ul>
      <br>

      'SolCast5' is the name of the SolarForecast device to be included. <b>&lt;argument&gt;</b> is one of the above
      described selection options.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-nextHours"></a>
      <li><b>nextHours </b> <br><br>
      Lists the stored values for the coming hours. <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>aihit</b>           </td><td>delivery status of the AI for the PV forecast (0-no delivery, 1-delivery)              </td></tr>
            <tr><td> <b>confc</b>           </td><td>expected energy consumption including the shares of registered consumers               </td></tr>
            <tr><td> <b>confcEx</b>         </td><td>expected energy consumption without consumer shares with set key exconfc=1             </td></tr>
            <tr><td> <b>crange</b>          </td><td>calculated cloud area                                                                  </td></tr>
            <tr><td> <b>correff</b>         </td><td>correction factor/quality used                                                         </td></tr>
            <tr><td>                        </td><td>&lt;factor&gt;/- -> no quality defined                                                 </td></tr>
            <tr><td>                        </td><td>&lt;factor&gt;/0..1 - quality of the PV forecast (1 = best quality)                    </td></tr>
            <tr><td> <b>day</b>             </td><td>Date of day                                                                            </td></tr>
            <tr><td> <b>DaysInRange</b>     </td><td>previously recorded days with comparable sun position and clouds at this time          </td></tr>
            <tr><td> <b>DoN</b>             </td><td>sunrise and sunset status (0 - night, 1 - day)                                         </td></tr>
            <tr><td> <b>hourofday</b>       </td><td>current hour of the day                                                                </td></tr>
            <tr><td> <b>pvapifcraw</b>      </td><td>expected PV generation (Wh) of the used API (raw)                                      </td></tr>
            <tr><td> <b>pvapifc</b>         </td><td>expected PV generation (Wh) of the used API incl. a possible correction                </td></tr>
            <tr><td> <b>pvaifc</b>          </td><td>expected PV generation of the AI (Wh)                                                  </td></tr>
            <tr><td> <b>pvfc</b>            </td><td>PV generation forecast used (Wh)                                                       </td></tr>
            <tr><td> <b>rad1h</b>           </td><td>predicted global radiation                                                             </td></tr>
            <tr><td> <b>starttime</b>       </td><td>start time of the record                                                               </td></tr>
            <tr><td> <b>sunaz</b>           </td><td>Azimuth of the sun (in decimal degrees)                                                </td></tr>
            <tr><td> <b>sunalt</b>          </td><td>Altitude of the sun (in decimal degrees)                                               </td></tr>
            <tr><td> <b>temp</b>            </td><td>predicted outdoor temperature                                                          </td></tr>
            <tr><td> <b>today</b>           </td><td>has value '1' if start date on current day                                             </td></tr>
            <tr><td> <b>rcdchargebatXX</b>  </td><td>Charging recommendation with full power for battery XX (1 - Yes, 0 - No)               </td></tr>
            <tr><td> <b>lcintimebatXX</b>   </td><td>Charge management for battery XX is activated or will be activated (1 - Yes, 0 - No)   </td></tr>
            <tr><td> <b>strategybatXX</b>   </td><td>the selected charging strategy                                                         </td></tr>
            <tr><td> <b>rr1c</b>            </td><td>Total precipitation during the last hour kg/m2                                         </td></tr>
            <tr><td> <b>rrange</b>          </td><td>range of total rain                                                                    </td></tr>
            <tr><td> <b>socXX</b>           </td><td>current (NextHour00) or predicted SoC (%) of battery XX                                </td></tr>
            <tr><td> <b>socprogwhsum</b>    </td><td>current (NextHour00) or forecast SoC (Wh) summarized across all batteries              </td></tr>
            <tr><td> <b>weatherid</b>       </td><td>ID of the predicted weather                                                            </td></tr>
            <tr><td> <b>wcc</b>             </td><td>predicted degree of cloudiness                                                         </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-pvHistory"></a>
      <li><b>pvHistory </b> <br><br>
      Displays or exports the contents of the pvHistory data memory sorted by date and hour. <br>
      The selection list can be used to jump to a specific day. The drop-down list contains the days currently
      available in the memory.
      Without an argument, the entire data storage is listed.
      The 'exportToCsv' specification exports the entire content of the pvHistory to a CSV file. <br>

      The hour specifications refer to the respective hour of the day, e.g. the hour 09 refers to the time from
      08 o'clock to 09 o'clock. The hour '99' contains daily values.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>batintotalXX</b>   </td><td>total battery XX charge (Wh) at the beginning of the hour                                                                </td></tr>
            <tr><td> <b>batinXX</b>        </td><td>Charge of battery XX within the hour (Wh)                                                                                </td></tr>
            <tr><td> <b>batouttotalXX</b>  </td><td>total battery XX discharge (Wh) at the beginning of the hour                                                             </td></tr>
            <tr><td> <b>batoutXX</b>       </td><td>Discharge of battery XX within the hour (Wh)                                                                             </td></tr>
            <tr><td> <b>batprogsocXX</b>   </td><td>predicted state of charge SOC (%) of battery XX at the end of the hour                                                   </td></tr>
            <tr><td> <b>batsocXX</b>       </td><td>real State of charge SOC (%) of battery XX at the end of the hour                                                        </td></tr>
            <tr><td> <b>batmaxsocXX</b>    </td><td>Maximum SOC (%) achieved by battery XX on the day                                                                        </td></tr>
            <tr><td> <b>batsetsocXX</b>    </td><td>Optimum SOC setpoint (%) of battery XX  for the day                                                                      </td></tr>
            <tr><td> <b>confc</b>          </td><td>expected energy consumption (Wh)                                                                                         </td></tr>
            <tr><td> <b>con</b>            </td><td>real energy consumption (Wh) of the house                                                                                </td></tr>
            <tr><td> <b>conprice</b>       </td><td>Price for the purchase of one kWh. The currency of the price is defined in the setupMeterDev.                            </td></tr>
            <tr><td> <b>csmtXX</b>         </td><td>total energy consumption of ConsumerXX                                                                                   </td></tr>
            <tr><td> <b>csmeXX</b>         </td><td>Energy consumption of ConsumerXX in the hour of the day (hour 99 = daily energy consumption)                             </td></tr>
            <tr><td> <b>cyclescsmXX</b>    </td><td>Number of active cycles of ConsumerXX of the day                                                                         </td></tr>
            <tr><td> <b>dayname</b>        </td><td>short name of the day (locale-dependent)                                                                                 </td></tr>
            <tr><td> <b>DoN</b>            </td><td>Sunrise and sunset status (0 - night, 1 - day)                                                                           </td></tr>
            <tr><td> <b>etotaliXX</b>      </td><td>PV meter reading “Total energy yield” (Wh) of inverter XX at the beginning of the hour                                   </td></tr>
            <tr><td> <b>etotalpXX</b>      </td><td>Meter reading “Total energy yield” (Wh) of producer XX at the beginning of the hour                                      </td></tr>
            <tr><td> <b>gcons</b>          </td><td>real consumption (Wh) from the electricity grid                                                                          </td></tr>
            <tr><td> <b>gfeedin</b>        </td><td>real feed-in (Wh) into the electricity grid                                                                              </td></tr>
            <tr><td> <b>feedprice</b>      </td><td>Remuneration for the feed-in of one kWh. The currency of the price is defined in the setupMeterDev.                      </td></tr>
            <tr><td> <b>hourscsmeXX</b>    </td><td>total active hours of the day from ConsumerXX                                                                            </td></tr>
            <tr><td> <b>lcintimebatXX</b>  </td><td>the charge management for battery XX was activated (1 - Yes, 0 - No)                                                     </td></tr>
            <tr><td> <b>strategybatXX</b>  </td><td>the selected charging strategy                                                                                           </td></tr>
            <tr><td> <b>minutescsmXX</b>   </td><td>total active minutes in the hour of ConsumerXX                                                                           </td></tr>
            <tr><td> <b>plantderated</b>   </td><td>Timestamp of the first curtailment event of the system in this hour, otherwise '0'                                       </td></tr>
            <tr><td> <b>pprlXX</b>         </td><td>Energy generation of producer XX (see attribute setupOtherProducerXX) in the hour (Wh)                                   </td></tr>
            <tr><td> <b>pvapifcraw</b>     </td><td>expected PV generation (Wh) of the API used (raw)                                                                        </td></tr>
            <tr><td> <b>pvfc</b>           </td><td>the predicted PV yield (Wh)                                                                                              </td></tr>
            <tr><td> <b>pvrlXX</b>         </td><td>real PV generation (Wh) of inverter XX                                                                                   </td></tr>
            <tr><td> <b>pvrl</b>           </td><td>Sum real PV generation (Wh) of all inverters                                                                             </td></tr>
            <tr><td> <b>pvrlvd</b>         </td><td>1-'pvrl' is valid and is taken into account in the learning process, 0-'pvrl' is assessed as copromitted                 </td></tr>
            <tr><td> <b>pvcorrf</b>        </td><td>Autocorrection factor used / forecast quality achieved                                                                   </td></tr>
            <tr><td> <b>rad1h</b>          </td><td>global radiation (kJ/m2)                                                                                                 </td></tr>
            <tr><td> <b>rr1c</b>           </td><td>Total precipitation during the last hour kg/m2                                                                           </td></tr>
            <tr><td> <b>socwhsum</b>       </td><td>real SoC achieved (Wh) summarized across all batteries                                                                   </td></tr>
            <tr><td> <b>socprogwhsum</b>   </td><td>predicted SoC (Wh) summarized across all batteries                                                                       </td></tr>
            <tr><td> <b>sunalt</b>         </td><td>Altitude of the sun (in decimal degrees)                                                                                 </td></tr>
            <tr><td> <b>sunaz</b>          </td><td>Azimuth of the sun (in decimal degrees)                                                                                  </td></tr>
            <tr><td> <b>wid</b>            </td><td>Weather identification number                                                                                            </td></tr>
            <tr><td> <b>wcc</b>            </td><td>effective cloud cover                                                                                                    </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-pvCircular"></a>
      <li><b>pvCircular </b> <br><br>
      Lists the stored data for the selected hour or all existing values in the ring buffer. <br>
      The hours 01 - 24 refer to the hour of the day, e.g. the hour 09 refers to the time from
      08 - 09 o'clock. <br>
      Hour 99 has a special function. <br>
      The values of the keys pvcorrf, quality, pvrlsum, pvfcsum and dnumsum are coded in the form
      &lt;range sun elevation&gt;.&lt;cloud cover range&gt;.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>aihit</b>               </td><td>Delivery status of the AI for the PV forecast (0-no delivery, 1-delivery)                                             </td></tr>
            <tr><td> <b>attrInvChangedTs</b>    </td><td>Timestamp of the last change to the inverter device definition                                                        </td></tr>
            <tr><td> <b>batinXX</b>             </td><td>Battery XX charge (Wh)                                                                                                </td></tr>
            <tr><td> <b>batoutXX</b>            </td><td>Battery XX discharge (Wh)                                                                                             </td></tr>
            <tr><td> <b>batouttotXX</b>         </td><td>total energy drawn from the battery XX (Wh)                                                                           </td></tr>
            <tr><td> <b>batintotXX</b>          </td><td>current total energy charged into the battery XX (Wh)                                                                 </td></tr>
            <tr><td> <b>confc</b>               </td><td>expected energy consumption (Wh) of the house on the current day                                                      </td></tr>
            <tr><td> <b>con_all</b>             </td><td>an array of values of the house consumption (Wh) on certain days of the selected hour                                 </td></tr>
            <tr><td> <b>days2careXX</b>         </td><td>remaining days until the battery XX maintenance SoC (default 95%) is reached                                          </td></tr>
            <tr><td> <b>dnumsum</b>             </td><td>Number of days per cloudy area over the entire term                                                                   </td></tr>
            <tr><td> <b>feedintotal</b>         </td><td>total PV energy fed into the public grid (Wh)                                                                         </td></tr>
            <tr><td> <b>gcons</b>               </td><td>real energy consumption (Wh) from the electricity grid                                                                </td></tr>
            <tr><td> <b>gcons_a</b>             </td><td>an array of values of energy consumption (Wh) from the public grid on specific days of the selected hour              </td></tr>
            <tr><td> <b>gfeedin</b>             </td><td>real power feed-in to the electricity grid                                                                            </td></tr>
            <tr><td> <b>gridcontotal</b>        </td><td>total energy drawn from the public grid (Wh)                                                                          </td></tr>
            <tr><td> <b>initdayfeedin</b>       </td><td>initial PV feed-in value at the beginning of the current day (Wh)                                                     </td></tr>
            <tr><td> <b>initdaygcon</b>         </td><td>initial grid reference value at the beginning of the current day (Wh)                                                 </td></tr>
            <tr><td> <b>initdaybatintotXX</b>   </td><td>initial value of the total energy charged into the battery XX at the beginning of the current day. (Wh)               </td></tr>
            <tr><td> <b>initdaybatouttotXX</b>  </td><td>initial value of the total energy drawn from the battery XX at the beginning of the current day. (Wh)                 </td></tr>
            <tr><td> <b>lastTsMaxSocRchdXX</b>  </td><td>Timestamp of last achievement of battery XX SoC >= maxSoC (default 95%)                                               </td></tr>
            <tr><td> <b>nextTsMaxSocChgeXX</b>  </td><td>Timestamp by which the battery XX should reach maxSoC at least once                                                   </td></tr>
            <tr><td> <b>pvapifcraw</b>          </td><td>expected PV generation (Wh) of the API used (raw)                                                                     </td></tr>
            <tr><td> <b>pvapifc</b>             </td><td>expected PV generation (Wh) of the API used incl. correction factor applied                                           </td></tr>
            <tr><td> <b>pvaifc</b>              </td><td>PV forecast (Wh) of the AI for the next 24h from the current hour of the day                                          </td></tr>
            <tr><td> <b>pvfc</b>                </td><td>PV forecast used for the next 24h from the current hour of the day                                                    </td></tr>
            <tr><td> <b>pvfc_XX</b>             </td><td>Array of predicted PV generation (raw value in Wh) depending on the degree of cloud cover, altitude of the sun (XX)   </td></tr>
            <tr><td> <b>pvcorrf</b>             </td><td>Autocorrection factors for the hour of the day, where 'simple' is the simple correction factor.                       </td></tr>
            <tr><td> <b>pvfcsum</b>             </td><td>summary PV forecast per cloud area over the entire term                                                               </td></tr>
            <tr><td> <b>pvrl</b>                </td><td>real PV generation of the last 24h (Attention: pvforecast and pvreal do not refer to the same period!)                </td></tr>
            <tr><td> <b>pvrl_XX</b>             </td><td>Array of real PV generation values generated at a certain degree of cloudiness (XX = altitude of the sun)             </td></tr>
            <tr><td> <b>pvrlsum</b>             </td><td>summary real PV generation per cloud area over the entire term                                                        </td></tr>
            <tr><td> <b>pprlXX</b>              </td><td>Energy generation of producer XX (see attribute setupOtherProducerXX) in the last 24 hours (Wh)                       </td></tr>
            <tr><td> <b>quality</b>             </td><td>Quality of the autocorrection factors (0..1), where 'simple' is the quality of the simple correction factor.          </td></tr>
            <tr><td> <b>runTimeTrainAI</b>      </td><td>Duration of the last AI training                                                                                      </td></tr>
            <tr><td> <b>aitrainLastFinishTs</b> </td><td>Timestamp of the last successful AI training                                                                          </td></tr>
            <tr><td> <b>aiRulesNumber</b>       </td><td>Number of rules in the trained AI instance                                                                            </td></tr>
            <tr><td> <b>todayConsumption</b>    </td><td>real energy consumption (Wh) of the house on the current day                                                          </td></tr>
            <tr><td> <b>tdayDvtn</b>            </td><td>Today's deviation PV forecast/generation in %                                                                         </td></tr>
            <tr><td> <b>temp</b>                </td><td>Outdoor temperature                                                                                                   </td></tr>
            <tr><td> <b>wcc</b>                 </td><td>Degree of cloud cover                                                                                                 </td></tr>
            <tr><td> <b>rr1c</b>                </td><td>Total precipitation during the last hour kg/m2                                                                        </td></tr>
            <tr><td> <b>wid</b>                 </td><td>ID of the predicted weather                                                                                           </td></tr>
            <tr><td> <b>wtxt</b>                </td><td>Description of the predicted weather                                                                                  </td></tr>
            <tr><td> <b>ydayDvtn</b>            </td><td>Deviation PV forecast/generation in % on the previous day                                                             </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-rooftopData"></a>
      <li><b>rooftopData </b> <br><br>
      The expected solar radiation data or PV generation data are retrieved from the selected API. <br>
      If an API is also selected for weather data, this data is also retrieved.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-radiationApiData"></a>
      <li><b>radiationApiData </b> <br><br>

      Lists the radiation data saved in the context of the API call.
      The forecast data supplied by the API regarding the global radiation Rad1h and the predicted PV yield (Wh)
      related to a string are normalized to one hour.
      The available characteristic values differ depending on the API used.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>Rad1h</b>          </td><td>expected global irradiation (GI) in kJ/m2                       </td></tr>
            <tr><td> <b>GTIWh</b>          </td><td>expected Global Tilted Radiation  (GTI) in Wh/m2                </td></tr>
            <tr><td> <b>pv_estimateXX</b>  </td><td>Expected PV generation (Wh)                                     </td></tr>
            <tr><td> <b>KI-based</b>       </td><td>expected PV generation (Wh) of the VictronKI-API                </td></tr>
            <tr><td> <b>KI-based_co</b>    </td><td>expected energy consumption (Wh) of the VictronKI-API           </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-statusApiData"></a>
      <li><b>statusApiData </b> <br><br>
      Shows the status data of the radiation data API or weather data API used.
      Only the status data of the leading weather service is output.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="37%"> <col width="63%"> </colgroup>
            <tr><td> <b>currentAPIinterval</b>        </td><td>the API call interval currently used in seconds                   </td></tr>
            <tr><td> <b>lastretrieval_time</b>        </td><td>Time of the last API call                                         </td></tr>
            <tr><td> <b>lastretrieval_timestamp</b>   </td><td>Unix timestamp of the last API call                               </td></tr>
            <tr><td> <b>todayDoneAPIrequests</b>      </td><td>Number of API requests executed on the current day                </td></tr>
            <tr><td> <b>todayRemainingAPIrequests</b> </td><td>Number of remaining SolCast API requests on the current day       </td></tr>
            <tr><td> <b>todayDoneAPIcalls</b>         </td><td>Number of API calls executed on the current day                   </td></tr>
            <tr><td> <b>todayRemainingAPIcalls</b>    </td><td>Number of SolCast API calls still possible on the current day     </td></tr>
            <tr><td>                                  </td><td>(one call can execute several SolCast API requests)               </td></tr>
            <tr><td> <b>todayMaxAPIcalls</b>          </td><td>Maximum number of possible SolCast API calls per day              </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valBattery"></a>
      <li><b>valBattery </b> <br><br>
      Shows the operating values determined for the selected battery or all defined battery devices.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="30%"> <col width="70%"> </colgroup>
            <tr><td> <b>bname </b>          </td><td>Name of the device                                     </td></tr>
            <tr><td> <b>balias </b>         </td><td>Alias of the device                                    </td></tr>
            <tr><td> <b>basynchron </b>     </td><td>Mode of processing received battery events             </td></tr>
            <tr><td> <b>bcharge </b>        </td><td>current SoC (State of Charge) of the battery (%)       </td></tr>
            <tr><td> <b>bchargewh </b>      </td><td>current SoC (State of Charge) of the battery (Wh)      </td></tr>
            <tr><td> <b>befficiency </b>    </td><td>Storage efficiency (%)                                 </td></tr>
            <tr><td> <b>binstcap </b>       </td><td>installed battery capacity (Wh)                        </td></tr>
            <tr><td> <b>bpowerin </b>       </td><td>current charging power (W)                             </td></tr>
            <tr><td> <b>bpinmax </b>        </td><td>maximum possible charging power (W)                    </td></tr>
            <tr><td> <b>bpinreduced </b>    </td><td>reduced charging power (W), e.g. when SoC <= lowSoC    </td></tr>
            <tr><td> <b>bpowerout </b>      </td><td>current discharge power (W)                            </td></tr>
            <tr><td> <b>bpoutmax </b>       </td><td>maximum possible discharging power (W)                 </td></tr>
            <tr><td> <b>bloadAbortCond </b> </td><td>general load termination condition (boolean)           </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valConsumerMaster"></a>
      <li><b>valConsumerMaster </b> <br><br>
      Shows the data of the consumers currently registered in the SolarForecast Device. <br>
      The drop-down list can be used to jump to a specific consumer. The drop-down list contains the consumers
      or consumer numbers currently available in the data memory.
      Without an argument, the entire data memory is listed.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valCurrent"></a>
      <li><b>valCurrent </b> <br><br>
      Lists current operating data, key figures and status.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valDecTree"></a>
      <li><b>valDecTree </b> <br><br>

      Display of AI-relevant data.
      The available display options depend on the available and activated AI support level.
      <br><br>

      <ul>
       <table>
       <colgroup> <col width="20%"> <col width="80%"> </colgroup>
          <tr><td> <b>aiRawData</b>     </td><td>Display of the PV, radiation and environmental data currently saved for an AI evaluation.   </td></tr>
          <tr><td>                      </td><td>                                                                                            </td></tr>
          <tr><td> <b>aiRuleStrings</b> </td><td>Returns a list that describes the AI's decision tree in the form of rules.                  </td></tr>
          <tr><td>                      </td><td><b>Note:</b> While the order of the rules is not predictable, the                           </td></tr>
          <tr><td>                      </td><td>order of criteria within each rule, however, reflects the order                             </td></tr>
          <tr><td>                      </td><td>in which the criteria are considered in the decision-making process.                        </td></tr>
          <tr><td>                      </td><td>(available if an AI-compatible SolarForecast MODEL of the PV forecast is activated)         </td></tr>
        </table>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valInverter"></a>
      <li><b>valInverter </b> <br><br>
      Shows the operating values determined for the selected inverter or all defined inverters.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>ialias </b>         </td><td>Alias of the device                                                   </td></tr>
            <tr><td> <b>iasynchron </b>     </td><td>Mode of processing received inverter events                           </td></tr>
            <tr><td> <b>ietotal </b>        </td><td>total energy generated by the inverter to date (Wh)                   </td></tr>
            <tr><td> <b>ifeed </b>          </td><td>Energy supply characteristics                                         </td></tr>
            <tr><td> <b>ipvin </b>          </td><td>current DC PV input power in W (sum of all connected strings)         </td></tr>
            <tr><td> <b>ipvout </b>         </td><td>current PV power from PV generation in W                              </td></tr>
            <tr><td> <b>iicon </b>          </td><td>any icons defined for displaying the device in the graphic            </td></tr>
            <tr><td> <b>ilimit </b>         </td><td>set power limitation in % (e.g. by 70% rule)                          </td></tr>
            <tr><td> <b>iname </b>          </td><td>Name of the device                                                    </td></tr>
            <tr><td> <b>invertercap </b>    </td><td>the nominal power (W) of the inverter (if defined)                    </td></tr>
            <tr><td> <b>ipac2dc </b>        </td><td>current AC->DC power (W) of a battery inverter                        </td></tr>
            <tr><td> <b>ipdc2ac </b>        </td><td>current DC->AC power (W) of a battery inverter                        </td></tr>
            <tr><td> <b>isource </b>        </td><td>Type of energy source of the inverter                                 </td></tr>
            <tr><td> <b>istrings </b>       </td><td>List of strings assigned to the inverter (if defined)                 </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valProducer"></a>
      <li><b>valProducer </b> <br><br>
      Shows the operating values determined for the selected non-PV generator or all defined non-PV generators.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>petotal </b>        </td><td>total energy generated by the producer to date (Wh)              </td></tr>
            <tr><td> <b>pfeed </b>          </td><td>Energy supply characteristics                                    </td></tr>
            <tr><td> <b>pgeneration </b>    </td><td>current power (W)                                                </td></tr>
            <tr><td> <b>picon </b>          </td><td>any icons defined for displaying the device in the graphic       </td></tr>
            <tr><td> <b>palias </b>         </td><td>Alias of the device                                              </td></tr>
            <tr><td> <b>pname </b>          </td><td>Name of the device                                               </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valStrings"></a>
      <li><b>valStrings </b> <br><br>
      Lists the parameters of the selected or all defined strings.

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-weatherApiData"></a>
      <li><b>weatherApiData </b> <br><br>
      Shows the data supplied by the selected weather API.
      </li>
    </ul>
    <br>

  </ul>
  <br>

  <a id="SolarForecast-attr"></a>
  <b>Attribute</b>
  <br><br>
  <ul>
     <ul>
       <a id="SolarForecast-attr-aiControl"></a>
       <li><b>aiControl &lt;Key=Value&gt; &lt;Key=Value&gt; ... </b><br>
         By optionally specifying the following key=value pairs, various properties of the AI support can be
         properties of the AI support can be influenced. <br>
         AI support for PV forecast autocorrection is activated with the set command
         <a href="#SolarForecast-set-pvCorrectionFactor_Auto">pvCorrectionFactor_Auto </a> switched on. <br>
         The entry can be made in several lines.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="26%"> <col width="74%"> </colgroup>
            <tr><td> <b>aiTrainStart</b>      </td><td>Daily training takes place when using the internal AI.                                                                        </td></tr>
            <tr><td>                          </td><td>Training starts approx. 15 minutes after the hour specified in this key.                                                      </td></tr>
            <tr><td>                          </td><td>For example, with a set value of '3', training would start at around 03:15.                                                   </td></tr>
            <tr><td>                          </td><td>Value: <b>1 ... 23</b>, default: 2                                                                                            </td></tr>
            <tr><td>                          </td><td>                                                                                                                              </td></tr>
            <tr><td> <b>aiStorageDuration</b> </td><td>Training data is collected and stored for the module's internal AI.                                                           </td></tr>
            <tr><td>                          </td><td>This data is deleted when it has exceeded the specified holding period (days).                                                </td></tr>
            <tr><td>                          </td><td>Value: <b>Integer</b>, default: 1825                                                                                          </td></tr>
            <tr><td>                          </td><td>                                                                                                                              </td></tr>
            <tr><td> <b>aiTreesPV</b>         </td><td>Defines the number of AI decision trees (random forests). A higher number increases the                                       </td></tr>
            <tr><td>                          </td><td>accuracy and robustness of AI prediction, but requires more CPU and RAM resources.                                            </td></tr>
            <tr><td>                          </td><td><b>Note:</b> Only carry out an increase in small steps and in consideration of the performance of the hardware!               </td></tr>
            <tr><td>                          </td><td>                                                                                                                              </td></tr>
            <tr><td>                          </td><td>Value: <b>1 ... 50</b>, default: 10                                                                                           </td></tr>
        </table>
         </ul>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; aiControl aiTrainStart=7 aiStorageDuration=3000 aiTreesPV=3
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-consumerControl"></a>
       <li><b>consumerControl &lt;Key=Value&gt; &lt;Key=Value&gt; ... </b><br>
         By specifying the 'Key=Value' pairs listed below, various overlapping properties of the consumer display can be set. <br>
         The entry can be made in several lines.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>adviceIcon</b>          </td><td>Defines the type of information about the planned switching times of a consumer in the consumer legend.                 </td></tr>
            <tr><td>                            </td><td><b>&lt;Icon&gt[@&lt;Color]&gt</b> - Activation recommendation is displayed by icon and color (default: clock@gold)      </td></tr>
            <tr><td>                            </td><td><b>times</b> - the planning status and the planned switching times are displayed as text                                </td></tr>
            <tr><td>                            </td><td><b>none</b>  - no display of planning data                                                                              </td></tr>
            <tr><td>                            </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>detailLink</b>          </td><td>If set, the devices can be clicked on in the consumer legend to open the detailed view of the device.                   </td></tr>
            <tr><td>                            </td><td>Value: <b>0|1</b>, default: 1                                                                                           </td></tr>
            <tr><td>                            </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>dummyIcon</b>           </td><td>Icon and, if applicable, its color for displaying the dummy consumer in the flow chart (optional).                      </td></tr>
            <tr><td>                            </td><td>Syntax: <b>[&lt;Icon&gt;][@&lt;Color&gt;]</b>                                                                           </td></tr>
            <tr><td>                            </td><td>If only the color of the standard dummy icon is to be changed, only '@&lt;color&gt;' can be specified.                  </td></tr>
            <tr><td>                            </td><td>The color can be specified as a hex value (e.g. #cc3300) or designation (e.g. red, blue).                               </td></tr>
            <tr><td>                            </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showLegend</b>          </td><td>Defines the position or display method of the consumer legend if consumers are registered.                              </td></tr>
            <tr><td>                            </td><td>To hide the consumer panel, please use <a href=“#SolarForecast-attr-graphicSelect”>graphicSelect</a>.                   </td></tr>
            <tr><td>                            </td><td><b>icon_top</b> - the legend is displayed above the bar chart with consumer icons (default)                             </td></tr>
            <tr><td>                            </td><td><b>icon_bottom</b> - the legend is displayed below the bar and flow chart with consumer icons                           </td></tr>
            <tr><td>                            </td><td><b>text_top</b> - the legend is displayed above the bar chart without consumer icons                                    </td></tr>
            <tr><td>                            </td><td><b>text_bottom</b> - the legend is displayed below the bar chart and flow chart without consumer icons                  </td></tr>
         </table>
         </ul>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; consumerControl dummyIcon=status_comfort@#ff8c00 adviceIcon=times showLegend=icon_bottom
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-consumer" data-pattern="consumer.*"></a>
       <li><b>consumerXX &lt;Device&gt;[:&lt;Alias&gt;] type=&lt;type&gt; power=&lt;power&gt; [switchdev=&lt;device&gt;]                                                                                  <br>
                         [aliasshort=&lt;String&gt;] [mode=&lt;mode&gt;] [icon=&lt;Icon&gt;[@&lt;Color&gt;]] [mintime=&lt;Option&gt;]                                                                                                 <br>
                         [on=&lt;command&gt;] [off=&lt;command&gt;] [swstate=&lt;Readingname&gt;:&lt;on-Regex&gt;:&lt;off-Regex&gt;] [asynchron=&lt;Option&gt;]                                           <br>
                         [notbefore=&lt;Expression&gt;] [notafter=&lt;Expression&gt;] [locktime=&lt;offlt&gt;[:&lt;onlt&gt;]]                                                                             <br>
                         [auto=&lt;Readingname&gt;] [pcurr=&lt;Readingname&gt;:&lt;Unit&gt;[:&lt;Threshold&gt;]] [etotal=&lt;Readingname&gt;:&lt;Einheit&gt;[:&lt;Threshold&gt;]]                         <br>
                         [swoncond=&lt;Device&gt;:&lt;Reading&gt;:&lt;Condition&gt;] [swoffcond=&lt;Device&gt;:&lt;Reading&gt;:&lt;Condition&gt;]                                                         <br>
                         [spignorecond=&lt;Device&gt;:&lt;Reading&gt;:&lt;Condition&gt;] [surpmeth=&lt;Option&gt;] [interruptable=&lt;Option&gt;] [noshow=&lt;Option&gt;] [exconfc=&lt;Option&gt;] </b>   <br>
                         <br>

        Registers a consumer &lt;Device&gt; with the SolarForecast Device. An optional alias can be specified. <br>
        In this case, &lt;Device&gt; is a consumer device already created in FHEM, e.g. a switchable socket.
        Most of the keys are optional, but are a prerequisite for certain functionalities and are filled with
        default values. <br>
        If the dish is defined "auto", the automatic mode in the integrated consumer graphic can be switched with the
        corresponding push-buttons. If necessary, the specified reading is created in the consumer device if
        it is not available. <br><br>

        With the optional key <b>swoncond</b>, an <b>additional external condition</b> can be defined to enable the
        switch-on process of the consumer.
        If the condition (Regex) is not fulfilled, the load is not switched on, even if the other conditions such as
        other conditions such as scheduling, on key, auto mode and current PV power are fulfilled. Thus, there is an
        <b>AND-link</b> of the key swoncond with the further switch-on conditions. <br><br>

        The optional key <b>swoffcond</b> defines a <b>priority switch-off condition</b> (Regex).
        As soon as this condition is fulfilled, the consumer is switched off even if the planned end time
        (consumerXX_planned_stop) has not yet been reached (<b>OR link</b>). Further conditions such as off key and auto mode must be
        be fulfilled for automatic switch-off. <br><br>

        With the optional <b>interruptable</b> key, an automatic
        interruption and reconnection of the consumer during the planned switch-on time.
        The load is temporarily switched off (interrupted) and switched on again (continued) when the
        interrupt condition is no longer present.
        The remaining runtime is not affected by an interrupt!
        <br><br>

        The <b>power</b> key indicates the nominal power consumption of the consumer according to its data sheet.
        This value is used to schedule the switching times of the load and to control the switching depending on
        the actual PV surplus at the time of scheduling.
        This value is used to schedule the switching times of the load and to control the switching depending on
        the actual PV surplus at the time of scheduling.
        <br><br>

         <ul>
         <table>
         <colgroup> <col width="12%"> <col width="88%"> </colgroup>
            <tr><td> <b>Device</b>         </td><td>Consumer device. In the simple case, the device works both as an energy meter and as a switch.                                                    </td></tr>
            <tr><td>                       </td><td>In the optional alias, spaces must be replaced by '+' (e.g. 'Ein+toller+Alias').                                                                  </td></tr>
            <tr><td>                       </td><td>If the consumer consists of different devices/channels (e.g. Homematic), the energy meter is defined as a &lt;Device&gt;.                         </td></tr>
            <tr><td>                       </td><td>The associated switching device is specified with the key 'switchdev'.                                                                            </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>aliasshort</b>     </td><td>Short alias of the consumer for display in the flow chart. A maximum of 10 characters and no spaces are allowed.                                  </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>type</b>           </td><td>Type of consumer. The following types are allowed:                                                                                                </td></tr>
            <tr><td>                       </td><td><b>dishwasher</b>     - Consumer is a dishwasher                                                                                                  </td></tr>
            <tr><td>                       </td><td><b>dryer</b>          - Consumer is a tumble dryer                                                                                                </td></tr>
            <tr><td>                       </td><td><b>washingmachine</b> - Consumer is a washing machine                                                                                             </td></tr>
            <tr><td>                       </td><td><b>heater</b>         - Consumer is a heating rod                                                                                                 </td></tr>
            <tr><td>                       </td><td><b>charger</b>        - Consumer is a charging device (battery, car, bicycle, etc.)                                                               </td></tr>
            <tr><td>                       </td><td><b>other</b>          - Consumer is none of the above types                                                                                       </td></tr>
            <tr><td>                       </td><td><b>noSchedule</b>     - there is no scheduling or automatic switching for the consumer.                                                           </td></tr>
            <tr><td>                       </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                                    Display functions or manual switching are available.                                                                                              </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>power</b>          </td><td>nominal power consumption of the consumer (see data sheet) in W                                                                                   </td></tr>
            <tr><td>                       </td><td>(can be set to "0")                                                                                                                               </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>switchdev</b>      </td><td>The specified &lt;device&gt; is assigned to the consumer as a switch device (optional). Switching operations are performed with this device.      </td></tr>
            <tr><td>                       </td><td>The key is useful for consumers where energy measurement and switching is carried out with different devices                                      </td></tr>
            <tr><td>                       </td><td>e.g. Homematic or readingsProxy. If switchdev is specified, the keys on, off, swstate, auto, asynchronous refer to this device.                   </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>mode</b>           </td><td>Consumer planning mode (optional). Allowed are:                                                                                                   </td></tr>
            <tr><td>                       </td><td><b>can</b>  - Scheduling takes place at the time when there is probably enough PV surplus available (default).                                    </td></tr>
            <tr><td>                       </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The consumer is not started at the time of planning if the PV surplus is insufficient.           </td></tr>
            <tr><td>                       </td><td><b>must</b> - The consumer is optimally planned, even if there will probably not be enough PV surplus.                                            </td></tr>
            <tr><td>                       </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The load is started even if there is insufficient PV surplus, provided that
                                                    a set "swoncond" condition is met and "swoffcond" is not met.                                                                                     </td></tr>
            <tr><td>                       </td><td><b>&lt;Device&gt;:&lt;Reading&gt;</b> - Device/Reading combination to be able to change the planning mode dynamically.
                                                    The reading must return 'can' or 'must'.                                                                                                          </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>icon</b>           </td><td>Icon and, if applicable, its color for displaying the consumer in the overview graphic (optional)                                                 </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>mintime</b>        </td><td>Scheduling duration in minutes (optional). The following definition options are possible:                                                         </td></tr>
            <tr><td>                       </td><td><b>&lt;Number&gt;</b> - the scheduling time in minutes as a numerical value                                                                       </td></tr>
            <tr><td>                       </td><td><b>SunPath</b>[:&lt;Offset_Sunrise&gt;:&lt;Offset_Sunset&gt;] - scheduling takes place from sunrise to sunset.                                    </td></tr>
            <tr><td>                       </td><td> Optionally, a positive and negative shift (minutes) of the planning time with regard to sunrise or sunset can be specified.                      </td></tr>
            <tr><td>                       </td><td><b>&lt;Device&gt;:&lt;Reading&gt;</b> - Device/reading combination that provides a variably definable scheduling duration in minutes.             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                                                                                                                                                                     </td></tr>
            <tr><td>                       </td><td>If mintime is not specified, a standard scheduling duration according to the following table is used.                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td>                       </td><td><b>Default mintime by consumer type:</b>                                                                                                          </td></tr>
            <tr><td>                       </td><td>- dishwasher: 180 minutes                                                                                                                         </td></tr>
            <tr><td>                       </td><td>- dryer: 90 minutes                                                                                                                               </td></tr>
            <tr><td>                       </td><td>- washingmachine: 120 minutes                                                                                                                     </td></tr>
            <tr><td>                       </td><td>- heater: 240 minutes                                                                                                                             </td></tr>
            <tr><td>                       </td><td>- charger: 120 minutes                                                                                                                            </td></tr>
            <tr><td>                       </td><td>- other: 60 minutes                                                                                                                               </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>on</b>             </td><td>Set command for switching on the consumer (optional)                                                                                              </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>off</b>            </td><td>Set command for switching off the consumer (optional)                                                                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>swstate</b>        </td><td>Reading which indicates the switching status of the consumer (default: 'state').                                                                  </td></tr>
            <tr><td>                       </td><td><b>on-Regex</b> - regular expression for the state 'on' (default: 'on')                                                                           </td></tr>
            <tr><td>                       </td><td><b>off-Regex</b> - regular expression for the state 'off' (default: 'off')                                                                        </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>asynchron</b>      </td><td>the type of switching status determination in the consumer device. The status of the consumer is only determined after a switching command        </td></tr>.
            <tr><td>                       </td><td>by polling within a data collection interval (synchronous) or additionally by event processing (asynchronous).                                    </td></tr>
            <tr><td>                       </td><td><b>0</b> - only synchronous processing of switching states (default)                                                                              </td></tr>
            <tr><td>                       </td><td><b>1</b> - additional asynchronous processing of switching states through event processing                                                        </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>notbefore</b>      </td><td>Schedule start time consumer not before specified time 'hour[:minute]' (optional)                                                                 </td></tr>
            <tr><td>                       </td><td>The &lt;Expression&gt; has the format hh[:mm] or is Perl code enclosed in {...} that returns hh[:mm].                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>notafter</b>       </td><td>Schedule start time consumer not after specified time 'hour[:minute]' (optional)                                                                  </td></tr>
            <tr><td>                       </td><td>The &lt;Expression&gt; has the format hh[:mm] or is Perl code enclosed in {...} that returns hh[:mm].                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>auto</b>           </td><td>Reading in the consumer device which enables or blocks the switching of the consumer (optional)                                                   </td></tr>
            <tr><td>                       </td><td>If the key switchdev is given, the reading is set and evaluated in this device.                                                                   </td></tr>
            <tr><td>                       </td><td>Reading value = 1 - switching enabled (default), 0: switching blocked                                                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>pcurr</b>          </td><td>Reading:Unit (W/kW) which provides the current energy consumption (optional)                                                                      </td></tr>
            <tr><td>                       </td><td>:&lt;Threshold&gt; (W) - From this power reference on, the consumer is considered active. The specification is optional (default: 0)              </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>etotal</b>         </td><td>Reading:Unit (Wh/kWh) of the consumer device that supplies the sum of the consumed energy (optional)                                              </td></tr>
            <tr><td>                       </td><td>:&lt;Threshold&gt (Wh) - From this energy consumption per hour, the consumption is considered valid. Optional specification (default: 0)          </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>swoncond</b>       </td><td>Condition that must also be fulfilled in order to switch on the consumer (optional). The scheduled cycle is started.                              </td></tr>
            <tr><td>                       </td><td><b>Device:Reading</b> - the device/reading combination returns the check value $VALUE ('undef' is ignored)                                        </td></tr>
            <tr><td>                       </td><td>The check can be formulated as a regular expression or as Perl code enclosed in {..}:                                                             </td></tr>
            <tr><td>                       </td><td><b>Regex</b> - regular expression for checking $VALUE which must return 'true' if successful                                                      </td></tr>
            <tr><td>                       </td><td><b>{Perl-Code}</b> - the Perl code enclosed in {..} must not contain any spaces. The variable $VALUE can be evaluated by the code.                </td></tr>
            <tr><td>                       </td><td>The return value must be 'true' if successful.                                                                                                    </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>swoffcond</b>      </td><td>priority condition to switch off the consumer (optional). The scheduled cycle is stopped.                                                         </td></tr>
            <tr><td>                       </td><td><b>Device:Reading</b> - the device/reading combination returns the check value $VALUE ('undef' is ignored)                                        </td></tr>
            <tr><td>                       </td><td>The check can be formulated as a regular expression or as Perl code enclosed in {..}:                                                             </td></tr>
            <tr><td>                       </td><td><b>Regex</b> - regular expression for checking $VALUE which must return 'true' if successful                                                      </td></tr>
            <tr><td>                       </td><td><b>{Perl-Code}</b> - the Perl code enclosed in {..} must not contain any spaces. The variable $VALUE can be evaluated by the code.                </td></tr>
            <tr><td>                       </td><td>The return value must be 'true' if successful.                                                                                                    </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>surpmeth</b>       </td><td>The possible options define the procedure for determining the PV surplus. (optional)                                                              </td></tr>
            <tr><td>                       </td><td><b>default</b> - the PV surplus is read directly from the 'Current_Surplus' reading. (default)                                                    </td></tr>
            <tr><td>                       </td><td><b>median[_2..20]</b> - The median of the last PV surplus values is used. The optional specification '_XX' uses the last XX measured values.      </td></tr>
            <tr><td>                       </td><td><b>average[_2..20]</b> - is the average of 20 PV surplus values. The optional specification '_XX' uses the last XX measured values.               </td></tr>
            <tr><td>                       </td><td><b>&lt;Device&gt;:&lt;Reading&gt;</b> - Device/Reading combination that provides a numerical PV surplus value in Watt
                                                    determined or calculated by the user.                                                                                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>spignorecond</b>   </td><td>Condition to ignore a missing PV surplus (optional). If the condition is fulfilled, the load is switched on according to                          </td></tr>
            <tr><td>                       </td><td>the planning even if there is no PV surplus at the time.                                                                                          </td></tr>
            <tr><td>                       </td><td><b>CAUTION:</b> Using both keys <I>spignorecond</I> and <I>interruptable</I> can lead to undesired behaviour!                                     </td></tr>
            <tr><td>                       </td><td><b>Device:Reading</b> - the device/reading combination returns the check value $VALUE ('undef' is ignored)                                        </td></tr>
            <tr><td>                       </td><td>The check can be formulated as a regular expression or as Perl code enclosed in {..}:                                                             </td></tr>
            <tr><td>                       </td><td><b>Regex</b> - regular expression for checking $VALUE which must return 'true' if successful                                                      </td></tr>
            <tr><td>                       </td><td><b>{Perl-Code}</b> - the Perl code enclosed in {..} must not contain any spaces. The variable $VALUE can be evaluated by the code.                </td></tr>
            <tr><td>                       </td><td>The return value must be 'true' if successful.                                                                                                    </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>interruptable</b>  </td><td>defines the possible interruption options for the consumer after it has been started (optional). Options can be:                                  </td></tr>
            <tr><td>                       </td><td><b>0</b> - Load is not temporarily switched off even if the PV surplus falls below the required energy (default)                                  </td></tr>
            <tr><td>                       </td><td><b>1</b> - Load is temporarily switched off if the PV surplus falls below the required energy                                                     </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td>                       </td><td><b>Device:Reading:{Perl-Code}</b> - Load is temporarily interrupted if the Perl code returns 'true' <b>or</b> insufficient                        </td></tr>
            <tr><td>                       </td><td>PV surplus (if power is not equal to 0) and is switched on again if the Perl code returns 'false' <b>and</b> PV surplus                           </td></tr>
            <tr><td>                       </td><td>(if power is not equal to 0). The value of Device:Reading is passed to the code with the variable $VALUE.                                         </td></tr>
            <tr><td>                       </td><td>The code must be enclosed in {..} and must <b>not contain any spaces</b>.                                                                         </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td>                       </td><td><b>Device:Reading:Regex[:Hysteresis]</b> - Load is temporarily interrupted when the value of the specified                                        </td></tr>
            <tr><td>                       </td><td>Device:Readings on the Regex matched <b>or</b> there is insufficient PV surplus (if power is not equal to 0).                                     </td></tr>
            <tr><td>                       </td><td>The interrupted load is switched on again when the value is no longer matched <b>and</b> there is sufficient PV surplus                           </td></tr>
            <tr><td>                       </td><td>is present (if power is not equal to 0).                                                                                                          </td></tr>
            <tr><td>                       </td><td>If the optional <b>hysteresis</b> is specified, the hysteresis value is subtracted from the reading value and the regex is then applied.          </td></tr>
            <tr><td>                       </td><td>If this and the original reading value match, the consumer is temporarily interrupted.                                                            </td></tr>
            <tr><td>                       </td><td>The consumer is continued if both the original and the subtracted readings value do not (or no longer) match.                                     </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>locktime</b>       </td><td>Blocking times in seconds for switching the consumer (optional).                                                                                  </td></tr>
            <tr><td>                       </td><td><b>offlt</b> - Blocking time in seconds after the consumer has been switched off or interrupted                                                   </td></tr>
            <tr><td>                       </td><td><b>onlt</b> - Blocking time in seconds after the consumer has been switched on or continued                                                       </td></tr>
            <tr><td>                       </td><td>The consumer is only switched again when the corresponding blocking time has elapsed.                                                             </td></tr>
            <tr><td>                       </td><td><b>Note:</b> The 'locktime' switch is only effective in automatic mode.                                                                           </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>noshow</b>         </td><td>Hide or show consumers or certain elements (optional). The values can be combined (see example).                                                  </td></tr>
            <tr><td>                       </td><td><b>0</b> - the consumer is displayed (default)                                                                                                    </td></tr>
            <tr><td>                       </td><td><b>1</b> - the consumer is hidden                                                                                                                 </td></tr>
            <tr><td>                       </td><td><b>2</b> - the consumer is hidden in the consumer legend                                                                                          </td></tr>
            <tr><td>                       </td><td><b>3</b> - the consumer is hidden in the flow chart                                                                                               </td></tr>
            <tr><td>                       </td><td><b>9</b> - the switching element of the consumer is hidden in the consumer legend                                                                 </td></tr>
            <tr><td>                       </td><td><b>[Device:]Reading</b> - Reading in the consumer or (optionally) an alternative device.                                                          </td></tr>
            <tr><td>                       </td><td>If the reading has the value 0 or is not present, the consumer is displayed.                                                                      </td></tr>
            <tr><td>                       </td><td>The effect of the possible reading values 1, 2 and 3 is as described.                                                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>exconfc</b>        </td><td>Indicator for using the historical energy consumption of the consumer (optional).                                                                 </td></tr>
            <tr><td>                       </td><td><b>0</b> - the stored energy consumption shares are retained as part of the general consumption forecast (default)                                </td></tr>
            <tr><td>                       </td><td><b>1</b> - the general consumption forecast is reduced by the stored energy consumption shares.                                                   </td></tr>
            <tr><td>                       </td><td><b>2</b> - as with '1', but the consumer's planning data is included in the forecast for the coming hours.                                        </td></tr>
            <tr><td>                       </td><td><b>Note:</b> When using exconfc, <b>plantControl->consForecastIdentWeekdays=1</b> and <b>plantControl->consForecastLastDays=4</b>                 </td></tr>
            <tr><td>                       </td><td>should be set.                                                                                                                                    </td></tr>
            <tr><td>                       </td><td>See the explanations in the <a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Wie_wird_die_Verbrauchsprognose_erstellt?' target='_blank'>German Wiki</a>  </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                  </td></tr>
         </table>
         </ul>
       <br>

       <ul>
         <b>Examples: </b> <br>
         <b>attr &lt;name&gt; consumer01</b> wallplug icon=scene_dishwasher@orange type=dishwasher mode=can power=2500 on=on off=off notafter=20 etotal=total:kWh:5 <br>
         <b>attr &lt;name&gt; consumer02</b> WPxw type=heater mode=can power=3000 mintime=180 on="on-for-timer 3600" notafter=12 auto=automatic                     <br>
         <b>attr &lt;name&gt; consumer03</b> Shelly.shellyplug2 type=other power=300 mode=must icon=it_ups_on_battery mintime=120 on=on off=off swstate=state:on:off auto=automatic pcurr=relay_0_power:W etotal:relay_0_energy_Wh:Wh swoncond=EcoFlow:data_data_socSum:-?([1-7][0-9]|[0-9]) swoffcond:EcoFlow:data_data_socSum:{$VALUE==100?1:0}       <br>
         <b>attr &lt;name&gt; consumer04</b> Shelly.shellyplug3 icon=scene_microwave_oven@ed type=heater power=2000 mode=must notbefore=07 mintime=600 on=on off=off etotal=relay_0_energy_Wh:Wh pcurr=relay_0_power:W auto=automatic interruptable=eg.wz.wandthermostat:diff-temp:(22)(\.[2-9])|([2-9][3-9])(\.[0-9]):0.2                              <br>
         <b>attr &lt;name&gt; consumer05</b> Shelly.shellyplug4 icon=sani_buffer_electric_heater_side type=heater mode=must power=1000 notbefore=7 notafter=20:10 auto=automatic pcurr=actpow:W on=on off=off mintime=SunPath interruptable=1                                                                                                           <br>
         <b>attr &lt;name&gt; consumer06</b> Shelly.shellyplug5 icon=sani_buffer_electric_heater_side type=heater mode=must power=1000 notbefore=07:20 notafter={return'20:05'} auto=automatic pcurr=actpow:W on=on off=off mintime=SunPath:60:-120 interruptable=1 spignorecond=SolCast:Current_PV:{($VALUE)=split/\s/,$VALUE;$VALUE>10?1:0;}          <br>
         <b>attr &lt;name&gt; consumer07</b> SolCastDummy icon=sani_buffer_electric_heater_side type=heater mode=can power=600 auto=automatic pcurr=actpow:W on=on off=off mintime=15 asynchron=1 locktime=300:1200 interruptable=1 noshow=39 surpmeth=median_10                                                                                                      <br>
       </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlBatSocManagementXX" data-pattern="ctrlBatSocManagement.*"></a>
       <li><b>ctrlBatSocManagementXX lowSoc=&lt;Value&gt; upSoC=&lt;Value&gt; [maxSoC=&lt;Value&gt;] [stepSoC=&lt;Value&gt;] [careCycle=&lt;Value&gt;] 
                                     [lcSlot=&lt;hh:mm&gt;-&lt;hh:mm&gt;] [loadAbort=&lt;SoC1&gt;:&lt;MinPwr&gt;:&lt;SoC2&gt;] 
                                     [safetyMargin=&lt;Value&gt;[:&lt;Value&gt;]] [loadStrategy=&lt;Value&gt;] [loadTarget=&lt;Wert&gt;] 
                                     [weightOwnUse=&lt;Wert&gt;] </b> <br><br>
                                     
         If a battery device (setupBatteryDevXX) is installed, this attribute activates the battery SoC and charge management 
         for this battery device. <br>
         A set of control readings is generated; the module itself does not interfere with battery control. <br>
         The <b>Battery_OptimumTargetSoC_XX</b> reading contains the optimum minimum SoC calculated by the module. <br>
         The <b>Battery_ChargeRequest_XX</b> reading is set to '1' if the current SoC has fallen below the minimum SoC. <br>
         In this case, the battery should be reloaded, possibly with mains power. <br>
         The reading <b>Battery_ChargeUnrestricted_XX</b> contains the charging release, i.e. whether the battery should be charged at 
         full power without restriction (1), or not at all, or only when the <br>
         feed-in limit (see <a href="#SolarForecast-attr-plantControl">plantControl->feedinPowerLimit</a>) is exceeded (0). 
         If you want to charge the battery continuously throughout the day, Reading 
         <b>Battery_ChargeOptTargetPower_XX</b> provides optimized charging power for battery control. <br>         
         The readings can be used to control the SoC (State of Charge) and to control the charging power used for the
         battery. <br>
         Detailed information on battery SoC and charging management is described in the
         <a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Aktivierung_des_Batterie_SOC-_und_Lade-Managements' target='_blank'>german Wiki</a>. <br><br>

         <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>lowSoc</b>       </td><td>lower minimum SoC - the battery should not be discharged below this value (> 0)                 </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>upSoC</b>        </td><td>upper minimum SoC - the usual value of the optimum SoC tends to be                              </td></tr>
            <tr><td>                     </td><td>between 'lowSoC' and 'upSoC' in periods with a high PV surplus                                  </td></tr>
            <tr><td>                     </td><td>and between 'upSoC' and 'maxSoC' in periods with a low PV surplus                               </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>maxSoC</b>       </td><td>Maximum minimum SoC - value that must be reached at least every 'careCycle' days                </td></tr>
            <tr><td>                     </td><td>in order to balance the charge in the storage network.                                          </td></tr>
            <tr><td>                     </td><td>The specification is optional (&lt;= 100, default: 95)                                          </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>stepSoC</b>      </td><td>Optional step size for optimal SoC calculation (Battery_OptimumTargetSoC_XX) in %.              </td></tr>
            <tr><td>                     </td><td>The specification 'stepSoC=0' deactivates the SoC management and sets                           </td></tr>
			<tr><td>                     </td><td>Battery_OptimumTargetSoC_XX to the value 'lowSoC'.                                              </td></tr> 
            <tr><td>                     </td><td><b>Note:</b> The relationship ‘careCycle * stepSoC = 100’ should be observed!                   </td></tr>
            <tr><td>                     </td><td>Wert: <b>0..5</b>, default: 5                                                                   </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>          
            <tr><td> <b>careCycle</b>    </td><td>Maximum interval in days between two charge states of at least 'maxSoC' that should not be      </td></tr>
            <tr><td>                     </td><td>exceeded if possible. The specification is optional (default: 20)                               </td></tr>
            <tr><td>                     </td><td><b>Note:</b> The relationship ‘careCycle * stepSoC = 100’ should be observed!                   </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>lcSlot</b>       </td><td>A daily time window is defined in which the charging control of the module should be active     </td></tr>
            <tr><td>                     </td><td>for this battery. Outside the time window, the battery charge is released                       </td></tr>
            <tr><td>                     </td><td>at full power. The SoC management of the battery is not affected by this.                       </td></tr>
            <tr><td>                     </td><td>Value: <b>&lt;hh:mm&gt;-&lt;hh:mm&gt;</b>, default: all day                                     </td></tr>           
            <tr><td>                     </td><td>                                                                                                </td></tr>           
            <tr><td> <b>loadAbort</b>    </td><td>Condition for a general charging abort and Unlocking. The abort condition is fulfilled if the   </td></tr>
            <tr><td>                     </td><td>specified SoC1 (%) is reached or exceeded <b>AND</b> the specified charging power               </td></tr>
            <tr><td>                     </td><td>&lt;MinPwr&gt; (W) has been undercut -> Reading <b>Battery_ChargeAbort_XX=1</b>.                </td></tr>
            <tr><td>                     </td><td>If the current SoC falls below the specified SoC2, the <b>Battery_ChargeAbort_XX=0</b> is set.  </td></tr>
            <tr><td>                     </td><td>If SoC2 is not specified, SoC2=SoC1.                                                            </td></tr>            
            <tr><td>                     </td><td>                                                                                                </td></tr>            
            <tr><td> <b>loadStrategy</b> </td><td>Depending on the selected charging strategy, the battery charge forecast and, if applicable,    </td></tr>
            <tr><td>                     </td><td>the generation of control readings are influenced. The specification is optional.               </td></tr>
            <tr><td>                     </td><td>For more information on selecting a strategy, see german <a href="https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Welche_Ladestrategie_soll_ich_w%C3%A4hlen?_-_eine_M%C3%B6glichkeit_zur_Best-Practice_Findung_mit_Codebeispiel">Wiki</a>.  </td></tr>           
            <tr><td>                     </td><td>Value: <b>loadRelease</b> | <b>optPower</b> | <b>smartPower</b>, default: loadRelease           </td></tr>           
            <tr><td>                     </td><td>                                                                                                </td></tr>           
            <tr><td> <b>loadTarget</b>   </td><td>Optional target SoC in % for calculating charge release or optimal charging power.              </td></tr>
            <tr><td>                     </td><td>The target value is a calculated figure. The actual SoC may be higher or lower than this within </td></tr>
            <tr><td>                     </td><td>certain limits, depending on the situation. The higher value from Reading                       </td></tr>
			<tr><td>                     </td><td><b>Battery_OptimumTargetSoC_XX</b> and 'loadTarget' takes precedence for the calculation.       </td></tr>
			<tr><td>                     </td><td>Value: <b>0..100</b>, default: 100                                                              </td></tr>           
            <tr><td>                     </td><td>                                                                                                </td></tr>           
            <tr><td> <b>safetyMargin</b> </td><td>When calculating the load clearance and optimized load capacity, safety margins are taken       </td></tr>
            <tr><td>                     </td><td>into account in the predicted load requirements.                                                </td></tr>
            <tr><td>                     </td><td>Deviating from the default, this parameter can be used to specify individual safety margins     </td></tr>
            <tr><td>                     </td><td>separately for calculating load clearance and optimized load capacity.                          </td></tr>
            <tr><td>                     </td><td>The first value is the surcharge used to calculate the load release, the second value is the    </td></tr>
            <tr><td>                     </td><td>surcharge used to calculate the optimized load capacity. Both values are percentages.           </td></tr>
            <tr><td>                     </td><td>Value: <b>0..100[:0..100]</b> (integers)                                                        </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>weightOwnUse</b> </td><td>Optional weighting of the hourly consumption forecast as an additional usable portion for       </td></tr>
            <tr><td>                     </td><td>battery charging in %. Technically, the available PV surplus is increased to calculate the      </td></tr>
            <tr><td>                     </td><td>optimized charging power by reducing the calculated consumption by the specified percentage.    </td></tr>
            <tr><td>                     </td><td>Value: <b>0..100</b> default: 0                                                                 </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
         </table>
         </ul>
         <br>

         All SoC values are whole numbers in %. The following applies: 'lowSoc' &lt; 'upSoC' &lt; 'maxSoC'. <br><br>

         <b>Example: </b> <br>
         attr &lt;name&gt; ctrlBatSocManagement01 lowSoc=10 upSoC=50 maxSoC=99 careCycle=25 lcSlot=11:00-17:30 loadAbort=99:40:90 safetyMargin=30 weightOwnUse=20 <br>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlConsRecommendReadings"></a>
       <li><b>ctrlConsRecommendReadings </b><br>
         Readings of the form <b>consumerXX_ConsumptionRecommended</b> are created for the selected consumers (number). <br>
         These readings indicate whether it is recommended to switch on this consumer depending on its consumption data and the current
         PV generation or the current energy surplus. The value of the reading created correlates
         with the calculated planning data of the consumer, but may deviate from the planning period. <br>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlDebug"></a>
       <li><b>ctrlDebug</b><br>
         Enables/disables various debug modules. If only "none" is selected, there is no DEBUG output. <br>
         For the output of debug messages the verbose level of the device must be at least "1". <br>
         The debug modules can be combined with each other: <br><br>

         <ul>
         <table>
         <colgroup> <col width="25%"> <col width="75%"> </colgroup>
            <tr><td> <b>aiProcess</b>            </td><td>Data enrichment and training process for AI support                              </td></tr>
            <tr><td> <b>aiData</b>               </td><td>Data use AI in the forecasting process                                           </td></tr>
            <tr><td> <b>apiCall</b>              </td><td>Retrieval API interface without data output                                      </td></tr>
            <tr><td> <b>apiProcess</b>           </td><td>API data retrieval and processing                                                </td></tr>
            <tr><td> <b>batteryManagement</b>    </td><td>Battery management control values (SoC)                                          </td></tr>
            <tr><td> <b>collectData</b>          </td><td>Data collection of energy and power values                                       </td></tr>
            <tr><td> <b>collectData_long</b>     </td><td>like collectData, plus collection of weather and astro data                      </td></tr>
            <tr><td> <b>consumerPlanning</b>     </td><td>Consumer scheduling processes                                                    </td></tr>
            <tr><td> <b>consumerSwitchingXX</b>  </td><td>Operations of the internal consumer switching module of consumer XX              </td></tr>
            <tr><td> <b>consumption</b>          </td><td>Consumption calculation, consumption forecasting and utilization                 </td></tr>
            <tr><td> <b>consumption_long</b>     </td><td>extended output of the consumption forecast Determination                        </td></tr>
            <tr><td> <b>dwdComm</b>              </td><td>Communication with the website or server of the German Weather Service (DWD)     </td></tr>
            <tr><td> <b>epiecesCalc</b>          </td><td>Calculation of specific energy consumption per operating hour and consumer       </td></tr>
            <tr><td> <b>graphic</b>              </td><td>Module graphic information                                                       </td></tr>
            <tr><td> <b>notifyHandling</b>       </td><td>Sequence of event processing in the module                                       </td></tr>
            <tr><td> <b>pvCorrectionRead</b>     </td><td>Application of PV correction factors                                             </td></tr>
            <tr><td> <b>pvCorrectionWrite</b>    </td><td>Calculation of PV correction factors                                             </td></tr>
            <tr><td> <b>radiationProcess</b>     </td><td>Collection and processing of solar radiation data                                </td></tr>
            <tr><td> <b>saveData2Cache</b>       </td><td>Data storage in internal memory structures                                       </td></tr>
         </table>
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlLanguage"></a>
       <li><b>ctrlLanguage &lt;DE | EN&gt; </b><br>
         Defines the used language of the device. The language definition has an effect on the module graphics and various
         reading contents. <br>
         If the attribute is not set, the language is defined by setting the global attribute "language". <br>
         (default: EN)
       </li><br>

       <a id="SolarForecast-attr-ctrlNextDayForecastReadings"></a>
       <li><b>ctrlNextDayForecastReadings &lt;01,02,..,24&gt; </b><br>
         If set, readings of the form <b>Tomorrow_Hour&lt;hour&gt;_PVforecast</b> are created. <br>
         These readings contain the expected PV generation of the coming day. Here &lt;hour&gt; is the
         hour of the day. <br>
       <br>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; ctrlNextDayForecastReadings 09,11 <br>
         # creates readings for hour 09 (08:00-09:00) and 11 (10:00-11:00) of the coming day
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-ctrlNextHoursSoCForecastReadings"></a>
       <li><b>ctrlNextHoursSoCForecastReadings &lt;00,02,..,23&gt; </b><br>
         If set, readings of the form Battery_NextHourXX_SoCforecast_BN are created if a battery is registered
         in the SolarForecast device (see <a href="#SolarForecast-attr-setupBatteryDev">attr &lt;name&gt; setupBatteryDevXX </a>). <br>
         These readings contain the predicted SoC value (%) at the end of the selected hour. <br>
         Where 'XX' is the hour in the future starting from the current hour (00) and 'BN' is the number of the registered battery.
         <br><br>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; ctrlNextHoursSoCForecastReadings 00,03,12,18 <br>
         # creates readings for the current hour (00) and the following hours +03, +12 and +18.
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-ctrlSolCastAPImaxReq"></a>
       <li><b>ctrlSolCastAPImaxReq </b><br>
         (only when using Model SolCastAPI) <br><br>

         The setting of the maximum possible daily requests to the SolCast API. <br>
         This value is specified by SolCast and may change according to the SolCast
         license model. <br>
         (default: 50)
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlSpecialReadings"></a>
       <li><b>ctrlSpecialReadings </b><br>
         Readings are created for the selected key figures and indicators with the
         naming scheme 'special_&lt;indicator&gt;'. The following list shows the selectable key figures and indicators: <br><br>

         <ul>
         <table>
         <colgroup> <col width="27%"> <col width="73%"> </colgroup>
            <tr><td> <b>BatPowerIn_Sum</b>                   </td><td>the sum of the current battery charging power of all defined battery devices                                                </td></tr>
            <tr><td> <b>BatPowerOut_Sum</b>                  </td><td>the sum of the current battery discharge power of all defined battery devices                                               </td></tr>
            <tr><td> <b>BatWeightedTotalSOC</b>              </td><td>the resulting (weighted) SOC across all installed batteries in %                                                            </td></tr>
            <tr><td> <b>allStringsFullfilled</b>             </td><td>Fulfillment status of error-free generation of all strings                                                                  </td></tr>
            <tr><td> <b>conForecastComingNight</b>           </td><td>Consumption forecast from the coming sunset to the coming sunrise. If the sunset has already passed,                        </td></tr>
            <tr><td>                                         </td><td>it is the consumption forecast from the current time (night) until the next sunrise.                                        </td></tr>
            <tr><td> <b>conForecastTillNextSunrise</b>       </td><td>Consumption forecast from current hour to the coming sunrise                                                                </td></tr>
            <tr><td> <b>currentAPIinterval</b>               </td><td>the current polling interval of the selected radiation data API in seconds                                                  </td></tr>
            <tr><td> <b>currentRunMtsConsumer_XX</b>         </td><td>the running time (minutes) of the consumer "XX" since the last switch-on. (last running cycle)                              </td></tr>
            <tr><td> <b>dayAfterTomorrowPVforecast</b>       </td><td>provides the forecast of PV generation for the day after tomorrow (if available) without autocorrection (raw data)          </td></tr>
            <tr><td> <b>daysUntilBatteryCare_XX</b>          </td><td>Days until the next battery XX maintenance (reaching the charge 'maxSoC' from attribute ctrlBatSocManagementXX)             </td></tr>
            <tr><td> <b>dummyConsumption</b>                 </td><td>Provides the current household consumption that cannot be attributed to consumers. Also includes power loss components.     </td></tr>
            <tr><td> <b>lastretrieval_time</b>               </td><td>the last retrieval time of the selected radiation data API                                                                  </td></tr>
            <tr><td> <b>lastretrieval_timestamp</b>          </td><td>the timestamp of the last retrieval time of the selected radiation data API                                                 </td></tr>         
            <tr><td> <b>remainingSurplsHrsMinPwrBat_XX</b>   </td><td>the remaining number of hours on the current day in which the PV surplus (Wh) is higher than the                            </td></tr>
            <tr><td>                                         </td><td>calculated hourly integral of the minimum charging power &lt;MinPwr&gt; of battery XX.                                      </td></tr>
            <tr><td>                                         </td><td>The &lt;MinPwr&gt; is specified in the ctrlBatSocManagementXX->loadAbort attribute.                                         </td></tr>           
            <tr><td> <b>remainingHrsWoChargeRcmdBat_XX</b>   </td><td>the remaining number of hours without charging recommendation for battery XX on the current day                             </td></tr>
            <tr><td> <b>response_message</b>                 </td><td>the last status message of the selected radiation data API                                                                  </td></tr>
            <tr><td> <b>runTimeAvgDayConsumer_XX</b>         </td><td>the average running time (minutes) of consumer "XX" on one day                                                              </td></tr>
            <tr><td> <b>runTimeCentralTask</b>               </td><td>the runtime of the last SolarForecast interval (total process) in seconds                                                   </td></tr>
            <tr><td> <b>runTimeTrainAI</b>                   </td><td>the runtime of the last AI training cycle in seconds                                                                        </td></tr>
            <tr><td> <b>runTimeLastAPIAnswer</b>             </td><td>the last response time of the radiation data API retrieval to a request in seconds                                          </td></tr>
            <tr><td> <b>runTimeLastAPIProc</b>               </td><td>the last process time for processing the received radiation data API data                                                   </td></tr>
            <tr><td> <b>SunMinutes_Remain</b>                </td><td>the remaining minutes until sunset of the current day                                                                       </td></tr>
            <tr><td> <b>SunHours_Remain</b>                  </td><td>the remaining hours until sunset of the current day                                                                         </td></tr>
            <tr><td> <b>todayConsumption</b>                 </td><td>the energy consumption of the house on the current day                                                                      </td></tr>
            <tr><td> <b>todayNotOwnerConsumption</b>         </td><td>the energy consumption on the current day that cannot be allocated to the registered consumers                              </td></tr>
            <tr><td> <b>todayConsumptionForecastDay</b>      </td><td>Consumption forecast for the current day                                                                                    </td></tr>
            <tr><td> <b>todayConsumptionForecast</b>         </td><td>Consumption forecast per hour of the current day (01-24)                                                                    </td></tr>
            <tr><td> <b>todayConForecastTillSunset</b>       </td><td>Consumption forecast from current hour to hour before sunset                                                                </td></tr>
            <tr><td> <b>todayDoneAPIcalls</b>                </td><td>the number of radiation data API calls executed on the current day                                                          </td></tr>
            <tr><td> <b>todayDoneAPIrequests</b>             </td><td>the number of radiation data API requests executed on the current day                                                       </td></tr>
            <tr><td> <b>todayGridConsumption</b>             </td><td>the energy drawn from the public grid on the current day                                                                    </td></tr>
            <tr><td> <b>todayGridFeedIn</b>                  </td><td>PV energy fed into the public grid on the current day                                                                       </td></tr>
            <tr><td> <b>todayMaxAPIcalls</b>                 </td><td>the maximum possible number of radiation data API calls.                                                                    </td></tr>
            <tr><td>                                         </td><td>A call can contain multiple API requests.                                                                                   </td></tr>
            <tr><td> <b>todayRemainingAPIcalls</b>           </td><td>the number of radiation data API calls still possible on the current day                                                    </td></tr>
            <tr><td> <b>todayRemainingAPIrequests</b>        </td><td>the number of radiation data API requests still possible on the current day                                                 </td></tr>
            <tr><td> <b>todayBatIn_XX</b>                    </td><td>the energy charged into the battery XX on the current day                                                                   </td></tr>
            <tr><td> <b>todayBatInSum</b>                    </td><td>Total energy charged in all batteries on the current day                                                                    </td></tr>
            <tr><td> <b>todayBatOut_XX</b>                   </td><td>the energy taken from the battery XX on the current day                                                                     </td></tr>
            <tr><td> <b>todayBatOutSum</b>                   </td><td>Total energy drawn from all batteries on the current day                                                                    </td></tr>
            <tr><td> <b>tomorrowConsumptionForecast</b>      </td><td>Consumption forecast per hour of the coming day (01-24)                                                                     </td></tr>
         </table>
         </ul>
       <br>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlUserExitFn"></a>
       <li><b>ctrlUserExitFn {&lt;Code&gt;} </b><br>
         After each cycle (see the <a href="#SolarForecast-attr-plantControl">plantControl->cycleInterval </a> attribute),
         the code given in this attribute is executed. The code is to be enclosed in curly brackets {...}. <br>
         The code is passed the variables <b>$name</b> and <b>$hash</b>, which contain the name of the SolarForecast
         device and its hash. <br>
         In the SolarForecast Device, readings can be created and modified using the <b>storeReading</b> function.
         <br>
         <br>

         <ul>
         <b>Example: </b> <br>
            {                                                                                           <br>
              my $batdev = (split " ", AttrVal ($name, 'setupBatteryDev01', ''))[0];                    <br>
              my $pvfc   = ReadingsNum ($name, 'RestOfDayPVforecast',            0);                    <br>
              my $cofc   = ReadingsNum ($name, 'RestOfDayConsumptionForecast',   0);                    <br>
              my $diff   = $pvfc - $cofc;                                                               <br>
                                                                                                        <br>
              storeReading ('userFn_Battery_device',  $batdev);                                         <br>
              storeReading ('userFn_estimated_surplus', $diff);                                         <br>
            }
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-flowGraphicControl"></a>
       <li><b>flowGraphicControl &lt;Key=Value&gt; &lt;Key=Value&gt; ... </b><br>
         By optionally specifying the key=value pairs listed below, various display properties of the energy flow
         graph can be influenced. <br>
         The entry can be made in several lines.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="26%"> <col width="74%"> </colgroup>
            <tr><td> <b>animate</b>                 </td><td> Animates the energy flow graphic if displayed. (<a href="#SolarForecast-attr-graphicSelect">graphicSelect</a>)         </td></tr>
            <tr><td>                                </td><td><b>0</b> - Animation off, <b>1</b> - Animation on, default: 1                                                           </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>consumerdist</b>            </td><td>Controls the distance between the consumer icons.                                                                       </td></tr>
            <tr><td>                                </td><td>Value: <b>80 ... 500</b>, default: 130                                                                                  </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>h2consumerdist</b>          </td><td>Extension of the vertical distance between the house and the consumer icons.                                            </td></tr>
            <tr><td>                                </td><td>Value: <b>0 ... 999</b>, default: 0                                                                                     </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>homenodedyncol</b>          </td><td>The house node icon can be colored dynamically depending on the current self-sufficiency.                               </td></tr>
            <tr><td>                                </td><td><b>0</b> - no dynamic coloring,  <b>1</b> - dynamic coloring, default: 0                                                </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>inverterNodeIcon</b>        </td><td>Icon for the inverter node (the icon below the inverter line) and, if applicable, its color when active.                </td></tr>
            <tr><td>                                </td><td>The color can be specified as a hex value (e.g. #cc3300) or designation (e.g. red, blue).                               </td></tr>
            <tr><td>                                </td><td>Syntax: <b>&lt;Icon&gt;[@&lt;Farbe&gt;]</b>                                                                             </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>shiftx</b>                  </td><td>Horizontal shift of the energy flow graph.                                                                              </td></tr>
            <tr><td>                                </td><td>Value: <b>positive or negative Integers</b>, default: 0                                                                 </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>shifty</b>                  </td><td>Vertical shift of the energy flow chart.                                                                                </td></tr>
            <tr><td>                                </td><td>Value: <b>Integer</b>, default: 0                                                                                       </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumer</b>            </td><td>Display of consumers in the energy flow chart.                                                                          </td></tr>
            <tr><td>                                </td><td><b>0</b> - Display off, <b>1</b> - Display on, default: 1                                                               </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumerdummy</b>       </td><td>Controls the display of the dummy consumer. The dummy consumer is assigned the                                          </td></tr>
            <tr><td>                                </td><td>energy consumption that cannot be assigned to other consumers.                                                          </td></tr>
            <tr><td>                                </td><td><b>0</b> - Display off, <b>1</b> - Display on, default: 1                                                               </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumerpower</b>       </td><td>Controls the display of the consumers' energy consumption.                                                              </td></tr>
            <tr><td>                                </td><td><b>0</b> - Display off, <b>1</b> - Display on, default: 1                                                               </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showGenerators</b>          </td><td>SThe display of the generator line (solar cells) above the inverters.                                                   </td></tr>
            <tr><td>                                </td><td><b>0</b> - Display off, <b>1</b> - Display on, default: 0                                                               </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumerremaintime</b>  </td><td>Controls the display of the remaining running time (minutes) of the loads.                                              </td></tr>
            <tr><td>                                </td><td><b>0</b> - Display off, <b>1</b> - Display on, default: 1                                                               </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>size </b>                   </td><td>Size of the energy flow graphic in pixels if displayed. (<a href="#SolarForecast-attr-graphicSelect">graphicSelect</a>) </td></tr>
            <tr><td>                                </td><td>Value: <b>Integer</b>, default: 400                                                                                     </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokeconsumerdyncol</b>    </td><td>The lines from the house node to the consumers can be colored dynamically depending on the consumption value.           </td></tr>
            <tr><td>                                </td><td><b>0</b> - no dynamic coloring,  <b>1</b> - dynamic coloring, default: 0                                                </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokeCmrRedColLimit</b>    </td><td>Power consumption from which the house -> consumer line is displayed in red if strokeconsumerdyncol=1 is set.           </td></tr>
            <tr><td>                                </td><td>Value: <b>Integer</b>, default: 400                                                                                     </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokecolina </b>           </td><td>Color of an inactive line                                                                                               </td></tr>
            <tr><td>                                </td><td>Value: <b>Hex (e.g. #cc3300) or designation (e.g. red, blue)</b>, default: gray                                         </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokecolsig </b>           </td><td>Color of an active signal line                                                                                          </td></tr>
            <tr><td>                                </td><td>Value: <b>Hex (e.g. #cc3300) or designation (e.g. red, blue)</b>, default: red                                          </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokecolstd </b>           </td><td>Color of an active standard line                                                                                        </td></tr>
            <tr><td>                                </td><td>Value: <b>Hex (e.g. #cc3300) or designation (e.g. red, blue)</b>, default: darkorange                                   </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokewidth </b>            </td><td>Width of the lines                                                                                                      </td></tr>
            <tr><td>                                </td><td>Value: <b>Integer</b>, default: 25                                                                                      </td></tr>
        </table>
         </ul>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; flowGraphicControl size=300 animate=0 consumerdist=100 showconsumer=1 showconsumerdummy=0 shiftx=-20 strokewidth=15 strokecolstd=#99cc00
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-graphicBeamXColor" data-pattern="graphicBeam.*Color"></a>
       <li><b>graphicBeamXColor </b><br>
         Color selection for the bar of the selected layer. <br>
         Odd bar numbers indicate the primary bar, even bar numbers indicate the secondary bar. <br>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicBeamXFontColor" data-pattern="graphicBeam.*FontColor"></a>
       <li><b>graphicBeamXFontColor </b><br>
         Selection of the font color of the bar of the selected layer. <br>
         Odd bar numbers indicate the primary bar, even bar numbers indicate the secondary bar. <br>
         (default: 000000)
       </li>
       <br>

       <a id="SolarForecast-attr-graphicBeamXContent" data-pattern="graphicBeam.*Content"></a>
       <li><b>graphicBeamXContent </b><br>
         Defines the content of the bars to be displayed in the bar charts.
         The bar charts are available in several levels. <br>
         Level 1 is preset by default.
         The content is determined by the attributes graphicBeam1Content and graphicBeam2Content. <br>
         Level 2 can be activated by setting the attributes graphicBeam3Content and graphicBeam4Content. <br>
         Level 3 can be activated by setting the attributes graphicBeam5Content and graphicBeam6Content. <br>
         The attributes with odd numbers (1,3,5) represent the primary bars, the attributes with even numbers the secondary bars
         of the respective level.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>batsocCombi_XX</b>      </td><td>the predicted (from the next hour) and actual SOC (%) of the battery XX up to the current time         </td></tr>
            <tr><td> <b>batsocForecast_XX</b>   </td><td>the predicted SOC (%) of the battery XX                                                                </td></tr>
            <tr><td> <b>batsocReal_XX</b>       </td><td>the real SOC (%) achieved by the battery XX                                                            </td></tr>
            <tr><td> <b>batsocForecastSum</b>   </td><td>the predicted SOC (%) as the resultant across all batteries                                            </td></tr>
            <tr><td> <b>batsocRealSum</b>       </td><td>the real SOC achieved (%) as the resultant across all batteries                                        </td></tr>
            <tr><td> <b>consumption</b>         </td><td>Energy consumption                                                                                     </td></tr>
            <tr><td> <b>consumptionForecast</b> </td><td>forecasted energy consumption                                                                          </td></tr>
            <tr><td> <b>energycosts</b>         </td><td>Cost of energy purchased from the grid. The currency is defined in the setupMeterDev, key conprice.    </td></tr>
            <tr><td> <b>feedincome</b>          </td><td>Remuneration for feeding into the grid. The currency is defined in the setupMeterDev, key feedprice.   </td></tr>
            <tr><td> <b>gridconsumption</b>     </td><td>Energy purchase from the public grid                                                                   </td></tr>
            <tr><td> <b>gridfeedin</b>          </td><td>Feed into the public grid                                                                              </td></tr>
            <tr><td> <b>pvForecast</b>          </td><td>predicted PV generation (default for graphicBeam2Content)                                              </td></tr>
            <tr><td> <b>pvReal</b>              </td><td>real PV generation (default for graphicBeam1Content)                                                   </td></tr>
         </table>
         </ul>
         <br>

         <b>Hinweis:</b> The selection of the parameters energycosts and feedincome only makes sense if the optional keys
                         conprice and feedprice are set in setupMeterDev.
       </li>
       <br>

       <a id="SolarForecast-attr-graphicControl"></a>
       <li><b>graphicControl &lt;Schlüssel=Wert&gt; &lt;Schlüssel=Wert&gt; ... </b><br>
         By specifying the 'Key=Value' pairs listed below, various overarching properties of the graphic or bar graph display
         can be set. <br>
         The entry can be made in several lines.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>beamHeightlevel</b>     </td><td>The bar height for each level of the bar chart can be specified.                                                                          </td></tr>
            <tr><td>                            </td><td>The specification for a layer consists of the layer number (1..X), a ':' followed by a positive integer > 0.                              </td></tr>
            <tr><td>                            </td><td>The numerical value is used as a normalization factor in the height calculation.                                                          </td></tr>
            <tr><td>                            </td><td>Further levels are specified separated by commas (see example).                                                                           </td></tr>
            <tr><td>                            </td><td><b>&lt;Level&gt;:&lt;Integer&gt;</b> - normalization factor (default: 200)                                                                </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>beamPaddingBottom</b>   </td><td>Defines the space in px in the bar chart that is inserted between the last text or icon row of the respective bar chart layer             </td></tr>
            <tr><td>                            </td><td>and the bottom edge of this layer.                                                                                                        </td></tr>
            <tr><td>                            </td><td>The value applies uniformly to all bar chart levels.                                                                                      </td></tr>
            <tr><td>                            </td><td>Value: <b>Integer</b>, default: 0                                                                                                         </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>beamPaddingTop</b>      </td><td>Defines the space in px in the bar chart that is inserted between the upper edge of the respective bar chart layer and the first          </td></tr>
            <tr><td>                            </td><td>text or icon row of this layer.                                                                                                           </td></tr>
            <tr><td>                            </td><td>The value applies uniformly to all bar chart levels.                                                                                      </td></tr>
            <tr><td>                            </td><td>Value: <b>Integer</b>, default: 0                                                                                                         </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>beamWidth</b>           </td><td>Determines the width of the bars of the bar chart in px.                                                                                  </td></tr>
            <tr><td>                            </td><td>If no attribute is set, the bar width is automatically adjusted dynamically by the module.                                                </td></tr>
            <tr><td>                            </td><td>Value: <b>Integer 20..100</b>, default: 20                                                                                                </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>energyUnit</b>          </td><td>Defines the unit for displaying the electrical power in the graph.                                                                        </td></tr>
            <tr><td>                            </td><td>The kilowatt hour is rounded to one decimal place.                                                                                        </td></tr>
            <tr><td>                            </td><td>Value: <b>Wh | kWh</b>, default: Wh                                                                                                       </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>hourCount</b>           </td><td>Number of bars/hours in the bar chart.                                                                                                    </td></tr>
            <tr><td>                            </td><td>Value: <b>Integer 4..24</b>, default: 24                                                                                                  </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>headerDetail</b>        </td><td>Selection of the zones to be displayed in the graphic header area. The selected options are separated by commas.                          </td></tr>
            <tr><td>                            </td><td><b>all</b>    - all zones of the header area (default)                                                                                    </td></tr>
            <tr><td>                            </td><td><b>co</b>     - Consumption range                                                                                                         </td></tr>
            <tr><td>                            </td><td><b>pv</b>     - Production area                                                                                                           </td></tr>
            <tr><td>                            </td><td><b>own</b>    - User zone (see <a href="#SolarForecast-attr-graphicHeaderOwnspec">graphicHeaderOwnspec</a>)                               </td></tr>
            <tr><td>                            </td><td><b>status</b> - Status information area                                                                                                   </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>hourStyle</b>           </td><td>Format of the time in the bar chart.                                                                                                      </td></tr>
            <tr><td>                            </td><td><b>not set</b> - only hours without minutes (default)                                                                                     </td></tr>
            <tr><td>                            </td><td><b>:00</b>     - Hours and minutes in two digits, e.g. 10:00                                                                              </td></tr>
            <tr><td>                            </td><td><b>:0</b>      - Hours and minutes in single digits, e.g. 8:0                                                                             </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>layoutType</b>          </td><td>Layout der Balkengrafik. Der darzustellende Inhalt der Balken wird durch die Attribute <b>graphicBeamXContent</b> bestimmt.               </td></tr>
            <tr><td>                            </td><td><b>double</b> - shows the primary bar and the secondary bar (default)                                                                     </td></tr>
            <tr><td>                            </td><td><b>single</b> - only shows the primary bar                                                                                                </td></tr>
            <tr><td>                            </td><td><b>diff</b>   - Difference display. The following applies: &lt;Difference&gt; = &lt;Value primary bar&gt; - &lt;Value secondary bar&gt;   </td></tr>
            <tr><td>                            </td><td>The setting of <a href="#SolarForecast-attr-graphicControl">graphicControl->energyUnit</a> is not taken into account.                     </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>scaleMode</b>           </td><td>The scaling mode can be set to linear or logarithmic for each level of the bar chart.                                                     </td></tr>
            <tr><td>                            </td><td>The logarithmic setting emphasizes small values and compresses larger values in the display.                                              </td></tr>
            <tr><td>                            </td><td>The specification for a level consists of the level number (1..X), a ':' followed by the mode 'lin' or 'log'.                             </td></tr>
            <tr><td>                            </td><td>The strings for each level are separated by commas (see example).                                                                         </td></tr>
            <tr><td>                            </td><td><b>&lt;Level&gt;:lin</b> - linear scaling (default)                                                                                       </td></tr>
            <tr><td>                            </td><td><b>&lt;Level&gt;:log</b> - logarithmic scaling                                                                                            </td></tr>
            <tr><td>                            </td><td><b>&lt;Ebene&gt;:staple</b> - The bars are 'stacked', with the secondary bar displayed above the primary bar.                             </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>showDiff</b>            </td><td>Additional numerical display of the difference '&lt;primary bar content&gt; - &lt;secondary bar content&gt;'.                             </td></tr>
            <tr><td>                            </td><td>The specification for each level consists of the level number (1..X), a ':' followed by the position 'top' or 'bottom'.                   </td></tr>
            <tr><td>                            </td><td>The strings for each level are separated by commas (see example).                                                                         </td></tr>
            <tr><td>                            </td><td><b>&lt;Level&gt;:top</b>    - display above the bars                                                                                      </td></tr>
            <tr><td>                            </td><td><b>&lt;Level&gt;:bottom</b> - display below the bars                                                                                      </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
            <tr><td> <b>spaceSize</b>           </td><td>Defines how much space in px is kept free above or below the bar (for display type layoutType=diff) to display the                        </td></tr>
            <tr><td>                            </td><td>values. For styles with large fonts, the default value may be too small or a bar may slide over the baseline.                             </td></tr>
            <tr><td>                            </td><td>In these cases, please increase the value.                                                                                                </td></tr>
            <tr><td>                            </td><td>Value: <b>Integer</b>, default: 24                                                                                                        </td></tr>
            <tr><td>                            </td><td>                                                                                                                                          </td></tr>
          </table>
         </ul>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; graphicControl beamWidth=45 headerDetail=co,pv energyUnit=kWh hourCount=10 layoutType=diff hourStyle=:00 scaleMode=1:log,2:lin,3:log showDiff=1:top,2:bottom
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-graphicHeaderOwnspec"></a>
       <li><b>graphicHeaderOwnspec &lt;Label&gt;:&lt;Reading&gt;[@Device] &lt;Label&gt;:&lt;Set&gt;[@Device] &lt;Label&gt;:&lt;Attr&gt;[@Device] ... </b> <br><br>

         Display of any readings, set commands and attributes of the device in the graphic header. <br>
         Four values (fields) are displayed per line. <br>
         Values with the units "Wh" or "kWh" are converted according to the setting of the attribute 
         <a href="#SolarForecast-attr-graphicControl">graphicControl->energyUnit</a>.
         <br><br>

         Each value must be defined by a label and the element to be displayed (attribute, reading, set command) connected by “:”. <br>
         A single key value of a combined attribute (ctrlBatSocManagementXX, flowGraphicControl, etc.) can be displayed and changed by 
         adding '->&lt;key&gt;'. <br>
         The element can optionally be supplemented with '@&lt;Device&gt;' to display readings, set commands, and attributes of other devices. <br>
         The elements to be displayed are separated by spaces or a new line.
         Spaces in the label are to be inserted by "&amp;nbsp;", a line break by "&lt;br&gt;". <br>
         An empty field in a line is created by ":". <br>
         A line title can be inserted by specifying "#:&lt;Text&gt;", an empty title by entering "#".
         <br><br>

       <ul>
         <b>Example: </b> <br>
         <table>
         <colgroup> <col width="33%"> <col width="67%"> </colgroup>
            <tr><td> attr &lt;name&gt; graphicHeaderOwnspec  </td><td>#                                                                                       </td></tr>
            <tr><td>                                         </td><td>AutarkyRate:Current_AutarkyRate                                                         </td></tr>
            <tr><td>                                         </td><td>Surplus:Current_Surplus                                                                 </td></tr>
            <tr><td>                                         </td><td>current&amp;nbsp;Gridconsumption:Current_GridConsumption                                </td></tr>
            <tr><td>                                         </td><td>:                                                                                       </td></tr>
            <tr><td>                                         </td><td>#                                                                                       </td></tr>
            <tr><td>                                         </td><td>CO&amp;nbsp;until&amp;nbsp;sunset:special_todayConForecastTillSunset                    </td></tr>
            <tr><td>                                         </td><td>PV&amp;nbsp;Day&amp;nbsp;after&amp;nbsp;tomorrow:special_dayAfterTomorrowPVforecast     </td></tr>
            <tr><td>                                         </td><td>:                                                                                       </td></tr>
            <tr><td>                                         </td><td>:                                                                                       </td></tr>
            <tr><td>                                         </td><td>#Battery                                                                                </td></tr>
            <tr><td>                                         </td><td>in&amp;nbsp;today:special_todayBatIn                                                    </td></tr>
            <tr><td>                                         </td><td>out&amp;nbsp;today:special_todayBatOut                                                  </td></tr>
            <tr><td>                                         </td><td>Charging&amp;nbsp;target:ctrlBatSocManagement01->loadTarget                                                                                       </td></tr>
            <tr><td>                                         </td><td>:                                                                                       </td></tr>
            <tr><td>                                         </td><td>#Settings                                                                               </td></tr>
            <tr><td>                                         </td><td>Autocorrection:pvCorrectionFactor_Auto : : :                                            </td></tr>
            <tr><td>                                         </td><td>Consumer&lt;br&gt;Replanning:consumerNewPlanning : : :                                  </td></tr>
            <tr><td>                                         </td><td>Consumer&lt;br&gt;Quickstart:consumerImmediatePlanning : : :                            </td></tr>
            <tr><td>                                         </td><td>Weather:graphicShowWeather : : :                                                        </td></tr>
            <tr><td>                                         </td><td>History:graphicHistoryHour : : :                                                        </td></tr>
            <tr><td>                                         </td><td>ShowNight:graphicShowNight : : :                                                        </td></tr>
            <tr><td>                                         </td><td>Debug:ctrlDebug : : :                                                                   </td></tr>
         </table>
       </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicHeaderOwnspecValForm"></a>
       <li><b>graphicHeaderOwnspecValForm </b> <br><br>

         The readings to be displayed with the attribute
         <a href="#SolarForecast-attr-graphicHeaderOwnspec">graphicHeaderOwnspec</a> can be manipulated with sprintf and
         other Perl operations.  <br>
         There are two basic notation options that cannot be combined with each other. <br>
         The notations are always specified within two curly brackets {...}.
         <br><br>
         <b>Note:</b> Values with the units 'Wh' or 'kWh' are automatically converted and displayed according to the setting
         automatically converted and displayed according to the setting of attribute
         <a href="#SolarForecast-attr-graphicControl">graphicControl->energyUnit</a>.
         <br><br>

         <b>Notation 1: </b> <br>
         A simple formatting of readings of your own device with sprintf is carried out as shown in line
         'Current_AutarkyRate' or 'Current_GridConsumption'. <br>
         Other Perl operations are to be bracketed with (). The respective readings values and units are available via
         the variables $VALUE and $UNIT. <br>
         Readings of other devices are specified by '&lt;Device&gt;.&lt;Reading&gt;'.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td>{                                        </td><td>                                               </td></tr>
            <tr><td> 'Current_AutarkyRate'                   </td><td> => "%.1f %%",                                 </td></tr>
            <tr><td> 'Current_GridConsumption'               </td><td> => "%.2f $UNIT",                              </td></tr>
            <tr><td> 'SMA_Energymeter.Cover_RealPower'       </td><td> => q/($VALUE)." W"/,                          </td></tr>
            <tr><td> 'SMA_Energymeter.L2_Cover_RealPower'    </td><td> => "($VALUE).' W'",                           </td></tr>
            <tr><td> 'SMA_Energymeter.L1_Cover_RealPower'    </td><td> => '(sprintf "%.2f", ($VALUE / 1000))." kW"', </td></tr>
            <tr><td>}                                        </td><td>                                               </td></tr>
         </table>
         </ul>
         <br>

         <b>Notation 2: </b> <br>
         The manipulation of reading values and units is done via Perl If ... else structures. <br>
         The device, reading, reading value and unit are available to the structure with the variables $DEVICE, $READING,
         $VALUE and $UNIT. <br>
         If the variables are changed, the new values are transferred to the display accordingly.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="5%"> <col width="95%"> </colgroup>
            <tr><td>{ </td><td>                                                   </td></tr>
            <tr><td>  </td><td> if ($READING eq 'Current_AutarkyRate') {          </td></tr>
            <tr><td>  </td><td> &nbsp;&nbsp; $VALUE = sprintf "%.1f", $VALUE;     </td></tr>
            <tr><td>  </td><td> &nbsp;&nbsp; $UNIT  = "%";                        </td></tr>
            <tr><td>  </td><td> }                                                 </td></tr>
            <tr><td>  </td><td> elsif ($READING eq 'Current_GridConsumption') {   </td></tr>
            <tr><td>  </td><td> &nbsp;&nbsp; ...                                  </td></tr>
            <tr><td>  </td><td> }                                                 </td></tr>
            <tr><td>} </td><td>                                                   </td></tr>
         </table>
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicHistoryHour"></a>
       <li><b>graphicHistoryHour </b><br>
         Number of previous hours displayed in the bar graph. <br>
         (default: 2)
       </li>
       <br>

       <a id="SolarForecast-attr-graphicSelect"></a>
       <li><b>graphicSelect </b><br>
         Selects the graphic segments of the module to be displayed.
         <br><br>

         <ul>
           <table>
           <colgroup> <col width="30%"> <col width="70%"> </colgroup>
           <tr><td> <b>both</b>                    </td><td>displays graphic header, load panel, bar graph and energy flow graph (default)        </td></tr>
           <tr><td> <b>both_noHead</b>             </td><td>displays load panel, bar graph and energy flow graph                                  </td></tr>
           <tr><td> <b>both_noCons</b>             </td><td>displays graph header, bar graph and energy flow graph                                </td></tr>
           <tr><td> <b>both_noHead_noCons</b>      </td><td>displays bar graph and energy flow graph                                              </td></tr>
           <tr><td> <b>swap</b>                    </td><td>like 'both', with swapped bar and energy flow graph sequence                          </td></tr>
           <tr><td> <b>swap_noHead</b>             </td><td>like 'both_noHead', with swapped bar and energy flow graph sequence                   </td></tr>
           <tr><td> <b>swap_noCons</b>             </td><td>like 'both_noCons', with swapped bar and energy flow graph sequence                   </td></tr>
           <tr><td> <b>swap_noHead_noCons</b>      </td><td>like 'both_noHead_noCons', with swapped bar and energy flow graph sequence            </td></tr>
           <tr><td> <b>flow</b>                    </td><td>displays graphic header, load panel and energy flow graphic                           </td></tr>
           <tr><td> <b>flow_noHead</b>             </td><td>displays load panel and energy flow graph                                             </td></tr>
           <tr><td> <b>flow_noCons</b>             </td><td>displays graphic header and energy flow graphic                                       </td></tr>
           <tr><td> <b>flow_noHead_noCons</b>      </td><td>displays energy flow graph                                                            </td></tr>
           <tr><td> <b>forecast</b>                </td><td>displays graphic header, consumer panel and bar graph                                 </td></tr>
           <tr><td> <b>forecast_noHead</b>         </td><td>displays consumer panel and bar graph                                                 </td></tr>
           <tr><td> <b>forecast_noCons</b>         </td><td>displays graphic header and bar chart                                                 </td></tr>
           <tr><td> <b>forecast_noHead_noCons</b>  </td><td>displays bar graph                                                                    </td></tr>
           <tr><td> <b>none</b>                    </td><td>only displays graphic header and consumer panel                                       </td></tr>
           </table>
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicShowNight"></a>
       <li><b>graphicShowNight </b><br>
         Display or hide the night hours in the bar chart.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="5%"> <col width="95%"> </colgroup>
            <tr><td> <b>0</b>   </td><td>no display of night hours if no value is to be displayed (default)            </td></tr>
            <tr><td>            </td><td>If the selected content contains a value, these bars are still displayed.     </td></tr>
            <tr><td> <b>01</b>  </td><td>Like '0', but time synchronisation takes place between the level 1            </td></tr>
            <tr><td>            </td><td>and the subsequent bar chart level.                                           </td></tr>
            <tr><td> <b>1</b>   </td><td>the night hours are always displayed                                          </td></tr>
         </table>
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicShowWeather"></a>
       <li><b>graphicShowWeather </b><br>
         Show/hide weather icons in the bar graph. <br>
         (default: 1)
       </li>
       <br>

       <a id="SolarForecast-attr-graphicWeatherColor"></a>
       <li><b>graphicWeatherColor </b><br>
         Color of the weather icons in the bar graph for the daytime hours.
       </li>
       <br>

       <a id="SolarForecast-attr-graphicWeatherColorNight"></a>
       <li><b>graphicWeatherColorNight </b><br>
         Color of the weather icons for the night hours.
       </li>
       <br>

       <a id="SolarForecast-attr-plantControl"></a>
       <li><b>plantControl &lt;Key=Value&gt; &lt;Key=Value&gt; ... </b><br>
         By optionally specifying the 'Key=Value' pairs listed below, various properties of the overall
         properties of the overall system can be set.
         The entry can be made in several lines.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="23%"> <col width="77%"> </colgroup>
            <tr><td> <b>backupFilesKeep</b>           </td><td>Defines the number of generations of backup files.                                                                                                              </td></tr>
            <tr><td>                                  </td><td>(see <a href="#SolarForecast-set-operatingMemory">set &lt;name&gt; operatingMemory backup</a>)                                                                  </td></tr>
            <tr><td>                                  </td><td>If backupFilesKeep explit is set to '0', no automatic generation and cleanup of backup files takes place.                                                       </td></tr>
            <tr><td>                                  </td><td>Manual execution with the aforementioned set command is still possible.                                                                                         </td></tr>
            <tr><td>                                  </td><td>Value: <b>Integer</b>, default: 3                                                                                                                               </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>batteryPreferredCharge</b>    </td><td>Consumers with the <b>can</b> mode are only switched on when the specified battery charge (%) is reached.                                                       </td></tr>
            <tr><td>                                  </td><td>Consumers with the <b>must</b> mode do not observe the priority charging of the battery.                                                                        </td></tr>
            <tr><td>                                  </td><td>Value: <b>Integer 0..100</b>, default: 0                                                                                                                        </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>consForecastIdentWeekdays</b> </td><td>If set, only the same weekdays (Mon..Sun) are included in the calculation of the consumption forecast.                                                          </td></tr>
            <tr><td>                                  </td><td>Otherwise, all weekdays are used equally for the calculation.                                                                                                   </td></tr>
            <tr><td>                                  </td><td>Value: <b>0|1</b>, default: 0                                                                                                                                   </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>consForecastInPlanning</b>    </td><td>The key determines the procedure for scheduling registered consumers.                                                                                           </td></tr>
            <tr><td>                                  </td><td><b>0</b> - the consumers are scheduled on the basis of the PV forecast (default)                                                                                </td></tr>
            <tr><td>                                  </td><td><b>1</b> - consumers are scheduled on the basis of the PV forecast and the consumption forecast                                                                 </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>consForecastLastDays</b>      </td><td>The specified number of historical days is included in the calculation of the consumption forecast.                                                             </td></tr>
            <tr><td>                                  </td><td>For example, with the attribute value “1” only the previous day is taken into account, with the value “14” the previous 14 days.                                </td></tr>
            <tr><td>                                  </td><td>The days taken into account may be fewer if there are not enough values in the internal memory.                                                                 </td></tr>
            <tr><td>                                  </td><td>If the key 'consForecastIdentWeekdays' is also set, the specified number of past weekdays                                                                       </td></tr>
            <tr><td>                                  </td><td>of the <b>same</b> day (Mon .. Sun) is taken into account.                                                                                                      </td></tr>
            <tr><td>                                  </td><td>For example, if the value is set to '8', the same weekdays of the past 8 weeks are taken into account.                                                          </td></tr>
            <tr><td>                                  </td><td>Value: <b>Integer 0..180</b>, default: 60                                                                                                                       </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>cycleInterval</b>             </td><td>Repetition interval of the data collection in seconds.                                                                                                          </td></tr>
            <tr><td>                                  </td><td>If cycleInterval is explicitly set to '0', there is no regular data collection and must be started externally                                                   </td></tr>
            <tr><td>                                  </td><td>with 'get &lt;name&gt; data'.                                                                                                                                   </td></tr>
            <tr><td>                                  </td><td>Value: <b>Integer</b>, default: 70                                                                                                                              </td></tr>
            <tr><td>                                  </td><td><b>Note:</b> Regardless of the interval set (even with '0'), data is collected automatically a few seconds before the end                                       </td></tr>
            <tr><td>                                  </td><td>and after the start of a full hour. Data is also collected automatically when an event from a device defined                                                    </td></tr>
            <tr><td>                                  </td><td>as “asynchronous” (consumer, meter, etc.) is received and processed.                                                                                            </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>feedinPowerLimit</b>          </td><td>Feed-in limit of the entire system into the public grid in watts.                                                                                               </td></tr>
            <tr><td>                                  </td><td>SolarForecast does not limit the feed-in, but uses this information                                                                                             </td></tr>
            <tr><td>                                  </td><td>within the battery charge management to avoid system curtailment.                                                                                               </td></tr>
            <tr><td>                                  </td><td>Value: <b>Integer</b>, default: unlimited                                                                                                                       </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>genPVdeviation</b>            </td><td>Defines the method for calculating the deviation between forecast and actual PV generation.                                                                     </td></tr>
            <tr><td>                                  </td><td>The reading <b>Today_PVdeviation</b> is created depending on this setting.                                                                                      </td></tr>
            <tr><td>                                  </td><td>The optional addition ':reverse' specifies that PV generation > forecast is evaluated as a positive value instead of a negative value (change of perspective).  </td></tr>
            <tr><td>                                  </td><td><b>daily[:reverse]</b>        - Calculation and creation of Today_PVdeviation takes place after sunset (default)                                                </td></tr>
            <tr><td>                                  </td><td><b>continuously[:reverse]</b> - Calculation and creation of Today_PVdeviation is continuous                                                                     </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>genPVforecastsToEvent</b>     </td><td>The module generates daily 'AllPVforecastsToEvent' events to visualize the PV forecast.                                                                         </td></tr>
            <tr><td>                                  </td><td>Further explanations can be found in the <a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Visualisierung_solare_Vorhersage_und_reale_Erzeugung' target='_blank'>german Wiki</a>. </td></tr>
            <tr><td>                                  </td><td><b>Note:</b> When using the attribute, the attribute <b>event-on-update-reading=AllPVforecastsToEvent</b> must also be set.                                     </td></tr>
            <tr><td>                                  </td><td>Event generation can be optimized for specific uses:                                                                                                            </td></tr>
            <tr><td>                                  </td><td><b>adapt4Steps</b> - the events are optimized for the SVG plot type 'steps'                                                                                     </td></tr>
            <tr><td>                                  </td><td><b>adapt4fSteps</b> - the events are optimized for the SVG plot type 'fsteps'                                                                                   </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>reductionState</b>            </td><td>Delivers a status to SolarForecast when the PV system is or has been curtailed (optional).                                                                      </td></tr>
            <tr><td>                                  </td><td><b>Device</b> - Device which provides the reduction status                                                                                                      </td></tr>
            <tr><td>                                  </td><td><b>Reading</b> - Reading that provides the reduction status                                                                                                     </td></tr>
            <tr><td>                                  </td><td>The check of the supplied value can be formulated as a regular expression or as Perl code enclosed in {..}:                                                     </td></tr>
            <tr><td>                                  </td><td><b>Regex</b> - Regular expression that must be fulfilled for a reduction status (true)                                                                          </td></tr>
            <tr><td>                                  </td><td><b>{Perl-Code}</b> - the Perl code enclosed in {..} must return 'true' for a reduction status. It must not contain spaces.                                      </td></tr>
            <tr><td>                                  </td><td>The value of Device:Reading is transferred to the code with the variable $VALUE.                                                                                </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
            <tr><td> <b>showLink</b>                  </td><td>Display of a link to the detailed view of the device above the graphics area                                                                                    </td></tr>
            <tr><td>                                  </td><td><b>0</b> - Display off, <b>1</b> - Display on, default: 0                                                                                                       </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                                </td></tr>
         </table>
         </ul>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; plantControl feedinPowerLimit=4800 consForecastInPlanning=1 showLink=1 backupFilesKeep=2 consForecastIdentWeekdays=1 consForecastLastDays=8 genPVdeviation=continuously genPVforecastsToEvent=adapt4Steps
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-setupBatteryDev" data-pattern="setupBatteryDev.*"></a>
       <li><b>setupBatteryDevXX &lt;Battery Device Name&gt; pin=&lt;Readingname&gt;:&lt;Unit&gt; pout=&lt;Readingname&gt;:&lt;Unit&gt; cap=&lt;Option&gt;                         <br>
                                [pinmax=&lt;Integer&gt] [pinreduced=&lt;Integer&gt] [poutmax=&lt;Integer&gt] [intotal=&lt;Readingname&gt;:&lt;Unit&gt;] [efficiency=&lt;Value&gt] <br>
                                [outtotal=&lt;Readingname&gt;:&lt;Unit&gt;] [charge=&lt;Readingname&gt;] [asynchron=&lt;Option&gt] [show=&lt;Option&gt]                           <br>
                                [label=&lt;Option&gt] [[icon=&lt;recomm&gt;@&lt;Color&gt;]:[&lt;charge&gt;@&lt;Color&gt;]:[&lt;discharge&gt;@&lt;Color&gt;]:[&lt;omit&gt;@&lt;Color&gt;]]  </b> <br><br>

       Specifies an arbitrary Device and its Readings to deliver the battery performance data. <br>
       The module assumes that the numerical value of the readings is always positive.
       It can also be a dummy device with corresponding readings.
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>pin</b>       </td><td>Reading which provides the current battery charging power                                                     </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>pout</b>      </td><td>Reading which provides the current battery discharge rate                                                     </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>pinmax</b>    </td><td>the maximum possible charging power in watts (optional)                                                       </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>pinreduced</b></td><td>The reduced charging power in watts (optional). The value is set in Reading Battery_ChargeOptTargetPower_XX   </td></tr>
           <tr><td>                  </td><td>if the calculated charging power falls below this value or the SoC <= lowSoC.                                 </td></tr>
           <tr><td>                  </td><td>This means that the value can also be applied in the case of demand charging from the public grid.            </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>poutmax</b>   </td><td>the maximum possible discharge power in watts (optional)                                                      </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>intotal</b>   </td><td>Reading which provides the total battery charge as a continuous counter (optional)                            </td></tr>
           <tr><td>                  </td><td>If the reading violates the specification of a continuously rising counter, SolarForecast handles             </td></tr>
           <tr><td>                  </td><td>this error and reports the situation that has occurred with a log entry with verbose 3.                       </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>outtotal</b>  </td><td>Reading which provides the total battery discharge as a continuous counter (optional)                         </td></tr>
           <tr><td>                  </td><td>If the reading violates the specification of a continuously rising counter, SolarForecast handles             </td></tr>
           <tr><td>                  </td><td>this error and reports the situation that has occurred with a log entry with verbose 3.                       </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>cap</b>       </td><td>installed battery capacity. Option can be:                                                                    </td></tr>
           <tr><td>                  </td><td><b>Integer</b> - direct specification of the battery capacity in Wh without specifying the unit!              </td></tr>
           <tr><td>                  </td><td><b>&lt;Readingname&gt;:&lt;unit&gt;</b> - Reading which provides the capacity and unit (Wh, kWh)              </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>charge</b>    </td><td>Reading which provides the current state of charge (SOC in percent) (optional)                                </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>Unit</b>      </td><td>the respective unit (W,Wh,kW,kWh)                                                                             </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td><b>efficiency</b> </td><td>Optional specification of the energy storage efficiency in %. This efficiency describes not                   </td></tr>
           <tr><td>                  </td><td>only the battery itself, but also the chain of effects, including the inverters involved.                     </td></tr>
           <tr><td>                  </td><td>Depending on the type of coupling and other factors, the typical efficiency is between 75 and 90%.            </td></tr>
           <tr><td>                  </td><td>Value: <b>0..100</b> default: 87                                                                              </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>icon</b>      </td><td>Icon and/or (only) color of the battery in the bar graph according to the status (optional).                  </td></tr>
           <tr><td>                  </td><td>The identifier (e.g. blue), HEX value (e.g. #d9d9d9) or 'dyn' can be specified as the color.                  </td></tr>
           <tr><td>                  </td><td>If 'dyn' is used, the icon is colored depending on the SoC value.                                             </td></tr>
           <tr><td>                  </td><td><b>&lt;recomm&gt;</b> - Icon if charging is recommended but inactive (no charging / discharging)              </td></tr>
           <tr><td>                  </td><td><b>&lt;charge&gt;</b> - Icon is used when the battery is currently being charged                              </td></tr>
           <tr><td>                  </td><td><b>&lt;discharge&gt;</b> - Icon is used when the battery is currently being discharged                        </td></tr>
           <tr><td>                  </td><td><b>&lt;omit&gt;</b> - Icon if charging is only recommended if the feed-in limit is exceeded                   </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>label</b>     </td><td>If the battery is displayed in the bar graph with the 'show' key, the symbol can be labeled                   </td></tr>
           <tr><td>                  </td><td>with the current SOC value (%).                                                                               </td></tr>
           <tr><td>                  </td><td><b>none</b>   - no label (default)                                                                            </td></tr>
           <tr><td>                  </td><td><b>below</b>  - Label below the battery icon                                                                  </td></tr>
           <tr><td>                  </td><td><b>beside</b> - Label next to the battery icon                                                                </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>show</b>      </td><td>Control of the battery display in the bar graph (optional)                                                    </td></tr>
           <tr><td>                  </td><td><b>0</b> - no display of the device (default)                                                                 </td></tr>
           <tr><td>                  </td><td><b>1..3[:top|bottom]</b> - display of the device in level 1,2 or 3 (above|below) the bar                      </td></tr>
           <tr><td>                  </td><td>                                                                                                              </td></tr>
           <tr><td> <b>asynchron</b> </td><td>Data collection mode according to the plantControl->cycleInterval setting (synchronous) or additionally by    </td></tr>
           <tr><td>                  </td><td>event processing (asynchronous).                                                                              </td></tr>
           <tr><td>                  </td><td><b>0</b> - no data collection after receiving an event from the device (default)                              </td></tr>
           <tr><td>                  </td><td><b>1</b> - trigger a data collection when an event is received from the device                                </td></tr>
         </table>
       </ul>
       <br>

       <b>Special cases:</b> If the reading for pin and pout should be identical but signed,
       the keys pin and pout can be defined as follows: <br><br>
       <ul>
         pin=-pout  &nbsp;&nbsp;&nbsp;(a negative value of pout is used as pin)  <br>
         pout=-pin  &nbsp;&nbsp;&nbsp;(a negative value of pin is used as pout)
       </ul>
       <br>

       The unit is omitted in the particular special case. <br><br>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; setupBatteryDev01 BatDummy pin=BatVal:W pout=-pin intotal=BatInTot:Wh outtotal=BatOutTot:Wh cap=BatCap:kWh show=2:bottom icon=measure_battery_50@#262626:@yellow:measure_battery_100@red  <br>
         attr &lt;name&gt; setupBatteryDev02 MQTT2_cerboGX_c0619ab34e08_battery 
                                             pin=BatIn:W 
                                             pout=BatOut:W
                                             pinmax=14402
                                             poutmax=14402
                                             intotal=BatInTotal:Wh outtotal=BatOutTotal:Wh 
                                             charge=SOC_value cap=InstalledCapacity_Wh:Wh 
                                             asynchron=0
                                             show=1
                                             label=below
                                             icon=@dyn:::@dyn
       </ul>
       <br>

       <b>Note:</b> Deleting the attribute also removes the internally corresponding data.
       </li>
       <br>

       <a id="SolarForecast-attr-setupInverterDev" data-pattern="setupInverterDev.*"></a>
       <li><b>setupInverterDevXX &lt;Inverter Device Name&gt; pvOut=&lt;Reading&gt;:&lt;Unit&gt; ac2dc=&lt;Reading&gt;:&lt;Unit&gt; dc2ac=&lt;Reading&gt;:&lt;Unit&gt;             <br>
                                 etotal=&lt;Reading&gt;:&lt;Unit&gt; capacity=&lt;max. inverter power&gt; [strings=&lt;String1&gt;,&lt;String2&gt;,...] [asynchron=&lt;Option&gt]  <br>
                                 [feed=&lt;Delivery type&gt;] [limit=&lt;0..100&gt;] [icon=&lt;active&gt;[@&lt;Color&gt;][:&lt;inactive&gt;[@&lt;Color&gt;]]] </b> <br><br>

       Specifies any inverter device or solar charger and its readings to provide the required information. <br>
       This can also be a dummy device with corresponding readings. <br>
       Various operating modes of the inverter can be activated:
       <br><br>

           <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>PV-Inverter</b>              </td><td>The standard inverter. It converts the energy from the connected solar cells into alternating current.            </td></tr>
           <tr><td>                                 </td><td>This device supplies energy to the household grid. Alternatively, <b>feed=grid</b> can be used to change the      </td></tr>
           <tr><td>                                 </td><td>function of the inverter to exclusive feed-in to the public grid.                                                 </td></tr>
           <tr><td>                                 </td><td>                                                                                                                  </td></tr>
           <tr><td> <b>Solar charger</b>            </td><td>A solar charger does not convert the energy from the connected solar cells into alternating current,              </td></tr>
           <tr><td>                                 </td><td>but works as a DC-DC converter and charges a battery directly or supplies a battery inverter.                     </td></tr>
           <tr><td>                                 </td><td>The function as a solar charger is activated with <b>feed=bat</b> (e.g. a Victron SmartSolar MPPT).               </td></tr>
           <tr><td>                                 </td><td>                                                                                                                  </td></tr>
           <tr><td> <b>Battery inverter</b>         </td><td>This device has no connected solar cells and works as DC-AC or AC-DC converter between a battery                  </td></tr>
           <tr><td>                                 </td><td>and the household grid.                                                                                           </td></tr>
           <tr><td>                                 </td><td>The function as a battery inverter is activated with <b>strings=none</b>.                                         </td></tr>
           <tr><td>                                 </td><td>                                                                                                                  </td></tr>
         </table>
       </ul>
       <br>

       The following &lt;Key=Value&gt; pairs define the properties of the inverter. <br>
       Keys that depend on the activated inverter type are assigned to the corresponding inverter type below.
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>strings</b>    </td><td>Comma-separated list of the strings assigned to the inverter (optional). The string names                                   </td></tr>
           <tr><td>                   </td><td>are defined in the <a href=“#SolarForecast-attr-setupInverterStrings”>setupInverterStrings</a> attribute.                   </td></tr>
           <tr><td>                   </td><td>If 'strings' is not specified, all defined string names are assigned to the inverter.                                       </td></tr>
           <tr><td>                   </td><td>With '<b>strings=none</b>', no strings are assigned to the inverter and the inverter type                                   </td></tr>
           <tr><td>                   </td><td><b>battery inverter is activated</b>.                                                                                       </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>feed</b>       </td><td>Defines special properties of the device's energy supply (optional).                                                        </td></tr>
           <tr><td>                   </td><td>If the key is not set, the device feeds the PV energy into the house's AC grid.                                             </td></tr>
           <tr><td>                   </td><td><b>bat</b> - the <b>solar charger type is activated</b>. Any surplus is fed to the inverter node/house grid.                </td></tr>
           <tr><td>                   </td><td><b>grid</b> - the energy is fed exclusively into the public grid                                                            </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>capacity</b>   </td><td>Rated power of the inverter according to data sheet, i.e. max. possible output in Watts                                     </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>limit</b>      </td><td>Defines any active power limitation in % (optional).                                                                        </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>icon</b>       </td><td>Icon for displaying the inverter in the flow chart (optional), otherwise standards are used.                                </td></tr>
           <tr><td>                   </td><td><b>&lt;active&gt;</b> - Icon and, if applicable, color for activity or PV generation                                        </td></tr>
           <tr><td>                   </td><td><b>&lt;inactive&gt;</b> - Icon and possibly color for inactivity                                                            </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>asynchron</b>  </td><td>Data collection mode according to the plantControl->cycleInterval setting (synchronous) or additionally by                  </td></tr>
           <tr><td>                   </td><td>event processing (asynchronous). (optional)                                                                                 </td></tr>
           <tr><td>                   </td><td><b>0</b> - no data collection after receiving an event from the device (default)                                            </td></tr>
           <tr><td>                   </td><td><b>1</b> - trigger a data collection when an event is received from the device                                              </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>Unit</b>       </td><td>the respective unit (W,kW,Wh,kWh)                                                                                           </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td>                   </td><td><b><u>PV-Inverter</u></b>                                                                                                   </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>pvIn</b>       </td><td>A reading that provides the current DC PV input power in W (sum of all connected strings).                                  </td></tr>
           <tr><td>                   </td><td>A positive numerical value is expected.                                                                                     </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>pvOut</b>      </td><td>A reading that provides the current power from PV generation that is supplied to the domestic or pblic grid.                </td></tr>
           <tr><td>                   </td><td>A positive numerical value is expected.                                                                                     </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>etotal</b>     </td><td>The Reading which provides the total PV energy generated (a steadily increasing counter).                                   </td></tr>
           <tr><td>                   </td><td>If the reading violates the specification of a continuously rising counter,                                                 </td></tr>
           <tr><td>                   </td><td>SolarForecast handles this error and reports the situation by means of a log message.                                       </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td>                   </td><td><b><u>Solar charger</u></b>                                                                                                 </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>pvIn</b>       </td><td>A reading that provides the current DC PV input power in W (sum of all connected strings).                                  </td></tr>
           <tr><td>                   </td><td>A positive numerical value is expected.                                                                                     </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>pvOut</b>      </td><td>A reading that provides the current power from PV generation that is supplied to the battery(ies) or to a battery inverter. </td></tr>
           <tr><td>                   </td><td>A positive numerical value is expected.                                                                                     </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>etotal</b>     </td><td>The Reading which provides the total PV energy generated (a steadily increasing counter).                                   </td></tr>
           <tr><td>                   </td><td>If the reading violates the specification of a continuously rising counter,                                                 </td></tr>
           <tr><td>                   </td><td>SolarForecast handles this error and reports the situation by means of a log message.                                       </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td>                   </td><td><b><u>Battery inverter</u></b>                                                                                              </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>ac2dc</b>      </td><td>A reading that indicates the current AC->DC power (house network to battery) as a positive value.                           </td></tr>
           <tr><td>                   </td><td>The key can <b>only be set for battery inverters</b>.                                                                       </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
           <tr><td> <b>dc2ac</b>      </td><td>A reading that indicates the current DC->AC power (battery/solar charger to the household grid) as a positive value.        </td></tr>
           <tr><td>                   </td><td>The key can <b>only be set for battery inverters</b>.                                                                       </td></tr>
           <tr><td>                   </td><td>                                                                                                                            </td></tr>
        </table>
       </ul>
       <br>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; setupInverterDev01 STP5000 pv=total_pac:kW etotal=etotal:kWh capacity=5000 asynchron=1 strings=Garage,Garden icon=inverter@red:solar
       </ul>
       <br>

       <b>Note:</b> Deleting the attribute also removes the internally corresponding data.
       </li>
       <br>

       <a id="SolarForecast-attr-setupInverterStrings"></a>
       <li><b>setupInverterStrings &lt;Stringname1&gt;[,&lt;Stringname2&gt;,&lt;Stringname3&gt;,...] </b> <br><br>

       Designations of the active strings. These names are used as keys in the further
       settings. <br>
       When using an AI based API (e.g. VictronKI API) only "<b>KI-based</b>" has to be entered regardless of
       which real strings exist. <br><br>

       <ul>
         <b>Examples: </b> <br>
         attr &lt;name&gt; setupInverterStrings eastroof,southgarage,S3 <br>
         attr &lt;name&gt; setupInverterStrings KI-based <br>
       </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-setupMeterDev"></a>
       <li><b>setupMeterDev &lt;Meter Device Name&gt; gcon=&lt;Readingname&gt;:&lt;Unit&gt; contotal=&lt;Readingname&gt;:&lt;Unit&gt;
                            gfeedin=&lt;Readingname&gt;:&lt;Unit&gt; feedtotal=&lt;Readingname&gt;:&lt;Unit&gt;
                            [conprice=&lt;Field&gt;] [feedprice=&lt;Field&gt;] [asynchron=&lt;Option&gt] </b> <br><br>

       Defines any device and its readings for measuring energy into or out of the public grid.
       The module assumes that the numeric value of the readings is positive.
       It can also be a dummy device with corresponding readings.
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>gcon</b>       </td><td>Reading which supplies the power currently drawn from the grid                                                            </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>contotal</b>   </td><td>Reading which provides the sum of the energy drawn from the grid (a constantly increasing meter)                          </td></tr>
           <tr><td>                   </td><td>If the counter is reset to '0' at the beginning of the day (daily counter), the module handles this situation accordingly.</td></tr>
           <tr><td>                   </td><td>In this case, a message is displayed in the log with verbose 3.                                                           </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>gfeedin</b>    </td><td>Reading which supplies the power currently fed into the grid                                                              </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>feedtotal</b>  </td><td>Reading which provides the sum of the energy fed into the grid (a constantly increasing meter)                            </td></tr>
           <tr><td>                   </td><td>If the counter is reset to '0' at the beginning of the day (daily counter), the module handles this situation accordingly.</td></tr>
           <tr><td>                   </td><td>In this case, a message is displayed in the log with verbose 3.                                                           </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>Unit</b>       </td><td>the respective unit (W,kW,Wh,kWh)                                                                                         </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>conprice</b>   </td><td>Price for the purchase of one kWh (optional). The &lt;field&gt; can be specified in one of the following variants:        </td></tr>
           <tr><td>                   </td><td>&lt;Price&gt;:&lt;Currency&gt; - Price as a numerical value and its currency                                              </td></tr>
           <tr><td>                   </td><td>&lt;Reading&gt;:&lt;Currency&gt; - Reading of the <b>meter device</b> that contains the price : Currency                  </td></tr>
           <tr><td>                   </td><td>&lt;Device&gt;:&lt;Reading&gt;:&lt;Currency&gt; - any device and reading containing the price : Currency                  </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>feedprice</b>  </td><td>Remuneration for the feed-in of one kWh (optional). The &lt;field&gt; can be specified in one of the following variants:  </td></tr>
           <tr><td>                   </td><td>&lt;Remuneration&gt;:&lt;Currency&gt; - Remuneration as a numerical value and its currency                                </td></tr>
           <tr><td>                   </td><td>&lt;Reading&gt;:&lt;Currency&gt; - Reading of the <b>meter device</b> that contains the remuneration : Currency           </td></tr>
           <tr><td>                   </td><td>&lt;Device&gt;:&lt;Reading&gt;:&lt;Currency&gt; - any device and reading containing the remuneration : Currency           </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>asynchron</b>  </td><td>Data collection mode according to the plantControl->cycleInterval setting (synchronous) or additionally by                </td></tr>
           <tr><td>                   </td><td>event processing (asynchronous).                                                                                          </td></tr>
           <tr><td>                   </td><td><b>0</b> - no data collection after receiving an event from the device (default)                                          </td></tr>
           <tr><td>                   </td><td><b>1</b> - trigger a data collection when an event is received from the device                                            </td></tr>
         </table>
       </ul>
       <br>

       <b>Special cases:</b> If the reading for gcon and gfeedin should be identical but signed,
       the keys gfeedin and gcon can be defined as follows: <br><br>
       <ul>
         gfeedin=-gcon  &nbsp;&nbsp;&nbsp;(a negative value of gcon is used as gfeedin)  <br>
         gcon=-gfeedin  &nbsp;&nbsp;&nbsp;(a negative value of gfeedin is used as gcon)
       </ul>
       <br>

       The unit is omitted in the particular special case. <br><br>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; setupMeterDev Meter gcon=Wirkleistung:W contotal=BezWirkZaehler:kWh gfeedin=-gcon feedtotal=EinWirkZaehler:kWh conprice=powerCost:€ feedprice=0.1269:€
       </ul>
       <br>

       <b>Note:</b> Deleting the attribute also removes the internally corresponding data.
       </li>
       <br>

       <a id="SolarForecast-attr-setupOtherProducer" data-pattern="setupOtherProducer.*"></a>
       <li><b>setupOtherProducerXX &lt;Device Name&gt; pcurr=&lt;Readingname&gt;:&lt;Unit&gt; etotal=&lt;Readingname&gt;:&lt;Unit&gt; [icon=&lt;Icon&gt;[@&lt;Color&gt;]] </b> <br><br>

       Defines any device and its readings for the delivery of other generation values
       (e.g. CHP, wind generation, emergency generator). This device is not intended for PV generation.
       It can also be a dummy device with corresponding readings.
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>icon</b>     </td><td>Icon and, if applicable, color for activity to display the producer in the flow chart (optional)                           </td></tr>
           <tr><td> <b>pcurr</b>    </td><td>Reading which returns the current generation as a positive value or a self-consumption (special case) as a negative value  </td></tr>
           <tr><td> <b>etotal</b>   </td><td>Reading which supplies the total energy generated (a continuously ascending counter)                                       </td></tr>
           <tr><td>                 </td><td>If the reading violates the specification of a continuously rising counter,                                                </td></tr>
           <tr><td>                 </td><td>SolarForecast handles this error and reports the situation that has occurred with a log entry.                             </td></tr>
           <tr><td> <b>Einheit</b>  </td><td>the respective unit (W,kW,Wh,kWh)                                                                                          </td></tr>
         </table>
       </ul>
       <br>

       <ul>
         <b>Example: </b> <br>
         attr &lt;name&gt; setupOtherProducer01 windwheel pcurr=total_pac:kW etotal=etotal:kWh icon=Ventilator_wind@darkorange
       </ul>
       <br>

       <b>Note:</b> Deleting the attribute also removes the internally corresponding data.
       </li>
       <br>

       <a id="SolarForecast-attr-setupRadiationAPI"></a>
       <li><b>setupRadiationAPI </b> <br><br>

       Defines the source for the delivery of the solar radiation data. You can select a device of the type DWD_OpenData or
       an implemented API can be selected. <br><br>

       <b>Note:</b> If an OpenMeteo API is also set in the 'setupWeatherDev1' attribute, the settings of both attributes
                    are harmonized, whereby the setting of 'setupRadiationAPI' is leading. <br><br>

       <b>OpenMeteoDWD-API</b> <br>

       Open-Meteo is an open source weather API and offers free access for non-commercial purposes.
       No API key is required.
       Open-Meteo leverages a powerful combination of global (11 km) and mesoscale (1 km) weather models from esteemed
       national weather services.
       This API provides access to the renowned ICON weather models of the German Weather Service (DWD), which provide
       15-minute data for short-term forecasts in Central Europe and global forecasts with a resolution of 11 km.
       The ICON model is a preferred choice for general weather forecast APIs when no other high-resolution weather
       models are available. The models DWD Icon D2, DWD Icon EU and DWD Icon Global models are merged into a
       seamless forecast.
       The comprehensive and clearly laid out
       <a href='https://open-meteo.com/en/docs/dwd-api' target='_blank'>API Documentation</a> is available on
       the service's website.
       <br><br>

       <b>OpenMeteoDWD_D2-API</b> <br>

       Like OpenMeteoDWD-API. However, only the ICON D2 model is used for Central Europe
       (Germany, Switzerland, Austria, France, Belgium, Netherlands, Denmark, Czech Republic, Slovenia) is used.
       The spatial resolution of this model is 0.02° (approx. 2 km) and a temporal resolution of 15 minutes.
       <br><br>

       <b>OpenMeteoDWDEnsemble-API</b> <br>

       This Open-Meteo API variant provides access to the DWD's global
       <a href='https://www.dwd.de/DE/forschung/wettervorhersage/num_modellierung/04_ensemble_methoden/ensemble_vorhersage/ensemble_vorhersagen.html' target='_blank'>Ensemble Prediction System (EPS)</a>.
       <br>
       The ensemble models ICON-D2-EPS, ICON-EU-EPS and ICON-EPS are seamlessly combined. <br>
       <a href='https://openmeteo.substack.com/p/ensemble-weather-forecast-api' target='_blank'>Ensemble weather forecasts</a> are
       a special type of forecasting method that takes into account the uncertainties in weather forecasting.
       They do this by running several simulations or models with slight differences in the starting conditions or settings.
       Each simulation, known as an ensemble member, represents a possible outcome of the weather.
       In this implementation, 40 ensemble members per weather feature are combined and the most probable result is used.
       <br><br>

       <b>OpenMeteoWorld-API</b> <br>

       As a variant of the Open Meteo service, the OpenMeteoWorld API provides the optimum forecast for a specific location worldwide.
       The OpenMeteoWorld API seamlessly combines weather models from well-known organizations such as NOAA (National Oceanic and Atmospheric
       Administration), DWD (German Weather Service), CMCC (Canadian) and ECMWF (European Centre for Medium-Range Weather Forecasts).
       The providers' models are combined for each location worldwide to produce the best possible forecast.
       The services and weather models are used automatically based on the location coordinates contained in the API call.
       <br><br>

       <b>SolCast-API</b> <br>

       API usage requires one or more API-keys (accounts) and one or more Rooftop-ID's in advance
       created on the <a href='https://toolkit.solcast.com.au/rooftop-sites/' target='_blank'>SolCast</a> website.
       A rooftop is equivalent to one <a href="#SolarForecast-attr-setupInverterStrings">setupInverterStrings</a>
       in the SolarForecast context. <br>
       Free API usage is limited to one daily rate API requests. The number of defined strings (rooftops)
       increases the number of API requests required. The module optimizes the query cycles automatically.
       <br><br>

       <b>ForecastSolar-API</b> <br>

       Free use of the <a href='https://doc.forecast.solar/start' target='_blank'>Forecast.Solar API</a>.
       does not require registration. API requests are limited to 12 within one hour in the free version.
       There is no daily limit. The module automatically determines the optimal query interval
       depending on the configured strings. <br>
       Note: Based on previous experience, unreliable and not recommended.
       <br><br>

       <b>VictronKI-API</b> <br>

       This API can be applied by users of the Victron Energy VRM Portal. This API is AI based.
       As string the value "AI-based" has to be entered in the setup of the
       <a href="#SolarForecast-attr-setupInverterStrings">setupInverterStrings</a>. <br>
       In the Victron Energy VRM Portal, the location of the PV system must be specified as a prerequisite. <br>
       See also the blog post
       <a href="https://www.victronenergy.com/blog/2023/07/05/new-vrm-solar-production-forecast-feature/">Introducing Solar Production Forecast</a>.
       <br><br>

       <b>DWD_OpenData Device</b> <br>

       The DWD service is integrated via a FHEM device of type DWD_OpenData.
       If there is no device of type DWD_OpenData yet, it must be defined in advance
       (look at <a href="http://fhem.de/commandref.html#DWD_OpenData">DWD_OpenData Commandref</a>). <br>
       To obtain a good radiation forecast, a DWD station located near the plant site should be used. <br>
       Unfortunately, not all
       <a href="https://www.dwd.de/DE/leistungen/klimadatendeutschland/statliste/statlex_html.html;jsessionid=EC5F572A52EB69684D552DCF6198F290.live31092?view=nasPublication&nn=16102">DWD stations</a>
       provide the required Rad1h values. <br>
       Explanations of the stations are listed in
       <a href="https://www.dwd.de/DE/leistungen/klimadatendeutschland/stationsliste.html">Stationslexikon</a>. <br>
       At least the following attributes must be set in the selected DWD_OpenData Device: <br><br>

       <ul>
          <table>
          <colgroup> <col width="25%"> <col width="75%"> </colgroup>
             <tr><td> <b>forecastDays</b>            </td><td>1  (set it to &gt;= 2 if you want longer prediction)                                          </td></tr>
             <tr><td> <b>forecastProperties</b>      </td><td>Rad1h                                                                                         </td></tr>
             <tr><td> <b>forecastResolution</b>      </td><td>1                                                                                             </td></tr>
             <tr><td> <b>forecastStation</b>         </td><td>&lt;Station code of the evaluated DWD station&gt;                                             </td></tr>
             <tr><td>                                </td><td><b>Note:</b> The selected DWD station must provide radiation values (Rad1h Readings).         </td></tr>
             <tr><td>                                </td><td>Not all stations provide this data!                                                           </td></tr>
          </table>
       </ul>
       </li>
       <br>

      <a id="SolarForecast-attr-setupRoofTops"></a>
      <li><b>setupRoofTops &lt;Stringname1&gt;=&lt;pk&gt; [&lt;Stringname2&gt;=&lt;pk&gt; &lt;Stringname3&gt;=&lt;pk&gt; ...] </b> <br>
      (only when using Model SolCastAPI) <br><br>

      The string "StringnameX" is assigned to a key &lt;pk&gt;. The key &lt;pk&gt; was created with the setter
      <a href="#SolarForecast-set-roofIdentPair">roofIdentPair</a>. This is used to specify the rooftop ID and API key to
      be used in the SolCast API.  <br>
      The StringnameX is a key value of the attribute <b>setupInverterStrings</b>.
      <br><br>

      <ul>
        <b>Example: </b> <br>
        attr &lt;name&gt; setupRoofTops eastroof=p1 southgarage=p2 S3=p3 <br>
      </ul>
      </li>
      <br>

    <ul>
      <a id="SolarForecast-attr-setupStringAzimuth"></a>
      <li><b>setupStringAzimuth &lt;Stringname1&gt;=&lt;dir&gt; [&lt;Stringname2&gt;=&lt;dir&gt; &lt;Stringname3&gt;=&lt;dir&gt; ...] </b> <br><br>

      Alignment &lt;dir&gt; of the solar modules in the string "StringnameX". The string name is a key value of the
      <b>setupInverterStrings</b> attribute. <br>
      The direction specification &lt;dir&gt; can be specified as an azimuth identifier or as an azimuth value: <br><br>

      <ul>
         <table>
         <colgroup> <col width="30%"> <col width="20%"> <col width="50%"> </colgroup>
            <tr><td> <b>Identifier</b></td><td><b>Azimuth</b></td><td>                            </td></tr>
            <tr><td> N                </td><td>-180          </td><td>North orientation           </td></tr>
            <tr><td> NE               </td><td>-135          </td><td>North-East orientation      </td></tr>
            <tr><td> E                </td><td>-90           </td><td>East orientation            </td></tr>
            <tr><td> SE               </td><td>-45           </td><td>South-east orientation      </td></tr>
            <tr><td> S                </td><td>0             </td><td>South orientation           </td></tr>
            <tr><td> SW               </td><td>45            </td><td>South-west orientation      </td></tr>
            <tr><td> W                </td><td>90            </td><td>West orientation            </td></tr>
            <tr><td> NW               </td><td>135           </td><td>North-West orientation      </td></tr>
         </table>
      </ul>
      <br>

      Azimuth values are integers in the range -180 to 180. Although the specified identifiers can be used,
      it is recommended to specify the exact azimuth value in the attribute. This allows any intermediate values such
      as 83, 48 etc. to be specified.
      <br><br>

      <ul>
        <b>Example: </b> <br>
        attr &lt;name&gt; setupStringAzimuth Ostdach=-85 Südgarage=S S3=132 <br>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-attr-setupStringDeclination"></a>
      <li><b>setupStringDeclination &lt;Stringname1&gt;=&lt;Angle&gt; [&lt;Stringname2&gt;=&lt;Angle&gt; &lt;Stringname3&gt;=&lt;Angle&gt; ...] </b> <br><br>

      Tilt angle of the solar modules. The string name is a key value of the attribute <b>setupInverterStrings</b>. <br>
      Integers between 0 and 90 can be specified as the angle of inclination. (0 = horizontal, 90 = vertical). <br><br>

      <ul>
        <b>Example: </b> <br>
        attr &lt;name&gt; setupStringDeclination eastroof=40 southgarage=60 S3=30 <br>
      </ul>
      </li>
    </ul>
    <br>

      <a id="SolarForecast-attr-setupStringPeak"></a>
      <li><b>setupStringPeak &lt;Stringname1&gt;=&lt;Peak&gt; [&lt;Stringname2&gt;=&lt;Peak&gt; &lt;Stringname3&gt;=&lt;Peak&gt; ...] </b> <br><br>

      The DC peak power of the string "StringnameX" in kWp. The string name is a key value of the
      attribute <b>setupInverterStrings</b>. <br>
      When using an AI-based API (e.g. Model VictronKiAPI), the peak powers of all existing strings are to be assigned as
      a sum to the string name <b>KI-based</b>. <br><br>

      <ul>
        <b>Examples: </b> <br>
        attr &lt;name&gt; setupStringPeak eastroof=5.1 southgarage=2.0 S3=7.2 <br>
        attr &lt;name&gt; setupStringPeak KI-based=14.3 (for AI based API)<br>
      </ul>
      </li>
      <br>

      <a id="SolarForecast-attr-setupWeatherDev" data-pattern="setupWeatherDev.*"></a>
      <li><b>setupWeatherDevX </b> <br><br>

      Specifies the device or API for providing the required weather data (cloud cover, precipitation, etc.).<br>
      The attribute 'setupWeatherDev1' specifies the leading weather service and is mandatory.<br><br>

      <b>Note:</b> If an OpenMeteo API is also set in the 'setupRadiationAPI' attribute, the settings of both attributes
                   are harmonized, whereby the setting of 'setupRadiationAPI' is leading. <br><br>

      <b>OpenMeteoDWD-API</b> <br>

      Open-Meteo is an open source weather API and offers free access for non-commercial purposes.
      No API key is required.
      Open-Meteo leverages a powerful combination of global (11 km) and mesoscale (1 km) weather models from esteemed
      national weather services.
      This API provides access to the renowned ICON weather models of the German Weather Service (DWD), which provide
      15-minute data for short-term forecasts in Central Europe and global forecasts with a resolution of 11 km.
      The ICON model is a preferred choice for general weather forecast APIs when no other high-resolution weather
      models are available. The models DWD Icon D2, DWD Icon EU and DWD Icon Global models are merged into a
      seamless forecast.
      The comprehensive and clearly laid out
      <a href='https://open-meteo.com/en/docs/dwd-api' target='_blank'>API Documentation</a> is available on
      the service's website.
      <br><br>

      <b>OpenMeteoDWD_D2-API</b> <br>

      Like OpenMeteoDWD-API. However, only the ICON D2 model is used for Central Europe
      (Germany, Switzerland, Austria, France, Belgium, Netherlands, Denmark, Czech Republic, Slovenia) is used.
      The spatial resolution of this model is 0.02° (approx. 2 km) and a temporal resolution of 15 minutes.
      <br><br>

      <b>OpenMeteoDWDEnsemble-API</b> <br>

      This Open-Meteo API variant provides access to the DWD's global
      <a href='https://www.dwd.de/DE/forschung/wettervorhersage/num_modellierung/04_ensemble_methoden/ensemble_vorhersage/ensemble_vorhersagen.html' target='_blank'>Ensemble Prediction System (EPS)</a>.
      <br>
      The ensemble models ICON-D2-EPS, ICON-EU-EPS and ICON-EPS are seamlessly combined. <br>
      <a href='https://openmeteo.substack.com/p/ensemble-weather-forecast-api' target='_blank'>Ensemble weather forecasts</a> are
      a special type of forecasting method that takes into account the uncertainties in weather forecasting.
      They do this by running several simulations or models with slight differences in the starting conditions or settings.
      Each simulation, known as an ensemble member, represents a possible outcome of the weather.
      In this implementation, 40 ensemble members per weather feature are combined and the most probable result is used.
      <br><br>

       <b>OpenMeteoWorld-API</b> <br>

       As a variant of the Open Meteo service, the OpenMeteoWorld API provides the optimum forecast for a specific location worldwide.
       The OpenMeteoWorld API seamlessly combines weather models from well-known organizations such as NOAA (National Oceanic and Atmospheric
       Administration), DWD (German Weather Service), CMCC (Canadian) and ECMWF (European Centre for Medium-Range Weather Forecasts).
       The providers' models are combined for each location worldwide to produce the best possible forecast.
       The services and weather models are used automatically based on the location coordinates contained in the API call.
       <br><br>

       <b>DWD Device</b> <br>

       As an alternative to Open-Meteo, an FHEM 'DWD_OpenData' device can be used to supply the weather data.<br>
       If no device of this type exists, at least one DWD_OpenData device must first be defined.
       (see <a href="http://fhem.de/commandref.html#DWD_OpenData">DWD_OpenData Commandref</a>). <br>
       If more than one setupWeatherDevX is specified, the average of all weather stations is determined
       if the respective value was supplied and is numerical. <br>
       Otherwise, the data from 'setupWeatherDev1' is always used as the leading weather device.<br>
       At least these attributes must be set in the selected DWD_OpenData Device: <br><br>

       <ul>
         <table>
         <colgroup> <col width="25%"> <col width="75%"> </colgroup>
            <tr><td> <b>forecastDays</b>            </td><td>2                                                                  </td></tr>
            <tr><td> <b>forecastProperties</b>      </td><td>TTT,Neff,RR1c,ww,SunUp,SunRise,SunSet                              </td></tr>
            <tr><td> <b>forecastResolution</b>      </td><td>1                                                                  </td></tr>
            <tr><td> <b>forecastStation</b>         </td><td>&lt;Station code of the evaluated DWD station&gt;                  </td></tr>
         </table>
       </ul>
       <br>

       <b>Note:</b> If the latitude and longitude attributes are set in the global device, the sunrise and sunset
                    result from this information.
       </li>
       <br>

     </ul>
  </ul>


</ul>
=end html
=begin html_DE

<a id="SolarForecast"></a>
<h3>SolarForecast</h3>
<br>

Das Modul SolarForecast erstellt auf Grundlage der Werte aus generischen Quellen eine
Vorhersage für den solaren Ertrag und integriert weitere Informationen als Grundlage für darauf aufbauende Steuerungen. <br>

Zur Erstellung der solaren Vorhersage kann das Modul SolarForecast unterschiedliche Dienste und Quellen nutzen: <br><br>

  <ul>
     <table>
     <colgroup> <col width="32%"> <col width="68%"> </colgroup>
        <tr><td> <b>DWD</b>                       </td><td>solare Vorhersage basierend auf MOSMIX Daten des Deutschen Wetterdienstes                                           </td></tr>
        <tr><td> <b>SolCast-API </b>              </td><td>verwendet Prognosedaten der <a href='https://toolkit.solcast.com.au/rooftop-sites/' target='_blank'>SolCast API</a> </td></tr>
        <tr><td> <b>ForecastSolar-API</b>         </td><td>verwendet Prognosedaten der <a href='https://doc.forecast.solar/api' target='_blank'>Forecast.Solar API</a>         </td></tr>
        <tr><td> <b>OpenMeteoDWD-API</b>          </td><td>ICON-Wettermodelle des Deutschen Wetterdienstes (DWD) über <a href='https://open-meteo.com/en/docs/dwd-api' target='_blank'>Open-Meteo</a> </td></tr>
        <tr><td> <b>OpenMeteoDWDEnsemble-API</b>  </td><td>Zugang zum <a href='https://www.dwd.de/DE/forschung/wettervorhersage/num_modellierung/04_ensemble_methoden/ensemble_vorhersage/ensemble_vorhersagen.html' target='_blank'>globalen Ensemble-Vorhersagesystem (EPS)</a> des DWD </td></tr>
        <tr><td> <b>OpenMeteoWorld-API</b>        </td><td>vereint nahtlos Wettermodelle von Organisationen wie NOAA, DWD, CMCC und ECMWF über <a href='https://open-meteo.com/en/docs' target='_blank'>Open-Meteo</a> </td></tr>
        <tr><td> <b>VictronKI-API</b>             </td><td>Victron Energy API des <a href='https://www.victronenergy.com/blog/2023/07/05/new-vrm-solar-production-forecast-feature/' target='_blank'>VRM Portals</a>   </td></tr>
     </table>
  </ul>
  <br>

Die Nutzung der erwähnten API's beschränkt sich auf die jeweils kostenlose Version des Dienstes. <br>
In Abhängigkeit vom verwendeten Model kann eine KI-Unterstützung aktiviert werden. <br><br>

Über die PV Erzeugungsprognose hinaus werden Verbrauchswerte bzw. Netzbezugswerte erfasst und für eine
Verbrauchsprognose verwendet. <br>
Das Modul errechnet aus den Prognosewerten einen zukünftigen Energieüberschuß der zur Betriebsplanung von Verbrauchern
genutzt wird. Weiterhin bietet das Modul eine <a href="#SolarForecast-Consumer">Consumer Integration</a> zur integrierten
Planung und Steuerung von PV Überschuß abhängigen Verbraucherschaltungen. Eine Unterstützung zum optimalen
Batterie SoC-Management gehört ebenfalls zum Funktionsumfang. <br><br>

Bei der ersten Definition des Moduls wird der Benutzer über eine Guided Procedure unterstützt um alle initial notwendigen Eingaben
vorzunehmen. <br>
Am Ende des Vorganges und nach relevanten Änderungen der Anlagen- bzw. Devicekonfiguration sollte unbedingt mit einem
<a href="#SolarForecast-set-plantConfiguration">set &lt;name&gt; plantConfiguration ceck</a>
die ordnungsgemäße Anlagenkonfiguration geprüft werden.

<ul>
  <a id="SolarForecast-define"></a>
  <b>Define</b>
  <br><br>

  <ul>
    Ein SolarForecast Device wird erstellt mit: <br><br>

    <ul>
      <b>define &lt;name&gt; SolarForecast </b>
    </ul>
    <br>

    Nach der Definition des Devices sind in Abhängigkeit der verwendeten Prognosequellen zwingend weitere
    anlagenspezifische Angaben zu hinterlegen. <br>
    Mit nachfolgenden Set-Kommandos und Attributen werden für die Funktion des Moduls maßgebliche Informationen
    hinterlegt: <br><br>

      <ul>
         <table>
         <colgroup> <col width="25%"> <col width="75%"> </colgroup>
            <tr><td> <b>setupWeatherDevX</b>       </td><td>DWD_OpenData Device welches meteorologische Daten (z.B. Bewölkung) liefert     </td></tr>
            <tr><td> <b>setupRadiationAPI </b>     </td><td>DWD_OpenData Device bzw. API zur Lieferung von Strahlungsdaten                 </td></tr>
            <tr><td> <b>setupInverterDevXX</b>     </td><td>Device welches PV Leistungsdaten liefert                                       </td></tr>
            <tr><td> <b>setupMeterDev</b>          </td><td>Device welches Netz I/O-Daten liefert                                          </td></tr>
            <tr><td> <b>setupBatteryDevXX</b>      </td><td>Device welches Batterie Leistungsdaten liefert (sofern vorhanden)              </td></tr>
            <tr><td> <b>setupInverterStrings</b>   </td><td>Bezeichner der vorhandenen Anlagenstrings                                      </td></tr>
            <tr><td> <b>setupStringAzimuth</b>     </td><td>Ausrichtung (Azimut) der Anlagenstrings                                        </td></tr>
            <tr><td> <b>setupStringPeak</b>        </td><td>die DC-Peakleistung der Anlagenstrings                                         </td></tr>
            <tr><td> <b>roofIdentPair</b>          </td><td>die Identifikationsdaten (bei Nutzung der SolCast API)                         </td></tr>
            <tr><td> <b>setupRoofTops</b>          </td><td>die Rooftop Parameter (bei Nutzung der SolCast API)                            </td></tr>
            <tr><td> <b>setupStringDeclination</b> </td><td>die Neigungswinkel der Anlagenmodule                                           </td></tr>
         </table>
      </ul>
      <br>

    Um eine Anpassung an die persönliche Anlage zu ermöglichen, können Korrekturfaktoren manuell fest bzw. automatisiert
    dynamisch angewendet werden.
    <br><br>
  </ul>

  <a id="SolarForecast-Consumer"></a>
  <b>Consumer Integration</b>
  <br><br>

  <ul>
    Der Nutzer kann Verbraucher (z.B. Schaltsteckdosen) direkt im Modul registrieren und die Planung der
    Ein/Ausschaltzeiten sowie deren Ausführung vom SolarForecast Modul übernehmen lassen. Die Registrierung erfolgt mit den
    <a href="#SolarForecast-attr-consumer">ConsumerXX-Attributen</a>. In den Attributen werden neben dem FHEM Consumer Device eine Vielzahl von obligatorischen oder
    optionalen Schlüsseln angegeben die das Einplanungs- und Schaltverhalten des Consumers beeinflussen. <br>
    Die Schlüssel sind in der ConsumerXX-Hilfe detailliiert beschreiben.
    Um sich in den Umgang mit der Consumersteuerung anzueignen, bietet es sich an zunächst einen oder
    mehrere Dummies anzulegen und diese Devices als Consumer zu registrieren.
    <br><br>

    Zu diesem Zweck eignet sich ein Dummy Device nach diesem Muster:
    <br><br>

    <ul>
        define SolCastDummy dummy                                                                                                   <br>
        attr SolCastDummy userattr nomPower                                                                                         <br>
        attr SolCastDummy alias SolarForecast Consumer Dummy                                                                        <br>
        attr SolCastDummy cmdIcon on:remotecontrol/black_btn_GREEN off:remotecontrol/black_btn_RED                                  <br>
        attr SolCastDummy devStateIcon off:light_light_dim_100@grey on:light_light_dim_100@darkorange                               <br>
        attr SolCastDummy group Solarprognose                                                                                       <br>
        attr SolCastDummy icon solar_icon                                                                                           <br>
        attr SolCastDummy nomPower 1000                                                                                             <br>
        attr SolCastDummy readingList BatIn BatOut BatVal  BatInTot BatOutTot bezW einW Batcharge Temp automatic                    <br>
        attr SolCastDummy room Energie,Testraum                                                                                     <br>
        attr SolCastDummy setList BatIn BatOut BatVal BatInTot BatOutTot bezW einW Batcharge on off Temp                            <br>
        attr SolCastDummy userReadings actpow {ReadingsVal ($name, 'state', 'off') eq 'on' ? AttrVal ($name, 'nomPower', 100) : 0}  <br>
    </ul>

    <br><br>
  </ul>

  <a id="SolarForecast-set"></a>
  <b>Set</b>
  <ul>

    <ul>
      <a id="SolarForecast-set-aiDecTree"></a>
      <li><b>aiDecTree </b> <br><br>

      Ist der KI Support im SolarForecast Device aktiviert, können verschiedene KI-Aktionen manuell ausgeführt werden.
      Die manuelle Ausführung der KI Aktionen ist im Allgemeinen nicht notwendig, da die Abarbeitung aller nötigen Schritte
      bereits automatisch im Modul vorgenommen wird.
      <br><br>

      <ul>
       <table>
       <colgroup> <col width="15%"> <col width="85%"> </colgroup>
          <tr><td><b>addInstAndTrain</b>   </td><td>Die KI wird mit den aktuell vorhandenen PV-, Strahlungs- und Umweltdaten angereichert.                                  </td></tr>
          <tr><td>                         </td><td>Anschließend wird die KI mit den historischen Daten trainiert.                                                          </td></tr>
          <tr><td>                         </td><td>Erfolgreich generierte Entscheidungsbäume werden im Filesystem gespeichert.                                             </td></tr>
          <tr><td>                         </td><td>                                                                                                                        </td></tr>
          <tr><td><b>addRawData</b>        </td><td>Relevante PV-, Strahlungs- und Umweltdaten werden extrahiert und für die spätere Verwendung gespeichert.                </td></tr>
          <tr><td>                         </td><td>                                                                                                                        </td></tr>
          <tr><td><b>rawDataGHIreplace</b> </td><td>Es werden historische GHI (Global Horizontal Irradiance) Werte vom Open-Meteo Dienst abgerufen und die in aiRawData     </td></tr>
          <tr><td>                         </td><td>(siehe <a href="#SolarForecast-get-valDecTree">get ... valDecTree aiRawData</a>) vorhanden Werte 'rad1h' ersetzt bzw.
                                                     ergänzt wenn sie nicht vorhanden sind.                                                                                 </td></tr>
        </table>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-attrKeyVal"></a>
      <li><b>attrKeyVal &lt;Attribut&gt; [&lt;Gerät&gt;] &lt;Schlüssel=Wert&gt; </b> <br><br>

      Es können ein oder mehrere Schlüssel=Wert Paare in den Sammelattributen (aiControl, consumerXX, plantControl, setup.*, etc.)
      neu gesetzt oder verändert werden. <br>
      Ist ein Gerät obligatorisch, wie in den setup.*-Attributen verlangt, kann es ebenfalls gesetzt oder geändert werden.
      Es erfolgt eine automatische Speicherung der Änderung sofern im global Device NICHT autosave=0 gesetzt ist.
      <br><br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; attrKeyVal setupBatteryDev01 asynchron=1 <br>
        set &lt;name&gt; attrKeyVal setupBatteryDev02 BatteryDummy2 asynchron=1 <br>
        set &lt;name&gt; attrKeyVal plantControl cycleInterval=77 <br>
        set &lt;name&gt; attrKeyVal plantControl batteryPreferredCharge=0 consForecastInPlanning=1 cycleInterval=77 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-batteryTrigger"></a>
      <li><b>batteryTrigger &lt;1on&gt;=&lt;Wert&gt; &lt;1off&gt;=&lt;Wert&gt; [&lt;2on&gt;=&lt;Wert&gt; &lt;2off&gt;=&lt;Wert&gt; ...] </b> <br><br>

      Generiert Trigger bei Über- bzw. Unterschreitung bestimmter Batterieladungswerte (SoC in %). <br>
      Der verwendete SoC wird als resultierender SoC (Summe aktuelle Ladung aller Batterie Geräte im Verhältnis zur installierten
      Gesamtkapazität) gebildet, d.h. alle Batterien werden als ein Cluster betrachtet. <br>
      Überschreiten die letzten drei SoC-Messungen eine definierte <b>Xon-Bedingung</b>, wird das Reading
      <b>batteryTrigger_X = on</b> erstellt/gesetzt. <br>
      Unterschreiten die letzten drei SoC-Messungen eine definierte <b>Xoff-Bedingung</b>, wird das Reading
      <b>batteryTrigger_X = off</b> erstellt/gesetzt. <br>
      Es kann eine beliebige Anzahl von Triggerbedingungen angegeben werden. Xon/Xoff-Bedingungen müssen nicht zwingend paarweise
      definiert werden. <br>
      <br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; batteryTrigger 1on=30 1off=10 2on=70 2off=20 3on=15 4off=90<br>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-consumerNewPlanning"></a>
      <li><b>consumerNewPlanning &lt;Verbrauchernummer&gt; </b> <br><br>

      Es wird die vorhandene Planung des angegebenen Verbrauchers gelöscht. <br>
      Die Neuplanung wird unter Berücksichtigung der im consumerXX Attribut gesetzten Parameter sofort vorgenommen.
      <br><br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; consumerNewPlanning 01 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-cycleInterval"></a>
      <li><b>cycleInterval &lt;Ganzzahl&gt; </b> <br><br>

      Wiederholungsintervall der Datensammlung in Sekunden. <br>
      Der Befehl ist geeignet um den Schlüssel 'cycleInterval' im Attribut 'plantControl' dynamisch zu ändern.
      Für die Eingabe gelten die Bedingungen des Attributes 'plantControl'.
      <br><br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; cycleInterval 120 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-consumerImmediatePlanning"></a>
      <li><b>consumerImmediatePlanning &lt;Verbrauchernummer&gt; </b> <br><br>

      Es wird das sofortige Einschalten des Verbrauchers zur aktuellen Zeit eingeplant.
      Eventuell im consumerXX Attribut gesetzte Schlüssel <b>notbefore</b>, <b>notafter</b> bzw. <b>mode</b> werden nicht
      beachtet. <br>
      <br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; consumerImmediatePlanning 01 <br>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-energyH4Trigger"></a>
      <li><b>energyH4Trigger &lt;1on&gt;=&lt;Wert&gt; &lt;1off&gt;=&lt;Wert&gt; [&lt;2on&gt;=&lt;Wert&gt; &lt;2off&gt;=&lt;Wert&gt; ...] </b> <br><br>

      Generiert Trigger bei Über- bzw. Unterschreitung der 4-Stunden PV Vorhersage (NextHours_Sum04_PVforecast). <br>
      Überschreiten die letzten drei Messungen der 4-Stunden PV Vorhersagen eine definierte <b>Xon-Bedingung</b>, wird das Reading
      <b>energyH4Trigger_X = on</b> erstellt/gesetzt.
      Unterschreiten die letzten drei Messungen der 4-Stunden PV Vorhersagen eine definierte <b>Xoff-Bedingung</b>, wird das Reading
      <b>energyH4Trigger_X = off</b> erstellt/gesetzt. <br>
      Es kann eine beliebige Anzahl von Triggerbedingungen angegeben werden. Xon/Xoff-Bedingungen müssen nicht zwingend paarweise
      definiert werden. <br>
      <br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; energyH4Trigger 1on=2000 1off=1700 2on=2500 2off=2000 3off=1500 <br>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-operatingMemory"></a>
      <li><b>operatingMemory backup | save | recover-&lt;Datei&gt; </b> <br><br>

      Die Komponenten pvHistory (PVH) und pvCircular (PVC) der internen Cache Datenbank werden im Filesystem gespeichert. <br>
      Das Zielverzeichnis ist "../FHEM/FhemUtils". Dieser Vorgang wird vom Modul regelmäßig im Hintergrund ausgeführt.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="17%"> <col width="83%"> </colgroup>
            <tr><td> <b>backup</b>                </td><td>Sichert die aktiven In-Memory Strukturen mit dem aktuellen Zeitstempel.                                                                                            </td></tr>
            <tr><td>                              </td><td>Es werden <a href="#SolarForecast-attr-backupFilesKeep">plantControl->backupFilesKeep</a> Generationen der Dateien gespeichert. Ältere Versionen werden gelöscht.  </td></tr>
            <tr><td>                              </td><td>Dateien: PVH_SolarForecast_&lt;name&gt;_&lt;Zeitstempel&gt;, PVC_SolarForecast_&lt;name&gt;_&lt;Zeitstempel&gt;                                                    </td></tr>
            <tr><td>                              </td><td>                                                                                                                                                                   </td></tr>
            <tr><td> <b>save</b>                  </td><td>Die aktiven In-Memory Strukturen werden gespeichert.                                                                                                               </td></tr>
            <tr><td>                              </td><td>Dateien: PVH_SolarForecast_&lt;name&gt;, PVC_SolarForecast_&lt;name&gt;                                                                                            </td></tr>
            <tr><td>                              </td><td>                                                                                                                                                                   </td></tr>
            <tr><td> <b>recover-&lt;Datei&gt;</b> </td><td>Stellt die Daten der ausgewählten Sicherungsdatei als aktive In-Memory Struktur wieder her.                                                                        </td></tr>
            <tr><td>                              </td><td>Um Inkonsistenzen zu vermeiden, sollten die Dateien PVH.* und PVC.* mit dem gleichen                                                                               </td></tr>
            <tr><td>                              </td><td>Zeitstempel paarweise recovert werden.                                                                                                                             </td></tr>
         </table>
      </ul>
      <br>
    </ul>
    </li>
    <br>

    <ul>
      <a id="SolarForecast-set-operationMode"></a>
      <li><b>operationMode  </b> <br><br>
      Mit <b>inactive</b> wird das SolarForecast Gerät deaktiviert. Die <b>active</b> Option aktiviert das Gerät wieder.
      Das Verhalten entspricht dem "disable"-Attribut, eignet sich aber vor allem zum Einsatz in Perl-Skripten da
      gegenüber dem "disable"-Attribut keine Speicherung der Gerätekonfiguration nötig ist.
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-plantConfiguration"></a>
      <li><b>plantConfiguration </b> <br><br>

       Je nach ausgewählter Kommandooption werden folgende Operationen ausgeführt: <br><br>

      <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>check</b>     </td><td>Prüft die aktuelle Anlagenkonfiguration. Es wird eine Plausibilitätsprüfung      </td></tr>
            <tr><td>                  </td><td>vorgenommen und das Ergebnis sowie eventuelle Hinweise bzw. Fehler ausgegeben.   </td></tr>
            <tr><td> <b>save</b>      </td><td>sichert wichtige Parameter der Anlagenkonfiguration.                             </td></tr>
            <tr><td>                  </td><td>Die Operation wird täglich kurz nach 00:00 Uhr automatisch ausgeführt.           </td></tr>
            <tr><td> <b>restore</b>   </td><td>stellt eine gesicherte Anlagenkonfiguration wieder her                           </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-powerTrigger"></a>
      <li><b>powerTrigger &lt;1on&gt;=&lt;Wert&gt; &lt;1off&gt;=&lt;Wert&gt; [&lt;2on&gt;=&lt;Wert&gt; &lt;2off&gt;=&lt;Wert&gt; ...] </b> <br><br>

      Generiert Trigger bei Über- bzw. Unterschreitung bestimmter PV Erzeugungswerte (Current_PV). <br>
      Überschreiten die letzten drei Messungen der PV Erzeugung eine definierte <b>Xon-Bedingung</b>, wird das Reading
      <b>powerTrigger_X = on</b> erstellt/gesetzt.
      Unterschreiten die letzten drei Messungen der PV Erzeugung eine definierte <b>Xoff-Bedingung</b>, wird das Reading
      <b>powerTrigger_X = off</b> erstellt/gesetzt. <br>
      Es kann eine beliebige Anzahl von Triggerbedingungen angegeben werden. Xon/Xoff-Bedingungen müssen nicht zwingend paarweise
      definiert werden. <br>
      <br>

      <ul>
        <b>Beispiel: </b> <br>
        set &lt;name&gt; powerTrigger 1on=1000 1off=500 2on=2000 2off=1000 3on=1600 4off=1100<br>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-pvCorrectionFactor_Auto"></a>
      <li><b>pvCorrectionFactor_Auto </b> <br><br>

      Schaltet die automatische Vorhersagekorrektur ein/aus.
      Die Wirkungsweise unterscheidet sich je nach gewählter Methode. <br>
      (default: off)
      <br><br>

      <b>noLearning:</b> <br>
      Mit dieser Option wird die erzeugte PV Energie der aktuellen Stunde vom Lernprozess (Korrekturfaktoren
      sowie KI) ausgeschlossen. <br>
      Die zuvor eingestellte Autokorrekturmethode wird weiterhin angewendet.
      <br><br>

      <b>on_simple(_ai):</b> <br>
      Bei dieser Methode wird die stündlich vorhergesagte mit der real erzeugten Energiemenge verglichen und daraus ein
      für die Zukunft verwendeter Korrekturfaktor für die jeweilige Stunde erstellt. Die von der gewählten API gelieferten
      Prognosedaten werden <b>nicht</b> zusätzlich mit weiteren Bedingungen wie den Bewölkungszustand oder Temperaturen in
      Beziehung gesetzt.<br>
      Ist die KI-Unterstützung eingeschaltet (on_simple_ai) und wird durch die KI ein PV-Prognosewert geliefert, wird dieser Wert
      anstatt des API-Wertes verwendet.
      <br><br>

      <b>on_complex(_ai):</b> <br>
      Bei dieser Methode wird die stündlich vorhergesagte mit der real erzeugten Energiemenge verglichen und daraus ein
      für die Zukunft verwendeter Korrekturfaktor für die jeweilige Stunde erstellt. Die von der gewählten API gelieferten
      Prognosedaten werden außerdem zusätzlich mit weiteren Bedingungen wie den Bewölkungszustand oder Temperaturen
      verknüpft.<br>
      Ist die KI-Unterstützung eingeschaltet (on_complex_ai) und wird durch die KI ein PV-Prognosewert geliefert, wird dieser Wert
      anstatt des API-Wertes verwendet.
      <br><br>

      <b>Hinweis:</b> Die automatische Vorhersagekorrektur ist lernend und benötigt Zeit um die Korrekturwerte zu optimieren.
      Nach der Aktivierung sind nicht sofort optimale Vorhersagen zu erwarten!
      <br><br>

      <b>on_complex_api_ai:</b> <br>
      Die Methode arbeitet wie 'on_complex_ai', jedoch wird der verwendete PV-Prognosewert durch eine Durchschnittsberechnung
      von gelieferten API-Wert und KI-Wert gebildet.
      <br><br>

      Nachfolgend einige API-spezifische Hinweise die lediglich Best Practice Empfehlungen darstellen.
      <br><br>

      <b>Model OpenMeteo...API:</b> <br>
      Die empfohlene Autokorrekturmethode ist <b>on_complex</b> bzw. <b>on_complex_ai</b>.
      <br><br>

      <b>Model SolCastAPI:</b> <br>
      Die empfohlene Autokorrekturmethode ist <b>on_complex</b>. <br>
      Bevor man die Autokorrektur eingeschaltet, ist die Prognose mit folgenden Schritten zu optimieren: <br><br>
      <ul>
         <li>
         definiere im RoofTop-Editor der SolCast API den
         <a href="https://articles.solcast.com.au/en/articles/2959798-what-is-the-efficiency-factor?_ga=2.119610952.1991905456.1665567573-1390691316.1665567573"><b>efficiency factor</b></a>
         entsprechend dem Alter der Anlage. <br>
         Bei einer 8 Jahre alten Anlage wäre er 84 (100 - (8 x 2%)). <br>
         </li>
         <li>
         nach Sonnenuntergang wird das Reading Today_PVdeviation erstellt, welches die Abweichung zwischen Prognose und
         realer PV Erzeugung in Prozent darstellt.
         </li>
         </li>
         <li>
         entsprechend der Abweichung passe den efficiency factor in Schritten an bis ein Optimum, d.h. die kleinste
         Tagesabweichung gefunden ist
         </li>
         <li>
         ist man der Auffassung die optimale Einstellung gefunden zu haben, kann pvCorrectionFactor_Auto on* gesetzt werden.
         </li>
      </ul>
      <br>

      Idealerweise wird dieser Prozess in einer Phase stabiler meteorologischer Bedingungen (gleichmäßige Sonne bzw.
      Bewölkung) durchgeführt.
      <br><br>

      <b>Model VictronKiAPI:</b> <br>
      Dieses Model basiert auf der KI gestützten API von Victron Energy.
      Die empfohlene Autokorrekturmethode ist <b>off</b>. <br><br>

      <b>Model DWD:</b> <br>
      Die empfohlene Autokorrekturmethode ist <b>on_complex</b> bzw. <b>on_complex_ai</b>. <br><br>

      <b>Model ForecastSolarAPI:</b> <br>
      Die empfohlene Autokorrekturmethode ist <b>on_complex</b>.
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-pvCorrectionFactor_" data-pattern="pvCorrectionFactor_.*"></a>
      <li><b>pvCorrectionFactor_XX &lt;Zahl&gt; </b> <br><br>

      Voreinstellung des Korrekturfaktors für die Stunde XX des Tages. <br>
      (default: 1.0)  <br><br>

      In Abhängigkeit vom Setting <a href="#SolarForecast-set-pvCorrectionFactor_Auto ">pvCorrectionFactor_Auto </a> ('off' bzw. 'on_.*') erfolgt
      eine statische oder dynamische Voreinstellung: <br><br>

      <ul>
         <table>
         <colgroup> <col width="10%"> <col width="90%"> </colgroup>
            <tr><td> <b>off</b>     </td><td>Der eingestellte Korrekturfaktor wird durch die Autokorrektur nicht überschrieben.             </td></tr>
            <tr><td>                </td><td>Im Reading pvCorrectionFactor_XX wird der Status durch den Zusatz 'manual fix' signalisiert.   </td></tr>
            <tr><td>                </td><td>                                                                                               </td></tr>
            <tr><td> <b>on_.*</b>   </td><td>Der eingestellte Korrekturfaktor wird durch die Autokorrektur bzw. KI überschrieben            </td></tr>
            <tr><td>                </td><td>sofern ein berechneter Korrekturwert im System verfügbar ist.                                  </td></tr>
            <tr><td>                </td><td>Im Reading pvCorrectionFactor_XX wird der Status durch den Zusatz 'manual flex' signalisiert.  </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-reset"></a>
      <li><b>reset </b> <br><br>

       Löscht die aus der Drop-Down Liste gewählte Datenquelle, zu der Funktion gehörende Readings oder weitere interne
       Datenstrukturen. <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>aiData</b>             </td><td>löscht eine vorhandene KI Instanz inklusive aller Trainings- und Rohdaten und initialisiert sie neu                                   </td></tr>
            <tr><td> <b>batteryTriggerSet</b>  </td><td>löscht die Triggerpunkte des Batteriespeichers                                                                                        </td></tr>
            <tr><td> <b>consumerPlanning</b>   </td><td>löscht die Planungsdaten aller registrierten Verbraucher                                                                              </td></tr>
            <tr><td>                           </td><td>Um die Planungsdaten nur eines Verbrauchers zu löschen verwendet man:                                                                 </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumerPlanning &lt;Verbrauchernummer&gt; </ul>                                                           </td></tr>
            <tr><td>                           </td><td>Das Modul führt eine automatische Neuplanung der Verbraucherschaltung durch.                                                          </td></tr>
            <tr><td> <b>consumerMaster</b>     </td><td>löscht die aktuellen und historischen Daten aller registrierten Verbraucher aus dem Speicher                                          </td></tr>
            <tr><td>                           </td><td>Die definierten Consumer Attribute bleiben bestehen und die Daten werden neu gesammelt.                                               </td></tr>
            <tr><td>                           </td><td>Um die Daten nur eines Verbrauchers zu löschen verwendet man:                                                                         </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumerMaster &lt;Verbrauchernummer&gt; </ul>                                                             </td></tr>
            <tr><td> <b>consumptionHistory</b> </td><td>löscht die gespeicherten Verbrauchswerte des Hauses aus dem pvHistory Speicher                                                        </td></tr>
            <tr><td>                           </td><td>Um die Verbrauchswerte eines bestimmten Tages zu löschen:                                                                             </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumptionHistory &lt;Tag&gt;   (z.B. set &lt;name&gt; reset consumptionHistory 08) </ul>                 </td></tr>
            <tr><td>                           </td><td>Um die Verbrauchswerte einer bestimmten Stunde eines Tages zu löschen:                                                                </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset consumptionHistory &lt;Tag&gt; &lt;Stunde&gt; (z.B. set &lt;name&gt; reset consumptionHistory 08 10) </ul> </td></tr>
            <tr><td> <b>energyH4TriggerSet</b> </td><td>löscht die 4-Stunden Energie Triggerpunkte                                                                                            </td></tr>
            <tr><td> <b>powerTriggerSet</b>    </td><td>löscht die Triggerpunkte für PV Erzeugungswerte                                                                                       </td></tr>
            <tr><td> <b>pvCorrection</b>       </td><td>Löscht die Readings pvCorrectionFactor* sowie verborgene Steuerreadings des Korrektursystems.                                         </td></tr>
            <tr><td>                           </td><td>Um alle bisher gespeicherten PV Korrekturfaktoren aus den Caches zu löschen:                                                          </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvCorrection cached </ul>                                                                                  </td></tr>
            <tr><td>                           </td><td>Um gespeicherte PV Korrekturfaktoren einer bestimmten Stunde aus den Caches zu löschen:                                               </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvCorrection cached &lt;Stunde&gt;  </ul>                                                                  </td></tr>
            <tr><td>                           </td><td><ul>(z.B. set &lt;name&gt; reset pvCorrection cached 10)       </ul>                                                                  </td></tr>
            <tr><td> <b>pvHistory</b>          </td><td>löscht den Speicher aller historischen Tage (01 ... 31)                                                                               </td></tr>
            <tr><td>                           </td><td>Um einen bestimmten historischen Tag zu löschen:                                                                                      </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvHistory &lt;Tag&gt;   (z.B. set &lt;name&gt; reset pvHistory 08) </ul>                                   </td></tr>
            <tr><td>                           </td><td>Um eine bestimmte Stunde eines historischer Tages zu löschen:                                                                         </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset pvHistory &lt;Tag&gt; &lt;Stunde&gt;  (z.B. set &lt;name&gt; reset pvHistory 08 10) </ul>                  </td></tr>
            <tr><td> <b>roofIdentPair</b>      </td><td>löscht alle gespeicherten SolCast API Rooftop-ID / API-Key Paare                                                                      </td></tr>
            <tr><td>                           </td><td>Um ein bestimmtes Paar zu löschen ist dessen Schlüssel &lt;pk&gt; anzugeben:                                                          </td></tr>
            <tr><td>                           </td><td><ul>set &lt;name&gt; reset roofIdentPair &lt;pk&gt;   (z.B. set &lt;name&gt; reset roofIdentPair p1) </ul>                            </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-roofIdentPair"></a>
      <li><b>roofIdentPair &lt;pk&gt; rtid=&lt;Rooftop-ID&gt; apikey=&lt;SolCast API Key&gt; </b> <br>
       (nur bei Verwendung Model SolCastAPI) <br><br>

       Der Abruf jedes in <a href='https://toolkit.solcast.com.au/rooftop-sites' target='_blank'>SolCast Rooftop Sites</a>
       angelegten Rooftops ist mit der Angabe eines Paares <b>Rooftop-ID</b> und <b>API-Key</b> zu identifizieren. <br>
       Der Schlüssel &lt;pk&gt; kennzeichnet eindeutig ein verbundenes Paar Rooftop-ID / API-Key. Es können beliebig viele
       Paare <b>nacheinander</b> angelegt werden. In dem Fall ist jeweils ein neuer Name für "&lt;pk&gt;" zu verwenden.
       <br><br>

       Der Schlüssel &lt;pk&gt; wird im Attribut <a href="#SolarForecast-attr-setupRoofTops">setupRoofTops</a> dem abzurufenden
       Rooftop (=String) zugeordnet.
       <br><br>

       <ul>
        <b>Beispiele: </b> <br>
        set &lt;name&gt; roofIdentPair p1 rtid=92fc-6796-f574-ae5f apikey=oNHDbkKuC_eGEvZe7ECLl6-T1jLyfOgC <br>
        set &lt;name&gt; roofIdentPair p2 rtid=f574-ae5f-92fc-6796 apikey=eGEvZe7ECLl6_T1jLyfOgC_oNHDbkKuC <br>
       </ul>

        <br>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-set-vrmCredentials"></a>
      <li><b>vrmCredentials user=&lt;Benutzer&gt; pwd=&lt;Paßwort&gt; idsite=&lt;idSite&gt; </b> <br>
      (nur bei Verwendung Model VictronKiAPI) <br><br>

       Wird die Victron VRM API genutzt, sind mit diesem set-Befehl die benötigten Zugangsdaten zu hinterlegen. <br><br>

      <ul>
         <table>
         <colgroup> <col width="10%"> <col width="90%"> </colgroup>
            <tr><td> <b>user</b>   </td><td>Benutzername für das Victron VRM Portal                                           </td></tr>
            <tr><td> <b>pwd</b>    </td><td>Paßwort für den Zugang zum Victron VRM Portal                                     </td></tr>
            <tr><td> <b>idsite</b> </td><td>idSite ist der Bezeichner "XXXXXX" in der Victron VRM Portal Dashboard URL.       </td></tr>
            <tr><td>               </td><td>URL des Victron VRM Dashboard ist:                                                </td></tr>
            <tr><td>               </td><td>https://vrm.victronenergy.com/installation/<b>XXXXXX</b>/dashboard                </td></tr>
         </table>
      </ul>
      <br>

      Um die gespeicherten Credentials zu löschen, ist dem Kommando nur das Argument <b>delete</b> zu übergeben. <br><br>

       <ul>
        <b>Beispiele: </b> <br>
        set &lt;name&gt; vrmCredentials user=john@example.com pwd=somepassword idsite=212008 <br>
        set &lt;name&gt; vrmCredentials delete <br>
       </ul>

      </li>
    </ul>
    <br>

  </ul>
  <br>

  <a id="SolarForecast-get"></a>
  <b>Get</b>
  <ul>
    <ul>
      <a id="SolarForecast-get-data"></a>
      <li><b>data </b> <br><br>
      Startet die Datensammlung zur Bestimmung der solaren Vorhersage und anderer Werte.
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-dwdCatalog"></a>
      <li><b>dwdCatalog </b> <br><br>
      Der Deutsche Wetterdienst (DWD) stellt einen Katalog der MOSMIX Stationen zur Verfügung. <br>
      Die Stationen liefern Daten deren Bedeutung in dieser
      <a href='https://www.dwd.de/DE/leistungen/opendata/help/schluessel_datenformate/kml/mosmix_elemente_xls.html' target='_blank'>Übersicht</a>
      erläutert ist. Der DWD unterscheidet dabei zwischen MOSMIX_L und MOSMIX_S Stationen die sich durch Aktualisierungfrequenz
      und Datenumfang unterscheiden. <br>
      Mit diesem Kommando wird der Katalog in SolarForecast eingelesen und in der Datei
      ./FHEM/FhemUtils/DWDcat_SolarForecast gespeichert. <br>
      Der Katalog kann umfangreich gefiltert und im GPS Exchange Format (GPX) gespeichert werden.
      Die Koordinaten Latitude und Logitude werden in Dezimalgrad ausgegeben. <br>
      Zur Filterung werden Regex-Ausdrücke in den entsprechenden Schlüsseln verwendet. Der Regex wird zur Auswertung in
      ^...$ eingeschlossen. <br>
      Folgende Parameter können angegeben werden. Ohne Parameter erfolgt die Ausgabe des gesamten Katalogs: <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>byID</b>               </td><td>Die Ausgabe erfolgt sortiert nach Stations-ID. (default)                                                                        </td></tr>
            <tr><td> <b>byName</b>             </td><td>Die Ausgabe erfolgt sortiert nach Stations-Name.                                                                                </td></tr>
            <tr><td> <b>force</b>              </td><td>Es wird die neueste Version des DWD Stationskatalogs in das System geladen.                                                     </td></tr>
            <tr><td> <b>exportgpx</b>          </td><td>Die (gefilterten) Stationen werden in der Datei ./FHEM/FhemUtils/DWDcat_SolarForecast.gpx gespeichert.                          </td></tr>
            <tr><td>                           </td><td>Diese Datei kann z.B. im <a href='https://www.j-berkemeier.de/ShowGPX.html' target='_blank'>GPX-Viewer</a> dargestellt werden.  </td></tr>
            <tr><td> <b>id=&lt;Regex&gt;</b>   </td><td>Es erfolgt eine Filterung nach Stations-ID.                                                                                     </td></tr>
            <tr><td> <b>name=&lt;Regex&gt;</b> </td><td>Es erfolgt eine Filterung nach Stations-Name.                                                                                   </td></tr>
            <tr><td> <b>lat=&lt;Regex&gt;</b>  </td><td>Es erfolgt eine Filterung nach Latitude.                                                                                        </td></tr>
            <tr><td> <b>lon=&lt;Regex&gt;</b>  </td><td>Es erfolgt eine Filterung nach Longitude.                                                                                       </td></tr>
         </table>
      </ul>
      <br>

       <ul>
        <b>Beispiel: </b> <br>
        get &lt;name&gt; dwdCatalog byName name=ST.* exportgpx lat=(48|49|50|51|52)\..* lon=([5-9]|10|11|12|13|14|15)\..* <br>
        # filtert die Stationen weitgehend auf deutsche Orte beginnend mit "ST" und exportiert die Daten im GPS Exchange Format
       </ul>

    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-forecastQualities"></a>
      <li><b>forecastQualities </b> <br><br>
      Zeigt die zur Bestimmung der PV Vorhersage aktuell verwendeten Korrekturfaktoren mit der jeweiligen Startzeit sowie
      die bisher im Durchschnitt erreichte Vorhersagequalität dieses Zeitraumes an.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-ftuiFramefiles"></a>
      <li><b>ftuiFramefiles </b> <br><br>
      SolarForecast stellt Widgets für
      <a href='https://wiki.fhem.de/wiki/FHEM_Tablet_UI' target='_blank'>FHEM Tablet UI v2 (FTUI2)</a> zur Verfügung. <br>
      Ist FTUI2 auf dem System installiert, können die Dateien für das Framework mit diesem Kommando in die
      FTUI-Verzeichnisstruktur geladen werden. <br>
      Die Einrichtung und Verwendung der Widgets ist im Wiki
      <a href='https://wiki.fhem.de/wiki/SolarForecast_FTUI_Widget' target='_blank'>SolarForecast FTUI Widget</a>
      beschrieben.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-html"></a>
      <li><b>html </b> <br><br>
      Die SolarForecast Grafik wird als HTML-Code abgerufen und wiedergegeben. <br>
      <b>Hinweis:</b> Durch das Attribut <a href="#SolarForecast-attr-graphicHeaderOwnspec ">graphicHeaderOwnspec</a>
      generierte set-Kommandos oder Attribut-Befehle im Anwender spezifischen Bereich des Headers werden aus technischen
      Gründen generell ausgeblendet. <br>
      Als Argument kann dem Befehl eine der folgenden Selektionen mitgegeben werden:
      <br><br>

       <ul>
         <table>
         <colgroup> <col width="30%"> <col width="70%"> </colgroup>
         <tr><td> <b>both</b>                    </td><td>zeigt Grafikkopf, Verbraucherpaneel, Balken- und Energieflußgrafik an (default)       </td></tr>
         <tr><td> <b>both_noHead</b>             </td><td>zeigt Verbraucherpaneel, Balken- und Energieflußgrafik an                             </td></tr>
         <tr><td> <b>both_noCons</b>             </td><td>zeigt Grafikkopf, Balken- und Energieflußgrafik an                                    </td></tr>
         <tr><td> <b>both_noHead_noCons</b>      </td><td>zeigt Balken- und Energieflußgrafik an                                                </td></tr>
         <tr><td> <b>swap</b>                    </td><td>wie 'both', mit vertauschter Balken- und Energieflußgrafik Reihenfolge                </td></tr>
         <tr><td> <b>swap_noHead</b>             </td><td>wie 'both_noHead', mit vertauschter Balken- und Energieflußgrafik Reihenfolge         </td></tr>
         <tr><td> <b>swap_noCons</b>             </td><td>wie 'both_noCons', mit vertauschter Balken- und Energieflußgrafik Reihenfolge         </td></tr>
         <tr><td> <b>swap_noHead_noCons</b>      </td><td>wie 'both_noHead_noCons', mit vertauschter Balken- und Energieflußgrafik Reihenfolge  </td></tr>
         <tr><td> <b>flow</b>                    </td><td>zeigt Grafikkopf, Verbraucherpaneel und Energieflußgrafik an                          </td></tr>
         <tr><td> <b>flow_noHead</b>             </td><td>zeigt Verbraucherpaneel und Energieflußgrafik an                                      </td></tr>
         <tr><td> <b>flow_noCons</b>             </td><td>zeigt Grafikkopf und Energieflußgrafik an                                             </td></tr>
         <tr><td> <b>flow_noHead_noCons</b>      </td><td>zeigt Energieflußgrafik an                                                            </td></tr>
         <tr><td> <b>forecast</b>                </td><td>zeigt Grafikkopf, Verbraucherpaneel und Balkengrafik an                               </td></tr>
         <tr><td> <b>forecast_noHead</b>         </td><td>zeigt Verbraucherpaneel und Balkengrafik an                                           </td></tr>
         <tr><td> <b>forecast_noCons</b>         </td><td>zeigt Grafikkopf und Balkengrafik an                                                  </td></tr>
         <tr><td> <b>forecast_noHead_noCons</b>  </td><td>zeigt Balkengrafik an                                                                 </td></tr>
         <tr><td> <b>none</b>                    </td><td>zeigt nur Grafikkopf und Verbraucherpaneel an                                         </td></tr>
         </table>
       </ul>
      <br>

      Die Grafik kann abgerufen und in eigenen Code eingebettet werden. Auf einfache Weise kann dies durch die Definition
      eines weblink-Devices vorgenommen werden: <br><br>

      <ul>
        define wl.SolCast5 weblink htmlCode { FHEM::SolarForecast::pageAsHtml ('SolCast5', '-', '&lt;argument&gt;') }
      </ul>
      <br>
      'SolCast5' ist der Name des einzubindenden SolarForecast-Device. <b>&lt;argument&gt;</b> ist eine der oben
      beschriebenen Auswahlmöglichkeiten.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-nextHours"></a>
      <li><b>nextHours </b> <br><br>
      Listet die gespeicherte Werte der kommenden Stunden auf. <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>aihit</b>           </td><td>Lieferstatus der KI für die PV Vorhersage (0-keine Lieferung, 1-Lieferung)                 </td></tr>
            <tr><td> <b>confc</b>           </td><td>erwarteter Energieverbrauch inklusive der Anteile registrierter Verbraucher                </td></tr>
            <tr><td> <b>confcEx</b>         </td><td>erwarteter Energieverbrauch ohne Anteile Verbraucher mit gesetztem Schlüssel exconfc=1     </td></tr>
            <tr><td> <b>crange</b>          </td><td>berechneter Bewölkungsbereich                                                              </td></tr>
            <tr><td> <b>correff</b>         </td><td>verwendeter Korrekturfaktor/Qualität                                                       </td></tr>
            <tr><td>                        </td><td>&lt;Faktor&gt;/- -> keine Qualität definiert                                               </td></tr>
            <tr><td>                        </td><td>&lt;Faktor&gt;/0..1 - Qualität der PV Prognose (1 = beste Qualität)                        </td></tr>
            <tr><td> <b>day</b>             </td><td>Tagesdatum                                                                                 </td></tr>
            <tr><td> <b>DaysInRange</b>     </td><td>bisher aufgezeichnete Tage mit vergleichbaren Sonnenstand und Bewölkungen zu dieser Zeit   </td></tr>
            <tr><td> <b>DoN</b>             </td><td>Sonnenauf- und untergangsstatus (0 - Nacht, 1 - Tag)                                       </td></tr>
            <tr><td> <b>hourofday</b>       </td><td>laufende Stunde des Tages                                                                  </td></tr>
            <tr><td> <b>pvapifcraw</b>      </td><td>erwartete PV Erzeugung (Wh) der verwendeten API (raw)                                      </td></tr>
            <tr><td> <b>pvapifc</b>         </td><td>erwartete PV Erzeugung (Wh) der verwendeten API inkl. einer eventuellen Korrektur          </td></tr>
            <tr><td> <b>pvaifc</b>          </td><td>erwartete PV Erzeugung der KI (Wh)                                                         </td></tr>
            <tr><td> <b>pvfc</b>            </td><td>verwendete PV Erzeugungsprognose (Wh)                                                      </td></tr>
            <tr><td> <b>rad1h</b>           </td><td>vorhergesagte Globalstrahlung                                                              </td></tr>
            <tr><td> <b>starttime</b>       </td><td>Startzeit des Datensatzes                                                                  </td></tr>
            <tr><td> <b>sunaz</b>           </td><td>Azimuth der Sonne (in Dezimalgrad)                                                         </td></tr>
            <tr><td> <b>sunalt</b>          </td><td>Höhe der Sonne (in Dezimalgrad)                                                            </td></tr>
            <tr><td> <b>temp</b>            </td><td>vorhergesagte Außentemperatur                                                              </td></tr>
            <tr><td> <b>today</b>           </td><td>hat Wert '1' wenn Startdatum am aktuellen Tag                                              </td></tr>
            <tr><td> <b>rcdchargebatXX</b>  </td><td>Aufladeempfehlung mit voller Leistung für Batterie XX (1 - Ja, 0 - Nein)                   </td></tr>
            <tr><td> <b>lcintimebatXX</b>   </td><td>Lademanagement für Batterie XX ist aktiviert bzw. wird aktiviert sein (1 - Ja, 0 - Nein)   </td></tr>
            <tr><td> <b>strategybatXX</b>   </td><td>die gewählte Ladestrategie                                                                 </td></tr>
            <tr><td> <b>rr1c</b>            </td><td>Gesamtniederschlag in der letzten Stunde kg/m2                                             </td></tr>
            <tr><td> <b>rrange</b>          </td><td>Bereich des Gesamtniederschlags                                                            </td></tr>
            <tr><td> <b>socXX</b>           </td><td>aktueller (NextHour00) oder prognostizierter SoC (%) der Batterie XX                       </td></tr>
            <tr><td> <b>socprogwhsum</b>    </td><td>aktueller (NextHour00) oder prognostizierter SoC (Wh) zusammengefasst über alle Batterien  </td></tr>
            <tr><td> <b>weatherid</b>       </td><td>ID des vorhergesagten Wetters                                                              </td></tr>
            <tr><td> <b>wcc</b>             </td><td>vorhergesagter Grad der Bewölkung                                                          </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-pvHistory"></a>
      <li><b>pvHistory </b> <br><br>
      Zeigt oder exportiert den Inhalt des pvHistory Datenspeichers sortiert nach dem Tagesdatum und Stunde. <br>
      Mit der Auswahlliste kann ein bestimmter Tag angesprungen werden. Die Drop-Down Liste enthält die aktuell
      im Speicher verfügbaren Tage.
      Ohne Argument wird der gesamte Datenspeicher gelistet.
      Die Angabe 'exportToCsv' exportiert den gesamten Inhalt der pvHistory in eine CSV-Datei. <br>

      Die Stundenangaben beziehen sich auf die jeweilige Stunde des Tages, z.B. bezieht sich die Stunde 09 auf die Zeit
      von 08 Uhr bis 09 Uhr. Die Stunde '99' enthält Tageswerte.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>batintotalXX</b>    </td><td>Gesamtladung der Batterie XX (Wh) zu Beginn der Stunde                                                 </td></tr>
            <tr><td> <b>batinXX</b>         </td><td>Ladung der Batterie XX innerhalb der Stunde (Wh)                                                       </td></tr>
            <tr><td> <b>batouttotalXX</b>   </td><td>Gesamtentladung der Batterie XX (Wh) zu Beginn der Stunde                                              </td></tr>
            <tr><td> <b>batoutXX</b>        </td><td>Entladung der Batterie XX innerhalb der Stunde (Wh)                                                    </td></tr>
            <tr><td> <b>batprogsocXX</b>    </td><td>prognostizierte Ladezustand SOC (%) der Batterie XX am Ende der Stunde                                 </td></tr>
            <tr><td> <b>batsocXX</b>        </td><td>realer Ladezustand SOC (%) der Batterie XX am Ende der Stunde                                          </td></tr>
            <tr><td> <b>batmaxsocXX</b>     </td><td>maximal erreichter SOC (%) der Batterie XX an dem Tag                                                  </td></tr>
            <tr><td> <b>batsetsocXX</b>     </td><td>optimaler SOC Sollwert (%) der Batterie XX für den Tag                                                 </td></tr>
            <tr><td> <b>csmtXX</b>          </td><td>Energieverbrauch total von ConsumerXX                                                                  </td></tr>
            <tr><td> <b>csmeXX</b>          </td><td>Energieverbrauch von ConsumerXX in der Stunde des Tages (Stunde 99 = Tagesenergieverbrauch)            </td></tr>
            <tr><td> <b>confc</b>           </td><td>erwarteter Energieverbrauch (Wh)                                                                       </td></tr>
            <tr><td> <b>con</b>             </td><td>realer Energieverbrauch (Wh) des Hauses                                                                </td></tr>
            <tr><td> <b>conprice</b>        </td><td>Preis für den Bezug einer kWh. Die Einheit des Preises ist im setupMeterDev definiert.                 </td></tr>
            <tr><td> <b>cyclescsmXX</b>     </td><td>Anzahl aktive Zyklen von ConsumerXX des Tages                                                          </td></tr>
            <tr><td> <b>dayname</b>         </td><td>Kurzname des Tages (locale-abhängig)                                                                   </td></tr>
            <tr><td> <b>DoN</b>             </td><td>Sonnenauf- und untergangsstatus (0 - Nacht, 1 - Tag)                                                   </td></tr>
            <tr><td> <b>etotaliXX</b>       </td><td>PV Zählerstand "Energieertrag total" (Wh) von Inverter XX zu Beginn der Stunde                         </td></tr>
            <tr><td> <b>etotalpXX</b>       </td><td>Zählerstand "Energieertrag total" (Wh) des Produzenten XX zu Beginn der Stunde                         </td></tr>
            <tr><td> <b>gcons</b>           </td><td>realer Bezug (Wh) aus dem Stromnetz                                                                    </td></tr>
            <tr><td> <b>gfeedin</b>         </td><td>reale Einspeisung (Wh) in das Stromnetz                                                                </td></tr>
            <tr><td> <b>feedprice</b>       </td><td>Vergütung für die Einpeisung einer kWh. Die Währung des Preises ist im setupMeterDev definiert.        </td></tr>
            <tr><td> <b>avgcycmntscsmXX</b> </td><td>durchschnittliche Dauer eines Einschaltzyklus des Tages von ConsumerXX in Minuten                      </td></tr>
            <tr><td> <b>hourscsmeXX</b>     </td><td>Summe Aktivstunden des Tages von ConsumerXX                                                            </td></tr>
            <tr><td> <b>lcintimebatXX</b>   </td><td>das Lademanagement für Batterie XX war aktiviert (1 - Ja, 0 - Nein)                                    </td></tr>
            <tr><td> <b>strategybatXX</b>   </td><td>die gewählte Ladestrategie                                                                             </td></tr>
            <tr><td> <b>minutescsmXX</b>    </td><td>Summe Aktivminuten in der Stunde von ConsumerXX                                                        </td></tr>
            <tr><td> <b>plantderated</b>    </td><td>Zeitstempel des ersten Abregelungsvorfalls der Anlage in dieser Stunde, sonst '0'                      </td></tr>
            <tr><td> <b>pprlXX</b>          </td><td>Energieerzeugung des Produzenten XX (siehe Attribut setupOtherProducerXX) in der Stunde (Wh)           </td></tr>
            <tr><td> <b>pvapifcraw</b>      </td><td>erwartete PV Erzeugung (Wh) der verwendeten API (raw)                                                  </td></tr>
            <tr><td> <b>pvfc</b>            </td><td>der prognostizierte PV Ertrag (Wh)                                                                     </td></tr>
            <tr><td> <b>pvrlXX</b>          </td><td>reale PV Erzeugung (Wh) von Inverter XX                                                                </td></tr>
            <tr><td> <b>pvrl</b>            </td><td>Summe reale PV Erzeugung (Wh) aller Inverter                                                           </td></tr>
            <tr><td> <b>pvrlvd</b>          </td><td>1-'pvrl' ist gültig und wird im Lernprozess berücksichtigt, 0-'pvrl' ist als komprimittiert bewertet   </td></tr>
            <tr><td> <b>pvcorrf</b>         </td><td>verwendeter Autokorrekturfaktor / erreichte Prognosequalität                                           </td></tr>
            <tr><td> <b>rad1h</b>           </td><td>Globalstrahlung (kJ/m2)                                                                                </td></tr>
            <tr><td> <b>rr1c</b>            </td><td>Gesamtniederschlag in der letzten Stunde kg/m2                                                         </td></tr>
            <tr><td> <b>socwhsum</b>        </td><td>real erreichter SoC (Wh) zusammengefasst über alle Batterien                                           </td></tr>
            <tr><td> <b>socprogwhsum</b>    </td><td>prognostizierter SoC (Wh) zusammengefasst über alle Batterien                                          </td></tr>
            <tr><td> <b>sunalt</b>          </td><td>Höhe der Sonne (in Dezimalgrad)                                                                        </td></tr>
            <tr><td> <b>sunaz</b>           </td><td>Azimuth der Sonne (in Dezimalgrad)                                                                     </td></tr>
            <tr><td> <b>wid</b>             </td><td>Identifikationsnummer des Wetters                                                                      </td></tr>
            <tr><td> <b>wcc</b>             </td><td>effektive Wolkenbedeckung                                                                              </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-pvCircular"></a>
      <li><b>pvCircular </b> <br><br>
      Listet die gespeicherten Daten der ausgewählten Stunde oder alle vorhandenen Werte im Ringspeicher auf. <br>
      Die Stundenangaben 01 - 24 beziehen sich auf die Stunde des Tages, z.B. bezieht sich die Stunde 09 auf die Zeit von
      08 - 09 Uhr. <br>
      Die Stunde 99 hat eine Sonderfunktion. <br>
      Die Werte der Schlüssel pvcorrf, quality, pvrlsum, pvfcsum und dnumsum sind in der Form
      &lt;Bereich Sonnenstand Höhe&gt;.&lt;Bewölkungsbereich&gt; kodiert.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>aihit</b>               </td><td>Lieferstatus der KI für die PV Vorhersage (0-keine Lieferung, 1-Lieferung)                                                </td></tr>
            <tr><td> <b>attrInvChangedTs</b>    </td><td>Zeitstempel der letzten Änderung der Inverter Gerätedefinition                                                            </td></tr>
            <tr><td> <b>batinXX</b>             </td><td>Ladung der Batterie XX (Wh)                                                                                               </td></tr>
            <tr><td> <b>batoutXX</b>            </td><td>Entladung der Batterie XX (Wh)                                                                                            </td></tr>
            <tr><td> <b>batouttotXX</b>         </td><td>aktuell total aus der Batterie XX entnommene Energie (Wh)                                                                 </td></tr>
            <tr><td> <b>batintotXX</b>          </td><td>aktuell total in die Batterie XX geladene Energie (Wh)                                                                    </td></tr>
            <tr><td> <b>confc</b>               </td><td>erwarteter Energieverbrauch (Wh) des Hauses am aktuellen Tag                                                              </td></tr>
            <tr><td> <b>con_all</b>             </td><td>ein Array aus Werten des Hausverbrauches (Wh) an bestimmten Tagen der ausgewählten Stunde                                 </td></tr>
            <tr><td> <b>days2careXX</b>         </td><td>verbleibende Tage bis der Batterie XX Pflege-SoC (default 95%) erreicht sein soll                                         </td></tr>
            <tr><td> <b>dnumsum</b>             </td><td>Anzahl Tage pro Bewölkungsbereich über die gesamte Laufzeit                                                               </td></tr>
            <tr><td> <b>feedintotal</b>         </td><td>in das öffentliche Netz total eingespeiste PV Energie (Wh)                                                                </td></tr>
            <tr><td> <b>gcons</b>               </td><td>realer Energiebezug (Wh) aus dem Stromnetz                                                                                </td></tr>
            <tr><td> <b>gcons_a</b>             </td><td>ein Array aus Werten des Energiebezuges (Wh) aus dem öffentlichen Netz an bestimmten Tagen der ausgewählten Stunde        </td></tr>
            <tr><td> <b>gfeedin</b>             </td><td>reale Leistungseinspeisung in das Stromnetz                                                                               </td></tr>
            <tr><td> <b>gridcontotal</b>        </td><td>vom öffentlichen Netz total bezogene Energie (Wh)                                                                         </td></tr>
            <tr><td> <b>initdayfeedin</b>       </td><td>initialer PV Einspeisewert zu Beginn des aktuellen Tages (Wh)                                                             </td></tr>
            <tr><td> <b>initdaygcon</b>         </td><td>initialer Netzbezugswert zu Beginn des aktuellen Tages (Wh)                                                               </td></tr>
            <tr><td> <b>initdaybatintotXX</b>   </td><td>initialer Wert der total in die Batterie XX geladenen Energie zu Beginn des aktuellen Tages (Wh)                          </td></tr>
            <tr><td> <b>initdaybatouttotXX</b>  </td><td>initialer Wert der total aus der Batterie XX entnommenen Energie zu Beginn des aktuellen Tages (Wh)                       </td></tr>
            <tr><td> <b>lastTsMaxSocRchdXX</b>  </td><td>Timestamp des letzten Erreichens von Batterie XX SoC >= maxSoC (default 95%)                                              </td></tr>
            <tr><td> <b>nextTsMaxSocChgeXX</b>  </td><td>Timestamp bis zu dem die Batterie XX mindestens einmal maxSoC erreichen soll                                              </td></tr>
            <tr><td> <b>pvapifcraw</b>          </td><td>erwartete PV Erzeugung (Wh) der verwendeten API (raw)                                                                     </td></tr>
            <tr><td> <b>pvapifc</b>             </td><td>erwartete PV Erzeugung (Wh) der verwendeten API incl. angewendetem Korrekturfaktor                                        </td></tr>
            <tr><td> <b>pvaifc</b>              </td><td>PV Vorhersage (Wh) der KI für die nächsten 24h ab aktueller Stunde des Tages                                              </td></tr>
            <tr><td> <b>pvfc</b>                </td><td>verwendete PV Prognose für die nächsten 24h ab aktueller Stunde des Tages                                                 </td></tr>
            <tr><td> <b>pvfc_XX</b>             </td><td>Array der prognostizierten PV-Erzeugung (Raw-Wert in Wh) abhängig vom Bewölkungsgrad, Altitude der Sonne (XX)             </td></tr>
            <tr><td> <b>pvcorrf</b>             </td><td>Autokorrekturfaktoren für die Stunde des Tages, wobei 'simple' der einfach berechnete Korrekturfaktor ist.                </td></tr>
            <tr><td> <b>pvfcsum</b>             </td><td>Summe PV Prognose pro Bewölkungsbereich über die gesamte Laufzeit                                                         </td></tr>
            <tr><td> <b>pvrl</b>                </td><td>reale PV Erzeugung der letzten 24h (Achtung: pvforecast und pvreal beziehen sich nicht auf den gleichen Zeitraum!)        </td></tr>
            <tr><td> <b>pvrl_XX</b>             </td><td>Array realer PV Erzeugungswerte erzeugt bei einem bestimmten Bewölkungsgrad (XX = Altitude der Sonne)                     </td></tr>
            <tr><td> <b>pvrlsum</b>             </td><td>Summe reale PV Erzeugung pro Bewölkungsbereich über die gesamte Laufzeit                                                  </td></tr>
            <tr><td> <b>pprlXX</b>              </td><td>Energieerzeugung des Produzenten XX (siehe Attribut setupOtherProducerXX) der letzten 24 Stunden (Wh)                     </td></tr>
            <tr><td> <b>quality</b>             </td><td>Qualität der Autokorrekturfaktoren (0..1), wobei 'simple' die Qualität des einfach berechneten Korrekturfaktors ist.      </td></tr>
            <tr><td> <b>runTimeTrainAI</b>      </td><td>Laufzeit des letzten KI Trainings                                                                                         </td></tr>
            <tr><td> <b>aitrainLastFinishTs</b> </td><td>Timestamp des letzten erfolgreichen KI Trainings                                                                          </td></tr>
            <tr><td> <b>aiRulesNumber</b>       </td><td>Anzahl der Regeln in der trainierten KI Instanz                                                                           </td></tr>
            <tr><td> <b>todayConsumption</b>    </td><td>realer Energieverbrauch (Wh) des Hauses am aktuellen Tag                                                                  </td></tr>
            <tr><td> <b>tdayDvtn</b>            </td><td>heutige Abweichung PV Prognose/Erzeugung in %                                                                             </td></tr>
            <tr><td> <b>temp</b>                </td><td>Außentemperatur                                                                                                           </td></tr>
            <tr><td> <b>wcc</b>                 </td><td>Grad der Wolkenüberdeckung                                                                                                </td></tr>
            <tr><td> <b>rr1c</b>                </td><td>Gesamtniederschlag in der letzten Stunde kg/m2                                                                            </td></tr>
            <tr><td> <b>wid</b>                 </td><td>ID des vorhergesagten Wetters                                                                                             </td></tr>
            <tr><td> <b>wtxt</b>                </td><td>Beschreibung des vorhergesagten Wetters                                                                                   </td></tr>
            <tr><td> <b>ydayDvtn</b>            </td><td>Abweichung PV Prognose/Erzeugung in % am Vortag                                                                           </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-rooftopData"></a>
      <li><b>rooftopData </b> <br><br>
      Die erwarteten solaren Strahlungsdaten bzw. PV Erzeugungsdaten werden von der gewählten API abgerufen. <br>
      Ist bezüglich Wetterdaten ebenfalls eine API gewählt, werden diese Daten ebenfalls abgerufen.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-radiationApiData"></a>
      <li><b>radiationApiData </b> <br><br>

      Listet die im Kontext des API-Abrufs gespeicherten Strahlungsdaten auf.
      Die von der API gelieferten Vorhersagedaten bzgl. der Globalstrahlung Rad1h und des auf einen String bezogenen
      prognostizierten PV Ertrag (Wh) sind auf eine Stunde normiert.
      Die verfügbaren Kennwerte unterscheiden sich je nach verwendeter API.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>Rad1h</b>          </td><td>erwartete Globalstrahlung (GI) in kJ/m2                                     </td></tr>
            <tr><td> <b>GTIWh</b>          </td><td>erwartete globale Strahlung auf die geneigte Fläche (GTI) in Wh/m2          </td></tr>
            <tr><td> <b>pv_estimateXX</b>  </td><td>erwartete PV Erzeugung (Wh)                                                 </td></tr>
            <tr><td> <b>KI-based</b>       </td><td>erwartete PV Erzeugung (Wh) der VictronKI-API                               </td></tr>
            <tr><td> <b>KI-based_co</b>    </td><td>erwarteter Energieverbrauch (Wh) der VictronKI-API                          </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-statusApiData"></a>
      <li><b>statusApiData </b> <br><br>
      Zeigt die Statusdaten der verwendeten Strahlungsdaten-API bzw. Wetterdaten-API.
      Es werden nur die Statusdaten des führenden Wetterdienstes ausgegeben.
      <br><br>

      <ul>
         <table>
         <colgroup> <col width="37%"> <col width="63%"> </colgroup>
            <tr><td> <b>currentAPIinterval</b>        </td><td>das aktuell verwendete API Abrufintervall in Sekunden              </td></tr>
            <tr><td> <b>lastretrieval_time</b>        </td><td>Zeit des letzten API Abrufs                                        </td></tr>
            <tr><td> <b>lastretrieval_timestamp</b>   </td><td>Unix Timestamp des letzten API Abrufs                              </td></tr>
            <tr><td> <b>todayDoneAPIrequests</b>      </td><td>Anzahl der ausgeführten API Requests am aktuellen Tag              </td></tr>
            <tr><td> <b>todayRemainingAPIrequests</b> </td><td>Anzahl der verbleibenden SolCast API Requests am aktuellen Tag     </td></tr>
            <tr><td> <b>todayDoneAPIcalls</b>         </td><td>Anzahl der ausgeführten API Abrufe am aktuellen Tag                </td></tr>
            <tr><td> <b>todayRemainingAPIcalls</b>    </td><td>Anzahl der noch möglichen SolCast API Abrufe am aktuellen Tag      </td></tr>
            <tr><td>                                  </td><td>(ein Abruf kann mehrere SolCast API Requests ausführen)            </td></tr>
            <tr><td> <b>todayMaxAPIcalls</b>          </td><td>Anzahl der maximal möglichen SolCast API Abrufe pro Tag            </td></tr>
         </table>
      </ul>
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valBattery"></a>
      <li><b>valBattery </b> <br><br>
      Zeigt die ermittelten Betriebswerte der ausgewählten Batterie oder aller definierten Batteriegeräte.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="30%"> <col width="70%"> </colgroup>
            <tr><td> <b>bname </b>          </td><td>Name des Gerätes                                       </td></tr>
            <tr><td> <b>balias </b>         </td><td>Alias des Gerätes                                      </td></tr>
            <tr><td> <b>basynchron </b>     </td><td>Modus der Verarbeitung empfangener Batterie-Events     </td></tr>
            <tr><td> <b>bcharge </b>        </td><td>aktueller SoC (State of Charge) der Batterie (%)       </td></tr>
            <tr><td> <b>bchargewh </b>      </td><td>aktueller SoC (State of Charge) der Batterie (Wh)      </td></tr>
            <tr><td> <b>befficiency </b>    </td><td>Wirkungsgrad des Speichers (%)                         </td></tr>
            <tr><td> <b>binstcap </b>       </td><td>installierte Batteriekapazität (Wh)                    </td></tr>
            <tr><td> <b>bpowerin </b>       </td><td>momentane Ladeleistung (W)                             </td></tr>
            <tr><td> <b>bpinmax </b>        </td><td>maximal mögliche Ladeleistung (W)                      </td></tr>
            <tr><td> <b>bpinreduced </b>    </td><td>reduzierte Ladeleistung (W) z.B. wenn SoC <= lowSoC    </td></tr>
            <tr><td> <b>bpowerout </b>      </td><td>momentane Entladeleistung (W)                          </td></tr>
            <tr><td> <b>bpoutmax </b>       </td><td>maximal mögliche Entladeleistung (W)                   </td></tr>
            <tr><td> <b>bloadAbortCond </b> </td><td>generelle Ladeabbruchbedingung                         </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valConsumerMaster"></a>
      <li><b>valConsumerMaster </b> <br><br>
      Zeigt die Daten der aktuell im SolarForecast Device registrierten Verbraucher. <br>
      Mit der Auswahlliste kann ein bestimmter Verbraucher angesprungen werden. Die Drop-Down Liste enthält die aktuell
      im Datenspeicher verfügbaren Verbraucher bzw. Verbrauchernummern. Ohne Argument wird der gesamte Datenspeicher gelistet.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valCurrent"></a>
      <li><b>valCurrent </b> <br><br>
      Listet aktuelle Betriebsdaten, Kennzahlen und Status auf.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valDecTree"></a>
      <li><b>valDecTree </b> <br><br>

      Anzeige von KI relevanten Daten.
      Die verfügbaren Anzeigeoptionen sind abhängig vom verfügbaren und aktivierten KI Unterstützungslevel.
      <br><br>

      <ul>
       <table>
       <colgroup> <col width="15%"> <col width="85%"> </colgroup>
          <tr><td> <b>aiRawData</b>     </td><td>Anzeige der aktuell für eine KI-Auswertung gespeicherten PV-, Strahlungs- und Umweltdaten. </td></tr>
          <tr><td>                      </td><td>                                                                                           </td></tr>
          <tr><td> <b>aiRuleStrings</b> </td><td>Gibt eine Liste zurück, die den Entscheidungsbaum der KI in Form von Regeln beschreibt.    </td></tr>
          <tr><td>                      </td><td><b>Hinweis:</b> Die Reihenfolge der Regeln ist zwar nicht vorhersehbar, die                </td></tr>
          <tr><td>                      </td><td>Reihenfolge der Kriterien innerhalb jeder Regel spiegelt jedoch die Reihenfolge            </td></tr>
          <tr><td>                      </td><td>wider, in der die Kriterien bei der Entscheidungsfindung geprüft werden.                   </td></tr>
          <tr><td>                      </td><td>(verfügbar wenn ein KI kompatibles SolarForecast MODEL der PV Vorhersage aktiviert ist)    </td></tr>
        </table>
      </ul>
    </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valInverter"></a>
      <li><b>valInverter </b> <br><br>
      Zeigt die ermittelten Betriebswerte des ausgewählten Wechselrichters oder aller definierten Wechselrichter.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>ialias </b>         </td><td>Alias des Gerätes                                                           </td></tr>
            <tr><td> <b>iasynchron </b>     </td><td>Modus der Verarbeitung empfangener Inverter-Events                          </td></tr>
            <tr><td> <b>ietotal </b>        </td><td>Stand gesamte bisher erzeugte Energie des Wechselrichters (Wh)              </td></tr>
            <tr><td> <b>ifeed </b>          </td><td>Eigenschaften der Energielieferung                                          </td></tr>
            <tr><td> <b>ipvin </b>          </td><td>aktuelle DC PV-Eingangsleistung in W (Summe aller angeschlossenen Strings)  </td></tr>
            <tr><td> <b>ipvout </b>         </td><td>aktuelle Leistung aus PV-Erzeugung in W                                     </td></tr>
            <tr><td> <b>iicon </b>          </td><td>die evtl. festgelegten Icons zur Darstellung des Gerätes in der Grafik      </td></tr>
            <tr><td> <b>ilimit </b>         </td><td>eingestellte Leistungsbegrenzung in % (z.B. durch 70% Regel)                </td></tr>
            <tr><td> <b>iname </b>          </td><td>Name des Gerätes                                                            </td></tr>
            <tr><td> <b>invertercap </b>    </td><td>die nominale Leistung (W) des Wechselrichters (falls definiert)             </td></tr>
            <tr><td> <b>ipac2dc </b>        </td><td>aktuelle AC->DC Leistung (W) eines Batterie-Wechselrichters                 </td></tr>
            <tr><td> <b>ipdc2ac </b>        </td><td>aktuelle DC->AC Leistung (W) eines Batterie-Wechselrichters                 </td></tr>
            <tr><td> <b>isource </b>        </td><td>Art der Energiequelle des Inverters                                         </td></tr>
            <tr><td> <b>istrings </b>       </td><td>Liste der dem Wechselrichter zugeordneten Strings (falls definiert)         </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valProducer"></a>
      <li><b>valProducer </b> <br><br>
      Zeigt die ermittelten Betriebswerte des ausgewählten nicht PV-Erzeugers oder aller definierten nicht PV-Erzeuger.  <br><br>

      <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>petotal </b>        </td><td>Stand gesamte bisher erzeugte Energie des Erzeugers (Wh)                    </td></tr>
            <tr><td> <b>pfeed </b>          </td><td>Eigenschaften der Energielieferung                                          </td></tr>
            <tr><td> <b>pgeneration </b>    </td><td>aktuelle Leistung (W)                                                       </td></tr>
            <tr><td> <b>picon </b>          </td><td>die evtl. festgelegten Icons zur Darstellung des Gerätes in der Grafik      </td></tr>
            <tr><td> <b>palias </b>         </td><td>Alias des Gerätes                                                           </td></tr>
            <tr><td> <b>pname </b>          </td><td>Name des Gerätes                                                            </td></tr>
         </table>
      </ul>

      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-valStrings"></a>
      <li><b>valStrings </b> <br><br>
      Listet die Parameter des ausgewählten oder aller definierten Strings auf.
      </li>
    </ul>
    <br>

    <ul>
      <a id="SolarForecast-get-weatherApiData"></a>
      <li><b>weatherApiData </b> <br><br>
      Zeigt die gelieferten Daten der gewählten Wetter-API.
      </li>
    </ul>
    <br>

  </ul>
  <br>

  <a id="SolarForecast-attr"></a>
  <b>Attribute</b>
  <br><br>
  <ul>
     <ul>
       <a id="SolarForecast-attr-aiControl"></a>
       <li><b>aiControl &lt;Schlüssel=Wert&gt; &lt;Schlüssel=Wert&gt; ... </b><br>
         Durch die optionale Angabe der nachfolgend aufgeführten Schlüssel=Wert Paare können verschiedene
         Eigenschaften der KI Unterstützung beeinflusst werden. <br>
         Die KI Unterstützung der PV Prognose Autokorrektur wird mit dem Set-Befehl
         <a href="#SolarForecast-set-pvCorrectionFactor_Auto">pvCorrectionFactor_Auto </a> eingeschaltet. <br>
         Die Eingabe kann mehrzeilig erfolgen.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="26%"> <col width="74%"> </colgroup>
            <tr><td> <b>aiTrainStart</b>      </td><td>Bei Nutzung der internen KI erfolgt ein tägliches Training.                                                                   </td></tr>
            <tr><td>                          </td><td>Der Start des Trainings erfolgt ca. 15 Minuten nach der in diesem Schlüssel festgelegten vollen Stunde.                       </td></tr>
            <tr><td>                          </td><td>Zum Beispiel würde bei einem eingestellten Wert von '3' das Traning ca. 03:15 Uhr starten.                                    </td></tr>
            <tr><td>                          </td><td>Wert: <b>1 ... 23</b>, default: 2                                                                                             </td></tr>
            <tr><td>                          </td><td>                                                                                                                              </td></tr>
            <tr><td> <b>aiStorageDuration</b> </td><td>Es werden Trainingsdaten für die modulinterne KI gesammelt und gespeichert.                                                   </td></tr>
            <tr><td>                          </td><td>Diese Daten werden gelöscht, wenn sie die angegebene Haltedauer (Tage) überschritten haben.                                   </td></tr>
            <tr><td>                          </td><td>Wert: <b>Ganzzahl</b>, default: 1825                                                                                          </td></tr>
            <tr><td>                          </td><td>                                                                                                                              </td></tr>
            <tr><td> <b>aiTreesPV</b>         </td><td>Legt die Anzahl der KI-Entscheidungsbäume (Random Forests) fest. Eine höhere Anzahl steigert die                              </td></tr>
            <tr><td>                          </td><td>Genauigkeit und Robustheit der KI Vorhersage, erfordert aber mehr CPU und RAM Ressourcen.                                     </td></tr>
            <tr><td>                          </td><td><b>Hinweis:</b> Eine Erhöhung nur in kleinen Schritten und unter Beachtung der Leistungsfähigkeit der Hardware durchführen!   </td></tr>
            <tr><td>                          </td><td>                                                                                                                              </td></tr>
            <tr><td>                          </td><td>Wert: <b>1 ... 50</b>, default: 10                                                                                            </td></tr>
        </table>
         </ul>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; aiControl aiTrainStart=7 aiStorageDuration=3000 aiTreesPV=3
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-consumerControl"></a>
       <li><b>consumerControl &lt;Schlüssel=Wert&gt; &lt;Schlüssel=Wert&gt; ... </b><br>
         Durch die Angabe der nachfolgend aufgeführten 'Schlüssel=Wert' Paare können verschiedene
         übergreifende Eigenschaften der Verbraucherdarstellung eingestellt werden. <br>
         Die Eingabe kann mehrzeilig erfolgen.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>adviceIcon</b>          </td><td>Definiert die Art der Information über die geplanten Schaltzeiten eines Verbrauchers in der Verbraucherlegende.                 </td></tr>
            <tr><td>                            </td><td><b>&lt;Icon&gt[@&lt;Farbe]&gt</b> - Aktivierungsempfehlung wird durch Icon und Farbe dargestellt (default: clock@gold)          </td></tr>
            <tr><td>                            </td><td><b>times</b> - der Planungsstatus und die geplanten Schaltzeiten werden als Text angezeigt                                      </td></tr>
            <tr><td>                            </td><td><b>none</b>  - keine Anzeige der Planungsdaten                                                                                  </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>detailLink</b>          </td><td>Wenn gesetzt, sind die Geräte in der Verbraucher-Legende anklickbar um die Detailansicht des Gerätes zu öffnen.                 </td></tr>
            <tr><td>                            </td><td>Wert: <b>0|1</b>, default: 1                                                                                                    </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>dummyIcon</b>           </td><td>Icon und ggf. dessen Farbe zur Darstellung des Dummy-Verbrauchers in der Flußgrafik (optional)                                  </td></tr>
            <tr><td>                            </td><td>Syntax: <b>[&lt;Icon&gt;][@&lt;Farbe&gt;]</b>                                                                                   </td></tr>
            <tr><td>                            </td><td>Soll nur die Farbe des Standard Dummy-Icon geändert werden, kann lediglich '@&lt;Farbe&gt;' angegeben werden.                   </td></tr>
            <tr><td>                            </td><td>Die Farbe kann als Hex-Wert (z.B. #cc3300) oder Bezeichnung (z.B. red, blue) angegeben werden.                                  </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>showLegend</b>          </td><td>Definiert die Lage bzw. Darstellungsweise der Verbraucherlegende sofern Verbraucher registriert sind.                           </td></tr>
            <tr><td>                            </td><td>Zur Ausblendung des Verbraucherpaneels bitte <a href="#SolarForecast-attr-graphicSelect ">graphicSelect</a> verwenden.          </td></tr>
            <tr><td>                            </td><td><b>icon_top</b> - die Legende wird oberhalb der Balkengrafik mit Verbrauchericons angezeigt (default)                           </td></tr>
            <tr><td>                            </td><td><b>icon_bottom</b> - die Legende wird unterhalb der Balken- und Flußgrafik mit Verbrauchericons angezeigt                       </td></tr>
            <tr><td>                            </td><td><b>text_top</b> - die Legende wird oberhalb der Balkengrafik ohne Verbrauchericons angezeigt                                    </td></tr>
            <tr><td>                            </td><td><b>text_bottom</b> - die Legende wird unterhalb der Balken- und Flußgrafik ohne Verbrauchericons angezeigt                      </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
          </table>
         </ul>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; consumerControl dummyIcon=status_comfort@#ff8c00 adviceIcon=times showLegend=icon_bottom
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-consumer" data-pattern="consumer.*"></a>
       <li><b>consumerXX &lt;Device&gt;[:&lt;Alias&gt;] type=&lt;type&gt; power=&lt;power&gt; [switchdev=&lt;device&gt;]                                                                                  <br>
                         [aliasshort=&lt;String&gt;] [mode=&lt;mode&gt;] [icon=&lt;Icon&gt;[@&lt;Farbe&gt;]] [mintime=&lt;Option&gt;]                                                                                                 <br>
                         [on=&lt;Kommando&gt;] [off=&lt;Kommando&gt;] [swstate=&lt;Readingname&gt;:&lt;on-Regex&gt;:&lt;off-Regex&gt;] [asynchron=&lt;Option&gt;]                                         <br>
                         [notbefore=&lt;Ausdruck&gt;] [notafter=&lt;Ausdruck&gt;] [locktime=&lt;offlt&gt;[:&lt;onlt&gt;]]                                                                                 <br>
                         [auto=&lt;Readingname&gt;] [pcurr=&lt;Readingname&gt;:&lt;Einheit&gt;[:&lt;Schwellenwert&gt]] [etotal=&lt;Readingname&gt;:&lt;Einheit&gt;[:&lt;Schwellenwert&gt;]]               <br>
                         [swoncond=&lt;Device&gt;:&lt;Reading&gt;:&lt;Bedingung&gt;] [swoffcond=&lt;Device&gt;:&lt;Reading&gt;:&lt;Bedingung&gt;]                                                         <br>
                         [spignorecond=&lt;Device&gt;:&lt;Reading&gt;:&lt;Bedingung&gt;] [surpmeth=&lt;Option&gt;] [interruptable=&lt;Option&gt;] [noshow=&lt;Option&gt;] [exconfc=&lt;Option&gt;]  </b>  <br>
                         <br>

        Registriert einen Verbraucher &lt;Device&gt; beim SolarForecast Device. Ein optionaler Alias kann angegeben werden. <br>
        Dabei ist &lt;Device&gt; ein in FHEM bereits angelegtes Verbraucher Device, z.B. eine Schaltsteckdose.
        Die meisten Schlüssel sind optional, sind aber für bestimmte Funktionalitäten Voraussetzung und werden mit
        default-Werten besetzt. <br>
        Ist der Schlüssel "auto" definiert, kann der Automatikmodus in der integrierten Verbrauchergrafik mit den
        entsprechenden Drucktasten umgeschaltet werden. Das angegebene Reading wird ggf. im Consumer Device angelegt falls
        es nicht vorhanden ist. <br><br>

        Mit dem optionalen Schlüssel <b>swoncond</b> kann eine <b>zusätzliche externe Bedingung</b> definiert werden um den Einschaltvorgang des
        Consumers freizugeben. Ist die Bedingung (Regex) nicht erfüllt, erfolgt kein Einschalten des Verbrauchers auch wenn die
        sonstigen Voraussetzungen wie Zeitplanung, on-Schlüssel, auto-Mode und aktuelle PV-Leistung gegeben sind. Es erfolgt somit eine
        <b>UND-Verknüpfung</b> des Schlüssels swoncond mit den weiteren Einschaltbedingungen. <br><br>

        Der optionale Schlüssel <b>swoffcond</b> definiert eine <b>vorrangige Ausschaltbedingung</b> (Regex). Sobald diese
        Bedingung erfüllt ist, wird der Consumer ausgeschaltet auch wenn die geplante Endezeit (consumerXX_planned_stop)
        noch nicht erreicht ist (<b>ODER-Verknüpfung</b>). Weitere Bedingungen wie off-Schlüssel und auto-Mode müssen
        zum automatischen Ausschalten erfüllt sein. <br><br>

        Mit dem optionalen Schlüssel <b>interruptable</b> kann während der geplanten Einschaltzeit eine automatische
        Unterbrechung sowie Wiedereinschaltung des Verbrauchers vorgenommen werden.
        Der Verbraucher wird temporär ausgeschaltet (interrupted) und wieder eingeschaltet (continued) wenn die
        Interrupt-Bedingung nicht mehr vorliegt.
        Die verbleibende Laufzeit wird durch einen Interrupt nicht beeinflusst!
        <br><br>

        Der Schlüssel <b>power</b> gibt die nominale Leistungsaufnahme des Verbrauchers gemäß seines Datenblattes an.
        Dieser Wert wird verwendet um die Schaltzeiten des Verbrauchers zu planen und das Schalten in Abhängigkeit
        des tatsächlichen PV-Überschusses zum Einplanungszeitpunkt zu steuern.
        Ist <b>power=0</b> gesetzt, wird der Verbraucher unabhängig von einem ausreichend vorhandenem PV-Überschuß
        wie eingeplant geschaltet.
        <br><br>

         <ul>
         <table>
         <colgroup> <col width="12%"> <col width="88%"> </colgroup>
            <tr><td> <b>Device</b>         </td><td>Verbraucher-Gerät. Im einfachen Fall arbeitet das Gerät sowohl als Energiemesser als auch als Schalter.                                            </td></tr>
            <tr><td>                       </td><td>Im optionalen Alias sind Leerzeichen durch '+' zu ersetzen (z.B. 'Ein+toller+Alias').                                                              </td></tr>
            <tr><td>                       </td><td>Besteht der Verbraucher aus verschiedenen Geräten/Kanälen (z.B. Homematic), wird der Energiemesser als  &lt;Device&gt; definiert.                  </td></tr>
            <tr><td>                       </td><td>Das dazugehörige Schalt-Gerät wird mit dem Schlüssel 'switchdev' spezifiziert.                                                                     </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>aliasshort</b>     </td><td>Kurzalias des Verbrauchers zur Anzeige in der Flußgrafik. Es sind maximal 10 Zeichen und keine Leerzeichen erlaubt.                                </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>type</b>           </td><td>Typ des Verbrauchers. Folgende Typen sind erlaubt:                                                                                                 </td></tr>
            <tr><td>                       </td><td><b>dishwasher</b>     - Verbraucher ist eine Spülmaschine                                                                                          </td></tr>
            <tr><td>                       </td><td><b>dryer</b>          - Verbraucher ist ein Wäschetrockner                                                                                         </td></tr>
            <tr><td>                       </td><td><b>washingmachine</b> - Verbraucher ist eine Waschmaschine                                                                                         </td></tr>
            <tr><td>                       </td><td><b>heater</b>         - Verbraucher ist ein Heizstab                                                                                               </td></tr>
            <tr><td>                       </td><td><b>charger</b>        - Verbraucher ist eine Ladeeinrichtung (Akku, Auto, Fahrrad, etc.)                                                           </td></tr>
            <tr><td>                       </td><td><b>other</b>          - Verbraucher ist keiner der vorgenannten Typen                                                                              </td></tr>
            <tr><td>                       </td><td><b>noSchedule</b>     - für den Verbraucher erfolgt keine Einplanung oder automatische Schaltung.                                                  </td></tr>
            <tr><td>                       </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                                    Anzeigefunktionen oder manuelle Schaltungen sind verfügbar.                                                                                        </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>power</b>          </td><td>nominale Leistungsaufnahme des Verbrauchers (siehe Datenblatt) in W                                                                                </td></tr>
            <tr><td>                       </td><td>(kann auf "0" gesetzt werden)                                                                                                                      </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>switchdev</b>      </td><td>Das angegebene &lt;device&gt; wird als Schalter Device dem Verbraucher zugeordnet (optional). Schaltvorgänge werden mit diesem Gerät               </td></tr>
            <tr><td>                       </td><td>ausgeführt. Der Schlüssel ist für Verbraucher nützlich bei denen Energiemessung und Schaltung mit verschiedenen Geräten vorgenommen                </td></tr>
            <tr><td>                       </td><td>wird, z.B. Homematic oder readingsProxy. Ist switchdev angegeben, beziehen sich die Schlüssel on, off, swstate, auto, asynchron auf dieses Gerät.  </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>mode</b>           </td><td>Planungsmodus des Verbrauchers (optional). Erlaubt sind:                                                                                           </td></tr>
            <tr><td>                       </td><td><b>can</b>  - Die Einplanung erfolgt zum Zeitpunkt mit wahrscheinlich genügend verfügbaren PV Überschuß (default)                                  </td></tr>
            <tr><td>                       </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Der Start des Verbrauchers zum Planungszeitpunkt unterbleibt bei ungenügendem PV-Überschuß.       </td></tr>
            <tr><td>                       </td><td><b>must</b> - der Verbraucher wird optimiert eingeplant auch wenn wahrscheinlich nicht genügend PV Überschuß vorhanden sein wird                   </td></tr>
            <tr><td>                       </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Der Start des Verbrauchers erfolgt auch bei ungenügendem PV-Überschuß sofern eine
                                                    gesetzte "swoncond" Bedingung erfüllt und "swoffcond" nicht erfüllt ist.                                                                           </td></tr>
            <tr><td>                       </td><td><b>&lt;Device&gt;:&lt;Reading&gt;</b> - Device/Reading Kombination um den Planungsmodus dynamisch ändern zu können.
                                                    Das Reading muß 'can' oder 'must' zurückgeben.                                                                                                     </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>icon</b>           </td><td>Icon und ggf. dessen Farbe zur Darstellung des Verbrauchers in der Übersichtsgrafik (optional)                                                     </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>mintime</b>        </td><td>Einplanungsdauer in Minuten (optional). Folgende Optionen der Definition sind möglich:                                                             </td></tr>
            <tr><td>                       </td><td><b>&lt;Zahl&gt;</b> - die Einplanungsdauer in Minuten als numerische Angabe                                                                        </td></tr>
            <tr><td>                       </td><td><b>SunPath</b>[:&lt;Offset_Sunrise&gt;:&lt;Offset_Sunset&gt;] - die Einplanung erfolgt von Sonnenaufgang bis Sonnenuntergang.                      </td></tr>
            <tr><td>                       </td><td> Optional kann eine positive und negative Verschiebung (Minuten) der Planungszeit bzgl. Sonnenaufgang bzw. Sonnenuntergang angegeben werden.       </td></tr>
            <tr><td>                       </td><td><b>&lt;Device&gt;:&lt;Reading&gt;</b> - Device/Reading-Kombination, die eine variabel definierbare Einplanungsdauer in Minuten liefert.             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td>                       </td><td>Ist mintime nicht angegeben, wird eine Standard Einplanungsdauer gemäß nachfolgender Tabelle verwendet.                                            </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td>                       </td><td><b>Default mintime nach Verbrauchertyp:</b>                                                                                                        </td></tr>
            <tr><td>                       </td><td>- dishwasher: 180 Minuten                                                                                                                          </td></tr>
            <tr><td>                       </td><td>- dryer: 90 Minuten                                                                                                                                </td></tr>
            <tr><td>                       </td><td>- washingmachine: 120 Minuten                                                                                                                      </td></tr>
            <tr><td>                       </td><td>- heater: 240 Minuten                                                                                                                              </td></tr>
            <tr><td>                       </td><td>- charger: 120 Minuten                                                                                                                             </td></tr>
            <tr><td>                       </td><td>- other: 60 Minuten                                                                                                                                </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>on</b>             </td><td>Set-Kommando zum Einschalten des Verbrauchers (optional)                                                                                           </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>off</b>            </td><td>Set-Kommando zum Ausschalten des Verbrauchers (optional)                                                                                           </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>swstate</b>        </td><td>Reading welches den Schaltzustand des Verbrauchers anzeigt (default: 'state').                                                                     </td></tr>
            <tr><td>                       </td><td><b>on-Regex</b> - regulärer Ausdruck für den Zustand 'ein' (default: 'on')                                                                         </td></tr>
            <tr><td>                       </td><td><b>off-Regex</b> - regulärer Ausdruck für den Zustand 'aus' (default: 'off')                                                                       </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>asynchron</b>      </td><td>die Art der Schaltstatus Ermittlung im Verbraucher Device. Die Statusermittlung des Verbrauchers nach einem Schaltbefehl erfolgt nur               </td></tr>
            <tr><td>                       </td><td>durch Abfrage innerhalb eines Datensammelintervals (synchron) oder zusätzlich durch Eventverarbeitung (asynchron).                                 </td></tr>
            <tr><td>                       </td><td><b>0</b> - ausschließlich synchrone Verarbeitung von Schaltzuständen  (default)                                                                    </td></tr>
            <tr><td>                       </td><td><b>1</b> - zusätzlich asynchrone Verarbeitung von Schaltzuständen durch Eventverarbeitung                                                          </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>notbefore</b>      </td><td>Startzeitpunkt Verbraucher nicht vor angegebener Zeit 'Stunde[:Minute]' einplanen (optional)                                                       </td></tr>
            <tr><td>                       </td><td>Der &lt;Ausdruck&gt; hat das Format hh[:mm] oder ist in {...} eingeschlossener Perl-Code der hh[:mm] zurückgibt.                                   </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>notafter</b>       </td><td>Startzeitpunkt Verbraucher nicht nach angegebener Zeit 'Stunde[:Minute]' einplanen (optional)                                                      </td></tr>
            <tr><td>                       </td><td>Der &lt;Ausdruck&gt; hat das Format hh[:mm] oder ist in {...} eingeschlossener Perl-Code der hh[:mm] zurückgibt.                                   </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>auto</b>           </td><td>Reading im Verbraucherdevice welches das Schalten des Verbrauchers freigibt bzw. blockiert (optional)                                              </td></tr>
            <tr><td>                       </td><td>Ist der Schlüssel switchdev angegeben, wird das Reading in diesem Device gesetzt und ausgewertet.                                                  </td></tr>
            <tr><td>                       </td><td>Readingwert = 1 - Schalten freigegeben (default),  0: Schalten blockiert                                                                           </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>pcurr</b>          </td><td>Reading:Einheit (W/kW) welches den aktuellen Energieverbrauch liefert (optional)                                                                   </td></tr>
            <tr><td>                       </td><td>:&lt;Schwellenwert&gt; (W) - Ab diesem Leistungsbezug wird der Verbraucher als aktiv gewertet. Die Angabe ist optional (default: 0)                </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>etotal</b>         </td><td>Reading:Einheit (Wh/kWh) des Consumer Device, welches die Summe der verbrauchten Energie liefert (optional)                                        </td></tr>
            <tr><td>                       </td><td>:&lt;Schwellenwert&gt (Wh) - Ab diesem Energieverbrauch pro Stunde wird der Verbrauch als gültig gewertet. Optionale Angabe (default: 0)           </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>swoncond</b>       </td><td>Bedingung die zusätzlich erfüllt sein muß um den geplanten Zyklus zu starten und den Verbraucher einzuschalten (optional).                         </td></tr>
            <tr><td>                       </td><td><b>Device:Reading</b> - die Device/Reading Kombination liefert den Prüfwert $VALUE ('undef' wird ignoriert)                                        </td></tr>
            <tr><td>                       </td><td>Die Prüfung kann als regulärer Ausdruck oder als in {..} eingeschlossener Perl-Code formuliert sein:                                               </td></tr>
            <tr><td>                       </td><td><b>Regex</b> - regulärer Ausdruck zur Prüfung von $VALUE der im Erfolgsfall 'wahr' liefern muß                                                     </td></tr>
            <tr><td>                       </td><td><b>{Perl-Code}</b> - der in {..} eingeschlossene Perl-Code darf keine Leerzeichen enthalten. Die Variable $VALUE kann vom Code ausgewertet werden. </td></tr>
            <tr><td>                       </td><td>Der return Wert muß im Erfolgsfall 'wahr' sein.                                                                                                    </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>swoffcond</b>      </td><td>vorrangige Bedingung um den Verbraucher auszuschalten (optional). Der geplante Zyklus wird gestoppt.                                               </td></tr>
            <tr><td>                       </td><td><b>Device:Reading</b> - die Device/Reading Kombination liefert den Prüfwert $VALUE ('undef' wird ignoriert)                                        </td></tr>
            <tr><td>                       </td><td>Die Prüfung kann als regulärer Ausdruck oder als in {..} eingeschlossener Perl-Code formuliert sein:                                               </td></tr>
            <tr><td>                       </td><td><b>Regex</b> - regulärer Ausdruck zur Prüfung von $VALUE der im Erfolgsfall 'wahr' liefern muß                                                     </td></tr>
            <tr><td>                       </td><td><b>{Perl-Code}</b> - der in {..} eingeschlossene Perl-Code darf keine Leerzeichen enthalten. Die Variable $VALUE kann vom Code ausgewertet werden. </td></tr>
            <tr><td>                       </td><td>Der return Wert muß im Erfolgsfall 'wahr' sein.                                                                                                    </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>surpmeth</b>       </td><td>Die möglichen Optionen legen das Verfahren zur Ermittlung des PV-Überschusses fest. (optional)                                                     </td></tr>
            <tr><td>                       </td><td><b>default</b> - der PV-Überschuß wird aus dem Reading 'Current_Surplus' direkt ausgelesen. (default)                                              </td></tr>
            <tr><td>                       </td><td><b>median[_2..20]</b> - es wird der Median der letzten PV-Überschuß Werte verwendet. Die optionale Angabe '_XX' verwendet die letzten XX Meßwerte. </td></tr>
            <tr><td>                       </td><td><b>average[_2..20]</b> - bildet den Durchschnitt von 20 PV-Überschuß Werten. Die optionale Angabe '_XX' verwendet die letzten XX Meßwerte.         </td></tr>
            <tr><td>                       </td><td><b>&lt;Device&gt;:&lt;Reading&gt;</b> - Device/Reading-Kombination die einen vom Nutzer bestimmten bzw. berechneten
                                                    numerischen PV-Überschuß in Watt liefert.                                                                                                          </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>spignorecond</b>   </td><td>Bedingung um einen fehlenden PV Überschuß zu ignorieren (optional). Bei erfüllter Bedingung wird der Verbraucher entsprechend                      </td></tr>
            <tr><td>                       </td><td>der Planung eingeschaltet auch wenn zu dem Zeitpunkt kein PV Überschuß vorliegt.                                                                   </td></tr>
            <tr><td>                       </td><td><b>ACHTUNG:</b> Die Verwendung beider Schlüssel <I>spignorecond</I> und <I>interruptable</I> kann zu einem unerwünschten Verhalten führen!         </td></tr>
            <tr><td>                       </td><td><b>Device:Reading</b> - die Device/Reading Kombination liefert den Prüfwert $VALUE ('undef' wird ignoriert)                                        </td></tr>
            <tr><td>                       </td><td>Die Prüfung kann als regulärer Ausdruck oder als in {..} eingeschlossener Perl-Code formuliert sein:                                               </td></tr>
            <tr><td>                       </td><td><b>Regex</b> - regulärer Ausdruck zur Prüfung von $VALUE der im Erfolgsfall 'wahr' liefern muß                                                     </td></tr>
            <tr><td>                       </td><td><b>{Perl-Code}</b> - der in {..} eingeschlossene Perl-Code darf keine Leerzeichen enthalten. Die Variable $VALUE kann vom Code ausgewertet werden. </td></tr>
            <tr><td>                       </td><td>Der return Wert muß im Erfolgsfall 'wahr' sein.                                                                                                    </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>interruptable</b>  </td><td>definiert die möglichen Unterbrechungsoptionen für den Verbraucher nachdem er gestartet wurde (optional). Optionen können sein:                    </td></tr>
            <tr><td>                       </td><td><b>0</b> - Verbraucher wird nicht temporär ausgeschaltet auch wenn der PV Überschuß die benötigte Energie unterschreitet (default)                 </td></tr>
            <tr><td>                       </td><td><b>1</b> - Verbraucher wird temporär ausgeschaltet falls der PV Überschuß die benötigte Energie unterschreitet                                     </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td>                       </td><td><b>Device:Reading:{Perl-Code}</b> - Verbraucher wird temporär unterbrochen, wenn der Perl-Code 'wahr' zurückgibt <b>oder</b> unzureichender        </td></tr>
            <tr><td>                       </td><td>PV Überschuß (wenn power ungleich 0) vorliegt und wird wieder eingeschaltet, wenn der Perl-Code 'falsch' zurückgibt <b>und</b> PV Überschuß        </td></tr>
            <tr><td>                       </td><td>(wenn power ungleich 0) vorliegt. Der Wert von  Device:Reading wird dem Code mit der Variable $VALUE übergeben.                                    </td></tr>
            <tr><td>                       </td><td>Der Code ist in {..} einzuschließen und darf <b>keine Leerzeichen</b> enthalten.                                                                   </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td>                       </td><td><b>Device:Reading:Regex[:Hysterese]</b> - Verbraucher wird temporär unterbrochen, wenn der Wert des angegebenen                                    </td></tr>
            <tr><td>                       </td><td>Device:Readings auf den Regex matched <b>oder</b> unzureichender PV Überschuß (wenn power ungleich 0) vorliegt.                                    </td></tr>
            <tr><td>                       </td><td>Der unterbrochene Verbraucher wird wieder eingeschaltet, wenn der Wert nicht mehr matched <b>und</b> ausreichender PV Überschuß                    </td></tr>
            <tr><td>                       </td><td>(wenn power ungleich 0) vorliegt.                                                                                                                  </td></tr>
            <tr><td>                       </td><td>Ist die optionale <b>Hysterese</b> angegeben, wird der Hysteresewert vom Readingswert subtrahiert und danach der Regex angewendet.                 </td></tr>
            <tr><td>                       </td><td>Matched dieser und der originale Readingswert, wird der Verbraucher temporär unterbrochen.                                                         </td></tr>
            <tr><td>                       </td><td>Der Verbraucher wird fortgesetzt, wenn sowohl der originale als auch der substrahierte Readingswert nicht (mehr) matchen.                          </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>locktime</b>       </td><td>Sperrzeiten in Sekunden für die Schaltung des Verbrauchers (optional).                                                                             </td></tr>
            <tr><td>                       </td><td><b>offlt</b> - Sperrzeit in Sekunden nachdem der Verbraucher ausgeschaltet oder unterbrochen wurde                                                 </td></tr>
            <tr><td>                       </td><td><b>onlt</b> - Sperrzeit in Sekunden nachdem der Verbraucher eingeschaltet oder fortgesetzt wurde                                                   </td></tr>
            <tr><td>                       </td><td>Der Verbraucher wird erst wieder geschaltet wenn die entsprechende Sperrzeit abgelaufen ist.                                                       </td></tr>
            <tr><td>                       </td><td><b>Hinweis:</b> Der Schalter 'locktime' ist nur im Automatik-Modus wirksam.                                                                        </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>noshow</b>         </td><td>Verbraucher bzw. bestimmte Elemente ausblenden oder einblenden (optional). Die Werte können kombiniert werden (siehe Beispiel).                    </td></tr>
            <tr><td>                       </td><td><b>0</b> - der Verbraucher wird eingeblendet (default)                                                                                             </td></tr>
            <tr><td>                       </td><td><b>1</b> - der Verbraucher wird ausgeblendet                                                                                                       </td></tr>
            <tr><td>                       </td><td><b>2</b> - der Verbraucher wird in der Verbraucherlegende ausgeblendet                                                                             </td></tr>
            <tr><td>                       </td><td><b>3</b> - der Verbraucher wird in der Flußgrafik ausgeblendet                                                                                     </td></tr>
            <tr><td>                       </td><td><b>9</b> - das Schaltelement des Verbrauchers wird in der Verbraucherlegende ausgeblendet                                                          </td></tr>
            <tr><td>                       </td><td><b>[Device:]Reading</b> - Reading im Verbraucher oder (optional) einem alternativen Device.                                                        </td></tr>
            <tr><td>                       </td><td>Hat das Reading den Wert 0 oder ist nicht vorhanden, wird der Verbraucher eingeblendet.                                                            </td></tr>
            <tr><td>                       </td><td>Die Wirkung der möglichen Readingwerte 1, 2 und 3 ist wie beschrieben.                                                                             </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
            <tr><td> <b>exconfc</b>        </td><td>Kennzeichen zur Verwendung des historischen Energieverbrauchs des Verbrauchers (optional).                                                         </td></tr>
            <tr><td>                       </td><td><b>0</b> - die gespeicherten Energieverbrauchsanteile bleiben als Bestandteil der allgemeinen Verbrauchsprognose erhalten (default)                </td></tr>
            <tr><td>                       </td><td><b>1</b> - die allgemeine Verbrauchsprognose wird um die gespeicherten Energieverbrauchsanteile reduziert.                                         </td></tr>
            <tr><td>                       </td><td><b>2</b> - wie bei '1', jedoch gehen die Planungsdaten des Verbrauchers bei der Prognose der kommenden Stunden wieder mit ein.                     </td></tr>
            <tr><td>                       </td><td><b>Hinweis:</b> Bei Verwendung von exconfc sollte <b>plantControl->consForecastIdentWeekdays=1</b> und <b>plantControl->consForecastLastDays=4</b> </td></tr>
            <tr><td>                       </td><td>gesetzt werden.                                                                                                                                    </td></tr>
            <tr><td>                       </td><td>Siehe dazu die Erläuterungen im <a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Wie_wird_die_Verbrauchsprognose_erstellt?' target='_blank'>Wiki</a>  </td></tr>
            <tr><td>                       </td><td>                                                                                                                                                   </td></tr>
         </table>
         </ul>
       <br>

       <ul>
         <b>Beispiele: </b> <br>
         <b>attr &lt;name&gt; consumer01</b> wallplug icon=scene_dishwasher@orange type=dishwasher mode=can power=2500 on=on off=off notafter=20 etotal=total:kWh:5 <br>
         <b>attr &lt;name&gt; consumer02</b> WPxw type=heater mode=can power=3000 mintime=180 on="on-for-timer 3600" notafter=12 auto=automatic                     <br>
         <b>attr &lt;name&gt; consumer03</b> Shelly.shellyplug2 type=other power=300 mode=must icon=it_ups_on_battery mintime=120 on=on off=off swstate=state:on:off auto=automatic pcurr=relay_0_power:W etotal:relay_0_energy_Wh:Wh swoncond=EcoFlow:data_data_socSum:-?([1-7][0-9]|[0-9]) swoffcond:EcoFlow:data_data_socSum:{$VALUE==100?1:0}       <br>
         <b>attr &lt;name&gt; consumer04</b> Shelly.shellyplug3 icon=scene_microwave_oven@red type=heater power=2000 mode=must notbefore=07 mintime=600 on=on off=off etotal=relay_0_energy_Wh:Wh pcurr=relay_0_power:W auto=automatic interruptable=eg.wz.wandthermostat:diff-temp:(22)(\.[2-9])|([2-9][3-9])(\.[0-9]):0.2                             <br>
         <b>attr &lt;name&gt; consumer05</b> Shelly.shellyplug4 icon=sani_buffer_electric_heater_side type=heater mode=must power=1000 notbefore=7 notafter=20:10 auto=automatic pcurr=actpow:W on=on off=off mintime=SunPath interruptable=1                                                                                                           <br>
         <b>attr &lt;name&gt; consumer06</b> Shelly.shellyplug5 icon=sani_buffer_electric_heater_side type=heater mode=must power=1000 notbefore=07:20 notafter={return'20:05'} auto=automatic pcurr=actpow:W on=on off=off mintime=SunPath:60:-120 interruptable=1 spignorecond=SolCast:Current_PV:{($VALUE)=split/\s/,$VALUE;$VALUE>10?1:0;}          <br>
         <b>attr &lt;name&gt; consumer07</b> SolCastDummy icon=sani_buffer_electric_heater_side type=heater mode=can power=600 auto=automatic pcurr=actpow:W on=on off=off mintime=15 asynchron=1 locktime=300:1200 interruptable=1 noshow=39 surpmeth=median_10                                                                                                         <br>
       </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlBatSocManagementXX" data-pattern="ctrlBatSocManagement.*"></a>
       <li><b>ctrlBatSocManagementXX lowSoc=&lt;Wert&gt; upSoC=&lt;Wert&gt; [maxSoC=&lt;Wert&gt;] [stepSoC=&lt;Wert&gt;] [careCycle=&lt;Wert&gt;] 
                                     [lcSlot=&lt;hh:mm&gt;-&lt;hh:mm&gt;] [loadAbort=&lt;SoC1&gt;:&lt;MinPwr&gt;:&lt;SoC2&gt;] 
                                     [safetyMargin=&lt;Wert&gt;[:&lt;Wert&gt;]] [loadStrategy=&lt;Wert&gt;] [loadTarget=&lt;Wert&gt;] 
                                     [weightOwnUse=&lt;Wert&gt;] </b> <br><br>
         
         Sofern ein Batterie Device (setupBatteryDevXX) installiert ist, aktiviert dieses Attribut das Batterie
         SoC- und Lade-Management für dieses Batteriegerät. <br>
         Es wird ein Satz Steuerreadings erstellt; das Modul greift selbst <b>nicht</b> in die Batteriesteuerung ein. <br>
         Das Reading <b>Battery_OptimumTargetSoC_XX</b> enthält den vom Modul berechneten optimalen Mindest-SoC. <br>
         Das Reading <b>Battery_ChargeRequest_XX</b> wird auf '1' gesetzt, wenn der aktuelle SoC unter den Mindest-SoC gefallen
         ist. <br>
         In diesem Fall sollte die Batterie, unter Umständen mit Netzstrom, nachgeladen werden. <br>
         Das Reading <b>Battery_ChargeUnrestricted_XX</b> enthält die Ladefreigabe, d.h. ob die Batterie uneingeschränkt mit voller 
         Leistung (1), oder nicht bzw. nur bei Überschreitung des <br> 
         Einspeiselimits (siehe <a href="#SolarForecast-attr-plantControl">plantControl->feedinPowerLimit</a>) 
         geladen werden sollte (0). Möchte man die Batterie kontinuierlich über den gesamten Tag aufladen, wird im Reading 
         <b>Battery_ChargeOptTargetPower_XX</b> eine optimierte Ladeleistung zur Batteriesteuerung bereitgestellt.  <br>         
         Die Readings können zur Steuerung des SoC (State of Charge) sowie zur Steuerung des verwendeten Ladeleistung
         der Batterie verwendet werden. <br>
         Detaillierte Informationen zum Batterie SoC- und Lade-Management sind im 
         <a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Aktivierung_des_Batterie_SOC-_und_Lade-Managements' target='_blank'>Wiki</a> beschrieben. <br><br>

         <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>lowSoc</b>       </td><td>unterer Mindest-SoC - die Batterie soll nicht tiefer als dieser Wert entladen werden (> 0)      </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>upSoC</b>        </td><td>oberer Mindest-SoC - der übliche Wert des optimalen SoC bewegt sich in Perioden mit hohen       </td></tr>
            <tr><td>                     </td><td>PV-Überschuß tendenziell zwischen 'lowSoC' und 'upSoC', in Perioden mit geringem PV-Überschuß   </td></tr>
            <tr><td>                     </td><td>tendenziell zwischen 'upSoC' und 'maxSoC'                                                       </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>maxSoC</b>       </td><td>maximaler Mindest-SoC - Wert der mindestens im Abstand von 'careCycle' Tagen erreicht           </td></tr>
            <tr><td>                     </td><td>werden muß um den Ladungsausgleich im Speicherverbund auszuführen.                              </td></tr>
            <tr><td>                     </td><td>Die Angabe ist optional (&lt;= 100, default: 95)                                                </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>stepSoC</b>      </td><td>Optionale Schrittweite zur optimalen SoC-Berechnung (Battery_OptimumTargetSoC_XX) in %.         </td></tr>
            <tr><td>                     </td><td>Mit der Angabe 'stepSoC=0' wird das SoC-Management deaktiviert und Battery_OptimumTargetSoC_XX  </td></tr>
			<tr><td>                     </td><td>auf den Wert 'lowSoC' gesetzt.                                                                  </td></tr> 
            <tr><td>                     </td><td><b>Hinweis:</b> Die Beziehung 'careCycle * stepSoC = 100' sollte eingehalten werden!            </td></tr>
            <tr><td>                     </td><td>Wert: <b>0..5</b>, default: 5                                                                   </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>          
            <tr><td> <b>careCycle</b>    </td><td>maximaler Abstand in Tagen, der zwischen zwei Ladungszuständen von mindestens 'maxSoC'          </td></tr>
            <tr><td>                     </td><td>möglichst nicht überschritten werden soll. Die Angabe ist optional (default: 20)                </td></tr>
            <tr><td>                     </td><td><b>Hinweis:</b> Die Beziehung 'careCycle * stepSoC = 100' sollte eingehalten werden!            </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>        
            <tr><td> <b>lcSlot</b>       </td><td>Es wird ein tägliches Zeitfenster festgelegt, in dem die Ladesteuerung des Moduls für diese     </td></tr>
            <tr><td>                     </td><td>Batterie aktiv sein soll. Außerhalb des Zeitfensters wird die Batterieladung mit voller         </td></tr>
            <tr><td>                     </td><td>Leistung freigegeben. Das SoC-Management der Batterie ist davon nicht betroffen.                </td></tr>
            <tr><td>                     </td><td>Wert: <b>&lt;hh:mm&gt;-&lt;hh:mm&gt;</b>, default: ganztägig                                    </td></tr>           
            <tr><td>                     </td><td>                                                                                                </td></tr>           
            <tr><td> <b>loadAbort</b>    </td><td>Bedingung für einen generellen Ladeabbruch und Wiederfreigabe. Die Abbruchbedingung ist erfüllt,</td></tr>
            <tr><td>                     </td><td>wenn der angegebene SoC1 (%) erreicht bzw. überschritten ist <b>UND</b> die angegebene          </td></tr>
            <tr><td>                     </td><td>Ladeleistung &lt;MinPwr&gt; (W) unterschritten wurde -> Reading <b>Battery_ChargeAbort_XX=1</b>.</td></tr>
            <tr><td>                     </td><td>Fällt der aktuelle SoC wieder unter den SoC2, wird <b>Battery_ChargeAbort_XX=0</b> gesetzt.     </td></tr>
            <tr><td>                     </td><td>Ist SoC2 nicht angegeben, gilt SoC2=SoC1.                                                       </td></tr>            
            <tr><td>                     </td><td>                                                                                                </td></tr>            
            <tr><td> <b>loadStrategy</b> </td><td>Abhängig von der gewählten Ladestrategie wird die Prognose der Batterieladung und ggf. die      </td></tr>
            <tr><td>                     </td><td>Generierung der Steuerreadings beeinflusst. Die Angabe ist optional.                            </td></tr>
            <tr><td>                     </td><td>Weitere Informationen zur Auswahl der Strategie siehe <a href="https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Welche_Ladestrategie_soll_ich_w%C3%A4hlen?_-_eine_M%C3%B6glichkeit_zur_Best-Practice_Findung_mit_Codebeispiel">Wiki</a>.  </td></tr>           
            <tr><td>                     </td><td>Wert: <b>loadRelease</b> | <b>optPower</b> | <b>smartPower</b>, default: loadRelease            </td></tr>         
            <tr><td>                     </td><td>                                                                                                </td></tr>           
            <tr><td> <b>loadTarget</b>   </td><td>Optionaler Ziel-SoC in % für die Berechnung der Ladefreigabe bzw. der optimalen Ladeleistung.   </td></tr>
            <tr><td>                     </td><td>Der Zielwert ist eine kalkulatorische Rechengröße. Der reale SoC kann situativ in Grenzen       </td></tr>
            <tr><td>                     </td><td>über- oder unterschritten werden. Der höhere Wert aus Reading <b>Battery_OptimumTargetSoC_XX</b></td></tr>
			<tr><td>                     </td><td>und 'loadTarget' hat für die Berechnung Vorrang.                                                </td></tr>
			<tr><td>                     </td><td>Wert: <b>0..100</b>, default: 100                                                               </td></tr>           
            <tr><td>                     </td><td>                                                                                                </td></tr>           
            <tr><td> <b>safetyMargin</b> </td><td>Bei der Berechnung der Ladefreigabe und optimierten Ladeleistung werden Sicherheitszuschläge    </td></tr>
            <tr><td>                     </td><td>auf den prognostizierten Ladungsbedarf berücksichtigt.                                          </td></tr>
            <tr><td>                     </td><td>Abweichend vom Default können mit diesem Parameter individuelle Sicherheitszuschläge getrennt   </td></tr>
            <tr><td>                     </td><td>für die Berechnung der Ladefreigabe und optimierten Ladeleistung angegeben werden.              </td></tr>
            <tr><td>                     </td><td>Der erste Wert ist der Zuschlag bei der Berechnung der Ladefreigabe, der zweite Wert der        </td></tr>
            <tr><td>                     </td><td>Zuschlag bei der Berechnung der optimierten Ladeleistung. Beide Angaben sind Prozentwerte.      </td></tr>
            <tr><td>                     </td><td>Wert: <b>0..100[:0..100]</b> (Ganzzahlen)                                                       </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
            <tr><td> <b>weightOwnUse</b> </td><td>Optionale Gewichtung der stündlichen Verbrauchsprognose als zusätzlich verwendbaren Anteil zur  </td></tr>
            <tr><td>                     </td><td>Batterieladung in %. Technisch wird der verfügbare PV-Überschuß zur Berechnung der optimierten  </td></tr>
            <tr><td>                     </td><td>Ladeleistung erhöht indem der kalkulierte Verbrauch um den angegebenen Prozentsatz gesenkt wird.</td></tr>
            <tr><td>                     </td><td>Wert: <b>0..100</b> default: 0                                                                  </td></tr>
            <tr><td>                     </td><td>                                                                                                </td></tr>
         </table>
         </ul>
         <br>

         Alle SoC-Werte sind ganze Zahlen in %. Dabei gilt: 'lowSoc' &lt; 'upSoC' &lt; 'maxSoC'. <br><br>

         <b>Beispiel: </b> <br>
         attr &lt;name&gt; ctrlBatSocManagement01 lowSoc=10 upSoC=50 maxSoC=99 careCycle=25 lcSlot=11:00-17:30 loadAbort=99:40:90 safetyMargin=30 weightOwnUse=20 <br>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlConsRecommendReadings"></a>
       <li><b>ctrlConsRecommendReadings </b><br>
         Für die ausgewählten Consumer (Nummer) werden Readings der Form <b>consumerXX_ConsumptionRecommended</b> erstellt. <br>
         Diese Readings signalisieren ob das Einschalten dieses Consumers abhängig von seinen Verbrauchsdaten und der aktuellen
         PV-Erzeugung bzw. des aktuellen Energieüberschusses empfohlen ist. Der Wert des erstellten Readings korreliert
         mit den berechneten Planungsdaten des Consumers, kann aber von dem Planungszeitraum abweichen. <br>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlDebug"></a>
       <li><b>ctrlDebug</b><br>
         Aktiviert/deaktiviert verschiedene Debug Module. Ist ausschließlich "none" selektiert erfolgt keine DEBUG-Ausgabe. <br>
         Zur Ausgabe von Debug Meldungen muß der verbose Level des Device mindestens "1" sein. <br>
         Die Debug Module können miteinander kombiniert werden: <br><br>

         <ul>
         <table>
         <colgroup> <col width="25%"> <col width="75%"> </colgroup>
            <tr><td> <b>aiProcess</b>            </td><td>Datenanreicherung und Trainingsprozess der KI Unterstützung                      </td></tr>
            <tr><td> <b>aiData</b>               </td><td>Datennutzung KI im Prognoseprozess                                               </td></tr>
            <tr><td> <b>apiCall</b>              </td><td>Abruf API Schnittstelle ohne Datenausgabe                                        </td></tr>
            <tr><td> <b>apiProcess</b>           </td><td>Abruf und Verarbeitung von API Daten                                             </td></tr>
            <tr><td> <b>batteryManagement</b>    </td><td>Steuerungswerte des Batterie Managements (SoC)                                   </td></tr>
            <tr><td> <b>collectData</b>          </td><td>Datensammlung von Energie- und Leistungswerten                                   </td></tr>
            <tr><td> <b>collectData_long</b>     </td><td>wie collectData, zusätzlich Sammlung von Wetter- und Astrodaten                  </td></tr>
            <tr><td> <b>consumerPlanning</b>     </td><td>Consumer Einplanungsprozesse                                                     </td></tr>
            <tr><td> <b>consumerSwitchingXX</b>  </td><td>Operationen des internen Consumer Schaltmodul für Verbraucher XX                 </td></tr>
            <tr><td> <b>consumption</b>          </td><td>Verbrauchskalkulation, Verbrauchsvorhersage und -nutzung                         </td></tr>
            <tr><td> <b>consumption_long</b>     </td><td>erweiterte Ausgabe der Verbrauchsvorhersage Ermittlung                           </td></tr>
            <tr><td> <b>dwdComm</b>              </td><td>Kommunikation mit Webseite oder Server des Deutschen Wetterdienst (DWD)          </td></tr>
            <tr><td> <b>epiecesCalc</b>          </td><td>Berechnung des spezifischen Energieverbrauchs je Betriebsstunde und Verbraucher  </td></tr>
            <tr><td> <b>graphic</b>              </td><td>Informationen der Modulgrafik                                                    </td></tr>
            <tr><td> <b>notifyHandling</b>       </td><td>Ablauf der Eventverarbeitung im Modul                                            </td></tr>
            <tr><td> <b>pvCorrectionRead</b>     </td><td>Anwendung PV Korrekturfaktoren                                                   </td></tr>
            <tr><td> <b>pvCorrectionWrite</b>    </td><td>Berechnung PV Korrekturfaktoren                                                  </td></tr>
            <tr><td> <b>radiationProcess</b>     </td><td>Sammlung und Verarbeitung der Solarstrahlungsdaten                               </td></tr>
            <tr><td> <b>saveData2Cache</b>       </td><td>Datenspeicherung in internen Speicherstrukturen                                  </td></tr>
         </table>
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlLanguage"></a>
       <li><b>ctrlLanguage &lt;DE | EN&gt; </b><br>
         Legt die benutzte Sprache des Devices fest. Die Sprachendefinition hat Auswirkungen auf die Modulgrafik und
         verschiedene Readinginhalte. <br>
         Ist das Attribut nicht gesetzt, definiert sich die Sprache durch die Einstellung des globalen Attributs "language". <br>
         (default: EN)
       </li><br>

       <a id="SolarForecast-attr-ctrlNextDayForecastReadings"></a>
       <li><b>ctrlNextDayForecastReadings &lt;01,02,..,24&gt; </b><br>
         Wenn gesetzt, werden Readings der Form <b>Tomorrow_Hour&lt;hour&gt;_PVforecast</b> erstellt. <br>
         Diese Readings enthalten die voraussichtliche PV Erzeugung des kommenden Tages. Dabei ist &lt;hour&gt; die
         Stunde des Tages. <br>
       <br>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; ctrlNextDayForecastReadings 09,11 <br>
         # erstellt Readings für die Stunde 09 (08:00-09:00) und 11 (10:00-11:00) des kommenden Tages
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-ctrlNextHoursSoCForecastReadings"></a>
       <li><b>ctrlNextHoursSoCForecastReadings &lt;00,02,..,23&gt; </b><br>
         Wenn gesetzt, werden Readings der Form Battery_NextHourXX_SoCforecast_BN erstellt sofern eine Batterie im
         SolarForecast-Device registriert ist (siehe <a href="#SolarForecast-attr-setupBatteryDev">attr &lt;name&gt; setupBatteryDevXX </a>). <br>
         Diese Readings enthalten den prognostizierten SoC-Wert (%) zum Ende der ausgewählten Stunde. <br>
         Dabei ist 'XX' die Stunde in der Zukunft ausgehend von der aktuellen Stunde (00) und 'BN' die Nummer der registrierten Batterie.
         <br><br>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; ctrlNextHoursSoCForecastReadings 00,03,12,18 <br>
         # erstellt Readings für die aktuelle Stunde (00) sowie die nachfolgenden Stunden +03, +12 und +18.
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-ctrlSolCastAPImaxReq"></a>
       <li><b>ctrlSolCastAPImaxReq </b><br>
         (nur bei Verwendung Model SolCastAPI) <br><br>

         Die Einstellung der maximal möglichen täglichen Requests an die SolCast API. <br>
         Dieser Wert wird von SolCast vorgegeben und kann sich entsprechend des SolCast
         Lizenzmodells ändern. <br>
         (default: 50)
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlSpecialReadings"></a>
       <li><b>ctrlSpecialReadings </b><br>
         Für die ausgewählten Kennzahlen und Indikatoren werden Readings mit dem
         Namensschema 'special_&lt;Indikator&gt;' erstellt. Die nachfolgende Liste zeigt die auswählbaren Kennzahlen und Indikatoren: <br><br>

         <ul>
         <table>
         <colgroup> <col width="27%"> <col width="73%"> </colgroup>
            <tr><td> <b>BatPowerIn_Sum</b>                   </td><td>die Summe der momentanen Batterieladeleistung aller definierten Batterie Geräte                                 </td></tr>
            <tr><td> <b>BatPowerOut_Sum</b>                  </td><td>die Summe der momentanen Batterieentladeleistung aller definierten Batterie Geräte                              </td></tr>
            <tr><td> <b>BatWeightedTotalSOC</b>              </td><td>der resultierende (gewichtete) SOC über alle installierten Batterien in %                                       </td></tr>
            <tr><td> <b>allStringsFullfilled</b>             </td><td>Erfüllungsstatus der fehlerfreien Generierung aller Strings                                                     </td></tr>
            <tr><td> <b>conForecastComingNight</b>           </td><td>Verbrauchsprognose vom kommenden Sonnenuntergang bis zum kommenden Sonnenaufgang. Ist der Sonnenuntergang       </td></tr>
            <tr><td>                                         </td><td>bereits vergangen, ist es die Verbrauchsprognose ab aktueller Zeit (Nacht) bis zum kommenden Sonnenaufgang.     </td></tr>
            <tr><td> <b>conForecastTillNextSunrise</b>       </td><td>Verbrauchsprognose von aktueller Stunde bis zum kommenden Sonnenaufgang                                         </td></tr>
            <tr><td> <b>currentAPIinterval</b>               </td><td>das aktuelle Abrufintervall der gewählten Strahlungsdaten-API in Sekunden                                       </td></tr>
            <tr><td> <b>currentRunMtsConsumer_XX</b>         </td><td>die Laufzeit (Minuten) des Verbrauchers "XX" seit dem letzten Einschalten. (letzter Laufzyklus)                 </td></tr>
            <tr><td> <b>dayAfterTomorrowPVforecast</b>       </td><td>Liefert die Vorhersage der PV Erzeugung für Übermorgen (sofern verfügbar) ohne Autokorrektur (Rohdaten).        </td></tr>
            <tr><td> <b>dummyConsumption</b>                 </td><td>Liefert den aktuellen, Verbrauchern nicht zuordenbaren Hausverbrauch. Enthält auch Verlustleistungsanteile.     </td></tr>
            <tr><td> <b>daysUntilBatteryCare_XX</b>          </td><td>Tage bis zur nächsten Batterie XX Pflege (Erreichen der Ladung 'maxSoC' aus Attribut ctrlBatSocManagementXX)    </td></tr>
            <tr><td> <b>lastretrieval_time</b>               </td><td>der letzte Abrufzeitpunkt der gewählten Strahlungsdaten-API                                                     </td></tr>
            <tr><td> <b>lastretrieval_timestamp</b>          </td><td>der Timestamp der letzen Abrufzeitpunkt der gewählten Strahlungsdaten-API                                       </td></tr>
            <tr><td> <b>remainingSurplsHrsMinPwrBat_XX</b>   </td><td>die verbleibende Anzahl Stunden am aktuellen Tag, in denen der PV-Überschuß (Wh) höher ist als das              </td></tr>
            <tr><td>                                         </td><td>kalkulierte Stundenintegral der minimalen Ladeleistung &lt;MinPwr&gt; der Batterie XX.                          </td></tr>
            <tr><td>                                         </td><td>Die Angabe &lt;MinPwr&gt; erfolgt im Attribut ctrlBatSocManagementXX->loadAbort.                                </td></tr>
            <tr><td> <b>remainingHrsWoChargeRcmdBat_XX</b>   </td><td>die verbleibende Anzahl Stunden ohne Ladeempfehlung für Batterie XX am aktuellen Tag                            </td></tr>
            <tr><td> <b>response_message</b>                 </td><td>die letzte Statusmeldung der gewählten Strahlungsdaten-API                                                      </td></tr>
            <tr><td> <b>runTimeAvgDayConsumer_XX</b>         </td><td>die durchschnittliche Laufzeit (Minuten) des Verbrauchers "XX" an einem Tag                                     </td></tr>
            <tr><td> <b>runTimeCentralTask</b>               </td><td>die Laufzeit des letzten SolarForecast Intervalls (Gesamtprozess) in Sekunden                                   </td></tr>
            <tr><td> <b>runTimeTrainAI</b>                   </td><td>die Laufzeit des letzten KI Trainingszyklus in Sekunden                                                         </td></tr>
            <tr><td> <b>runTimeLastAPIAnswer</b>             </td><td>die letzte Antwortzeit des Strahlungsdaten-API Abrufs auf einen Request in Sekunden                             </td></tr>
            <tr><td> <b>runTimeLastAPIProc</b>               </td><td>die letzte Prozesszeit zur Verarbeitung der empfangenen Strahlungsdaten-API Daten                               </td></tr>
            <tr><td> <b>SunMinutes_Remain</b>                </td><td>die verbleibenden Minuten bis Sonnenuntergang des aktuellen Tages                                               </td></tr>
            <tr><td> <b>SunHours_Remain</b>                  </td><td>die verbleibenden Stunden bis Sonnenuntergang des aktuellen Tages                                               </td></tr>
            <tr><td> <b>todayConsumption</b>                 </td><td>der Energieverbrauch des Hauses am aktuellen Tag                                                                </td></tr>
            <tr><td> <b>todayNotOwnerConsumption</b>         </td><td>der Energieverbrauch am aktuellen Tag, der den registrierten Verbrauchern nicht zugeordnet werden kann          </td></tr>
            <tr><td> <b>todayConsumptionForecastDay</b>      </td><td>Verbrauchsprognose für den aktuellen Tag                                                                        </td></tr>
            <tr><td> <b>todayConsumptionForecast</b>         </td><td>Verbrauchsprognose pro Stunde des aktuellen Tages (01-24)                                                       </td></tr>
            <tr><td> <b>todayConForecastTillSunset</b>       </td><td>Verbrauchsprognose von aktueller Stunde bis Stunde vor Sonnenuntergang                                          </td></tr>
            <tr><td> <b>todayDoneAPIcalls</b>                </td><td>die Anzahl der am aktuellen Tag ausgeführten Strahlungsdaten-API Calls                                          </td></tr>
            <tr><td> <b>todayDoneAPIrequests</b>             </td><td>die Anzahl der am aktuellen Tag ausgeführten Strahlungsdaten-API Requests                                       </td></tr>
            <tr><td> <b>todayGridConsumption</b>             </td><td>die aus dem öffentlichen Netz bezogene Energie am aktuellen Tag                                                 </td></tr>
            <tr><td> <b>todayGridFeedIn</b>                  </td><td>die in das öffentliche Netz eingespeiste PV Energie am aktuellen Tag                                            </td></tr>
            <tr><td> <b>todayMaxAPIcalls</b>                 </td><td>die maximal mögliche Anzahl Strahlungsdaten-API Calls.                                                          </td></tr>
            <tr><td>                                         </td><td>Ein Call kann mehrere API Requests enthalten.                                                                   </td></tr>
            <tr><td> <b>todayRemainingAPIcalls</b>           </td><td>die Anzahl der am aktuellen Tag noch möglichen Strahlungsdaten-API Calls                                        </td></tr>
            <tr><td> <b>todayRemainingAPIrequests</b>        </td><td>die Anzahl der am aktuellen Tag noch möglichen Strahlungsdaten-API Requests                                     </td></tr>
            <tr><td> <b>todayBatIn_XX</b>                    </td><td>die am aktuellen Tag in die Batterie XX geladene Energie                                                        </td></tr>
            <tr><td> <b>todayBatInSum</b>                    </td><td>Summe der am aktuellen Tag in alle Batterien geladene Energie                                                   </td></tr>
            <tr><td> <b>todayBatOut_XX</b>                   </td><td>die am aktuellen Tag aus der Batterie XX entnommene Energie                                                     </td></tr>
            <tr><td> <b>todayBatOutSum</b>                   </td><td>Summe der am aktuellen Tag aus allen Batterien entnommene Energie                                               </td></tr>
            <tr><td> <b>tomorrowConsumptionForecast</b>      </td><td>Verbrauchsprognose pro Stunde des kommenden Tages (01-24)                                                       </td></tr>
         </table>
         </ul>
       <br>
       </li>
       <br>

       <a id="SolarForecast-attr-ctrlUserExitFn"></a>
       <li><b>ctrlUserExitFn {&lt;Code&gt;} </b><br>
         Nach jedem Zyklus (siehe Attribut <a href="#SolarForecast-attr-plantControl">plantControl->cycleInterval</a>) wird der in
         diesem Attribut abgegebene Code ausgeführt. Der Code ist in geschweifte Klammern {...} einzuschließen. <br>
         Dem Code werden die Variablen <b>$name</b> und <b>$hash</b> übergeben, die den Namen des SolarForecast Device und
         dessen Hash enthalten. <br>
         Im SolarForecast Device können Readings über die Funktion <b>storeReading</b> erzeugt und geändert werden.
         <br>
         <br>

         <ul>
         <b>Beispiel: </b> <br>
            {                                                                                           <br>
              my $batdev = (split " ", AttrVal ($name, 'setupBatteryDev01', ''))[0];                    <br>
              my $pvfc   = ReadingsNum ($name, 'RestOfDayPVforecast',            0);                    <br>
              my $cofc   = ReadingsNum ($name, 'RestOfDayConsumptionForecast',   0);                    <br>
              my $diff   = $pvfc - $cofc;                                                               <br>
                                                                                                        <br>
              storeReading ('userFn_Battery_device',  $batdev);                                         <br>
              storeReading ('userFn_estimated_surplus', $diff);                                         <br>
            }
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-flowGraphicControl"></a>
       <li><b>flowGraphicControl &lt;Schlüssel=Wert&gt; &lt;Schlüssel=Wert&gt; ... </b><br>
         Durch die optionale Angabe der nachfolgend aufgeführten Schlüssel=Wert Paare können verschiedene
         Anzeigeeigenschaften der Energieflußgrafik beeinflusst werden. <br>
         Die Eingabe kann mehrzeilig erfolgen.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="26%"> <col width="74%"> </colgroup>
            <tr><td> <b>animate</b>                 </td><td> Animiert die Energieflußgrafik sofern angezeigt. (<a href="#SolarForecast-attr-graphicSelect">graphicSelect</a>)       </td></tr>
            <tr><td>                                </td><td><b>0</b> - Animation aus,  <b>1</b> - Animation an, default: 1                                                          </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>consumerdist</b>            </td><td>Steuert den Abstand zwischen den Verbraucher-Icons.                                                                     </td></tr>
            <tr><td>                                </td><td>Wert: <b>80 ... 500</b>, default: 130                                                                                   </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>h2consumerdist</b>          </td><td>Erweiterung des vertikalen Abstandes zwischen dem Haus und den Verbraucher-Icons.                                       </td></tr>
            <tr><td>                                </td><td>Wert: <b>0 ... 999</b>, default: 0                                                                                      </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>homenodedyncol</b>          </td><td>Das Hausknoten-Icon kann dynamisch in Abhängigkeit der aktuellen Autarkie eingefärbt werden.                            </td></tr>
            <tr><td>                                </td><td><b>0</b> - keine dynamische Färbung,  <b>1</b> - dynamische Färbung, default: 0                                         </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>inverterNodeIcon</b>        </td><td>Icon für den Inverterknoten (das Icon unter der Wechselrichterzeile) und ggf. dessen Farbe bei Aktivität.               </td></tr>
            <tr><td>                                </td><td>Die Farbe kann als Hex-Wert (z.B. #cc3300) oder Bezeichnung (z.B. red, blue) angegeben werden.                          </td></tr>
            <tr><td>                                </td><td>Syntax: <b>&lt;Icon&gt;[@&lt;Farbe&gt;]</b>                                                                             </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>shiftx</b>                  </td><td>Horizontale Verschiebung der Energieflußgrafik.                                                                         </td></tr>
            <tr><td>                                </td><td>Wert: <b>positive oder negative Ganzzahl</b>, default: 0                                                                </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>shifty</b>                  </td><td>Vertikale Verschiebung der Energieflußgrafik.                                                                           </td></tr>
            <tr><td>                                </td><td>Wert: <b>Ganzzahl</b>, default: 0                                                                                       </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumer</b>            </td><td>Anzeige der Verbraucher in der Energieflußgrafik.                                                                       </td></tr>
            <tr><td>                                </td><td><b>0</b> - Anzeige aus,  <b>1</b> - Anzeige an, default: 1                                                              </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumerdummy</b>       </td><td>Steuert die Anzeige des Dummy-Verbrauchers. Dem Dummy-Verbraucher wird der                                              </td></tr>
            <tr><td>                                </td><td>Energieverbrauch zugewiesen der anderen Verbrauchern nicht zugeordnet werden kann.                                      </td></tr>
            <tr><td>                                </td><td><b>0</b> - Anzeige aus,  <b>1</b> - Anzeige an, default: 1                                                              </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumerpower</b>       </td><td>Steuert die Anzeige des Energieverbrauchs der Verbraucher.                                                              </td></tr>
            <tr><td>                                </td><td><b>0</b> - Anzeige aus,  <b>1</b> - Anzeige an, default: 1                                                              </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showconsumerremaintime</b>  </td><td>Steuert die Anzeige der Restlaufzeit (Minuten) der Verbraucher.                                                         </td></tr>
            <tr><td>                                </td><td><b>0</b> - Anzeige aus,  <b>1</b> - Anzeige an, default: 1                                                              </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>showGenerators</b>          </td><td>Steuert die Anzeige der Generatorenzeile (Solarzellen) über den Wechselrichtern.                                        </td></tr>
            <tr><td>                                </td><td><b>0</b> - Anzeige aus,  <b>1</b> - Anzeige an, default: 0                                                              </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>size </b>                   </td><td>Größe der Energieflußgrafik in Pixel sofern angezeigt. (<a href="#SolarForecast-attr-graphicSelect">graphicSelect</a>)  </td></tr>
            <tr><td>                                </td><td>Wert: <b>Ganzzahl</b>, default: 400                                                                                     </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokeconsumerdyncol</b>    </td><td>Die Linien vom Hausknoten zu den Verbrauchern können abhängig vom Verbrauchswert dynamisch eingefärbt werden.           </td></tr>
            <tr><td>                                </td><td><b>0</b> - keine dynamische Färbung,  <b>1</b> - dynamische Färbung, default: 0                                         </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokeCmrRedColLimit</b>    </td><td>Leistungsaufnahme ab der die Linie Haus -> Verbraucher rot dargestellt wird sofern strokeconsumerdyncol=1 gesetzt ist.  </td></tr>
            <tr><td>                                </td><td>Wert: <b>Ganzzahl</b>, default: 400                                                                                     </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokecolina </b>           </td><td>Farbe einer inaktiven Linie                                                                                             </td></tr>
            <tr><td>                                </td><td>Wert: <b>Hex (z.B. #cc3300) oder Bezeichnung (z.B. red, blue)</b>, default: gray                                        </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokecolsig </b>           </td><td>Farbe einer aktiven Signallinie                                                                                         </td></tr>
            <tr><td>                                </td><td>Wert: <b>Hex (z.B. #cc3300) oder Bezeichnung (z.B. red, blue)</b>, default: red                                         </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokecolstd </b>           </td><td>Farbe einer aktiven Standardlinie                                                                                       </td></tr>
            <tr><td>                                </td><td>Wert: <b>Hex (z.B. #cc3300) oder Bezeichnung (z.B. red, blue)</b>, default: darkorange                                  </td></tr>
            <tr><td>                                </td><td>                                                                                                                        </td></tr>
            <tr><td> <b>strokewidth </b>            </td><td>Breite der Linien                                                                                                       </td></tr>
            <tr><td>                                </td><td>Wert: <b>Ganzzahl</b>, default: 25                                                                                      </td></tr>
        </table>
         </ul>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; flowGraphicControl size=300 animate=0 consumerdist=100 showconsumer=1 showconsumerdummy=0 shiftx=-20 strokewidth=15 strokecolstd=#99cc00
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-graphicBeamXColor" data-pattern="graphicBeam.*Color"></a>
       <li><b>graphicBeamXColor </b><br>
         Farbauswahl für den Balken der ausgewählten Ebene. <br>
         Ungerade Balkennummern kennzeichnen den primären, gerade Balkennummern den sekundären Balken. <br>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicBeamXFontColor" data-pattern="graphicBeam.*FontColor"></a>
       <li><b>graphicBeamXFontColor </b><br>
         Auswahl der Schriftfarbe des Balkens der ausgewählten Ebene. <br>
         Ungerade Balkennummern kennzeichnen den primären, gerade Balkennummern den sekundären Balken. <br>
         (default: 000000)
       </li>
       <br>

       <a id="SolarForecast-attr-graphicBeamXContent" data-pattern="graphicBeam.*Content"></a>
       <li><b>graphicBeamXContent </b><br>
         Legt den darzustellenden Inhalt der Balken in den Balkendiagrammen fest.
         Die Balkendiagramme sind in mehreren Ebenen verfügbar. <br>
         Die Ebene 1 ist im Standard voreingestellt.
         Der Inhalt wird durch die Attribute graphicBeam1Content und graphicBeam2Content bestimmt. <br>
         Die Ebene 2 kann durch Setzen der Attribute graphicBeam3Content und graphicBeam4Content aktiviert werden. <br>
         Die Ebene 3 kann durch Setzen der Attribute graphicBeam5Content und graphicBeam6Content aktiviert werden. <br>
         Die Attribute mit ungeraden Ziffern (1,3,5) stellen die primären Balken, die Attribute mit geraden Ziffern die sekundären Balken
         der jeweiligen Ebene dar.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td> <b>batsocCombi_XX</b>      </td><td>der prognostizierte (ab kommender Stunde) und bis zur aktuellen Zeit real erreichte SOC (%) der Batterie XX  </td></tr>
            <tr><td> <b>batsocForecast_XX</b>   </td><td>der prognostizierte SOC (%) der Batterie XX                                                                  </td></tr>
            <tr><td> <b>batsocReal_XX</b>       </td><td>der real erreichte SOC (%) der Batterie XX                                                                   </td></tr>
            <tr><td> <b>batsocForecastSum</b>   </td><td>der prognostizierte SOC (%) als Resultierende über alle Batterien                                            </td></tr>
            <tr><td> <b>batsocRealSum</b>       </td><td>der real erreichte SOC (%) als Resultierende über alle Batterien                                             </td></tr>
            <tr><td> <b>consumption</b>         </td><td>Energieverbrauch                                                                                             </td></tr>
            <tr><td> <b>consumptionForecast</b> </td><td>prognostizierter Energieverbrauch                                                                            </td></tr>
            <tr><td> <b>energycosts</b>         </td><td>Kosten des Energiebezuges aus dem Netz. Die Währung ist im setupMeterDev, Schlüssel conprice, definiert.     </td></tr>
            <tr><td> <b>feedincome</b>          </td><td>Vergütung für die Netzeinspeisung. Die Währung ist im setupMeterDev, Schlüssel feedprice, definiert.         </td></tr>
            <tr><td> <b>gridconsumption</b>     </td><td>Energiebezug aus dem öffentlichen Netz                                                                       </td></tr>
            <tr><td> <b>gridfeedin</b>          </td><td>Einspeisung in das öffentliche Netz                                                                          </td></tr>
            <tr><td> <b>pvForecast</b>          </td><td>prognostizierte PV-Erzeugung (default für graphicBeam2Content)                                               </td></tr>
            <tr><td> <b>pvReal</b>              </td><td>reale PV-Erzeugung (default für graphicBeam1Content)                                                         </td></tr>
         </table>
         </ul>
         <br>

         <b>Hinweis:</b> Die Auswahl der Parameter energycosts und feedincome ist nur sinnvoll wenn in setupMeterDev die
                         optionalen Schlüssel conprice und feedprice gesetzt sind.
       </li>
       <br>

       <a id="SolarForecast-attr-graphicControl"></a>
       <li><b>graphicControl &lt;Schlüssel=Wert&gt; &lt;Schlüssel=Wert&gt; ... </b><br>
         Durch die Angabe der nachfolgend aufgeführten 'Schlüssel=Wert' Paare können verschiedene
         übergreifende Eigenschaften der Grafik- bzw. Balkengrafikdarstellung eingestellt werden. <br>
         Die Eingabe kann mehrzeilig erfolgen.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="15%"> <col width="85%"> </colgroup>
            <tr><td> <b>beamHeightlevel</b>     </td><td>Für jede Ebene der Balkengrafik kann die Balkenhöhe der jeweiligen Ebene festgelegt werden.                                     </td></tr>
            <tr><td>                            </td><td>Die Angabe für eine Ebene besteht aus der Ebenen-Nummer (1..X), einem ':' gefolgt von einer positiven Ganzzahl > 0.             </td></tr>
            <tr><td>                            </td><td>Der Zahlenwert wird als Normierungsfaktor bei der Höhenberechnung verwendet.                                                    </td></tr>
            <tr><td>                            </td><td>Die Angabe für weitere Ebenen erfolgt durch Komma getrennt (siehe Beispiel).                                                    </td></tr>
            <tr><td>                            </td><td><b>&lt;Ebene&gt;:&lt;Ganzzahl&gt;</b> - Normierungsfaktor (default: 200)                                                        </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>beamPaddingBottom</b>   </td><td>Legt den Platz in px im Balkendiagramm fest, der zwischen der letzten Text- oder Iconreihe der jeweiligen Balkengrafik Ebene    </td></tr>
            <tr><td>                            </td><td>und dem unteren Rand dieser Ebene eingefügt wird.                                                                               </td></tr>
            <tr><td>                            </td><td>Der Wert gilt einheitlich für alle Balkengrafik Ebenen.                                                                         </td></tr>
            <tr><td>                            </td><td>Wert: <b>Ganzzahl</b>, default: 0                                                                                               </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>beamPaddingTop</b>      </td><td>Legt den Platz in px im Balkendiagramm fest, der zwischen dem oberen Rand der jeweiligen Balkengrafik Ebene und der ersten      </td></tr>
            <tr><td>                            </td><td>Text- oder Iconreihe dieser Ebene eingefügt wird.                                                                               </td></tr>
            <tr><td>                            </td><td>Der Wert gilt einheitlich für alle Balkengrafik Ebenen.                                                                         </td></tr>
            <tr><td>                            </td><td>Wert: <b>Ganzzahl</b>, default: 0                                                                                               </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>beamWidth</b>           </td><td>Bestimmt die Breite der Balken der Balkengrafik in px.                                                                          </td></tr>
            <tr><td>                            </td><td>Ohne gesetzen Attribut wird die Balkenbreite durch das Modul automatisch dynamisch angepasst.                                   </td></tr>
            <tr><td>                            </td><td>Wert: <b>Ganzzahl 20..100</b>, default: 20                                                                                      </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>energyUnit</b>          </td><td>Definiert die Einheit zur Anzeige der elektrischen Leistung in der Grafik.                                                      </td></tr>
            <tr><td>                            </td><td>Die Kilowattstunde wird auf eine Nachkommastelle gerundet.                                                                      </td></tr>
            <tr><td>                            </td><td>Wert: <b>Wh | kWh</b>, default: Wh                                                                                              </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>hourCount</b>           </td><td>Anzahl der Balken/Stunden in der Balkengrafk.                                                                                   </td></tr>
            <tr><td>                            </td><td>Wert: <b>Ganzzahl 4..24</b>, default: 24                                                                                        </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>headerDetail</b>        </td><td>Auswahl der anzuzeigenden Zonen des Grafik Kopfbereiches. Die gewählten Optionen werden durch Komma getrennt angegeben.         </td></tr>
            <tr><td>                            </td><td><b>all</b>    - alle Zonen des Kopfbereiches (default)                                                                          </td></tr>
            <tr><td>                            </td><td><b>co</b>     - Verbrauchsbereich                                                                                               </td></tr>
            <tr><td>                            </td><td><b>pv</b>     - Erzeugungsbereich                                                                                               </td></tr>
            <tr><td>                            </td><td><b>own</b>    - Nutzerzone (siehe <a href="#SolarForecast-attr-graphicHeaderOwnspec">graphicHeaderOwnspec</a>)                  </td></tr>
            <tr><td>                            </td><td><b>status</b> - Bereich der Statusinformationen                                                                                 </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>hourStyle</b>           </td><td>Format der Zeitangabe in der Balkengrafik.                                                                                      </td></tr>
            <tr><td>                            </td><td><b>nicht gesetzt</b> - nur Stundenangabe ohne Minuten (default)                                                                 </td></tr>
            <tr><td>                            </td><td><b>:00</b>           - Stunden sowie Minuten zweistellig, z.B. 10:00                                                            </td></tr>
            <tr><td>                            </td><td><b>:0</b>            - Stunden sowie Minuten einstellig, z.B. 8:0                                                               </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>layoutType</b>          </td><td>Layout der Balkengrafik. Der darzustellende Inhalt der Balken wird durch die Attribute <b>graphicBeamXContent</b> bestimmt.     </td></tr>
            <tr><td>                            </td><td><b>double</b> - zeigt den primären Balken und den sekundären Balken an (default)                                                </td></tr>
            <tr><td>                            </td><td><b>single</b> - zeigt nur den primären Balken an                                                                                </td></tr>
            <tr><td>                            </td><td><b>diff</b>   - Differenzanzeige. Es gilt:  &lt;Differenz&gt; = &lt;Wert primärer Balken&gt; - &lt;Wert sekundärer Balken&gt;   </td></tr>
            <tr><td>                            </td><td>Die Einstellung von <a href="#SolarForecast-attr-graphicControl">graphicControl->energyUnit</a> wird nicht berücksichtigt.      </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>scaleMode</b>           </td><td>Für jede Ebene der Balkengrafik kann der Skalierungsmodus linear oder logarithmisch festgelegt werden.                          </td></tr>
            <tr><td>                            </td><td>Die logarithmische Einstellung hebt kleine Werte stärker an und komprimiert größere Werte in der Darstellung.                   </td></tr>
            <tr><td>                            </td><td>Die Angabe für eine Ebene besteht aus der Ebenen-Nummer (1..X), einem ':' gefolgt von dem Modus 'lin' oder 'log'.               </td></tr>
            <tr><td>                            </td><td>Die Strings für jede Ebene werden durch Komma getrennt (siehe Beispiel).                                                        </td></tr>
            <tr><td>                            </td><td><b>&lt;Ebene&gt;:lin</b> - lineare Skalierung (default)                                                                         </td></tr>
            <tr><td>                            </td><td><b>&lt;Ebene&gt;:log</b> - logarithmische Skalierung                                                                            </td></tr>
            <tr><td>                            </td><td><b>&lt;Ebene&gt;:staple</b> - die Balken werden 'gestapelt', der sekundäre Balken wird über dem primären Balken dargestellt     </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>showDiff</b>            </td><td>Zusätzliche numerische Anzeige der Differenz '&lt;primärer Balkeninhalt&gt; - &lt;sekundärer Balkeninhalt&gt;'.                 </td></tr>
            <tr><td>                            </td><td>Die Angabe für jede Ebene besteht aus der Ebenen-Nummer (1..X), einem ':' gefolgt von der Position 'top' oder 'bottom'.         </td></tr>
            <tr><td>                            </td><td>Die Strings für jede Ebene werden durch Komma getrennt (siehe Beispiel).                                                        </td></tr>
            <tr><td>                            </td><td><b>&lt;Ebene&gt;:top</b>    - Anzeige über den Balken                                                                           </td></tr>
            <tr><td>                            </td><td><b>&lt;Ebene&gt;:bottom</b> - Anzeige unter den Balken                                                                          </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
            <tr><td> <b>spaceSize</b>           </td><td>Legt fest, wieviel Platz in px über oder unter den Balken (bei Anzeigetyp layoutType=diff) zur Anzeige der                      </td></tr>
            <tr><td>                            </td><td>Werte freigehalten wird. Bei Styles mit großen Fonts kann der default-Wert zu klein sein bzw. rutscht ein                       </td></tr>
            <tr><td>                            </td><td>Balken u.U. über die Grundlinie. In diesen Fällen bitte den Wert erhöhen.                                                       </td></tr>
            <tr><td>                            </td><td>Wert: <b>Ganzzahl</b>, default: 24                                                                                              </td></tr>
            <tr><td>                            </td><td>                                                                                                                                </td></tr>
          </table>
         </ul>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; graphicControl beamWidth=45 headerDetail=co,pv energyUnit=kWh hourCount=10 layoutType=diff hourStyle=:00 scaleMode=1:log,2:lin,3:log showDiff=1:top,2:bottom beamHeightlevel=1:260,2:80,3:400
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-graphicHeaderOwnspec"></a>
       <li><b>graphicHeaderOwnspec &lt;Label&gt;:&lt;Reading&gt;[@Device] &lt;Label&gt;:&lt;Set&gt;[@Device] &lt;Label&gt;:&lt;Attr&gt;[@Device] ... </b> <br><br>

         Anzeige beliebiger Readings, Set-Kommandos und Attribute des SolarForecast Devices im Grafikkopf. <br>
         Es werden vier Werte (Felder) pro Zeile dargestellt. <br>
         Werte mit den Einheiten "Wh" bzw. "kWh" werden entsprechend der Einstellung
         des Attributs <a href="#SolarForecast-attr-graphicControl">graphicControl->energyUnit</a> umgerechnet.
         <br><br>

         Jeder Wert ist jeweils durch ein Label und das anzuzeigende Element (Attribut, Reading, Set-Kommando) verbunden durch ":" zu definieren. <br>
         Ein einzelner Schlüsselwert eines kombinierten Attributes (ctrlBatSocManagementXX, flowGraphicControl, etc.) kann durch Ergänzung 
         von '->&lt;Schlüssel&gt;' angezeigt und geändert werden. <br>
         Das Element kann optional mit '@&lt;Device&gt;' ergänzt werden um Readings, Set-Kommandos und Attribute anderer Devices anzuzeigen. <br>
         Die anzuzeigenden Elemente werden durch Leerzeichen oder eine neue Zeile getrennt.
         Leerzeichen im Label sind durch "&amp;nbsp;" einzufügen, ein Zeilenumbruch durch "&lt;br&gt;". <br>
         Ein leeres Feld in einer Zeile wird durch ":" erzeugt. <br>
         Ein Zeilentitel kann durch Angabe von "#:&lt;Text&gt;" eingefügt werden, ein leerer Titel durch die Eingabe von "#".
         <br><br>

       <ul>
         <b>Beispiel: </b> <br>
         <table>
         <colgroup> <col width="35%"> <col width="65%"> </colgroup>
            <tr><td> attr &lt;name&gt; graphicHeaderOwnspec  </td><td>#                                                                             </td></tr>
            <tr><td>                                         </td><td>AutarkyRate:Current_AutarkyRate                                               </td></tr>
            <tr><td>                                         </td><td>Überschuß:Current_Surplus                                                     </td></tr>
            <tr><td>                                         </td><td>aktueller&amp;nbsp;Netzbezug:Current_GridConsumption                          </td></tr>
            <tr><td>                                         </td><td>:                                                                             </td></tr>
            <tr><td>                                         </td><td>#                                                                             </td></tr>
            <tr><td>                                         </td><td>CO&amp;nbsp;bis&amp;nbsp;Sonnenuntergang:special_todayConForecastTillSunset   </td></tr>
            <tr><td>                                         </td><td>PV&amp;nbsp;Übermorgen:special_dayAfterTomorrowPVforecast                     </td></tr>
            <tr><td>                                         </td><td>InverterRelay:gridrelay_status@MySTP_5000                                     </td></tr>
            <tr><td>                                         </td><td>:                                                                             </td></tr>
            <tr><td>                                         </td><td>#Batterie                                                                     </td></tr>
            <tr><td>                                         </td><td>in&amp;nbsp;heute:special_todayBatIn                                          </td></tr>
            <tr><td>                                         </td><td>out&amp;nbsp;heute:special_todayBatOut                                        </td></tr>
            <tr><td>                                         </td><td>Ladeziel:ctrlBatSocManagement01->loadTarget                                                                             </td></tr>
            <tr><td>                                         </td><td>:                                                                             </td></tr>
            <tr><td>                                         </td><td>#Settings                                                                     </td></tr>
            <tr><td>                                         </td><td>Autokorrektur:pvCorrectionFactor_Auto : : :                                   </td></tr>
            <tr><td>                                         </td><td>Consumer&lt;br&gt;Neuplanung:consumerNewPlanning : : :                        </td></tr>
            <tr><td>                                         </td><td>Consumer&lt;br&gt;Sofortstart:consumerImmediatePlanning : : :                 </td></tr>
            <tr><td>                                         </td><td>Wetter:graphicShowWeather : : :                                               </td></tr>
            <tr><td>                                         </td><td>History:graphicHistoryHour : : :                                              </td></tr>
            <tr><td>                                         </td><td>ShowNight:graphicShowNight : : :                                              </td></tr>
            <tr><td>                                         </td><td>Debug:ctrlDebug : : :                                                         </td></tr>
         </table>
       </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicHeaderOwnspecValForm"></a>
       <li><b>graphicHeaderOwnspecValForm </b> <br><br>

         Die mit dem Attribut <a href="#SolarForecast-attr-graphicHeaderOwnspec">graphicHeaderOwnspec</a> anzuzeigenden
         Readings können mit sprintf und anderen Perl Operationen manipuliert werden. <br>
         Es stehen zwei grundsätzliche, miteinander nicht kombinierbare Möglichkeiten der Notation zur Verfügung. <br>
         Die Angabe der Notationen erfolgt grundsätzlich innerhalb von zwei geschweiften Klammern {...}.
         <br><br>
         <b>Hinweis:</b> Werte mit den Einheiten 'Wh' oder 'kWh' werden entsprechend der Einstellung
         des Attributs <a href="#SolarForecast-attr-graphicControl">graphicControl->energyUnit</a> automatisch umgerechnet und dargestellt.
         <br><br>

         <b>Notation 1: </b> <br>
         Eine einfache Formatierung von Readings des eigenen Devices mit sprintf erfolgt wie in Zeile
         'Current_AutarkyRate' bzw. 'Current_GridConsumption' angegeben. <br>
         Andere Perl Operationen sind mit () zu klammern. Die jeweiligen Readingswerte und Einheiten stehen über
         die Variablen $VALUE und $UNIT zur Verfügung. <br>
         Readings anderer Devices werden durch die Angabe '&lt;Device&gt;.&lt;Reading&gt;' spezifiziert.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="20%"> <col width="80%"> </colgroup>
            <tr><td>{                                        </td><td>                                               </td></tr>
            <tr><td> 'Current_AutarkyRate'                   </td><td> => "%.1f %%",                                 </td></tr>
            <tr><td> 'Current_GridConsumption'               </td><td> => "%.2f $UNIT",                              </td></tr>
            <tr><td> 'SMA_Energymeter.Cover_RealPower'       </td><td> => q/($VALUE)." W"/,                          </td></tr>
            <tr><td> 'SMA_Energymeter.L2_Cover_RealPower'    </td><td> => "($VALUE).' W'",                           </td></tr>
            <tr><td> 'SMA_Energymeter.L1_Cover_RealPower'    </td><td> => '(sprintf "%.2f", ($VALUE / 1000))." kW"', </td></tr>
            <tr><td>}                                        </td><td>                                               </td></tr>
         </table>
         </ul>
         <br>

         <b>Notation 2: </b> <br>
         Die Manipulation von Readingwerten und Einheiten erfolgt über Perl If ... else Strukturen. <br>
         Der Struktur stehen Device, Reading, Readingwert und Einheit mit den Variablen $DEVICE, $READING, $VALUE und
         $UNIT zur Verfügung. <br>
         Bei Änderung der Variablen werden die neuen Werte entsprechend in die Anzeige übernommen.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="5%"> <col width="95%"> </colgroup>
            <tr><td>{ </td><td>                                                   </td></tr>
            <tr><td>  </td><td> if ($READING eq 'Current_AutarkyRate') {          </td></tr>
            <tr><td>  </td><td> &nbsp;&nbsp; $VALUE = sprintf "%.1f", $VALUE;     </td></tr>
            <tr><td>  </td><td> &nbsp;&nbsp; $UNIT  = "%";                        </td></tr>
            <tr><td>  </td><td> }                                                 </td></tr>
            <tr><td>  </td><td> elsif ($READING eq 'Current_GridConsumption') {   </td></tr>
            <tr><td>  </td><td> &nbsp;&nbsp; ...                                  </td></tr>
            <tr><td>  </td><td> }                                                 </td></tr>
            <tr><td>} </td><td>                                                   </td></tr>
         </table>
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicHistoryHour"></a>
       <li><b>graphicHistoryHour </b><br>
         Anzahl der vorangegangenen Stunden die in der Balkengrafik dargestellt werden. <br>
         (default: 2)
       </li>
       <br>

       <a id="SolarForecast-attr-graphicSelect"></a>
       <li><b>graphicSelect </b><br>
         Wählt die anzuzeigenden Grafiksegmente des Moduls aus.
         <br><br>

       <ul>
         <table>
         <colgroup> <col width="30%"> <col width="70%"> </colgroup>
         <tr><td> <b>both</b>                    </td><td>zeigt Grafikkopf, Verbraucherpaneel, Balken- und Energieflußgrafik an (default)       </td></tr>
         <tr><td> <b>both_noHead</b>             </td><td>zeigt Verbraucherpaneel, Balken- und Energieflußgrafik an                             </td></tr>
         <tr><td> <b>both_noCons</b>             </td><td>zeigt Grafikkopf, Balken- und Energieflußgrafik an                                    </td></tr>
         <tr><td> <b>both_noHead_noCons</b>      </td><td>zeigt Balken- und Energieflußgrafik an                                                </td></tr>
         <tr><td> <b>swap</b>                    </td><td>wie 'both', mit vertauschter Balken- und Energieflußgrafik Reihenfolge                </td></tr>
         <tr><td> <b>swap_noHead</b>             </td><td>wie 'both_noHead', mit vertauschter Balken- und Energieflußgrafik Reihenfolge         </td></tr>
         <tr><td> <b>swap_noCons</b>             </td><td>wie 'both_noCons', mit vertauschter Balken- und Energieflußgrafik Reihenfolge         </td></tr>
         <tr><td> <b>swap_noHead_noCons</b>      </td><td>wie 'both_noHead_noCons', mit vertauschter Balken- und Energieflußgrafik Reihenfolge  </td></tr>
         <tr><td> <b>flow</b>                    </td><td>zeigt Grafikkopf, Verbraucherpaneel und Energieflußgrafik an                          </td></tr>
         <tr><td> <b>flow_noHead</b>             </td><td>zeigt Verbraucherpaneel und Energieflußgrafik an                                      </td></tr>
         <tr><td> <b>flow_noCons</b>             </td><td>zeigt Grafikkopf und Energieflußgrafik an                                             </td></tr>
         <tr><td> <b>flow_noHead_noCons</b>      </td><td>zeigt Energieflußgrafik an                                                            </td></tr>
         <tr><td> <b>forecast</b>                </td><td>zeigt Grafikkopf, Verbraucherpaneel und Balkengrafik an                               </td></tr>
         <tr><td> <b>forecast_noHead</b>         </td><td>zeigt Verbraucherpaneel und Balkengrafik an                                           </td></tr>
         <tr><td> <b>forecast_noCons</b>         </td><td>zeigt Grafikkopf und Balkengrafik an                                                  </td></tr>
         <tr><td> <b>forecast_noHead_noCons</b>  </td><td>zeigt Balkengrafik an                                                                 </td></tr>
         <tr><td> <b>none</b>                    </td><td>zeigt nur Grafikkopf und Verbraucherpaneel an                                         </td></tr>
         </table>
       </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicShowNight"></a>
       <li><b>graphicShowNight </b><br>
         Anzeigen oder Verbergen der Nachtstunden in der Balkengrafik.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="5%"> <col width="95%"> </colgroup>
            <tr><td> <b>0</b>   </td><td>keine Anzeige der Nachtstunden sofern kein Wert anzuzeigen ist (default)                           </td></tr>
            <tr><td>            </td><td>Sofern die ausgewählten Inhalte einen Wert enthalten, werden diese Balken dennoch dargestellt.     </td></tr>
            <tr><td> <b>01</b>  </td><td>Wie '0', es findet jedoch eine Zeitsynchronisation zwischen der Ebene 1                            </td></tr>
            <tr><td>            </td><td>und der nachfolgenden Balkengrafikebene statt.                                                     </td></tr>
            <tr><td> <b>1</b>   </td><td>Nachtstunden werden immer angezeigt                                                                </td></tr>
         </table>
         </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-graphicShowWeather"></a>
       <li><b>graphicShowWeather </b><br>
         Wettericons in der Balkengrafik anzeigen/verbergen. <br>
         (default: 1)
       </li>
       <br>

       <a id="SolarForecast-attr-graphicWeatherColor"></a>
       <li><b>graphicWeatherColor </b><br>
         Farbe der Wetter-Icons in der Balkengrafik für die Tagesstunden.
       </li>
       <br>

       <a id="SolarForecast-attr-graphicWeatherColorNight"></a>
       <li><b>graphicWeatherColorNight </b><br>
         Farbe der Wetter-Icons für die Nachtstunden.
       </li>
       <br>

       <a id="SolarForecast-attr-plantControl"></a>
       <li><b>plantControl &lt;Schlüssel=Wert&gt; &lt;Schlüssel=Wert&gt; ... </b><br>
         Durch die optionale Angabe der nachfolgend aufgeführten 'Schlüssel=Wert' Paare können verschiedene
         Eigenschaften der Gesamtanlage eingestellt werden.
         Die Eingabe kann mehrzeilig erfolgen.
         <br><br>

         <ul>
         <table>
         <colgroup> <col width="23%"> <col width="77%"> </colgroup>
            <tr><td> <b>backupFilesKeep</b>           </td><td>Legt die Anzahl der Generationen von Sicherungsdateien fest.                                                                                      </td></tr>
            <tr><td>                                  </td><td>(siehe <a href="#SolarForecast-set-operatingMemory">set &lt;name&gt; operatingMemory backup</a>)                                                  </td></tr>
            <tr><td>                                  </td><td>Ist backupFilesKeep explit auf '0' gesetzt, erfolgt keine automatische Generierung und Bereinigung von Sicherungsdateien.                         </td></tr>
            <tr><td>                                  </td><td>Eine manuelle Ausführung mit dem genannten Set-Kommando ist weiterhin möglich.                                                                    </td></tr>
            <tr><td>                                  </td><td>Wert: <b>Ganzzahl</b>, default: 3                                                                                                                 </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>batteryPreferredCharge</b>    </td><td>Verbraucher mit dem Mode <b>can</b> werden erst dann eingeschaltet, wenn die angegebene Batterieladung (%) erreicht ist.                          </td></tr>
            <tr><td>                                  </td><td>Verbraucher mit dem Mode <b>must</b> beachten die Vorrangladung der Batterie nicht.                                                               </td></tr>
            <tr><td>                                  </td><td>Wert: <b>Ganzzahl 0..100</b>, default: 0                                                                                                          </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>consForecastIdentWeekdays</b> </td><td>Wenn gesetzt, werden zur Berechnung der Verbrauchsprognose nur gleiche Wochentage (Mo..So) einbezogen.                                            </td></tr>
            <tr><td>                                  </td><td>Anderenfalls werden alle Wochentage gleichberechtigt zur Kalkulation verwendet.                                                                   </td></tr>
            <tr><td>                                  </td><td>Wert: <b>0|1</b>, default: 0                                                                                                                      </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>consForecastInPlanning</b>    </td><td>Der Schlüssel bestimmt die Vorgehensweise bei der Einplanung der registrierten Verbraucher.                                                       </td></tr>
            <tr><td>                                  </td><td><b>0</b> - die Einplanung der Verbraucher erfolgt auf Grundlage der PV Prognose (default)                                                         </td></tr>
            <tr><td>                                  </td><td><b>1</b> - die Einplanung der Verbraucher erfolgt auf Grundlage der PV Prognose und der Prognose des Verbrauchs                                   </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>consForecastLastDays</b>      </td><td>Es wird die angegebene Anzahl historischer Tage bei der Berechnung der Verbrauchsprognose einbezogen.                                             </td></tr>
            <tr><td>                                  </td><td>So wird z.B. mit dem Attributwert "1" nur der vorangegangene Tag berücksichtigt, mit dem Wert '14' die vergangenen 14 Tage.                       </td></tr>
            <tr><td>                                  </td><td>Die berücksichtigten Tage können geringer ausfallen, wenn noch nicht genügend Werte im internen Speicher vorhanden sind.                          </td></tr>
            <tr><td>                                  </td><td>Bei einem zusätzlich gesetzten Schlüssel 'consForecastIdentWeekdays' wird die angegebene Anzahl vergangener                                       </td></tr>
            <tr><td>                                  </td><td><b>gleicher</b> Wochentage (Mo .. So) berücksichtigt.                                                                                             </td></tr>
            <tr><td>                                  </td><td>Zum Beispiel werden dann bei einem gesetzten Wert von '8' die gleichen Wochentage der vergangenen 8 Wochen berücksichtigt.                        </td></tr>
            <tr><td>                                  </td><td>Wert: <b>Ganzzahl 0..180</b>, default: 60                                                                                                         </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>cycleInterval</b>             </td><td>Wiederholungsintervall der Datensammlung in Sekunden.                                                                                             </td></tr>
            <tr><td>                                  </td><td>Ist cycleInterval explizit auf '0' gesetzt, erfolgt keine regelmäßige Datensammlung und muss mit 'get &lt;name&gt; data'                          </td></tr>
            <tr><td>                                  </td><td>extern gestartet werden.                                                                                                                          </td></tr>
            <tr><td>                                  </td><td>Wert: <b>Ganzzahl</b>, default: 70                                                                                                                </td></tr>
            <tr><td>                                  </td><td><b>Hinweis:</b> Unabhängig vom eingestellten Intervall (auch bei '0') erfolgt einige Sekunden vor dem Ende                                        </td></tr>
            <tr><td>                                  </td><td>sowie nach dem Beginn einer vollen Stunde eine automatische Datensammlung. Weiterhin erfolgt eine automatische Datensammlung                      </td></tr>
            <tr><td>                                  </td><td>wenn ein Event eines als "asynchron" definierten Gerätes (Consumer, Meter, etc.) empfangen und verarbeitet wird.                                  </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>feedinPowerLimit</b>          </td><td>Einspeiselimit der Gesamtanlage in das öffentliche Netz in Watt.                                                                                  </td></tr>
            <tr><td>                                  </td><td>SolarForecast limitiert die Einspeisung nicht, verwendet diese Angabe jedoch                                                                      </td></tr>
            <tr><td>                                  </td><td>innerhalb des Batterie-Lademanagements zur Vermeidung einer Anlagenabregelung.                                                                    </td></tr>
            <tr><td>                                  </td><td>Wert: <b>Ganzzahl</b>, default: unbegrent                                                                                                         </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>genPVdeviation</b>            </td><td>Legt die Methode zur Berechnung der Abweichung von prognostizierter und realer PV Erzeugung fest.                                                 </td></tr>
            <tr><td>                                  </td><td>Das Reading <b>Today_PVdeviation</b> wird in Abhängigkeit dieser Einstellung erstellt.                                                            </td></tr>
            <tr><td>                                  </td><td>Der optionale Zusatz ':reverse' legt fest, dass PV-Erzeugung > Prognose als positiver statt negativer Wert gewertet wird (Perspektivwechsel).     </td></tr>
            <tr><td>                                  </td><td><b>daily[:reverse]</b>        - Berechnung und Erstellung von Today_PVdeviation erfolgt nach Sonnenuntergang (default)                            </td></tr>
            <tr><td>                                  </td><td><b>continuously[:reverse]</b> - Berechnung und Erstellung von Today_PVdeviation erfolgt fortlaufend                                               </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>genPVforecastsToEvent</b>     </td><td>Das Modul erzeugt täglich 'AllPVforecastsToEvent'-Events zur Visualisierung der PV Prognose.                                                      </td></tr>
            <tr><td>                                  </td><td>Nähere Erläuterungen dazu sind im <a href='https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung#Visualisierung_solare_Vorhersage_und_reale_Erzeugung' target='_blank'>Wiki</a> beschrieben. </td></tr>
            <tr><td>                                  </td><td><b>Hinweis:</b> Bei Nutzung des Attributes ist ebenfalls das Attribut <b>event-on-update-reading=AllPVforecastsToEvent</b> zu setzen.             </td></tr>
            <tr><td>                                  </td><td>Die Eventerzeugung kann für bestimmte Nutzungen optimiert werden:                                                                                 </td></tr>
            <tr><td>                                  </td><td><b>adapt4Steps</b> - die Events werden für den SVG Plot-Type 'steps' optimiert                                                                    </td></tr>
            <tr><td>                                  </td><td><b>adapt4fSteps</b> - die Events werden für den SVG Plot-Type 'fsteps' optimiert                                                                  </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>reductionState</b>            </td><td>Liefert einen Status an SolarForecast wenn die PV-Anlage abgeregelt wird bzw. abgeregelt ist (optional).                                          </td></tr>
            <tr><td>                                  </td><td><b>Device</b> - Device welches den Abregelungsstatus liefert                                                                                      </td></tr>
            <tr><td>                                  </td><td><b>Reading</b> - Reading welches den Abregelungsstatus liefert                                                                                    </td></tr>
            <tr><td>                                  </td><td>Die Prüfung des gelieferten Wertes kann als regulärer Ausdruck oder als in {..} eingeschlossener Perl-Code formuliert sein:                       </td></tr>
            <tr><td>                                  </td><td><b>Regex</b> - regulärer Ausdruck der für einen Abregelungsstatus (wahr) erfüllt sein muß                                                         </td></tr>
            <tr><td>                                  </td><td><b>{Perl-Code}</b> - der in {..} eingeschlossene Perl-Code muß 'wahr' für einen Abregelungsstatus liefern. Er darf keine Leerzeichen enthalten.   </td></tr>
            <tr><td>                                  </td><td>Der Wert von  Device:Reading wird dem Code mit der Variable $VALUE übergeben.                                                                     </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
            <tr><td> <b>showLink</b>                  </td><td>Anzeige eines Links zur Detailansicht des Device über dem Grafikbereich                                                                           </td></tr>
            <tr><td>                                  </td><td><b>0</b> - Anzeige aus, <b>1</b> - Anzeige an, default: 0                                                                                         </td></tr>
            <tr><td>                                  </td><td>                                                                                                                                                  </td></tr>
         </table>
         </ul>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; plantControl feedinPowerLimit=4800 consForecastInPlanning=1 showLink=1 backupFilesKeep=2 consForecastIdentWeekdays=1 consForecastLastDays=8 genPVdeviation=continuously genPVforecastsToEvent=adapt4Steps
       </ul>

       </li>
       <br>

       <a id="SolarForecast-attr-setupBatteryDev" data-pattern="setupBatteryDev.*"></a>
       <li><b>setupBatteryDevXX &lt;Batterie Device Name&gt; pin=&lt;Readingname&gt;:&lt;Einheit&gt; pout=&lt;Readingname&gt;:&lt;Einheit&gt; cap=&lt;Option&gt;                                                <br>
                                [pinmax=&lt;Ganzzahl&gt] [pinreduced=&lt;Ganzzahl&gt] [poutmax=&lt;Ganzzahl&gt] [intotal=&lt;Readingname&gt;:&lt;Einheit&gt;] [efficiency=&lt;Wert&gt]                          <br>
                                [outtotal=&lt;Readingname&gt;:&lt;Einheit&gt;] [charge=&lt;Readingname&gt;] [asynchron=&lt;Option&gt] [show=&lt;Option&gt]                                                      <br>
                                [label=&lt;Option&gt] [[icon=&lt;empfohlen&gt;@&lt;Farbe&gt;]:[&lt;aufladen&gt;@&lt;Farbe&gt;]:[&lt;entladen&gt;@&lt;Farbe&gt;]:[icon=&lt;unterlassen&gt;@&lt;Farbe&gt;]]  </b> <br><br>

       Legt ein beliebiges Device und seine Readings zur Lieferung der Batterie Leistungsdaten fest. <br>
       Das Modul geht davon aus, dass der numerische Wert der Readings immer positiv ist.
       Es kann auch ein Dummy Device mit entsprechenden Readings sein.
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>pin</b>       </td><td>Reading welches die aktuelle Batterieladeleistung liefert                                                </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>pout</b>      </td><td>Reading welches die aktuelle Batterieentladeleistung liefert                                             </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>pinmax</b>    </td><td>die maximal mögliche Ladeleistung in Watt (optional)                                                     </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>pinreduced</b></td><td>Die reduzierte Ladeleistung in Watt (optional). Der Wert wird im Reading Battery_ChargeOptTargetPower_XX </td></tr>
           <tr><td>                  </td><td>gesetzt wenn die kalkulierte Ladeleistung unter diesen Wert fällt oder der SoC <= lowSoC beträgt.        </td></tr>
           <tr><td>                  </td><td>Somit kann der Wert auch im Fall der Anforderungsladung aus dem öffentlichen Netz zur Anwendung kommen.  </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>poutmax</b>   </td><td>die maximal mögliche Entladeleistung in Watt (optional)                                                  </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>intotal</b>   </td><td>Reading welches die totale Batterieladung als fortlaufenden Zähler liefert (optional)                    </td></tr>
           <tr><td>                  </td><td>Sollte des Reading die Vorgabe eines stetig aufsteigenden Zählers verletzen, behandelt                   </td></tr>
           <tr><td>                  </td><td>SolarForecast diesen Fehler und meldet die aufgetretene Situation durch einen Logeintrag mit verbose 3.  </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>outtotal</b>  </td><td>Reading welches die totale Batterieentladung als fortlaufenden Zähler liefert (optional)                 </td></tr>
           <tr><td>                  </td><td>Sollte des Reading die Vorgabe eines stetig aufsteigenden Zählers verletzen, behandelt                   </td></tr>
           <tr><td>                  </td><td>SolarForecast diesen Fehler und meldet die aufgetretene Situation durch einen Logeintrag mit verbose 3.  </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>cap</b>       </td><td>installierte Batteriekapazität. Option kann sein:                                                        </td></tr>
           <tr><td>                  </td><td><b>Ganzzahl</b> - direkte Angabe der Batteriekapazität in Wh ohne die Einheit anzugeben!                 </td></tr>
           <tr><td>                  </td><td><b>&lt;Readingname&gt;:&lt;Einheit&gt;</b> - Reading welches die Kapazität liefert und Einheit (Wh, kWh) </td></tr>
           <tr><td> <b>charge</b>    </td><td>Reading welches den aktuellen Ladezustand (SOC in Prozent) liefert (optional)                            </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>Einheit</b>   </td><td>die jeweilige Einheit (W,Wh,kW,kWh)                                                                      </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td><b>efficiency</b> </td><td>Optionale Angabe des Wirkungsgrades der Energiespeicherung in %. Dieser Wirkungsgrad beschreibt nicht    </td></tr>
           <tr><td>                  </td><td>nur die Batterie selbst, sondern die Wirkkette inkl. der betroffenen Wechselrichter.                     </td></tr>
           <tr><td>                  </td><td>Je nach Koppelart und anderen Faktoren liegt der typische Wirkungsgrad zwischen 75 - 90 %.               </td></tr>
           <tr><td>                  </td><td>Wert: <b>0..100</b> default: 87                                                                          </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>icon</b>      </td><td>Icon und/oder (nur) Farbe der Batterie in der Balkengrafik entsprechend des Status (optional).           </td></tr>
           <tr><td>                  </td><td>Als Farbe kann der Bezeichner (z.B. blue), HEX-Wert (z.B. #d9d9d9) oder 'dyn' angegeben werden.          </td></tr>
           <tr><td>                  </td><td>Wird 'dyn' verwendet, erfolgt eine vom SoC-Wert abhängige Einfärbung des Icon.                           </td></tr>
           <tr><td>                  </td><td><b>&lt;empfohlen&gt;</b> - Icon wenn die Aufladung empfohlen, aber inaktiv ist (kein Aufladen / Entladen)</td></tr>
           <tr><td>                  </td><td><b>&lt;aufladen&gt;</b> - Icon wird verwendet wenn die Batterie aktuell aufgeladen wird                  </td></tr>
           <tr><td>                  </td><td><b>&lt;entladen&gt;</b> - Icon wird verwendet wenn die Batterie aktuell entladen wird                    </td></tr>
           <tr><td>                  </td><td><b>&lt;unterlassen&gt;</b> - Icon wenn Aufladen nur bei Überschreitung des Einspeiselimits empfohlen     </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>label</b>     </td><td>Wird die Batterie in der Balkengrafik mit dem Schlüssel 'show' angezeigt, kann das Symbol mit dem        </td></tr>
           <tr><td>                  </td><td>aktuellen SOC-Wert (%) beschriftet werden.                                                               </td></tr>
           <tr><td>                  </td><td><b>none</b>   - keine Beschriftung (default)                                                             </td></tr>
           <tr><td>                  </td><td><b>below</b>  - Beschriftung unterhalb des Batteriesymbols                                               </td></tr>
           <tr><td>                  </td><td><b>beside</b> - Beschriftung neben dem Batteriesymbol                                                    </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>show</b>      </td><td>Steuerung der Anzeige der Batterie in der Balkengrafik (optional)                                        </td></tr>
           <tr><td>                  </td><td><b>0</b> - keine Anzeige des Gerätes (default)                                                           </td></tr>
           <tr><td>                  </td><td><b>1..3[:top|bottom]</b> - Anzeige des Gerätes in der Ebene 1,2 oder 3 (über|unter) den Balken           </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
           <tr><td> <b>asynchron</b> </td><td>Modus der Datensammlung entsprechend Einstellung plantControl->cycleInterval (synchron) oder             </td></tr>
           <tr><td>                  </td><td>zusätzlich durch Eventverarbeitung (asynchron).                                                          </td></tr>
           <tr><td>                  </td><td><b>0</b> - keine Datensammlung nach Empfang eines Events des Gerätes (default)                           </td></tr>
           <tr><td>                  </td><td><b>1</b> - auslösen einer Datensammlung bei Empfang eines Events des Gerätes                             </td></tr>
           <tr><td>                  </td><td>                                                                                                         </td></tr>
         </table>
       </ul>
       <br>

       <b>Sonderfälle:</b> Sollte das Reading für pin und pout identisch, aber vorzeichenbehaftet sein,
       können die Schlüssel pin und pout wie folgt definiert werden: <br><br>
       <ul>
         pin=-pout  &nbsp;&nbsp;&nbsp;(ein negativer Wert von pout wird als pin verwendet)  <br>
         pout=-pin  &nbsp;&nbsp;&nbsp;(ein negativer Wert von pin wird als pout verwendet)
       </ul>
       <br>

       Die Einheit entfällt in dem jeweiligen Sonderfall. <br><br>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; setupBatteryDev01 BatDummy pin=BatVal:W pout=-pin intotal=BatInTot:Wh outtotal=BatOutTot:Wh cap=BatCap:kWh show=2:bottom icon=measure_battery_50@#262626:@yellow:measure_battery_100@red  <br>
         attr &lt;name&gt; setupBatteryDev02 MQTT2_cerboGX_c0619ab34e08_battery 
                                             pin=BatIn:W 
                                             pout=BatOut:W
                                             pinmax=14402
                                             poutmax=14402
                                             intotal=BatInTotal:Wh outtotal=BatOutTotal:Wh 
                                             charge=SOC_value cap=InstalledCapacity_Wh:Wh 
                                             asynchron=0
                                             show=1
                                             label=below
                                             icon=@dyn:::@dyn
       </ul>
       <br>

       <b>Hinweis:</b> Durch Löschen des Attributes werden ebenfalls die intern korrespondierenden Daten entfernt.
       </li>
       <br>

       <a id="SolarForecast-attr-setupInverterDev" data-pattern="setupInverterDev.*"></a>
       <li><b>setupInverterDevXX &lt;Inverter Device Name&gt; pvOut=&lt;Reading&gt;:&lt;Einheit&gt; [pvIn=&lt;Reading&gt;:&lt;Einheit&gt;]                                              <br>
                                  ac2dc=&lt;Reading&gt;:&lt;Einheit&gt; dc2ac=&lt;Reading&gt;:&lt;Einheit&gt; etotal=&lt;Reading&gt;:&lt;Einheit&gt; capacity=&lt;max. WR-Leistung&gt;  <br>
                                 [strings=&lt;String1&gt;,&lt;String2&gt;,...] [asynchron=&lt;Option&gt] [feed=&lt;Liefertyp&gt;] [limit=&lt;0..100&gt;] [icon=&lt;aktiv&gt;[@&lt;Farbe&gt;][:&lt;inaktiv&gt;[@&lt;Farbe&gt;]]] </b> <br><br>

       Legt ein beliebiges Wechselrichter-Gerät bzw. Solar-Ladegerät und dessen Readings zur Lieferung der benötigten Angaben fest. <br>
       Dabei kann es sich auch um ein Dummy Gerät mit entsprechenden Readings handeln. <br>
       Es können verschiedene Arbeitsweisen des Wechselrichters aktiviert werden:
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="20%"> <col width="80%"> </colgroup>
           <tr><td> <b>PV-Wechselrichter</b>        </td><td>Der Standard Wechselrichter. Er wandelt die Energie der angeschlossenen Solarzellen in Wechselstrom um.           </td></tr>
           <tr><td>                                 </td><td>Dieses Gerät liefert die Energie in das Hausnetz. Alternativ kann mit <b>feed=grid</b> die Funktion des           </td></tr>
           <tr><td>                                 </td><td>Wechselrichters in exklusive Einspeisung in das öffentliche Netz geändert werden.                                 </td></tr>
           <tr><td>                                 </td><td>                                                                                                                  </td></tr>
           <tr><td> <b>Solar-Ladegerät</b>          </td><td>Ein Solar-Ladegerät wandelt die Energie der angeschlossenen Solarzellen nicht in Wechselstrom um, sondern         </td></tr>
           <tr><td>                                 </td><td>arbeitet als DC-DC Wandler und lädt direkt eine Batterie bzw. versorgt einen Batteriewechselrichter.              </td></tr>
           <tr><td>                                 </td><td>Die Funktion als Solar-Ladegerät wird mit <b>feed=bat</b> aktiviert (z.B. ein Victron SmartSolar MPPT).           </td></tr>
           <tr><td>                                 </td><td>                                                                                                                  </td></tr>
           <tr><td> <b>Batterie-Wechselrichter</b>  </td><td>Dieses Gerät hat keine angeschlossenen Solarzellen und arbeitet als DC-AC bzw. AC-DC Wandler zwischen einer       </td></tr>
           <tr><td>                                 </td><td>Batterie und dem Hausnetz.                                                                                        </td></tr>
           <tr><td>                                 </td><td>Die Funktion als Batterie-Wechselrichter wird mit <b>strings=none</b> aktiviert.                                  </td></tr>
           <tr><td>                                 </td><td>                                                                                                                  </td></tr>
         </table>
       </ul>
       <br>

       Die nachfolgenden &lt;Schlüssel=Wert&gt; Paare legen die Eigenschaften des Wechselrichters fest.  <br>
       Schlüssel, die von dem aktivierten Wechselrichtertyp abhängen, werden nachfolgend dem entsprechenden Wechselrichtertyp zugeordnet.
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>strings</b>    </td><td>Komma getrennte Liste der dem Wechselrichter zugeordneten Strings (optional). Die Stringnamen                             </td></tr>
           <tr><td>                   </td><td>werden im Attribut <a href="#SolarForecast-attr-setupInverterStrings">setupInverterStrings</a> definiert.                 </td></tr>
           <tr><td>                   </td><td>Ist 'strings' nicht angegeben, werden alle definierten Stringnamen dem Wechselrichter zugeordnet.                         </td></tr>
           <tr><td>                   </td><td>Mit '<b>strings=none</b>' werden dem Wechselrichter keine Strings zugeordnet und der Wechselrichtertyp                    </td></tr>
           <tr><td>                   </td><td><b>Batterie-Wechselrichter wird aktiviert</b>.                                                                            </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>feed</b>       </td><td>Definiert spezielle Eigenschaften der Energielieferung des Gerätes (optional).                                            </td></tr>
           <tr><td>                   </td><td>Ist der Schlüssel nicht gesetzt, speist das Gerät die PV-Energie in das Wechselstromnetz des Hauses ein.                  </td></tr>
           <tr><td>                   </td><td><b>bat</b> - es wird ein <b>Solar-Ladegerät aktiviert</b>. Ein Überschuß wird dem Inverterknoten/Hausnetz zugeführt.      </td></tr>
           <tr><td>                   </td><td><b>grid</b> - die Energie wird ausschließlich in das öffentliche Netz eingespeist                                         </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>capacity</b>   </td><td>Bemessungsleistung des Wechselrichters gemäß Datenblatt, d.h. max. möglicher Output in Watt                               </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>limit</b>      </td><td>Definiert eine eventuelle Wirkleistungsbeschränkung in % (optional).                                                      </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>icon</b>       </td><td>Icon zur Darstellung des Inverters in der Flowgrafik (optional), sonst werden Standards verwendet.                        </td></tr>
           <tr><td>                   </td><td><b>&lt;aktiv&gt;</b> - Icon und ggf. Farbe bei Aktivität bzw. PV Erzeugung                                                </td></tr>
           <tr><td>                   </td><td><b>&lt;inaktiv&gt;</b> - Icon und ggf. Farbe bei Inaktivität                                                              </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>asynchron</b>  </td><td>Modus der Datensammlung entsprechend Einstellung plantControl->cycleInterval (synchron) oder                              </td></tr>
           <tr><td>                   </td><td>zusätzlich durch Eventverarbeitung (asynchron). (optional)                                                                </td></tr>
           <tr><td>                   </td><td><b>0</b> - keine Datensammlung nach Empfang eines Events des Gerätes (default)                                            </td></tr>
           <tr><td>                   </td><td><b>1</b> - auslösen einer Datensammlung bei Empfang eines Events des Gerätes                                              </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>Einheit</b>    </td><td>die jeweilige Einheit (W,kW,Wh,kWh)                                                                                       </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td>                   </td><td><b><u>PV-Wechselrichter</u></b>                                                                                           </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>pvIn</b>       </td><td>Ein Reading, welches die aktuelle DC PV-Eingangsleistung in W liefert (Summe aller angeschlossenen Strings).              </td></tr>
           <tr><td>                   </td><td>Es wird ein positiver numerischer Wert erwartet.                                                                          </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>pvOut</b>      </td><td>Ein Reading, welches die aktuelle Leistung aus PV-Erzeugung, die an das Hausnetz oder öffentliche Netz                    </td></tr>
           <tr><td>                   </td><td>geliefert wird, bereitstellt. Es wird ein positiver numerischer Wert erwartet.                                            </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>etotal</b>     </td><td>Das Reading, welches die gesamte erzeugte PV-Energie liefert (ein stetig aufsteigender Zähler).                           </td></tr>
           <tr><td>                   </td><td>Sollte des Reading die Vorgabe eines stetig aufsteigenden Zählers verletzen, behandelt                                    </td></tr>
           <tr><td>                   </td><td>SolarForecast diesen Fehler und meldet die aufgetretene Situation durch einen Logeintrag.                                 </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td>                   </td><td><b><u>Solar-Ladegerät</u></b>                                                                                             </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>pvIn</b>       </td><td>Ein Reading, welches die aktuelle DC PV-Eingangsleistung in W liefert (Summe aller angeschlossenen Strings).              </td></tr>
           <tr><td>                   </td><td>Es wird ein positiver numerischer Wert erwartet.                                                                          </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>pvOut</b>      </td><td>Ein Reading welches die aktuelle Leistung aus PV-Erzeugung, die an die Batterie(n) bzw. an Batterie-Wechselrichter        </td></tr>
           <tr><td>                   </td><td>geliefert wird, bereitstellt. Es wird ein positiver numerischer Wert erwartet.                                            </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>etotal</b>     </td><td>Das Reading, welches die gesamte erzeugte PV-Energie liefert (ein stetig aufsteigender Zähler).                           </td></tr>
           <tr><td>                   </td><td>Sollte des Reading die Vorgabe eines stetig aufsteigenden Zählers verletzen, behandelt                                    </td></tr>
           <tr><td>                   </td><td>SolarForecast diesen Fehler und meldet die aufgetretene Situation durch einen Logeintrag.                                 </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td>                   </td><td><b><u>Batterie-Wechselrichter</u></b>                                                                                     </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>ac2dc</b>      </td><td>Ein Reading, das die aktuelle AC->DC-Leistung (Hausnetz zur Batterie) als positiven Wert angibt.                          </td></tr>
           <tr><td>                   </td><td>Der Schlüssel kann <b>nur für Batterie-Wechselrichter</b> gesetzt werden.                                                 </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
           <tr><td> <b>dc2ac</b>      </td><td>Ein Reading, das die aktuelle DC->AC-Leistung (Batterie / Solar-Ladegerät zum Hausnetz) als positiven Wert angibt.        </td></tr>
           <tr><td>                   </td><td>Der Schlüssel kann <b>nur für Batterie-Wechselrichter</b> gesetzt werden.                                                 </td></tr>
           <tr><td>                   </td><td>                                                                                                                          </td></tr>
         </table>
       </ul>
       <br>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; setupInverterDev01 STP5000 pv=total_pac:kW etotal=etotal:kWh capacity=5000 asynchron=1 strings=Garage,Garden icon=inverter@red:solar
       </ul>
       <br>

       <b>Hinweis:</b> Durch Löschen des Attributes werden ebenfalls die intern korrespondierenden Daten entfernt.
       </li>
       <br>

       <a id="SolarForecast-attr-setupInverterStrings"></a>
       <li><b>setupInverterStrings &lt;Stringname1&gt;[,&lt;Stringname2&gt;,&lt;Stringname3&gt;,...] </b> <br><br>

       Bezeichnungen der aktiven Strings. Diese Bezeichnungen werden als Schlüssel in den weiteren
       Settings verwendet. <br>
       Bei Nutzung einer KI basierenden API (z.B. VictronKI-API) ist nur "<b>KI-based</b>" einzutragen unabhängig davon
       welche realen Strings existieren. <br><br>

       <ul>
         <b>Beispiele: </b> <br>
         attr &lt;name&gt; setupInverterStrings Ostdach,Südgarage,S3 <br>
         attr &lt;name&gt; setupInverterStrings KI-based <br>
       </ul>
       </li>
       <br>

       <a id="SolarForecast-attr-setupMeterDev"></a>
       <li><b>setupMeterDev &lt;Meter Device Name&gt; gcon=&lt;Readingname&gt;:&lt;Einheit&gt; contotal=&lt;Readingname&gt;:&lt;Einheit&gt;
                            gfeedin=&lt;Readingname&gt;:&lt;Einheit&gt; feedtotal=&lt;Readingname&gt;:&lt;Einheit&gt;
                            [conprice=&lt;Feld&gt;] [feedprice=&lt;Feld&gt;] [asynchron=&lt;Option&gt] </b> <br><br>

       Legt ein beliebiges Device und seine Readings zur Energiemessung in bzw. aus dem öffentlichen Netz fest.
       Das Modul geht davon aus, dass der numerische Wert der Readings positiv ist.
       Es kann auch ein Dummy Device mit entsprechenden Readings sein.
       <br><br>

       <ul>
        <table>
        <colgroup> <col width="15%"> <col width="85%"> </colgroup>
           <tr><td> <b>gcon</b>       </td><td>Reading welches die aktuell aus dem Netz bezogene Leistung liefert                                                         </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td> <b>contotal</b>   </td><td>Reading welches die Summe der aus dem Netz bezogenen Energie liefert (ein sich stetig erhöhender Zähler)                   </td></tr>
           <tr><td>                   </td><td>Wird der Zähler zu Beginn des Tages auf '0' zurückgesetzt (Tageszähler), behandelt das Modul diese Situation entsprechend. </td></tr>
           <tr><td>                   </td><td>In diesem Fall erfolgt eine Meldung im Log mit verbose 3.                                                                  </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td> <b>gfeedin</b>    </td><td>Reading welches die aktuell in das Netz eingespeiste Leistung liefert                                                      </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td> <b>feedtotal</b>  </td><td>Reading welches die Summe der in das Netz eingespeisten Energie liefert (ein sich stetig erhöhender Zähler)                </td></tr>
           <tr><td>                   </td><td>Wird der Zähler zu Beginn des Tages auf '0' zurückgesetzt (Tageszähler), behandelt das Modul diese Situation entsprechend. </td></tr>
           <tr><td>                   </td><td>In diesem Fall erfolgt eine Meldung im Log mit verbose 3.                                                                  </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td> <b>Einheit</b>    </td><td>die jeweilige Einheit (W,kW,Wh,kWh)                                                                                        </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td> <b>conprice</b>   </td><td>Preis für den Bezug einer kWh (optional). Die Angabe &lt;Feld&gt; ist in einer der folgenden Varianten möglich:            </td></tr>
           <tr><td>                   </td><td>&lt;Preis&gt;:&lt;Währung&gt; - Preis als numerischer Wert und dessen Währung                                              </td></tr>
           <tr><td>                   </td><td>&lt;Reading&gt;:&lt;Währung&gt; - Reading des <b>Meter Device</b> das den Preis enthält : Währung                          </td></tr>
           <tr><td>                   </td><td>&lt;Device&gt;:&lt;Reading&gt;:&lt;Währung&gt; - beliebiges Device und Reading welches den Preis enthält : Währung         </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td> <b>feedprice</b>  </td><td>Vergütung für die Einspeisung einer kWh (optional). Die Angabe &lt;Feld&gt; ist in einer der folgenden Varianten möglich:  </td></tr>
           <tr><td>                   </td><td>&lt;Vergütung&gt;:&lt;Währung&gt; - Vergütung als numerischer Wert und dessen Währung                                      </td></tr>
           <tr><td>                   </td><td>&lt;Reading&gt;:&lt;Währung&gt; - Reading des <b>Meter Device</b> das die Vergütung enthält : Währung                      </td></tr>
           <tr><td>                   </td><td>&lt;Device&gt;:&lt;Reading&gt;:&lt;Währung&gt; - beliebiges Device und Reading welches die Vergütung enthält : Währung     </td></tr>
           <tr><td>                   </td><td>                                                                                                                           </td></tr>
           <tr><td> <b>asynchron</b>  </td><td>Modus der Datensammlung entsprechend Einstellung plantControl->cycleInterval (synchron) oder zusätzlich durch              </td></tr>
           <tr><td>                   </td><td>Eventverarbeitung (asynchron).                                                                                             </td></tr>
           <tr><td>                   </td><td><b>0</b> - keine Datensammlung nach Empfang eines Events des Gerätes (default)                                             </td></tr>
           <tr><td>                   </td><td><b>1</b> - auslösen einer Datensammlung bei Empfang eines Events des Gerätes                                               </td></tr>
        </table>
       </ul>
       <br>

       <b>Sonderfälle:</b> Sollte das Reading für gcon und gfeedin identisch, aber vorzeichenbehaftet sein,
       können die Schlüssel gfeedin und gcon wie folgt definiert werden: <br><br>
       <ul>
         gfeedin=-gcon  &nbsp;&nbsp;&nbsp;(ein negativer Wert von gcon wird als gfeedin verwendet)  <br>
         gcon=-gfeedin  &nbsp;&nbsp;&nbsp;(ein negativer Wert von gfeedin wird als gcon verwendet)
       </ul>
       <br>

       Die Einheit entfällt in dem jeweiligen Sonderfall. <br><br>

       <ul>
         <b>Beispiel: </b> <br>
         attr &lt;name&gt; setupMeterDev Meter gcon=Wirkleistung:W contotal=BezWirkZaehler:kWh gfeedin=-gcon feedtotal=EinWirkZaehler:kWh conprice=powerCost:€ feedprice=0.1269:€
       </ul>
       <br>

       <b>Hinweis:</b> Durch Löschen des Attributes werden ebenfalls die intern korrespondierenden Daten entfernt.
      </li>
      <br>

      <a id="SolarForecast-attr-setupOtherProducer" data-pattern="setupOtherProducer.*"></a>
      <li><b>setupOtherProducerXX &lt;Device Name&gt; pcurr=&lt;Readingname&gt;:&lt;Einheit&gt; etotal=&lt;Readingname&gt;:&lt;Einheit&gt; [icon=&lt;Icon&gt;[@&lt;Farbe&gt;]] </b> <br><br>

      Legt ein beliebiges Device und dessen Readings zur Lieferung sonstiger Erzeugungswerte fest
      (z.B. BHKW, Winderzeugung, Notstromaggregat). Dieses Device ist nicht für PV-Erzeugung vorgsehen.
      Es kann auch ein Dummy Device mit entsprechenden Readings sein.
      <br><br>

      <ul>
       <table>
       <colgroup> <col width="15%"> <col width="85%"> </colgroup>
          <tr><td> <b>icon</b>     </td><td>Icon und ggf. Farbe bei Aktivität zur Darstellung des Producers in der Flowgrafik (optional)                                 </td></tr>
          <tr><td> <b>pcurr</b>    </td><td>Reading welches die aktuelle Erzeugung als positiven Wert oder einen Eigenverbrauch (Sonderfall) als negativen Wert liefert  </td></tr>
          <tr><td> <b>etotal</b>   </td><td>Reading welches die gesamte erzeugte Energie liefert (ein stetig aufsteigender Zähler)                                       </td></tr>
          <tr><td>                 </td><td>Sollte des Reading die Vorgabe eines stetig aufsteigenden Zählers verletzen, behandelt                                       </td></tr>
          <tr><td>                 </td><td>SolarForecast diesen Fehler und meldet die aufgetretene Situation durch einen Logeintrag.                                    </td></tr>
          <tr><td> <b>Einheit</b>  </td><td>die jeweilige Einheit (W,kW,Wh,kWh)                                                                                          </td></tr>
        </table>
      </ul>
      <br>

      <ul>
        <b>Beispiel: </b> <br>
        attr &lt;name&gt; setupOtherProducer01 windwheel pcurr=total_pac:kW etotal=etotal:kWh icon=Ventilator_wind@darkorange
      </ul>
      <br>

      <b>Hinweis:</b> Durch Löschen des Attributes werden ebenfalls die intern korrespondierenden Daten entfernt.
      </li>
      <br>

      <a id="SolarForecast-attr-setupRadiationAPI"></a>
      <li><b>setupRadiationAPI </b> <br><br>

      Legt die Quelle zur Lieferung der solaren Strahlungsdaten fest. Es kann ein Device vom Typ DWD_OpenData oder
      eine implementierte API eines Dienstes ausgewählt werden. <br><br>

      <b>Hinweis:</b> Ist im Attribut 'setupWeatherDev1' ebenfalls eine OpenMeteo API gesetzt, werden die Einstellungen
                      beider Attribute harmonisiert wobei die Einstellung von 'setupRadiationAPI' führend ist. <br><br>

      <b>OpenMeteoDWD-API</b> <br>

      Open-Meteo ist eine Open-Source-Wetter-API und bietet kostenlosen Zugang für nicht-kommerzielle Zwecke.
      Es ist kein API-Schlüssel erforderlich.
      Open-Meteo nutzt eine leistungsstarke Kombination aus globalen (11 km) und mesoskaligen (1 km) Wettermodellen
      von angesehenen nationalen Wetterdiensten.
      Diese API bietet Zugang zu den renommierten ICON-Wettermodellen des Deutschen Wetterdienstes (DWD), die
      15-minütige Daten für kurzfristige Vorhersagen in Mitteleuropa und globale Vorhersagen mit einer Auflösung
      von 11 km liefern. Das ICON-Modell ist eine bevorzugte Wahl für allgemeine Wettervorhersage-APIs, wenn keine
      anderen hochauflösenden Wettermodelle verfügbar sind. Es werden die Modelle DWD Icon D2, DWD Icon EU
      und DWD Icon Global zu einer nahtlosen Vorhersage zusammengeführt.
      Auf der Webseite des Dienstes ist die umfangreiche und übersichtliche
      <a href='https://open-meteo.com/en/docs/dwd-api' target='_blank'>API Dokumentation</a> verfügbar.
      <br><br>

      <b>OpenMeteoDWD_D2-API</b> <br>

      Wie OpenMeteoDWD-API. Es wird jedoch nur das Modell ICON D2 für Mitteleuropa
      (Deutschland, Schweiz, Österreich, Frankreich, Belgien, Niederlande, Dänemark, Tschechien, Slowenien) verwendet.
      Die Raumauflösung dieses Modells beträgt 0,02° (ca. 2 km) und eine zeitliche Auflösung von 15 Minuten.
      <br><br>

      <b>OpenMeteoDWDEnsemble-API</b> <br>

      Diese Open-Meteo API Variante bietet Zugang zum globalen
      <a href='https://www.dwd.de/DE/forschung/wettervorhersage/num_modellierung/04_ensemble_methoden/ensemble_vorhersage/ensemble_vorhersagen.html' target='_blank'>Ensemble-Vorhersagesystem (EPS)</a>
      des DWD. <br>
      Es werden die Ensemble Modelle ICON-D2-EPS, ICON-EU-EPS und ICON-EPS nahtlos vereint. <br>
      <a href='https://openmeteo.substack.com/p/ensemble-weather-forecast-api' target='_blank'>Ensemble-Wetterprognosen</a> sind
      eine spezielle Art von Vorhersagemethode, die die Unsicherheiten bei der Wettervorhersage berücksichtigt.
      Sie tun dies, indem sie mehrere Simulationen oder Modelle mit leichten Unterschieden in den Startbedingungen
      oder Einstellungen ausführen. Jede Simulation, bekannt als Ensemblemitglied, stellt ein mögliches Ergebnis des Wetters dar.
      In der vorliegenden Implementierung werden 40 Ensemblemitglieder pro Wettermerkmal zusammengeführt und das wahrscheinlichste
      Ergbnis verwendet.
      <br><br>

      <b>OpenMeteoWorld-API</b> <br>

      Als Variante des Open-Meteo Dienstes liefert die OpenMeteoWorld-API die optimale Vorhersage für einen bestimmten Ort weltweit.
      Die OpenMeteoWorld-API vereint nahtlos Wettermodelle bekannter Organisationen wie NOAA (National Oceanic and Atmospheric
      Administration), DWD (Deutscher Wetterdienst), CMCC (Canadian) und ECMWF (Europäisches Zentrum für mittelfristige Wettervorhersage).
      Für jeden Ort weltweit werden die Modelle der Anbieter kombiniert, um die bestmögliche Vorhersage zu erstellen.
      Die Nutzung der Dienste und Wettermodelle erfolgt automatisch anhand der im API Aufruf enthaltenen Standortkoordinaten.
      <br><br>

      <b>SolCast-API</b> <br>

      Die API-Nutzung benötigt vorab ein oder mehrere API-keys (Accounts) sowie ein oder mehrere Rooftop-ID's
      die auf der <a href='https://toolkit.solcast.com.au/rooftop-sites/' target='_blank'>SolCast</a> Webseite angelegt
      werden müssen.
      Ein Rooftop ist im SolarForecast-Kontext mit einem <a href="#SolarForecast-attr-setupInverterStrings">setupInverterString</a>
      gleichzusetzen. <br>
      Die kostenfreie API-Nutzung ist auf eine Tagesrate API-Anfragen begrenzt. Die Anzahl definierter Strings (Rooftops)
      erhöht die Anzahl erforderlicher API-Anfragen. Das Modul optimiert die Abfragezyklen automatisch.
      <br><br>

      <b>ForecastSolar-API</b> <br>

      Die kostenfreie Nutzung der <a href='https://doc.forecast.solar/start' target='_blank'>Forecast.Solar API</a>
      erfordert keine Registrierung. Die API-Anfragen sind in der kostenfreien Version auf 12 innerhalb einer Stunde
      begrenzt. Ein Tageslimit gibt es dabei nicht. Das Modul ermittelt automatisch das optimale Abfrageintervall
      in Abhängigkeit der konfigurierten Strings. <br>
      Hinweis: Nach den bisherigen Erfahrungen unzuverlässig und nicht zu empfehlen.
      <br><br>

      <b>VictronKI-API</b> <br>

      Diese API kann durch Nutzer des Victron Energy VRM Portals angewendet werden. Diese API ist KI basierend.
      Als String ist der Wert "KI-based" im Setup der <a href="#SolarForecast-attr-setupInverterStrings">setupInverterStrings</a>
      einzutragen. <br>
      Im Victron Energy VRM Portal ist als Voraussetzung der Standort der PV-Anlage anzugeben. <br>
      Siehe dazu auch den Blog-Beitrag
      <a href="https://www.victronenergy.com/blog/2023/07/05/new-vrm-solar-production-forecast-feature/">Introducing Solar Production Forecast</a>.
      <br><br>

      <b>DWD_OpenData Device</b> <br>

      Der DWD-Dienst wird über ein FHEM Device vom Typ DWD_OpenData eingebunden.
      Ist noch kein Device des Typs DWD_OpenData vorhanden, muß es vorab definiert werden
      (siehe <a href="http://fhem.de/commandref.html#DWD_OpenData">DWD_OpenData Commandref</a>). <br>
      Um eine gute Strahlungsprognose zu erhalten, sollte eine nahe dem Anlagenstandort gelegene DWD-Station genutzt
      werden. <br>
      Leider liefern nicht alle
      <a href="https://www.dwd.de/DE/leistungen/klimadatendeutschland/statliste/statlex_html.html;jsessionid=EC5F572A52EB69684D552DCF6198F290.live31092?view=nasPublication&nn=16102">DWD-Stationen</a>
      die benötigten Rad1h-Werte. <br>
      Erläuterungen zu den Stationen sind im
      <a href="https://www.dwd.de/DE/leistungen/klimadatendeutschland/stationsliste.html">Stationslexikon</a> aufgeführt. <br>
      Im ausgewählten DWD_OpenData Device müssen mindestens die folgenden Attribute gesetzt sein: <br><br>

      <ul>
         <table>
         <colgroup> <col width="25%"> <col width="75%"> </colgroup>
            <tr><td> <b>forecastDays</b>            </td><td>2  (auf &gt; 2 setzen wenn eine längere Vorhersage gewünscht ist)                            </td></tr>
            <tr><td> <b>forecastProperties</b>      </td><td>Rad1h                                                                                         </td></tr>
            <tr><td> <b>forecastResolution</b>      </td><td>1                                                                                             </td></tr>
            <tr><td> <b>forecastStation</b>         </td><td>&lt;Stationscode der ausgewerteten DWD Station&gt;                                            </td></tr>
            <tr><td>                                </td><td><b>Hinweis:</b> Die ausgewählte DWD Station muß Strahlungswerte (Rad1h Readings) liefern.     </td></tr>
            <tr><td>                                </td><td>Nicht alle Stationen liefern diese Daten!                                                     </td></tr>
         </table>
      </ul>
      </li>
      <br>

      <a id="SolarForecast-attr-setupRoofTops"></a>
      <li><b>setupRoofTops &lt;Stringname1&gt;=&lt;pk&gt; [&lt;Stringname2&gt;=&lt;pk&gt; &lt;Stringname3&gt;=&lt;pk&gt; ...] </b> <br>
      (nur bei Verwendung Model SolCastAPI) <br><br>

      Es erfolgt die Zuordnung des Strings "StringnameX" zu einem Schlüssel &lt;pk&gt;. Der Schlüssel &lt;pk&gt; wurde mit dem
      Setter <a href="#SolarForecast-set-roofIdentPair">roofIdentPair</a> angelegt. Damit wird bei Abruf des Rooftops (=String)
      in der SolCast API die zu verwendende Rooftop-ID sowie der zu verwendende API-Key festgelegt. <br>
      Der StringnameX ist ein Schlüsselwert des Attributs <b>setupInverterStrings</b>.
      <br><br>

      <ul>
        <b>Beispiel: </b> <br>
        attr &lt;name&gt; setupRoofTops Ostdach=p1 Südgarage=p2 S3=p3 <br>
      </ul>
      </li>
      <br>

      <ul>
        <a id="SolarForecast-attr-setupStringAzimuth"></a>
        <li><b>setupStringAzimuth &lt;Stringname1&gt;=&lt;dir&gt; [&lt;Stringname2&gt;=&lt;dir&gt; &lt;Stringname3&gt;=&lt;dir&gt; ...] </b> <br><br>

        Ausrichtung &lt;dir&gt; der Solarmodule im String "StringnameX". Der Stringname ist ein Schlüsselwert des
        Attributs <b>setupInverterStrings</b>. <br>
        Die Richtungsangabe &lt;dir&gt; kann als Azimut Kennung oder als Azimut Wert angegeben werden: <br><br>

        <ul>
           <table>
           <colgroup> <col width="30%"> <col width="20%"> <col width="50%"> </colgroup>
              <tr><td> <b>Kennung</b>   </td><td><b>Azimut</b> </td><td>                           </td></tr>
              <tr><td> N                </td><td>-180          </td><td>Nordausrichtung            </td></tr>
              <tr><td> NE               </td><td>-135          </td><td>Nord-Ost Ausrichtung       </td></tr>
              <tr><td> E                </td><td>-90           </td><td>Ostausrichtung             </td></tr>
              <tr><td> SE               </td><td>-45           </td><td>Süd-Ost Ausrichtung        </td></tr>
              <tr><td> S                </td><td>0             </td><td>Südausrichtung             </td></tr>
              <tr><td> SW               </td><td>45            </td><td>Süd-West Ausrichtung       </td></tr>
              <tr><td> W                </td><td>90            </td><td>Westausrichtung            </td></tr>
              <tr><td> NW               </td><td>135           </td><td>Nord-West Ausrichtung      </td></tr>
           </table>
        </ul>
        <br>

        Azimut Werte sind Ganzzahlen im Bereich von -180 bis 180. Obwohl die genannten Kennungen verwendet werden können,
        wird empfohlen den genauen Azimut Wert im Attribut anzugeben. Dadurch können beliebige Zwischenwerte wie 83, 48 etc.
        angeben werden.
        <br><br>

        <ul>
          <b>Beispiel: </b> <br>
          attr &lt;name&gt; setupStringAzimuth Ostdach=-85 Südgarage=S S3=132 <br>
        </ul>
        </li>
      </ul>
      <br>

      <ul>
        <a id="SolarForecast-attr-setupStringDeclination"></a>
        <li><b>setupStringDeclination &lt;Stringname1&gt;=&lt;Winkel&gt; [&lt;Stringname2&gt;=&lt;Winkel&gt; &lt;Stringname3&gt;=&lt;Winkel&gt; ...] </b> <br><br>

        Neigungswinkel der Solarmodule. Der Stringname ist ein Schlüsselwert des Attributs <b>setupInverterStrings</b>. <br>
        Als Neigungswinkel können Ganzzahlen zwischen 0 und 90 angegeben werden. (0 = waagerecht, 90 = senkrecht). <br><br>

        <ul>
          <b>Beispiel: </b> <br>
          attr &lt;name&gt; setupStringDeclination Ostdach=40 Südgarage=60 S3=30 <br>
        </ul>
        </li>
      </ul>
      <br>

      <a id="SolarForecast-attr-setupStringPeak"></a>
      <li><b>setupStringPeak &lt;Stringname1&gt;=&lt;Peak&gt; [&lt;Stringname2&gt;=&lt;Peak&gt; &lt;Stringname3&gt;=&lt;Peak&gt; ...] </b> <br><br>

      Die DC Peakleistung des Strings "StringnameX" in kWp. Der Stringname ist ein Schlüsselwert des
      Attributs <b>setupInverterStrings</b>. <br>
      Bei Verwendung einer KI basierenden API (z.B. Model VictronKiAPI) sind die Peakleistungen aller vorhandenen
      Strings als Summe dem Stringnamen <b>KI-based</b> zuzuordnen. <br><br>

      <ul>
        <b>Beispiele: </b> <br>
        attr &lt;name&gt; setupStringPeak Ostdach=5.1 Südgarage=2.0 S3=7.2 <br>
        attr &lt;name&gt; setupStringPeak KI-based=14.3 (bei KI basierender API)<br>
      </ul>
      </li>
      <br>

      <a id="SolarForecast-attr-setupWeatherDev" data-pattern="setupWeatherDev.*"></a>
      <li><b>setupWeatherDevX </b> <br><br>

      Gibt das Gerät oder die API zur Lieferung der erforderlichen Wetterdaten (Wolkendecke, Niederschlag usw.) an.<br>
      Das Attribut 'setupWeatherDev1' definiert den führenden Wetterdienst und ist zwingend erforderlich. <br><br>

      <b>Hinweis:</b> Ist im Attribut 'setupRadiationAPI' ebenfalls eine OpenMeteo API gesetzt, werden die Einstellungen
                      beider Attribute harmonisiert wobei die Einstellung von 'setupRadiationAPI' führend ist. <br><br>

      <b>OpenMeteoDWD-API</b> <br>

      Open-Meteo ist eine Open-Source-Wetter-API und bietet kostenlosen Zugang für nicht-kommerzielle Zwecke.
      Es ist kein API-Schlüssel erforderlich.
      Open-Meteo nutzt eine leistungsstarke Kombination aus globalen (11 km) und mesoskaligen (1 km) Wettermodellen
      von angesehenen nationalen Wetterdiensten.
      Diese API bietet Zugang zu den renommierten ICON-Wettermodellen des Deutschen Wetterdienstes (DWD), die
      15-minütige Daten für kurzfristige Vorhersagen in Mitteleuropa und globale Vorhersagen mit einer Auflösung
      von 11 km liefern. Das ICON-Modell ist eine bevorzugte Wahl für allgemeine Wettervorhersage-APIs, wenn keine
      anderen hochauflösenden Wettermodelle verfügbar sind. Es werden die Modelle DWD Icon D2, DWD Icon EU
      und DWD Icon Global zu einer nahtlosen Vorhersage zusammengeführt.
      Auf der Webseite des Dienstes ist die umfangreiche und übersichtliche
      <a href='https://open-meteo.com/en/docs/dwd-api' target='_blank'>API Dokumentation</a> verfügbar.
      <br><br>

      <b>OpenMeteoDWD_D2-API</b> <br>

      Wie OpenMeteoDWD-API. Es wird jedoch nur das Modell ICON D2 für Mitteleuropa
      (Deutschland, Schweiz, Österreich, Frankreich, Belgien, Niederlande, Dänemark, Tschechien, Slowenien) verwendet.
      Die Raumauflösung dieses Modells beträgt 0,02° (ca. 2 km) und eine zeitliche Auflösung von 15 Minuten.
      <br><br>

      <b>OpenMeteoDWDEnsemble-API</b> <br>

      Diese Open-Meteo API Variante bietet Zugang zum globalen
      <a href='https://www.dwd.de/DE/forschung/wettervorhersage/num_modellierung/04_ensemble_methoden/ensemble_vorhersage/ensemble_vorhersagen.html' target='_blank'>Ensemble-Vorhersagesystem (EPS)</a>
      des DWD. <br>
      Es werden die Ensemble Modelle ICON-D2-EPS, ICON-EU-EPS und ICON-EPS nahtlos vereint. <br>
      <a href='https://openmeteo.substack.com/p/ensemble-weather-forecast-api' target='_blank'>Ensemble-Wetterprognosen</a> sind
      eine spezielle Art von Vorhersagemethode, die die Unsicherheiten bei der Wettervorhersage berücksichtigt.
      Sie tun dies, indem sie mehrere Simulationen oder Modelle mit leichten Unterschieden in den Startbedingungen
      oder Einstellungen ausführen. Jede Simulation, bekannt als Ensemblemitglied, stellt ein mögliches Ergebnis des Wetters dar.
      In der vorliegenden Implementierung werden 40 Ensemblemitglieder pro Wettermerkmal zusammengeführt und das wahrscheinlichste
      Ergbnis verwendet.
      <br><br>

       <b>OpenMeteoWorld-API</b> <br>

       Als Variante des Open-Meteo Dienstes liefert die OpenMeteoWorld-API die optimale Vorhersage für einen bestimmten Ort weltweit.
       Die OpenMeteoWorld-API vereint nahtlos Wettermodelle bekannter Organisationen wie NOAA (National Oceanic and Atmospheric
       Administration), DWD (Deutscher Wetterdienst), CMCC (Canadian) und ECMWF (Europäisches Zentrum für mittelfristige Wettervorhersage).
       Für jeden Ort weltweit werden die Modelle der Anbieter kombiniert, um die bestmögliche Vorhersage zu erstellen.
       Die Nutzung der Dienste und Wettermodelle erfolgt automatisch anhand der im API Aufruf enthaltenen Standortkoordinaten.
       <br><br>

       <b>DWD Gerät</b> <br>

       Alternativ zu Open-Meteo kann ein FHEM 'DWD_OpenData'-Gerät zur Lieferung der Wetterdaten dienen.<br>
       Ist noch kein Gerät dieses Typs vorhanden, muß zunächst mindestens ein DWD_OpenData Gerät
       definiert werden (siehe <a href="http://fhem.de/commandref.html#DWD_OpenData">DWD_OpenData Commandref</a>). <br>
       Sind mehr als ein setupWeatherDevX angegeben, wird der Durchschnitt aller Wetterstationen ermittelt
       sofern der jeweilige Wert geliefert wurde und numerisch ist. <br>
       Anderenfalls werden immer die Daten von 'setupWeatherDev1' als führendes Wetterdevice genutzt. <br>
       Im ausgewählten DWD_OpenData Gerät müssen mindestens diese Attribute gesetzt sein: <br><br>

       <ul>
          <table>
          <colgroup> <col width="25%"> <col width="75%"> </colgroup>
             <tr><td> <b>forecastDays</b>            </td><td>2                                                   </td></tr>
             <tr><td> <b>forecastProperties</b>      </td><td>TTT,Neff,RR1c,ww,SunUp,SunRise,SunSet               </td></tr>
             <tr><td> <b>forecastResolution</b>      </td><td>1                                                   </td></tr>
             <tr><td> <b>forecastStation</b>         </td><td>&lt;Stationscode der ausgewerteten DWD Station&gt;  </td></tr>
          </table>
       </ul>
       <br>

       <b>Hinweis:</b> Sind die Attribute latitude und longitude im global Device gesetzt, ergibt sich der
                       Sonnenauf- und Sonnenuntergang aus diesen Angaben.
       </li>
       <br>

     </ul>
  </ul>

</ul>

=end html_DE

=for :application/json;q=META.json 76_SolarForecast.pm
{
  "abstract": "Creation of solar forecasts of PV systems including consumption forecasts and consumer management",
  "x_lang": {
    "de": {
      "abstract": "Erstellung solarer Vorhersagen von PV Anlagen inklusive Verbrauchsvorhersagen und Verbrauchermanagement"
    }
  },
  "keywords": [
    "inverter",
    "photovoltaik",
    "electricity",
    "forecast",
    "graphics",
    "Autarky",
    "Consumer",
    "PV"
  ],
  "version": "v1.1.1",
  "release_status": "stable",
  "author": [
    "Heiko Maaz <heiko.maaz@t-online.de>"
  ],
  "x_fhem_maintainer": [
    "DS_Starter"
  ],
  "x_fhem_maintainer_github": [
    "nasseeder1"
  ],
  "prereqs": {
    "runtime": {
      "requires": {
        "FHEM": 5.00918799,
        "perl": 5.014,
        "POSIX": 0,
        "GPUtils": 0,
        "Encode": 0,
        "Blocking": 0,
        "Color": 0,
        "utf8": 0,
        "HttpUtils": 0,
        "JSON": 4.020,
        "FHEM::SynoModules::SMUtils": 1.0270,
        "FHEM::SynoModules::ErrCodes": 1.003009,
        "Time::HiRes": 0,
        "MIME::Base64": 0,
        "Math::Trig": 0,
        "List::Util": 0,
        "Scalar::Util": 0,
        "Storable": 0
      },
      "recommends": {
        "FHEM::Meta": 0,
        "FHEM::Utility::CTZ": 1.00,
        "DateTime": 0,
        "DateTime::Format::Strptime": 0,
        "AI::DecisionTree": 0,
        "Data::Dumper": 0
      },
      "suggests": {
      }
    }
  },
  "resources": {
    "x_wiki": {
      "web": "https://wiki.fhem.de/wiki/SolarForecast_-_Solare_Prognose_(PV_Erzeugung)_und_Verbrauchersteuerung",
      "title": "SolarForecast - Solare Prognose (PV Erzeugung) und Verbrauchersteuerung"
    },
    "repository": {
      "x_dev": {
        "type": "svn",
        "url": "https://svn.fhem.de/trac/browser/trunk/fhem/contrib/DS_Starter",
        "web": "https://svn.fhem.de/trac/browser/trunk/fhem/contrib/DS_Starter/76_SolarForecast.pm",
        "x_branch": "dev",
        "x_filepath": "fhem/contrib/",
        "x_raw": "https://svn.fhem.de/fhem/trunk/fhem/contrib/DS_Starter/76_SolarForecast.pm"
      }
    }
  }
}
=end :application/json;q=META.json

=cut
